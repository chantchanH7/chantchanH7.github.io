<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Lab: networking这个实验需要写一个xv6网络接口卡的设备驱动器。 背景你需要使用E1000网络设备处理网络通信。对于xv6来说，E1000看起来就像是连接到真实以太网据局域网（LAN）的真实硬件。实际上，你的驱动程序将于之通信的E1000是由qemu提供的仿真，连接到的也是一个由qemu提供的仿真局域网。在这个仿真局域网上，xv6（作为客户机）的ip地址为10.0.2.15。qemu">
<meta property="og:type" content="article">
<meta property="og:title" content="Lab: networking">
<meta property="og:url" content="http://example.com/2024/03/16/Lab-networking/index.html">
<meta property="og:site_name" content="talk is cheap, show me the code.">
<meta property="og:description" content="Lab: networking这个实验需要写一个xv6网络接口卡的设备驱动器。 背景你需要使用E1000网络设备处理网络通信。对于xv6来说，E1000看起来就像是连接到真实以太网据局域网（LAN）的真实硬件。实际上，你的驱动程序将于之通信的E1000是由qemu提供的仿真，连接到的也是一个由qemu提供的仿真局域网。在这个仿真局域网上，xv6（作为客户机）的ip地址为10.0.2.15。qemu">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-03-16T01:34:05.000Z">
<meta property="article:modified_time" content="2024-03-17T04:58:11.786Z">
<meta property="article:author" content="theLonging">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2024/03/16/Lab-networking/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Lab: networking | talk is cheap, show me the code.</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">talk is cheap, show me the code.</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/16/Lab-networking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Lab: networking
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-16 09:34:05" itemprop="dateCreated datePublished" datetime="2024-03-16T09:34:05+08:00">2024-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-17 12:58:11" itemprop="dateModified" datetime="2024-03-17T12:58:11+08:00">2024-03-17</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Lab-networking"><a href="#Lab-networking" class="headerlink" title="Lab: networking"></a>Lab: networking</h1><p>这个实验需要写一个<code>xv6</code>网络接口卡的设备驱动器。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>你需要使用E1000网络设备处理网络通信。对于xv6来说，E1000看起来就像是连接到真实以太网据局域网（LAN）的真实硬件。实际上，你的驱动程序将于之通信的E1000是由qemu提供的仿真，连接到的也是一个由qemu提供的仿真局域网。在这个仿真局域网上，xv6（作为客户机）的ip地址为10.0.2.15。qemu还安排运行qemu的计算机出现在局域网上，IP地址为10.0.2.2。当xv6使用E1000向10.0.2.2发送数据包时，qemu会将数据包递送到运行qemu的（真实）计算机上的适当应用程序（“宿主机”）。</p>
<p>你将使用qemu的用户模式网络栈。Qemu的文档有更多关于user-mode stack的信息。Makefile已经更新并支持QEMU的用户模式网络栈和E1000网卡。</p>
<p>Makefile 配置了 QEMU，以便将所有进出的数据包记录到实验目录中的 packets.pcap 文件。查看这些记录文件可能有助于确认 xv6 是否发送和接收了你期望的数据包。要显示记录的数据包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -XXnr packets.pcap</span><br></pre></td></tr></table></figure>

<p>为了这个实验，我们在 xv6 仓库中添加了一些文件。文件 <code>kernel/e1000.c</code> 包含了 E1000 的初始化代码，以及用于发送和接收数据包的空函数，你将填充这些函数。<code>kernel/e1000_dev.h</code> 包含由 E1000 定义的寄存器和标志位的定义，这些定义在 Intel E1000 软件开发者手册中有描述。<code>kernel/net.c</code> 和 <code>kernel/net.h</code> 包含了一个简单的网络栈，实现了 IP、UDP 和 ARP 协议。这些文件还包含了一种用于存放数据包的灵活数据结构的代码，称为 mbuf。最后，<code>kernel/pci.c</code> 包含了在 xv6 启动时搜索 PCI 总线上的 E1000 卡的代码。</p>
<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>你的任务是完成 <code>kernel/e1000.c</code> 中的 <code>e1000_transmit()</code> 和 <code>e1000_recv()</code> 函数，使得驱动程序能够发送和接收数据包。当 <code>make grade</code> 显示你的解决方案通过了所有测试时，说明你已经完成了任务。</p>
<blockquote>
<p>在编写代码时，你会发现自己需要参考 E1000 软件开发者手册。以下几个部分可能特别有帮助：</p>
<ul>
<li>第2节是必不可少的，提供了整个设备的概览。</li>
<li>第3.2节提供了数据包接收的概览。</li>
<li>第3.3节和第3.4节一起提供了数据包传输的概览。</li>
<li>第13节提供了 E1000 使用的寄存器的概览。</li>
<li>第14节可能会帮助你理解我们提供的初始化代码。</li>
</ul>
</blockquote>
<p>浏览 E1000 软件开发者手册。这份手册涵盖了几个密切相关的以太网控制器。QEMU 模拟的是 82540EM。现在先浏览第2章，以对设备有一个基本了解。为了编写你的驱动程序，你需要熟悉第3章和第14章，以及第4.1章（但不包括4.1章的小节）。你还需要将第13章作为参考。其他章节主要涵盖了你的驱动程序不需要交互的 E1000 的组件。首先不用担心细节；只需了解文档的结构，以便稍后可以找到所需的信息。E1000 有许多高级功能，其中大部分你可以忽略。只需要一小部分基本功能就可以完成这个实验。</p>
<p>我们在 <code>e1000.c</code> 中提供给你的 <code>e1000_init()</code> 函数配置了 E1000 从 RAM 读取要传输的数据包，并将接收到的数据包写入 RAM。这种技术称为 DMA，即直接内存访问，指的是 E1000 硬件直接向 RAM 读写数据包的事实。</p>
<p>由于数据包的突发可能比驱动程序能够处理的更快地到达，<code>e1000_init()</code> 为 E1000 提供了多个缓冲区，E1000 可以将数据包写入这些缓冲区。E1000 要求这些缓冲区通过 RAM 中的一个“描述符”数组来描述；每个描述符包含一个 RAM 中的地址，E1000 可以将接收到的数据包写入该地址。<code>struct rx_desc</code> 描述了描述符的格式。描述符数组被称为接收环或接收队列。从环形的角度来说，当卡或驱动到达数组的末尾时，它会回到开始的位置。<code>e1000_init()</code> 使用 <code>mbufalloc()</code> 为 E1000 分配 <code>mbuf</code> 数据包缓冲区以便 DMA 使用。还有一个发送环，驱动程序应将其希望 E1000 发送的数据包放置在其中。<code>e1000_init()</code> 配置这两个环的大小为 <code>RX_RING_SIZE</code> 和 <code>TX_RING_SIZE</code>。</p>
<p>当 <code>net.c</code> 中的网络栈需要发送数据包时，它会调用 <code>e1000_transmit()</code> 函数，并传入一个包含待发送数据包的 <code>mbuf</code>。你的传输代码必须将指向数据包数据的指针放置在 TX（发送）环的一个描述符中。<code>struct tx_desc</code> 描述了描述符的格式。你需要确保每个 <code>mbuf</code> 最终都被释放，但只有在 E1000 完成数据包传输后才能这么做（E1000 通过在描述符中设置 <code>E1000_TXD_STAT_DD</code> 位来指示这一点）。</p>
<p>当 E1000 从以太网接收到每个数据包时，它会通过直接内存访问（DMA）将数据包传输到 RX（接收）环描述符中的下一个 <code>addr</code> 指向的内存。如果 E1000 中断尚未挂起，E1000 会请求 PLIC 在启用中断后尽快交付一个中断。你的 <code>e1000_recv()</code> 代码必须扫描 RX 环，并通过调用 <code>net_rx()</code> 将每个新数据包的 <code>mbuf</code> 交给 <code>net.c</code> 中的网络栈。然后，你需要分配一个新的 <code>mbuf</code> 并将其放入描述符中，以便当 E1000 再次到达 RX 环的那一点时，它找到一个新的缓冲区，可以将新数据包通过 DMA 传输进去。</p>
<p>除了在 RAM 中读写描述符环，你的驱动程序还需要通过内存映射的控制寄存器与 E1000 交互，以检测何时有接收到的数据包可用，并通知 E1000 驱动程序已经填充了一些 TX 描述符，准备发送数据包。全局变量 <code>regs</code> 保存了一个指向 E1000 第一个控制寄存器的指针；你的驱动程序可以通过将 <code>regs</code> 作为数组进行索引来访问其他寄存器。你特别需要使用索引 <code>E1000_RDT</code> 和 <code>E1000_TDT</code>。</p>
<p>为了测试你的驱动程序，在一个窗口中运行 <code>make server</code>，在另一个窗口运行 <code>make qemu</code>，然后在 xv6 中运行 <code>nettests</code>。<code>nettests</code> 中的第一个测试尝试向宿主操作系统发送一个 UDP 数据包，地址指向 <code>make server</code> 运行的程序。如果你还没有完成实验，E1000 驱动程序实际上不会发送数据包，因此几乎没有什么会发生。</p>
<p>完成实验后，E1000 驱动程序将发送数据包，qemu 将把它传送到你的宿主计算机，<code>make server</code> 将看到它，它将发送一个响应数据包，然后 E1000 驱动程序和 <code>nettests</code> 将看到响应数据包。然而，在宿主发送回复之前，它会向 xv6 发送一个“ARP”请求数据包，以找出其 48 位以太网地址，并期望 xv6 用 ARP 回复进行响应。一旦你完成了 E1000 驱动程序的工作，<code>kernel/net.c</code> 将处理这个问题。如果一切顺利，<code>nettests</code> 将打印 <code>testing ping: OK</code>，而 <code>make server</code> 将打印一条来自 xv6 的消息！</p>
<p>tcpdump -XXnr packets.pcap should produce output that starts like this:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">reading from file packets.pcap, link-type EN10MB (Ethernet)</span><br><span class="line">15:27:40.861988 IP 10.0.2.15.2000 &gt; 10.0.2.2.25603: UDP, length 19</span><br><span class="line">        0x0000:  ffff ffff ffff 5254 0012 3456 0800 4500  ......RT..4V..E.</span><br><span class="line">        0x0010:  002f 0000 0000 6411 3eae 0a00 020f 0a00  ./....d.&gt;.......</span><br><span class="line">        0x0020:  0202 07d0 6403 001b 0000 6120 6d65 7373  ....d.....a.mess</span><br><span class="line">        0x0030:  6167 6520 6672 6f6d 2078 7636 21         age.from.xv6!</span><br><span class="line">15:27:40.862370 ARP, Request who-has 10.0.2.15 tell 10.0.2.2, length 28</span><br><span class="line">        0x0000:  ffff ffff ffff 5255 0a00 0202 0806 0001  ......RU........</span><br><span class="line">        0x0010:  0800 0604 0001 5255 0a00 0202 0a00 0202  ......RU........</span><br><span class="line">        0x0020:  0000 0000 0000 0a00 020f                 ..........</span><br><span class="line">15:27:40.862844 ARP, Reply 10.0.2.15 is-at 52:54:00:12:34:56, length 28</span><br><span class="line">        0x0000:  ffff ffff ffff 5254 0012 3456 0806 0001  ......RT..4V....</span><br><span class="line">        0x0010:  0800 0604 0002 5254 0012 3456 0a00 020f  ......RT..4V....</span><br><span class="line">        0x0020:  5255 0a00 0202 0a00 0202                 RU........</span><br><span class="line">15:27:40.863036 IP 10.0.2.2.25603 &gt; 10.0.2.15.2000: UDP, length 17</span><br><span class="line">        0x0000:  5254 0012 3456 5255 0a00 0202 0800 4500  RT..4VRU......E.</span><br><span class="line">        0x0010:  002d 0000 0000 4011 62b0 0a00 0202 0a00  .-....@.b.......</span><br><span class="line">        0x0020:  020f 6403 07d0 0019 3406 7468 6973 2069  ..d.....4.this.i</span><br><span class="line">        0x0030:  7320 7468 6520 686f 7374 21              s.the.host!</span><br></pre></td></tr></table></figure>

<p>你的输出会有些不同，但它应该包含字符串 “ARP, Request”（ARP 请求），”ARP, Reply”（ARP 回复），”UDP”，”a.message.from.xv6” 和 “this.is.the.host”。</p>
<p><code>nettests</code> 还执行了一些其他测试，最终通过（真实的）互联网向谷歌的某个域名服务器发送了一个 DNS 请求。你应该确保你的代码通过了所有这些测试，之后你应该会看到以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ nettests</span><br><span class="line">nettests running on port 25603</span><br><span class="line">testing ping: OK</span><br><span class="line">testing single-process pings: OK</span><br><span class="line">testing multi-process pings: OK</span><br><span class="line">testing DNS</span><br><span class="line">DNS arecord for pdos.csail.mit.edu. is 128.52.129.126</span><br><span class="line">DNS OK</span><br><span class="line">all tests passed.</span><br></pre></td></tr></table></figure>

<p>你应该确保让分数同意你的解决方案通过。</p>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>首先，在 <code>e1000_transmit()</code> 和 <code>e1000_recv()</code> 中添加打印语句，然后运行 <code>make server</code> 和（在 xv6 中）<code>nettests</code>。你应该从打印语句中看到 <code>nettests</code> 生成了对 <code>e1000_transmit</code> 的调用。实现 <code>e1000_transmit</code> 的一些提示：</p>
<ol>
<li>首先询问 E1000 下一个期望的数据包将放在 TX 环的哪个索引位置，通过读取 <code>E1000_TDT</code> 控制寄存器来实现。</li>
<li>然后检查环是否溢出。如果 <code>E1000_TDT</code> 索引的描述符中没有设置 <code>E1000_TXD_STAT_DD</code>，则 E1000 尚未完成相应的之前的传输请求，因此返回一个错误。</li>
<li>否则，使用 <code>mbuffree()</code> 释放从该描述符传输的最后一个 <code>mbuf</code>（如果有的话）。</li>
<li>然后填写描述符。<code>m-&gt;head</code> 指向内存中数据包的内容，<code>m-&gt;len</code> 是数据包长度。设置必要的 cmd 标志（查看 E1000 手册的第 3.3 节）并保存一个指向 <code>mbuf</code> 的指针以便以后释放。</li>
<li>最后，通过向 <code>E1000_TDT</code> 加一模 <code>TX_RING_SIZE</code> 来更新环位置。</li>
<li>如果 <code>e1000_transmit()</code> 成功将 <code>mbuf</code> 添加到环中，则返回 0。如果失败（例如，没有可用的描述符来传输 <code>mbuf</code>），则返回 -1，以便调用者知道要释放 <code>mbuf</code>。</li>
</ol>
<p>实现 <code>e1000_recv</code> 的一些提示：</p>
<ol>
<li>首先通过获取 <code>E1000_RDT</code> 控制寄存器并加一模 <code>RX_RING_SIZE</code> 来询问 E1000 下一个等待接收的数据包（如果有的话）位于环的哪个索引位置。</li>
<li>然后通过检查描述符的状态部分中的 <code>E1000_RXD_STAT_DD</code> 位来检查是否有新数据包可用。如果没有，停止。</li>
<li>否则，将 <code>mbuf</code> 的 <code>m-&gt;len</code> 更新为描述符报告的长度。使用 <code>net_rx()</code> 将 <code>mbuf</code> 交给网络栈。</li>
<li>然后使用 <code>mbufalloc()</code> 分配一个新的 <code>mbuf</code> 来替换刚刚给 <code>net_rx()</code> 的那个。将其数据指针（<code>m-&gt;head</code>）编程到描述符中。将描述符的状态位清零。</li>
<li>最后，将 <code>E1000_RDT</code> 寄存器更新为最后处理的环描述符的索引。</li>
</ol>
<p><code>e1000_init()</code> 使用 <code>mbufs</code> 初始化 RX 环，你将需要查看它是如何做到的，并可能借用代码。在某个时刻，到达的数据包总数将超过环的大小（16）；确保你的代码能够处理这个情况。你将需要锁来应对 xv6 可能从多个进程使用 E1000，或者在中断到达时在内核线程中使用 E1000 的可能性。</p>
<h2 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h2><p>跟着提示一步一步的走就好</p>
<h3 id="E1000-transmit"><a href="#E1000-transmit" class="headerlink" title="E1000_transmit"></a>E1000_transmit</h3><h4 id="1-首先询问-E1000-下一个期望的数据包将放在-TX-环的哪个索引位置，通过读取-E1000-TDT-控制寄存器来实现。"><a href="#1-首先询问-E1000-下一个期望的数据包将放在-TX-环的哪个索引位置，通过读取-E1000-TDT-控制寄存器来实现。" class="headerlink" title="1.首先询问 E1000 下一个期望的数据包将放在 TX 环的哪个索引位置，通过读取 E1000_TDT 控制寄存器来实现。"></a>1.首先询问 E1000 下一个期望的数据包将放在 TX 环的哪个索引位置，通过读取 <code>E1000_TDT</code> 控制寄存器来实现。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acquire(&amp;e1000_lock); <span class="comment">// 请求锁</span></span><br><span class="line"><span class="type">int</span> index = regs[E1000_TDT]; <span class="comment">// 寄存器 E1000_TDT 中存储了第一个软件可以写入的描述符的位置</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span> * <span class="title">tail_desc</span> =</span> &amp; tx_ring[index]; <span class="comment">// 拿到可用的文件描述符</span></span><br></pre></td></tr></table></figure>

<h4 id="2-然后检查环是否溢出。如果-E1000-TDT-索引的描述符中没有设置-E1000-TXD-STAT-DD，则-E1000-尚未完成相应的之前的传输请求，因此返回一个错误。"><a href="#2-然后检查环是否溢出。如果-E1000-TDT-索引的描述符中没有设置-E1000-TXD-STAT-DD，则-E1000-尚未完成相应的之前的传输请求，因此返回一个错误。" class="headerlink" title="2.然后检查环是否溢出。如果 E1000_TDT 索引的描述符中没有设置 E1000_TXD_STAT_DD，则 E1000 尚未完成相应的之前的传输请求，因此返回一个错误。"></a>2.然后检查环是否溢出。如果 <code>E1000_TDT</code> 索引的描述符中没有设置 <code>E1000_TXD_STAT_DD</code>，则 E1000 尚未完成相应的之前的传输请求，因此返回一个错误。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((tail_desc-&gt;status &amp; E1000_TXD_STAT_DD) == <span class="number">0</span>) &#123; </span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-否则，使用-mbuffree-释放从该描述符传输的最后一个-mbuf（如果有的话）。"><a href="#3-否则，使用-mbuffree-释放从该描述符传输的最后一个-mbuf（如果有的话）。" class="headerlink" title="3.否则，使用 mbuffree() 释放从该描述符传输的最后一个 mbuf（如果有的话）。"></a>3.否则，使用 <code>mbuffree()</code> 释放从该描述符传输的最后一个 <code>mbuf</code>（如果有的话）。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tx_mbufs[index]) &#123;</span><br><span class="line">  mbuffree(tx_mbufs[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-然后填写描述符。m-gt-head-指向内存中数据包的内容，m-gt-len-是数据包长度。设置必要的-cmd-标志（查看-E1000-手册的第-3-3-节）并保存一个指向-mbuf-的指针以便以后释放。"><a href="#4-然后填写描述符。m-gt-head-指向内存中数据包的内容，m-gt-len-是数据包长度。设置必要的-cmd-标志（查看-E1000-手册的第-3-3-节）并保存一个指向-mbuf-的指针以便以后释放。" class="headerlink" title="4.然后填写描述符。m-&gt;head 指向内存中数据包的内容，m-&gt;len 是数据包长度。设置必要的 cmd 标志（查看 E1000 手册的第 3.3 节）并保存一个指向 mbuf 的指针以便以后释放。"></a>4.然后填写描述符。<code>m-&gt;head</code> 指向内存中数据包的内容，<code>m-&gt;len</code> 是数据包长度。设置必要的 cmd 标志（查看 E1000 手册的第 3.3 节）并保存一个指向 <code>mbuf</code> 的指针以便以后释放。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail_desc-&gt;length = m-&gt;len; <span class="comment">// 数据包的长度</span></span><br><span class="line">tail_desc-&gt;addr = (uint64)m-&gt;head; <span class="comment">// 数据包在缓存中的起始位置</span></span><br><span class="line">tail_desc-&gt;cmd |= E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS; <span class="comment">// cmd位，end of packet, report status</span></span><br></pre></td></tr></table></figure>

<h4 id="5-最后，将-E1000-RDT-寄存器更新为最后处理的环描述符的索引。"><a href="#5-最后，将-E1000-RDT-寄存器更新为最后处理的环描述符的索引。" class="headerlink" title="5.最后，将 E1000_RDT 寄存器更新为最后处理的环描述符的索引。"></a>5.最后，将 <code>E1000_RDT</code> 寄存器更新为最后处理的环描述符的索引。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">regs[E1000_RDT] = (index + <span class="number">1</span>) % tx_ring; <span class="comment">// 更新index</span></span><br><span class="line">release(&amp;e1000_lock); <span class="comment">// 释放锁</span></span><br></pre></td></tr></table></figure>

<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">e1000_transmit</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// the mbuf contains an ethernet frame; program it into</span></span><br><span class="line">  <span class="comment">// the TX descriptor ring so that the e1000 sends it. Stash</span></span><br><span class="line">  <span class="comment">// a pointer so that it can be freed after sending.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  acquire(&amp;e1000_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * todo: ask the E1000 for the TX ring index at which it&#x27;s expecting the next packet</span></span><br><span class="line"><span class="comment">   * E1000_TDT 指向 tx_ring 中下一个可以被分配的 descriptor 的索引</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> index = regs[E1000_TDT];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span>* <span class="title">tail_desc</span> =</span> &amp;tx_ring[index];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * todo: check if the ring is overflow</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">  <span class="keyword">if</span>((tail_desc-&gt;status &amp; E1000_TXD_STAT_DD) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//      printf(&quot;tx_ring buffer is overflow\n&quot;);</span></span><br><span class="line">      release(&amp;e1000_lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * todo: use mbuffree() to free the last mbuf that was transmitted from that descriptor</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">  <span class="keyword">if</span>(tx_mbufs[index]) &#123;</span><br><span class="line">      mbuffree(tx_mbufs[index]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// todo: m-&gt;head points to the packet&#x27;s content in memory,</span></span><br><span class="line">  tail_desc-&gt;addr = (uint64)(m-&gt;head);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// todo: m-&gt;len is the packet length</span></span><br><span class="line">  tail_desc-&gt;length = m-&gt;len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// todo: set the necessary cmd flag (look at Section 3.3 in the E1000 manual)</span></span><br><span class="line">  tail_desc-&gt;cmd |= E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// todo: stash away a pointer to the mbuf for later freeing.</span></span><br><span class="line">  tx_mbufs[index] = m;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// todo: update the E1000_TDT</span></span><br><span class="line">  regs[E1000_TDT] = (index + <span class="number">1</span>) % TX_RING_SIZE;</span><br><span class="line">  <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="E1000-recv"><a href="#E1000-recv" class="headerlink" title="E1000_recv"></a>E1000_recv</h3><p>我们要注意的是，在接收数据包时，不是一个一个接收的，所以我们要不断更新index，需要接收的包都接收完毕为止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"> ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-首先通过获取-E1000-RDT-控制寄存器并加一模-RX-RING-SIZE-来询问-E1000-下一个等待接收的数据包（如果有的话）位于环的哪个索引位置。"><a href="#1-首先通过获取-E1000-RDT-控制寄存器并加一模-RX-RING-SIZE-来询问-E1000-下一个等待接收的数据包（如果有的话）位于环的哪个索引位置。" class="headerlink" title="1.首先通过获取 E1000_RDT 控制寄存器并加一模 RX_RING_SIZE 来询问 E1000 下一个等待接收的数据包（如果有的话）位于环的哪个索引位置。"></a>1.首先通过获取 <code>E1000_RDT</code> 控制寄存器并加一模 <code>RX_RING_SIZE</code> 来询问 E1000 下一个等待接收的数据包（如果有的话）位于环的哪个索引位置。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint32 index = (regs[E1000_RDT] + <span class="number">1</span>) % RX_RING_SIZE; <span class="comment">// fetch the index</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rx_desc</span> *<span class="title">des</span> =</span> &amp;rx_ring[index]; <span class="comment">// fetch the desc</span></span><br></pre></td></tr></table></figure>

<h4 id="2-然后通过检查描述符的状态部分中的-E1000-RXD-STAT-DD-位来检查是否有新数据包可用。如果没有，停止。"><a href="#2-然后通过检查描述符的状态部分中的-E1000-RXD-STAT-DD-位来检查是否有新数据包可用。如果没有，停止。" class="headerlink" title="2.然后通过检查描述符的状态部分中的 E1000_RXD_STAT_DD 位来检查是否有新数据包可用。如果没有，停止。"></a>2.然后通过检查描述符的状态部分中的 <code>E1000_RXD_STAT_DD</code> 位来检查是否有新数据包可用。如果没有，停止。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(des-&gt;status &amp; E1000_RXD_STAT_DD)) &#123; <span class="comment">// 如果当前描述符的状态为不可用，则停止</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-否则，将-mbuf-的-m-gt-len-更新为描述符报告的长度。使用-net-rx-将-mbuf-交给网络栈。"><a href="#3-否则，将-mbuf-的-m-gt-len-更新为描述符报告的长度。使用-net-rx-将-mbuf-交给网络栈。" class="headerlink" title="3.否则，将 mbuf 的 m-&gt;len 更新为描述符报告的长度。使用 net_rx() 将 mbuf 交给网络栈。"></a>3.否则，将 <code>mbuf</code> 的 <code>m-&gt;len</code> 更新为描述符报告的长度。使用 <code>net_rx()</code> 将 <code>mbuf</code> 交给网络栈。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">buf</span> =</span> rx_mbufs[index];</span><br><span class="line">buf-&gt;len = des-&gt;length;</span><br><span class="line">net_rx(buf);</span><br></pre></td></tr></table></figure>

<h4 id="4-然后使用-mbufalloc-分配一个新的-mbuf-来替换刚刚给-net-rx-的那个。将其数据指针（m-gt-head）编程到描述符中。将描述符的状态位清零。"><a href="#4-然后使用-mbufalloc-分配一个新的-mbuf-来替换刚刚给-net-rx-的那个。将其数据指针（m-gt-head）编程到描述符中。将描述符的状态位清零。" class="headerlink" title="4.然后使用 mbufalloc() 分配一个新的 mbuf 来替换刚刚给 net_rx() 的那个。将其数据指针（m-&gt;head）编程到描述符中。将描述符的状态位清零。"></a>4.然后使用 <code>mbufalloc()</code> 分配一个新的 <code>mbuf</code> 来替换刚刚给 <code>net_rx()</code> 的那个。将其数据指针（<code>m-&gt;head</code>）编程到描述符中。将描述符的状态位清零。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">new_buf</span> =</span> mbufalloc(<span class="number">0</span>);</span><br><span class="line">rx_mbufs[index] = new_buf;</span><br><span class="line">des-&gt;addr = (uint64)new_buf-&gt;head;</span><br><span class="line">des-&gt;status = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="5-最后，将-E1000-RDT-寄存器更新为最后处理的环描述符的索引。-1"><a href="#5-最后，将-E1000-RDT-寄存器更新为最后处理的环描述符的索引。-1" class="headerlink" title="5.最后，将 E1000_RDT 寄存器更新为最后处理的环描述符的索引。"></a>5.最后，将 <code>E1000_RDT</code> 寄存器更新为最后处理的环描述符的索引。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regs[E1000_RDT] = index;</span><br></pre></td></tr></table></figure>

<h4 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">e1000_recv</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Check for packets that have arrived from the e1000</span></span><br><span class="line">  <span class="comment">// Create and deliver an mbuf for each packet (using net_rx()).</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// todo: First ask the E1000 for the ring index at which the next waiting received packet (if any) is located,</span></span><br><span class="line">      <span class="comment">// todo: by fetching the E1000_RDT control register and adding one modulo RX_RING_SIZE.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">// todo: check if a new packet is available by checking for the E1000_RXD_STAT_DD bit in the status portion of the descriptor.</span></span><br><span class="line">      uint32 index = (regs[E1000_RDT] + <span class="number">1</span>) % RX_RING_SIZE; <span class="comment">// fetch the index</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">rx_desc</span> *<span class="title">des</span> =</span> &amp;rx_ring[index];</span><br><span class="line">      <span class="keyword">if</span>(!(des-&gt;status &amp; E1000_RXD_STAT_DD)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// todo: update the mbuf&#x27;s m-&gt;len to the length reported in the descriptor. Deliver the mbuf to the network stack using net_rx().</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">buf</span> =</span> rx_mbufs[index];</span><br><span class="line">      buf-&gt;len = des-&gt;length;</span><br><span class="line">      net_rx(buf);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// todo: Then allocate a new mbuf using mbufalloc() to replace the one just given to net_rx().</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">new_buf</span> =</span> mbufalloc(<span class="number">0</span>);</span><br><span class="line">      rx_mbufs[index] = new_buf;</span><br><span class="line">      <span class="comment">// todo: Program its data pointer (m-&gt;head) into the descriptor. Clear the descriptor&#x27;s status bits to zero.</span></span><br><span class="line">      des-&gt;addr = (uint64)new_buf-&gt;head;</span><br><span class="line">      des-&gt;status = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// todo: Finally, update the E1000_RDT register to be the index of the last ring descriptor processed.</span></span><br><span class="line">      regs[E1000_RDT] = index;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/03/15/Lab-Multithreading/" rel="prev" title="Lab: Multithreading
">
      <i class="fa fa-chevron-left"></i> Lab: Multithreading

    </a></div>
      <div class="post-nav-item">
    <a href="/2024/03/24/ifizz/" rel="next" title="ifizz">
      ifizz <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab-networking"><span class="nav-number">1.</span> <span class="nav-text">Lab: networking</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">1.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.2.</span> <span class="nav-text">任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA"><span class="nav-number">1.3.</span> <span class="nav-text">提示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF"><span class="nav-number">1.4.</span> <span class="nav-text">实验思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#E1000-transmit"><span class="nav-number">1.4.1.</span> <span class="nav-text">E1000_transmit</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%A6%96%E5%85%88%E8%AF%A2%E9%97%AE-E1000-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9C%9F%E6%9C%9B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85%E5%B0%86%E6%94%BE%E5%9C%A8-TX-%E7%8E%AF%E7%9A%84%E5%93%AA%E4%B8%AA%E7%B4%A2%E5%BC%95%E4%BD%8D%E7%BD%AE%EF%BC%8C%E9%80%9A%E8%BF%87%E8%AF%BB%E5%8F%96-E1000-TDT-%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0%E3%80%82"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">1.首先询问 E1000 下一个期望的数据包将放在 TX 环的哪个索引位置，通过读取 E1000_TDT 控制寄存器来实现。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%84%B6%E5%90%8E%E6%A3%80%E6%9F%A5%E7%8E%AF%E6%98%AF%E5%90%A6%E6%BA%A2%E5%87%BA%E3%80%82%E5%A6%82%E6%9E%9C-E1000-TDT-%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%AD%E6%B2%A1%E6%9C%89%E8%AE%BE%E7%BD%AE-E1000-TXD-STAT-DD%EF%BC%8C%E5%88%99-E1000-%E5%B0%9A%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9B%B8%E5%BA%94%E7%9A%84%E4%B9%8B%E5%89%8D%E7%9A%84%E4%BC%A0%E8%BE%93%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%9B%A0%E6%AD%A4%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E3%80%82"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">2.然后检查环是否溢出。如果 E1000_TDT 索引的描述符中没有设置 E1000_TXD_STAT_DD，则 E1000 尚未完成相应的之前的传输请求，因此返回一个错误。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%90%A6%E5%88%99%EF%BC%8C%E4%BD%BF%E7%94%A8-mbuffree-%E9%87%8A%E6%94%BE%E4%BB%8E%E8%AF%A5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%BC%A0%E8%BE%93%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA-mbuf%EF%BC%88%E5%A6%82%E6%9E%9C%E6%9C%89%E7%9A%84%E8%AF%9D%EF%BC%89%E3%80%82"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">3.否则，使用 mbuffree() 释放从该描述符传输的最后一个 mbuf（如果有的话）。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E7%84%B6%E5%90%8E%E5%A1%AB%E5%86%99%E6%8F%8F%E8%BF%B0%E7%AC%A6%E3%80%82m-gt-head-%E6%8C%87%E5%90%91%E5%86%85%E5%AD%98%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8Cm-gt-len-%E6%98%AF%E6%95%B0%E6%8D%AE%E5%8C%85%E9%95%BF%E5%BA%A6%E3%80%82%E8%AE%BE%E7%BD%AE%E5%BF%85%E8%A6%81%E7%9A%84-cmd-%E6%A0%87%E5%BF%97%EF%BC%88%E6%9F%A5%E7%9C%8B-E1000-%E6%89%8B%E5%86%8C%E7%9A%84%E7%AC%AC-3-3-%E8%8A%82%EF%BC%89%E5%B9%B6%E4%BF%9D%E5%AD%98%E4%B8%80%E4%B8%AA%E6%8C%87%E5%90%91-mbuf-%E7%9A%84%E6%8C%87%E9%92%88%E4%BB%A5%E4%BE%BF%E4%BB%A5%E5%90%8E%E9%87%8A%E6%94%BE%E3%80%82"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">4.然后填写描述符。m-&gt;head 指向内存中数据包的内容，m-&gt;len 是数据包长度。设置必要的 cmd 标志（查看 E1000 手册的第 3.3 节）并保存一个指向 mbuf 的指针以便以后释放。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E6%9C%80%E5%90%8E%EF%BC%8C%E5%B0%86-E1000-RDT-%E5%AF%84%E5%AD%98%E5%99%A8%E6%9B%B4%E6%96%B0%E4%B8%BA%E6%9C%80%E5%90%8E%E5%A4%84%E7%90%86%E7%9A%84%E7%8E%AF%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E7%B4%A2%E5%BC%95%E3%80%82"><span class="nav-number">1.4.1.5.</span> <span class="nav-text">5.最后，将 E1000_RDT 寄存器更新为最后处理的环描述符的索引。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="nav-number">1.4.1.6.</span> <span class="nav-text">完整代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#E1000-recv"><span class="nav-number">1.4.2.</span> <span class="nav-text">E1000_recv</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%A6%96%E5%85%88%E9%80%9A%E8%BF%87%E8%8E%B7%E5%8F%96-E1000-RDT-%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8%E5%B9%B6%E5%8A%A0%E4%B8%80%E6%A8%A1-RX-RING-SIZE-%E6%9D%A5%E8%AF%A2%E9%97%AE-E1000-%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%AD%89%E5%BE%85%E6%8E%A5%E6%94%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%88%E5%A6%82%E6%9E%9C%E6%9C%89%E7%9A%84%E8%AF%9D%EF%BC%89%E4%BD%8D%E4%BA%8E%E7%8E%AF%E7%9A%84%E5%93%AA%E4%B8%AA%E7%B4%A2%E5%BC%95%E4%BD%8D%E7%BD%AE%E3%80%82"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">1.首先通过获取 E1000_RDT 控制寄存器并加一模 RX_RING_SIZE 来询问 E1000 下一个等待接收的数据包（如果有的话）位于环的哪个索引位置。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%84%B6%E5%90%8E%E9%80%9A%E8%BF%87%E6%A3%80%E6%9F%A5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E7%8A%B6%E6%80%81%E9%83%A8%E5%88%86%E4%B8%AD%E7%9A%84-E1000-RXD-STAT-DD-%E4%BD%8D%E6%9D%A5%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E6%9C%89%E6%96%B0%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8F%AF%E7%94%A8%E3%80%82%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%EF%BC%8C%E5%81%9C%E6%AD%A2%E3%80%82"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">2.然后通过检查描述符的状态部分中的 E1000_RXD_STAT_DD 位来检查是否有新数据包可用。如果没有，停止。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%90%A6%E5%88%99%EF%BC%8C%E5%B0%86-mbuf-%E7%9A%84-m-gt-len-%E6%9B%B4%E6%96%B0%E4%B8%BA%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%8A%A5%E5%91%8A%E7%9A%84%E9%95%BF%E5%BA%A6%E3%80%82%E4%BD%BF%E7%94%A8-net-rx-%E5%B0%86-mbuf-%E4%BA%A4%E7%BB%99%E7%BD%91%E7%BB%9C%E6%A0%88%E3%80%82"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">3.否则，将 mbuf 的 m-&gt;len 更新为描述符报告的长度。使用 net_rx() 将 mbuf 交给网络栈。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E7%84%B6%E5%90%8E%E4%BD%BF%E7%94%A8-mbufalloc-%E5%88%86%E9%85%8D%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84-mbuf-%E6%9D%A5%E6%9B%BF%E6%8D%A2%E5%88%9A%E5%88%9A%E7%BB%99-net-rx-%E7%9A%84%E9%82%A3%E4%B8%AA%E3%80%82%E5%B0%86%E5%85%B6%E6%95%B0%E6%8D%AE%E6%8C%87%E9%92%88%EF%BC%88m-gt-head%EF%BC%89%E7%BC%96%E7%A8%8B%E5%88%B0%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%AD%E3%80%82%E5%B0%86%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E7%8A%B6%E6%80%81%E4%BD%8D%E6%B8%85%E9%9B%B6%E3%80%82"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">4.然后使用 mbufalloc() 分配一个新的 mbuf 来替换刚刚给 net_rx() 的那个。将其数据指针（m-&gt;head）编程到描述符中。将描述符的状态位清零。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E6%9C%80%E5%90%8E%EF%BC%8C%E5%B0%86-E1000-RDT-%E5%AF%84%E5%AD%98%E5%99%A8%E6%9B%B4%E6%96%B0%E4%B8%BA%E6%9C%80%E5%90%8E%E5%A4%84%E7%90%86%E7%9A%84%E7%8E%AF%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E7%B4%A2%E5%BC%95%E3%80%82-1"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">5.最后，将 E1000_RDT 寄存器更新为最后处理的环描述符的索引。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-1"><span class="nav-number">1.4.2.6.</span> <span class="nav-text">完整代码</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="theLonging"
      src="/images/touxiang.JPG">
  <p class="site-author-name" itemprop="name">theLonging</p>
  <div class="site-description" itemprop="description">不捨晝夜。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/chantchanH7" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chantchanH7" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/562879980@qq.com" title="E-Mail → 562879980@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-07 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">theLonging</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">362k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:29</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
