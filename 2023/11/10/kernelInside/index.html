<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Kernel Inside!说是要做zns ssd存储开发，但是好像离不开linux内核，既然如此，那就开始愉快的Linux内核之旅吧！ 用到的参考资料包括（其实就是kernel inside 的学习笔记）：  Kernel Inside  深入理解Linux内核  Booting启动！ Kernel booting process. Part 1.From the boot loader to">
<meta property="og:type" content="article">
<meta property="og:title" content="kernelInside">
<meta property="og:url" content="http://example.com/2023/11/10/kernelInside/index.html">
<meta property="og:site_name" content="talk is cheap, show me the code.">
<meta property="og:description" content="Kernel Inside!说是要做zns ssd存储开发，但是好像离不开linux内核，既然如此，那就开始愉快的Linux内核之旅吧！ 用到的参考资料包括（其实就是kernel inside 的学习笔记）：  Kernel Inside  深入理解Linux内核  Booting启动！ Kernel booting process. Part 1.From the boot loader to">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-11%2010.58.21.png">
<meta property="og:image" content="http://example.com/images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-11%2011.14.17.png">
<meta property="og:image" content="http://example.com/images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-11%2011.16.57.png">
<meta property="og:image" content="http://example.com/images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-11%2011.32.50.png">
<meta property="og:image" content="http://example.com/images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-13%2011.10.19.png">
<meta property="article:published_time" content="2023-11-10T10:35:09.000Z">
<meta property="article:modified_time" content="2023-11-15T12:34:32.470Z">
<meta property="article:author" content="theLonging">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-11%2010.58.21.png">

<link rel="canonical" href="http://example.com/2023/11/10/kernelInside/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>kernelInside | talk is cheap, show me the code.</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">talk is cheap, show me the code.</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/10/kernelInside/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          kernelInside
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-10 18:35:09" itemprop="dateCreated datePublished" datetime="2023-11-10T18:35:09+08:00">2023-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-15 20:34:32" itemprop="dateModified" datetime="2023-11-15T20:34:32+08:00">2023-11-15</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>35k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>32 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Kernel-Inside"><a href="#Kernel-Inside" class="headerlink" title="Kernel Inside!"></a>Kernel Inside!</h1><p>说是要做<code>zns ssd</code>存储开发，但是好像离不开<code>linux</code>内核，既然如此，那就开始<del>愉快的</del>Linux内核之旅吧！</p>
<p>用到的参考资料包括（其实就是kernel inside 的学习笔记）：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://0xax.gitbooks.io/linux-insides/content/">Kernel Inside</a> </li>
<li>深入理解Linux内核</li>
</ul>
<h1 id="Booting"><a href="#Booting" class="headerlink" title="Booting"></a>Booting</h1><p>启动！</p>
<h1 id="Kernel-booting-process-Part-1"><a href="#Kernel-booting-process-Part-1" class="headerlink" title="Kernel booting process. Part 1."></a>Kernel booting process. Part 1.</h1><h2 id="From-the-boot-loader-to-the-kernel"><a href="#From-the-boot-loader-to-the-kernel" class="headerlink" title="From the boot loader to the kernel"></a>From the boot loader to the kernel</h2><h3 id="The-Magical-Power-Button-What-happens-next"><a href="#The-Magical-Power-Button-What-happens-next" class="headerlink" title="The Magical Power Button, What happens next?"></a>The Magical Power Button, What happens next?</h3><p>​	当按下开机键后，计算机首先会唤醒<code>cpu</code>，<code>80386</code>及之后的<code>cpu</code>会在其寄存器中定义如下数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP						0xfff0</span><br><span class="line">CS selector		0xf000</span><br><span class="line">CS base				0xffff0000</span><br></pre></td></tr></table></figure>

<p>​	处理器会在实模式<code>(real mode)</code>下运行</p>
<blockquote>
<ul>
<li><code>real mode</code>：所有的<code>x86</code>机器支持实模式，<code>8086</code>处理器的总线地址有20位，能处理<code>0 - 0xfffff</code>地址空间，但是该处理器的寄存器只有<code>16 bit</code>，只能处理<code>0-0xffff</code>位。</li>
<li><code>Memory segmentation</code>：使得所有地址空间都可以被访问，内存被分为小的，固定的<code>65536 bytes (64KB) segments</code>。但由于我们无法通过<code>16-bit</code>寻址<code>64KB</code>地址，下面会给出一个解决方法。</li>
<li><code>IP</code>： instruction pointer</li>
<li><code>CS selector</code>：Code Segment Selector</li>
<li><code>CS Base</code>：Code Segment Base Address</li>
</ul>
</blockquote>
<p>因此，一个<code>address</code>包括：<code>a segment selector</code>，<code>offset</code>；物理地址的计算公式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhysicalAddress = Segment Selector * 16 + Offset</span><br></pre></td></tr></table></figure>

<p>但如果<code>segment selector</code>和<code>offset</code>太大了，就会发生溢出，如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hex((0xffff &lt;&lt; 4) + 0xffff) = 0x10ffef</span><br></pre></td></tr></table></figure>

<p>由于实模式下只有20位地址位，所以<code>0x10ffef</code>会变成<code>0x00ffef</code>，这叫作<code>A20 line disabled</code>。</p>
<p>回到开机后的寄存器值：</p>
<p><code>CS register</code>包含：</p>
<ul>
<li><code>the visible segment selector</code></li>
<li><code>the hidden base address</code></li>
</ul>
<p>结合之前定义的<code>CS</code>基址和<code>IP</code>值，<code>CS:IP</code>是<code>0xf000:0xfff0</code>，经过物理地址公式的计算得到<code>0xfff0</code>.</p>
<p>该物理地址加上基址我们最终得到·存储在 <code>EIP register</code>中的值：<code>0xfffffff0</code>。</p>
<blockquote>
<ul>
<li><code>Extended Instruction Pointer</code>：该寄存器的作用是存储CPU当前正在执行的指令的地址。当CPU执行程序时，EIP寄存器会连续更新，以指向下一条要执行的指令。这对于程序的流程控制至关重要。</li>
</ul>
</blockquote>
<p>得到的值<code>0xfffffff0</code>被叫做复位向量<code>reset vector</code>，该内存地址是CPU在重置后希望找到第一个指令的地方。该内存地址包含一个<code>jump</code>指令，该指令通常指向<code>BIOS(Basic Input/ Output System)</code>入口。看看源代码，我们这里看的是 <a target="_blank" rel="noopener" href="https://www.coreboot.org`src/cpu/x86/16bit/reset16.inc%60%EF%BC%9A">https://www.coreboot.org`src/cpu/x86/16bit/reset16.inc`：</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> .section &quot;.reset&quot;, &quot;ax&quot;, %progbits</span><br><span class="line">    .code16</span><br><span class="line">.globl    _start</span><br><span class="line">_start:</span><br><span class="line">    .byte  0xe9</span><br><span class="line">    .int   _start16bit - ( . + 2 )</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p><code>0xe9</code>是<code>jump</code>指令的<code>opcode</code>，目的地址是<code>_start16bit - ( . + 2 )</code>。</p>
<p>同样，我们能找到之前说的其实地址是如何计算的<code>0xfffffff0 (src/cpu/x86/16bit/reset16.ld):</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    /* Trigger an error if I have an unuseable start address */</span><br><span class="line">    _bogus = ASSERT(_start16bit &gt;= 0xffff0000, &quot;_start16bit too low. Please report.&quot;);</span><br><span class="line">    _ROMTOP = 0xfffffff0;</span><br><span class="line">    . = _ROMTOP;</span><br><span class="line">    .reset . : &#123;</span><br><span class="line">        *(.reset);</span><br><span class="line">        . = 15;</span><br><span class="line">        BYTE(0x00);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<code>BIOS</code>启动，在检查完硬件后，<code>BIOS</code>需要找到一个可启动的设备，启动顺序是设定在<code>BIOS</code>中的，当尝试从硬盘中启动时，<code>BIOS</code>需要找到一个启动扇区<code>boot sector</code>。在硬盘上有一个分区叫作主引导记录<code>Main Boot Record</code>，<code>boot sector</code>在该分区的前<code>446</code>个字节，每个扇区有<code>512 bytes</code>，第一个扇区的最后两个字节为<code>0x55, 0xaa</code>，向<code>BIOS</code>说明该设备是可启动的。</p>
<p>​	下表给出实模式下的内存映射：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0x00000000 - 0x000003FF - Real Mode Interrupt Vector Table</span><br><span class="line">0x00000400 - 0x000004FF - BIOS Data Area</span><br><span class="line">0x00000500 - 0x00007BFF - Unused</span><br><span class="line">0x00007C00 - 0x00007DFF - Our Bootloader</span><br><span class="line">0x00007E00 - 0x0009FFFF - Unused</span><br><span class="line">0x000A0000 - 0x000BFFFF - Video RAM (VRAM) Memory</span><br><span class="line">0x000B0000 - 0x000B7777 - Monochrome Video Memory</span><br><span class="line">0x000B8000 - 0x000BFFFF - Color Video Memory</span><br><span class="line">0x000C0000 - 0x000C7FFF - Video ROM BIOS</span><br><span class="line">0x000C8000 - 0x000EFFFF - BIOS Shadow Area</span><br><span class="line">0x000F0000 - 0x000FFFFF - System BIOS</span><br></pre></td></tr></table></figure>

<p>​	之前我们说<code>CPU</code>尝试执行的第一个指令是存储在地址<code>0xffff fff0</code>中的，这比上表的地址大的多。<code>CPU</code>如何访问改地址？在<a target="_blank" rel="noopener" href="https://www.coreboot.org/Developer_Manual/Memory_map">coreboot</a>文档中给出了答案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xFFFE_0000 - 0xFFFF_FFFF: 128 kilobyte ROM mapped into address space</span><br></pre></td></tr></table></figure>

<p>​	现在我们知道，<code>BIOS</code>程序是存储在<code>ROM</code>中的。</p>
<h3 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h3><blockquote>
<p>​	现在 BIOS 已经选择了一个启动设备，并且将控制权转移给了启动扇区中的代码，在我们的例子中，启动扇区代码是 <a target="_blank" rel="noopener" href="http://git.savannah.gnu.org/gitweb/?p=grub.git;a=blob;f=grub-core/boot/i386/pc/boot.S;hb=HEAD">boot.img</a>。因为这段代码只能占用一个扇区，因此非常简单，只做一些必要的初始化，然后就跳转到 GRUB 2’s core image 去执行。 Core image 的代码请参考 <a target="_blank" rel="noopener" href="http://git.savannah.gnu.org/gitweb/?p=grub.git;a=blob;f=grub-core/boot/i386/pc/diskboot.S;hb=HEAD">diskboot.img</a>，一般来说 core image 在磁盘上存储在启动扇区之后到第一个可用分区之前。core image 的初始化代码会把整个 core image （包括 GRUB 2的内核代码和文件系统驱动） 引导到内存中。 引导完成之后，<a target="_blank" rel="noopener" href="http://git.savannah.gnu.org/gitweb/?p=grub.git;a=blob;f=grub-core/kern/main.c">grub_main</a>将被调用。</p>
<p>​	<code>grub_main</code> 初始化控制台，计算模块基地址，设置 root 设备，读取 grub 配置文件，加载模块。最后，将 GRUB 置于 normal 模式，在这个模式中，<code>grub_normal_execute</code>(from <code>grub-core/normal/main.c</code>) 将被调用以完成最后的准备工作，然后显示一个菜单列出所用可用的操作系统。当某个操作系统被选择之后，<code>grub_menu_execute_entry</code> 开始执行，它将调用 GRUB 的 <code>boot</code> 命令，来引导被选中的操作系统。</p>
<p>​	就像 kernel boot protocol 所描述的，引导程序必须填充 kernel setup header （位于 kernel setup code 偏移 <code>0x01f1</code> 处） 的必要字段。kernel setup header的定义开始于<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S">arch&#x2F;x86&#x2F;boot&#x2F;header.S</a>：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	.globl	hdr</span><br><span class="line">hdr:</span><br><span class="line">setup_sects:	.byte 0			/* Filled in by build.c */</span><br><span class="line">root_flags:	.word ROOT_RDONLY</span><br><span class="line">syssize:	.long 0			/* Filled in by build.c */</span><br><span class="line">ram_size:	.word 0			/* Obsolete */</span><br><span class="line">vid_mode:	.word SVGA_MODE</span><br><span class="line">root_dev:	.word 0			/* Filled in by build.c */</span><br><span class="line">boot_flag:	.word 0xAA55</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>.globl hdr</code>: <code>hdr</code>是一个全局符号，全局符号对程序的所有部分都是可见的，同时它也是一个标签，标记当前位置。</li>
<li>在后续的数据中遵循：<code>varible: .type value</code>，即<code>变量：类型 值</code>的形式。<ul>
<li><code>boot_flag:	.word 0xAA55</code>：<code>0xAA55</code>是可启动标志。</li>
</ul>
</li>
</ul>
</blockquote>
<p>​	我们将在<code>kernel boot protocol</code>中看到，内存在加载内核后是如何映射的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">         | Protected-mode kernel  |</span><br><span class="line">100000   +------------------------+</span><br><span class="line">         | I/O memory hole        |</span><br><span class="line">0A0000   +------------------------+</span><br><span class="line">         | Reserved for BIOS      | Leave as much as possible unused</span><br><span class="line">         ~                        ~</span><br><span class="line">         | Command line           | (Can also be below the X+10000 mark)</span><br><span class="line">X+10000  +------------------------+</span><br><span class="line">         | Stack/heap             | For use by the kernel real-mode code.</span><br><span class="line">X+08000  +------------------------+</span><br><span class="line">         | Kernel setup           | The kernel real-mode code.</span><br><span class="line">         | Kernel boot sector     | The kernel legacy boot sector.</span><br><span class="line">       X +------------------------+</span><br><span class="line">         | Boot loader            | &lt;- Boot sector entry point 0x7C00</span><br><span class="line">001000   +------------------------+</span><br><span class="line">         | Reserved for MBR/BIOS  |</span><br><span class="line">000800   +------------------------+</span><br><span class="line">         | Typically used by MBR  |</span><br><span class="line">000600   +------------------------+</span><br><span class="line">         | BIOS use only          |</span><br><span class="line">000000   +------------------------+</span><br></pre></td></tr></table></figure>

<p>当启动程序把控制权交给内核后，内核将从:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X + sizeof(KernelBootSector) + 1</span><br></pre></td></tr></table></figure>

<p><code>X</code>是内核启动扇区被加载的地址。启动程序现在加载<code>Linux</code>内核到内存中去，填充好头文件，然后跳转到相应的内存地址中去，我们去看内核建立程序。</p>
<h3 id="The-Beginning-of-the-Kernel-Setup-Stage"><a href="#The-Beginning-of-the-Kernel-Setup-Stage" class="headerlink" title="The Beginning of the Kernel Setup Stage"></a>The Beginning of the Kernel Setup Stage</h3><p>​	首先内核需要建立，这包括一些配置，如解压器和一些内存管理相关的东西，仅举几例。完成所有这些事情之后，内核设置部分将解压实际的内核并跳转到它。在代码<code>arch/x86/boot/header.S</code>的 <code>__start</code>标签是<code>setup part</code>。</p>
<pre><code> 为了能够作为`bootloader`来使用，`header.S`在开始处定义了 `MZ`，并且定义了`PE`头文件。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_EFI_STUB</span><br><span class="line">	# &quot;MZ&quot;, MS-DOS header</span><br><span class="line">	.word	MZ_MAGIC</span><br><span class="line">#endif</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">#ifdef CONFIG_EFI_STUB</span><br><span class="line">pe_header:</span><br><span class="line">	.long	PE_MAGIC</span><br></pre></td></tr></table></figure>

<p> 之所以代码需要这样写，这个是因为遵从 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">UEFI</a> 的硬件需要这样的结构才能正常引导操作系统。</p>
<p>除开这些作为<code>bootloader</code>的代码，真正的内核建立从下面开始：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// header.S line 299</span><br><span class="line">_start:</span><br><span class="line">		# Explicitly enter this as bytes, or the assembler</span><br><span class="line">		# tries to generate a 3-byte jump here, which causes</span><br><span class="line">		# everything else to push off to the wrong offset.</span><br><span class="line">		.byte	0xeb		# short (2-byte) jump</span><br><span class="line">		.byte	start_of_setup-1f</span><br></pre></td></tr></table></figure>

<p>bootloader 知道这个开始点，并且直接跳转到该点， 因此， bootloader将不会再从<code>.bstext section</code>开始。因为我们会在<code>arch/x86/boot/setup.ld</code>中看见：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// arch/x86/boot/setup.ld</span><br><span class="line">//</span><br><span class="line">. = 0;                    // current position</span><br><span class="line">.bstext : &#123; *(.bstext) &#125;  // put .bstext section to position 0</span><br><span class="line">.bsdata : &#123; *(.bsdata) &#125;</span><br></pre></td></tr></table></figure>

<p>​	这段代码是一个连接器脚本的一部分，用于指定程序编译后在内存中的布局。</p>
<blockquote>
<ul>
<li>设置当前位置：<code>. = 0;</code>设置连接器的当前位置指针为0。意味着紧接着的定义段将从内存地址0开始放置。</li>
<li>定义了<code>.bstext</code>段：<code>.bstext : &#123; *(.bstext) &#125;</code>，这行代码定义了一个名为 <code>.bstext</code> 的段。<code>&#123; *(.bstext) &#125;</code> 的意思是将所有标记为 <code>.bstext</code> 的部分（即汇编代码中用 <code>.section &quot;.bstext&quot;</code> 定义的部分）集中到这个段里。由于当前位置已经设置为0，所以这个段的内容将被放置在内存的开始位置。</li>
<li>定义了<code>.bsdata</code>段：<code>.bsdata : &#123; *(.bsdata) &#125;</code>：这行代码定义了一个名为 <code>.bsdata</code> 的段，并将所有标记为 <code>.bsdata</code> 的部分集中到这个段里。这允许链接器将这些数据放置在内存中的特定位置。</li>
</ul>
</blockquote>
<p>接着我们来看看内核设置的进入点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	# offset 512, entry point</span><br><span class="line"></span><br><span class="line">	.globl	_start</span><br><span class="line">_start:</span><br><span class="line">		# Explicitly enter this as bytes, or the assembler</span><br><span class="line">		# tries to generate a 3-byte jump here, which causes</span><br><span class="line">		# everything else to push off to the wrong offset.</span><br><span class="line">		.byte	0xeb		# short (2-byte) jump</span><br><span class="line">		.byte	start_of_setup-1f</span><br><span class="line">1:</span><br><span class="line"></span><br><span class="line">	# Part 2 of the header, from the old setup.S</span><br><span class="line"></span><br><span class="line">		.ascii	&quot;HdrS&quot;		# header signature</span><br><span class="line">		.word	0x020f		# header version number (&gt;= 0x0105)</span><br></pre></td></tr></table></figure>

<p>上述代码中， <code>0xeb</code>是<code>jmp</code>指令的<code>opcode</code>，表示将要跳转到<code>start_of_setup - 1f</code>。</p>
<p><code>Nf</code>声明：<code>2f</code>表示<code>local label 2</code>。在上述代码中，<code>1f</code>就是后面的<code>1:</code>，这部分代码包含了剩余的<code>setup header</code>，当<code>setup header</code>结束后，我们会看见<code>.entrytext</code>代码段，在<code>start_of_setup</code>标签处开始。	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># End of setup header #####################################################</span><br><span class="line">	.section &quot;.entrytext&quot;, &quot;ax&quot;</span><br><span class="line">start_of_setup:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这是第一段实际运行的代码。当内核配置<code>kernel setup</code>部分收到来自启动程序<code>bootloader</code>，第一个<code>jump</code>指令跳转到离内核起始点<code>(kernel real mode)``0x200 offset</code>。</p>
<p>终于，代码跳转到了<code>start_of_setup</code>，接着内核会做如下几件事：</p>
<ul>
<li><p>保证所有的段寄存器<code>segment register</code>值是相等的。</p>
</li>
<li><p>如果需要的话，建配置一个正确的栈。</p>
</li>
<li><p>配置bss</p>
<blockquote>
<p>BSS（Block Started by Symbol）是一个用来描述可执行文件或内存中的一部分的术语，它代表了一个程序中未初始化的全局变量和静态变量的集合。在程序的二进制文件中，BSS段通常不占用实际的磁盘空间，因为它只是一系列的零值。然而，在程序加载到内存时，操作系统为BSS段分配内存，并将其全部初始化为零。</p>
<p>BSS段的主要特点和作用包括：</p>
<ol>
<li><strong>未初始化的变量</strong>：BSS段用于存储程序中未显式初始化为特定值的全局变量和静态变量。这些变量在程序启动时默认被初始化为零。</li>
<li><strong>节省空间</strong>：由于BSS段中的数据默认为零，因此在程序的磁盘文件中不需要为它们分配空间。这有助于减少程序的文件大小。</li>
<li><strong>内存中的初始化</strong>：虽然在磁盘上不占用空间，但在程序加载到内存时，操作系统会为BSS段中的变量分配内存，并将它们初始化为零。</li>
<li><strong>与数据段的区别</strong>：BSS段通常与数据段（用于存储已初始化的全局变量和静态变量）相区分。数据段中的变量在程序的二进制文件中会占用相应的存储空间，以保持它们的初始值。</li>
</ol>
</blockquote>
</li>
<li><p>调转到c代码<code>arch/x86/boot/main.c</code></p>
</li>
</ul>
<h3 id="Aligning-the-Segment-Registers"><a href="#Aligning-the-Segment-Registers" class="headerlink" title="Aligning the Segment Registers"></a>Aligning the Segment Registers</h3><p>首先，内核保证，<code>ds</code>和<code>es</code>段寄存器指向同一个地址。接着使用<code>cld</code>指令，清除方向标志<code>direction flag</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Force %es = %ds</span><br><span class="line">	movw	%ds, %ax</span><br><span class="line">	movw	%ax, %es</span><br><span class="line">	cld</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>Direction Flag：在x86架构的CPU中，direction flag是标志寄存器（Flags Register）的一部分，用于控制字符串操作指令（如 <code>movsb</code>, <code>movsw</code>, <code>movsd</code>, <code>stosb</code>, <code>stosw</code>, <code>stosd</code>, <code>lodsb</code>, <code>lodsw</code>, <code>lodsd</code>, <code>scasb</code>, <code>scasw</code>, <code>scasd</code> 等）的处理方向。</p>
<p><code>direction flag = 1</code>时，这些操作指令处理字符串时会从高地址向底地址移动。为0时则相反。</p>
</li>
<li><p><code>cld</code>指令：<code>clear Direction Flag</code>，会将<code>Direction Flag</code>置为0。</p>
</li>
<li><p><code>es</code>：附加段寄存器</p>
</li>
<li><p><code>ds</code>：数据段寄存器</p>
</li>
<li><p><code>cs</code>：代码段寄存器</p>
</li>
<li><p><code>ss</code>：段寄存器</p>
</li>
<li><p><code>sp</code>：堆栈指针寄存器</p>
</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">segment = grub_linux_real_target &gt;&gt; 4;</span><br><span class="line">state.gs = state.fs = state.es = state.ds = state.ss = segment;</span><br><span class="line">state.cs = segment + 0x20; // cs = 0x1000 + 0x20 = 0x1020</span><br></pre></td></tr></table></figure>

<p><code>grub2</code>默认将<code>kernel setup</code>代码，加载到地址<code>0x10000</code>处，而<code>cs</code>是在<code>0x1020</code>处，这是因为代码的执行不会在文件的起始位置开始，而是跳转到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br><span class="line">    .byte 0xeb</span><br><span class="line">    .byte start_of_setup-1f</span><br></pre></td></tr></table></figure>

<p>这段代码是位于 <code>4d 5a</code>的<code>512 bytes</code>偏移处。之后开始配置栈。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> We will have entered with %cs = %ds+0x20, normalize %cs so</span><br><span class="line"># it is on par with the other segments.</span><br><span class="line">	pushw	%ds</span><br><span class="line">	pushw	$6f</span><br><span class="line">	lretw</span><br></pre></td></tr></table></figure>

<p>这段代码将 <code>ds</code>的值推入栈，紧跟着的是标签<code>6</code>的地址也推入栈，然后执行<code>lretw</code>。当执行<code>lretw</code>时，它将标签<code>6</code>的地址加载到<code>instruction pointer register</code>中，将<code>ds</code>的值加载到<code>cs</code>中。最终，<code>cs</code>和<code>ds</code>的值会保持一致。</p>
<blockquote>
<p><code>lretw</code>：这是一个远返回指令，用于从子程序返回。<code>lretw</code> 会从堆栈中弹出返回地址，并将其加载到指令指针寄存器（%ip）中。同时，它还会从堆栈中弹出一个值加载到代码段寄存器（%cs）中，这是远调用和远返回的特性。</p>
</blockquote>
<h3 id="Stack-Setup"><a href="#Stack-Setup" class="headerlink" title="Stack Setup"></a>Stack Setup</h3><p>​	几乎所有的配置代码是为了准备实模式下的<code>c</code>语言环境。下一个步骤是判断并纠正<code>ss</code>寄存器的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Force %es = %ds</span><br><span class="line">	movw	%ds, %ax</span><br><span class="line">	movw	%ax, %es</span><br><span class="line">	cld</span><br><span class="line"></span><br><span class="line"># Apparently some ancient versions of LILO invoked the kernel with %ss != %ds,</span><br><span class="line"># which happened to work by accident for the old code.  Recalculate the stack</span><br><span class="line"># pointer if %ss is invalid.  Otherwise leave it alone, LOADLIN sets up the</span><br><span class="line"># stack behind its own code, so we can&#x27;t blindly put it directly past the heap.</span><br><span class="line"></span><br><span class="line">	movw	%ss, %dx</span><br><span class="line">	cmpw	%ax, %dx	# %ds == %ss?</span><br><span class="line">	movw	%sp, %dx 	# move %sp to %dx</span><br></pre></td></tr></table></figure>

<p>我们首先要保证<code>%ss == %ds</code>，会出现三种情况：</p>
<p><code>ss</code>值合法</p>
<p><code>ss</code>值不合法且<code>CAN_USE_HEAP</code>被设置。</p>
<p><code>ss</code>值不合法且<code>CAN_USE_HEAP</code>未被设置。</p>
<ul>
<li>当<code>ss</code>值<code>(0x1000)</code>合法时，程序跳转到标签2：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2:	# Now %dx should point to the end of our stack space</span><br><span class="line">	andw	$~3, %dx	# dword align (might as well...)</span><br><span class="line">	jnz	3f					# jump if not zero</span><br><span class="line">	movw	$0xfffc, %dx	# Make sure we&#x27;re not zero</span><br><span class="line">3:	movw	%ax, %ss</span><br><span class="line">	movzwl	%dx, %esp	# Clear upper half of %esp</span><br><span class="line">	sti			# Now we should have a working stack</span><br></pre></td></tr></table></figure>

<p>​	首先将3取反得到<code>1111 1111 1111 1111 1111 1111 1111 1100</code> 之后和<code>%dx</code>做与运算，这将使 <code>%dx</code>的最后两位为0，以达到<code>dword align</code>双字对齐。即如果一个地址是4的倍数，我们就可以说它是双字对齐的。接着判断<code>andw</code>操作后的结果是否为0。如果为0，我们要将<code>%dx</code>的值设置为<code>0xfffc</code>（这是在 <code>64KB segment</code> 下的最大按四字对齐的地址）以保证<code>%dx</code>不为0。反之直接跳转到标签3。</p>
<p>​	标签3将<code>%ax</code>的值赋值给<code>%ss</code>。得到一个正确的栈：</p>
<p>​	<img src="/../images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-11%2010.58.21.png" alt="截屏2023-11-11 10.58.21"></p>
<ul>
<li>当<code>ss</code>值不合法且<code>CAN_USE_HEAP</code>被设置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Invalid %ss, make up a new stack</span><br><span class="line">	movw	$_end, %dx</span><br><span class="line">	testb	$CAN_USE_HEAP, loadflags</span><br><span class="line">	jz	1f</span><br><span class="line">	movw	heap_end_ptr, %dx</span><br><span class="line">1:	addw	$STACK_SIZE, %dx</span><br><span class="line">jnc	2f</span><br><span class="line">xorw	%dx, %dx	# Prevent wraparound</span><br></pre></td></tr></table></figure>

<p>我们首先将<code>$_end</code>赋值给 <code>%dx</code>，然后检查 <code>loadflag</code>中的 <code> $CAN_USE_HEAP</code>位。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S#L320">loadflags</a> is a bitmask header defined as:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOADED_HIGH     (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUIET_FLAG      (1&lt;&lt;5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEEP_SEGMENTS   (1&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_USE_HEAP    (1&lt;&lt;7)</span></span><br></pre></td></tr></table></figure>

<p>我们在<code>boot protocol</code>中了解到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Field name: loadflags</span><br><span class="line"></span><br><span class="line">  This field is a bitmask.</span><br><span class="line"></span><br><span class="line">  Bit 7 (write): CAN_USE_HEAP</span><br><span class="line">    Set this bit to 1 to indicate that the value entered in the</span><br><span class="line">    heap_end_ptr is valid.  If this field is clear, some setup code</span><br><span class="line">    functionality will be disabled.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>因此，如果<code>CAN_USE_HEAP</code>为1时 ，代表<code>heap_end_ptr</code>是合法的（指向栈底：<code>_end</code>）。然后将<code>%dx</code>加上一个<code>$STACK_SIZE</code>（这可能使得<code>%dx</code>指向栈顶）。如果没有溢出，则跳转到标签2，继续配置一个正确的栈。</p>
<p><img src="/../images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-11%2011.14.17.png" alt="截屏2023-11-11 11.14.17"></p>
<ul>
<li>当<code>ss</code>值不合法且<code>CAN_USE_HEAP</code>未被设置。那就只能用一个最小的栈，大小为from <code>_end</code> to <code>_end + STACK_SIZE</code></li>
</ul>
<p><img src="/../images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-11%2011.16.57.png" alt="截屏2023-11-11 11.16.57"></p>
<h3 id="BSS-Setup"><a href="#BSS-Setup" class="headerlink" title="BSS Setup"></a>BSS Setup</h3><p>在我们能跳向<code>main C code</code>之前，还有两个步骤需要配置，一个是配置<code>BSS</code>，第二个是检查<code>magic</code>签名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Check signature at end of setup</span><br><span class="line">	cmpl	$0x5a5aaa55, setup_sig</span><br><span class="line">	jne	setup_bad</span><br></pre></td></tr></table></figure>

<p>检查签名，如果不对，会报告一个<code>fatal error</code>。</p>
<p>签名匹配后，我们拥有了正确的段寄存器和栈，现在只需要配置正确的<code>BSS</code>段就可以跳转到<code>C</code>代码了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Zero the bss</span><br><span class="line">	movw	$__bss_start, %di</span><br><span class="line">	movw	$_end+3, %cx</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	subw	%di, %cx</span><br><span class="line">	shrw	$2, %cx</span><br><span class="line">	rep; stosl</span><br></pre></td></tr></table></figure>

<p><code>__bss_start</code>的地址赋值给<code>%di</code>，接着<code>__end + 3</code>的结果赋值给<code>%cx</code>。通过异或操作清空<code>%eax</code>的值。计算<code>cx -di</code>得到<code>bss section</code>的大小并存储到<code>cx</code>中。 <code>cx</code>除以4（右移2位）并重复执行<code>stosl</code>，该命令将持续把<code>eax</code>中的值（这里是0）存到<code>di</code>指向的地址中去，并将<code>di</code>的值增加4（这也是为什么<code>cx</code>要除以4的原因）。直到<code>cx</code>的值递减到0。以上的操作将<code>BSS section</code>的所有内存赋值为0：</p>
<p><img src="/../images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-11%2011.32.50.png" alt="截屏2023-11-11 11.32.50"></p>
<h3 id="Jump-to-main"><a href="#Jump-to-main" class="headerlink" title="Jump to main"></a>Jump to main</h3><p>现在我们跳转到主函数，<code>arch/x86/boot/main.c</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Jump to C code (should not return)</span><br><span class="line">	calll	main</span><br></pre></td></tr></table></figure>

<h1 id="Kernel-booting-process-Part-2"><a href="#Kernel-booting-process-Part-2" class="headerlink" title="Kernel booting process. Part 2."></a>Kernel booting process. Part 2.</h1><h2 id="First-steps-in-the-kernel-setup"><a href="#First-steps-in-the-kernel-setup" class="headerlink" title="First steps in the kernel setup"></a>First steps in the kernel setup</h2><p>现在我们将继续阅读<code>arch/x86/boot/main.c</code>，将学习如下内容：</p>
<ul>
<li>保护模式<code>protected mode</code>是什么。</li>
<li>计算机是怎样进入保护模式。</li>
<li>堆<code>heap</code>和控制台<code>console</code>的初始化。</li>
<li>内存检测，CPU确认，键盘初始化。</li>
<li><code>and much much more</code>。</li>
</ul>
<p>So, let‘s go ahead!</p>
<h2 id="Protected-mode"><a href="#Protected-mode" class="headerlink" title="Protected mode"></a>Protected mode</h2><p>在我们在进入<code>intel Long Mode</code>之前，内核需要将<code>CPU</code>转换到保护模式。</p>
<blockquote>
<ul>
<li><p>在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/X86-64">x86-64</a>处理器架构中，当处于<strong>长模式</strong>（Long mode）时，64位应用程序（或者是操作系统）可以使用64位指令和寄存器，而32位程序将以一种兼容子模式运行。<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC86%E6%A8%A1%E5%BC%8F">虚拟86模式</a>在长模式下不可用，也就是说，长模式不兼容16位程序。</p>
</li>
<li><p>不在长模式下运行时，处理器支持<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AE%9E%E6%A8%A1%E5%BC%8F">实模式</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BF%9D%E8%AD%B7%E6%A8%A1%E5%BC%8F">保护模式</a>两个子模式，在这两个模式下的x86-64处理器与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/X86-32">x86-32</a>处理器运行方式完全相同。</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CPUID">CPUID</a>扩展属性域中的一个位可以令运行在实模式或者保护模式的程序得知处理器能否转换到长模式，这使得程序能够检测是否使用了x86-64处理器。这类似于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Intel">Intel</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IA-64">IA-64</a>处理器使用CPUID中的一个属性位来让程序检测自己是否运行在IA-32仿真模式下。</p>
</li>
<li><p>保护模式在1982年第一次加入到<code>x86</code>架构，并在<code>intel 64</code>和长模式出现之前，一直是<code>intel</code>处理器的主模式。</p>
</li>
</ul>
</blockquote>
<p>从实模式<code>Real Mode</code>跳转出来的原因主要是实模式只提供非常有限的<code>RAM</code>访问。在前一章我们提到实模式只支持<code>1MB</code>，有时甚至只支持<code>640KB</code>的<code>RAM</code>。</p>
<p>保护模式带来了很多改变，其中最重要的是内存管理。实模式中20位地址总线被32位地址总线所替代。因此，它允许访问<code>4GB</code>的内存。同样，分页技术在保护模式中也可用。</p>
<p>实模式中的内存管理被分为两个部分：</p>
<ul>
<li>分段<code>Segmentation</code></li>
<li>分页<code>Paging</code></li>
</ul>
<p>在本节先讨论分段<code>segmentation</code>。在下一章我们会讨论分页<code>Paging</code>。</p>
<p>在之前我们介绍了实模式下的地址包含如下两部分：</p>
<ul>
<li>段基址<code>Base address of the segment</code></li>
<li>从段基址的偏移量<code>Offset from the segment base</code></li>
</ul>
<p>我们可以通过上述两部分获得物理地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhysicalAddress = Segment_Base * <span class="number">16</span> + Offset</span><br></pre></td></tr></table></figure>

<p>在保护模式，内存分段的方式则完全不同。不同于实模式下的固定<code>64KB</code>分段，保护模式中的段大小和位置被一个特殊的数据结构<code>Segment Descriptor</code>描述。这些段描述符<code>Segment Descriptor</code>存储在<code>Global Descriptor Table (GDT)</code>中。</p>
<p><code>GDT</code>常驻于内存中，但它在内存中没有固定的位置，因此它的地址存储在一个叫<code>GDTR</code>的寄存器中。</p>
<p>接着，我们介绍<code>GDT</code>是如何被加载到Linux内核代码中的。会有一个将它从内存中加载的操作，就像下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lgdt gdt	#	load global descriptor table 	</span><br></pre></td></tr></table></figure>

<p><code>lgdt</code>命令加载<code>GDT(global descriptor table)</code>的基址和大小加载到<code>GDTR</code>寄存器中，<code>GDTR</code>寄存器占48位：</p>
<ul>
<li><code>16</code>位表示<code>global descriptor table</code>的大小。</li>
<li><code>32</code>位表示<code>global descriptor table</code>的地址。</li>
</ul>
<p>之前提到，<code>GDT</code>包含<code>segment descriptors</code>，这是内存段的描述符。每个描述符占<code>64</code>位。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 63         56         51   48    45           39        32 </span><br><span class="line">------------------------------------------------------------</span><br><span class="line">|             | |B| |A|       | |   | |0|E|W|A|            |</span><br><span class="line">| BASE 31:24  |G|/|L|V| LIMIT |P|DPL|S|  TYPE | BASE 23:16 |</span><br><span class="line">|             | |D| |L| 19:16 | |   | |1|C|R|A|            |</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"> 31                         16 15                         0 </span><br><span class="line">------------------------------------------------------------</span><br><span class="line">|                             |                            |</span><br><span class="line">|        BASE 15:0            |       LIMIT 15:0           |</span><br><span class="line">|                             |                            |</span><br><span class="line">------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>51:48</code>和<code>15:0</code>表示段大小<code>length_of_segment - 1</code>，总共<code>20</code>位，同时段大小还取决于第<code>55</code>位<code>G (Granularity)</code>。</p>
<ul>
<li>当<code>G = 0</code>且<code>(segment) Limit = 0</code>时，段大小为<code>1 B</code>。</li>
<li>当<code>G = 1</code>且<code>(segment) Limit = 1</code>时，段大小为<code>4096 B</code>。</li>
<li>当<code>G = 0</code>且<code>(segment) Limit = 0xfffff</code>时，段大小为<code>1 MB。</code></li>
<li>当<code>G = 1</code>且<code>(segment) Limit = 0xfffff</code>时，段大小为<code>4 GB</code>。</li>
</ul>
<p>从上面的例子可以知道：</p>
<ul>
<li><code>G = 0</code>时，<code>Limit</code>被解释为<code>1 B</code>。</li>
<li><code>G = 1</code>时，<code>Limit</code>被解释为<code>4096 B = 4 KB = 1 页(page)</code>。</li>
</ul>
</li>
<li><p><code>Base</code>是<code>32位</code>，占<code>63:56</code>，<code>39:32</code>和<code>31:16</code>。表示段的起始物理地址。</p>
</li>
<li><p><code>Type/Attribute</code>为<code>5位</code>，占<code>44:40</code>，确定的段的属性。</p>
<ul>
<li><code>44位</code>的<code>S = 0</code>时，表示该段为系统段；<code>S = 1</code>时代表该段为数据段（栈段也属于数据段，且支持读和写）。</li>
<li><code>43位</code>的<code>Ex</code>规定该段是数据段还是代码段，<code>Ex = 0</code>表示数据段，反之为代码段。</li>
</ul>
</li>
</ul>
<p>下面列出所有类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">|           Type Field        | Descriptor Type | Description                        |</span><br><span class="line">|-----------------------------|-----------------|------------------------------------|</span><br><span class="line">| Decimal                     |                 |                                    |</span><br><span class="line">|             0    E    W   A |                 |                                    |</span><br><span class="line">| 0           0    0    0   0 | Data            | Read-Only                          |</span><br><span class="line">| 1           0    0    0   1 | Data            | Read-Only, accessed                |</span><br><span class="line">| 2           0    0    1   0 | Data            | Read/Write                         |</span><br><span class="line">| 3           0    0    1   1 | Data            | Read/Write, accessed               |</span><br><span class="line">| 4           0    1    0   0 | Data            | Read-Only, expand-down             |</span><br><span class="line">| 5           0    1    0   1 | Data            | Read-Only, expand-down, accessed   |</span><br><span class="line">| 6           0    1    1   0 | Data            | Read/Write, expand-down            |</span><br><span class="line">| 7           0    1    1   1 | Data            | Read/Write, expand-down, accessed  |</span><br><span class="line">|                  C    R   A |                 |                                    |</span><br><span class="line">| 8           1    0    0   0 | Code            | Execute-Only                       |</span><br><span class="line">| 9           1    0    0   1 | Code            | Execute-Only, accessed             |</span><br><span class="line">| 10          1    0    1   0 | Code            | Execute/Read                       |</span><br><span class="line">| 11          1    0    1   1 | Code            | Execute/Read, accessed             |</span><br><span class="line">| 12          1    1    0   0 | Code            | Execute-Only, conforming           |</span><br><span class="line">| 14          1    1    0   1 | Code            | Execute-Only, conforming, accessed |</span><br><span class="line">| 13          1    1    1   0 | Code            | Execute/Read, conforming           |</span><br><span class="line">| 15          1    1    1   1 | Code            | Execute/Read, conforming, accessed |</span><br><span class="line">--------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p><code>40, 41, 42</code>位表示<code>EXW</code>：<code>(Expansion, Writable, Accessiable)</code>或<code>CRA</code>：<code>(Conforming Readable Accesible)</code>。</p>
<ul>
<li><p><code>E = 0</code>，表示<code>expand up</code>，反之表示<code>expand down</code></p>
<blockquote>
<ul>
<li><strong>Expand Up</strong> 当一个内存段被定义为 “expand up” 时，这意味着段的大小可以向上扩展，也就是说，段的起始地址保持不变，而它的结束地址可以增大。在段描述符中，如果一个段是 “expand up” 类型的，当执行如堆（heap）内存分配这样的操作时，可以不断地向高地址扩展，增加段的大小。</li>
<li><strong>Expand Down</strong> 相反，”expand down” 段是指其结束地址固定，而起始地址可以减小（即向更低的内存地址扩展）。这通常用于如栈（stack）这样的数据结构，它们在增长时是向低地址扩展的。例如，在x86架构中，栈是向下增长的，这意味着如果栈需要更多空间，它的起始地址会向内存地址更低的方向移动。</li>
<li>在保护模式下的段描述符中，可以通过设置特定的标志位来定义段是 “expand up” 还是 “expand down”。这些标志位告诉处理器段的界限是如何随着数据的增长而变化的。</li>
</ul>
</blockquote>
</li>
<li><p><code>W = 1</code>，表示该段是写允许的；反之，该段为只读。</p>
</li>
<li><p><code>A = 1</code>，表示该段可被处理器访问。</p>
</li>
<li><p><code>C = 1</code>，该位仅在<code>43</code>位为1时有效，表示段代码可以被更低优先级的状态（例如用户态）执行。</p>
</li>
<li><p><code>R = 1</code>，表示可以从该段读取数据。</p>
</li>
</ul>
<ol>
<li><p><code>DPL[2 bits], (Descriptor privilege Level)</code>，占<code>46:45</code>两位。表示段的优先级，其中0为最高优先级。</p>
</li>
<li><p><code>47</code>位的<code>P</code>标志，表示该段是否存在内存中。<code>p = 0</code>表示该段不在内存中，如果处理器尝试访问一个不在内存中的段，会产生一个段不存在的异常。</p>
</li>
<li><p><code>52</code>位的<code>AVL</code>：保留位。</p>
</li>
<li><p><code>53</code>位的<code>L</code>表示该代码段是否包含<code>native 64-bit code</code>，如果包含，该代码段会在<code>64 bit</code>模式下执行。</p>
<blockquote>
<p>“Native 64-bit code”指的是为64位处理器架构专门编写和编译的程序代码。这些代码直接利用64位处理器能提供的特性，如更广泛的寄存器集合、更大的地址空间以及64位数据宽度，从而可以更高效地执行指令和处理数据。</p>
<p>当段描述符中的L标志（位53）被设置时，它表明该代码段包含的是原生的64位代码，且将在64位模式下执行。这与32位代码不同，后者即使在64位处理器上运行，也仅能使用32位架构的特性。</p>
</blockquote>
</li>
<li><p><code>54</code>位的<code>D/B</code>标志<code>(Default/Big flag)</code>表示操作数大小<code>32/16</code>位。</p>
<blockquote>
<p>操作数大小（Operand Size）是指在计算机架构中，CPU执行指令时所能处理的数据的位宽。这涉及到CPU指令能直接操作的数据单元的大小，例如，16位、32位或64位整数。</p>
<p>例如，在x86架构中：</p>
<ul>
<li>如果操作数大小是16位，那么CPU指令将会操作16位的数据单元，即它可以一次性读取、写入或处理16位（2字节）的数据。</li>
<li>如果操作数大小是32位，那么CPU指令将操作32位的数据单元，即它可以一次性读取、写入或处理32位（4字节）的数据。</li>
</ul>
</blockquote>
</li>
</ol>
<p>在实模式<code>real mode</code>下，段寄存器包<code>segment register</code>含了段选择器<code>segment selector</code>。然而在保护模式<code>protected mode</code>下，段选择器有所不同。每个段描述符拥有一个<code>16</code>位的段选择器<code>segment selector</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 15             3 2  1     0</span><br><span class="line">-----------------------------</span><br><span class="line">|      Index     | TI | RPL |</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Index</code>：存储描述符在<code>Gobal Descriptor Table</code>中的索引。</li>
<li><code>TI (Table Indicator)</code>：表示在什么地方寻找描述符。当<code>TI = 0</code>时，在<code>GDT</code>中寻找<code>Descriptor</code>。否则，在<code>Local Descriptor Table (LDT)</code>中寻找。</li>
<li><code>RPL</code>：存储请求者的优先级。</li>
</ul>
<p>每个段寄存器都有可见<code>visible</code>的和不可见<code>hidden</code>的部分：</p>
<ul>
<li><code>Visible</code>：存储段选择器。</li>
<li><code>Hidden</code>：存储段描述符（base, limit, attributes &amp; flags）</li>
</ul>
<p>在保护模式下，获取物理地址的步骤是：</p>
<ol>
<li><p>将段选择器<code>segment selector</code>加载到任意一个段寄存器<code>segment register</code>中。</p>
</li>
<li><p><code>CPU</code>从选择器<code>selector</code>中通过偏移<code>GDT address + Index</code>找到段描述符。然后将描述符加载到寄存器的不可见<code>hidden</code>部分。</p>
</li>
<li><p>如果不允许分页<code>paging disabled</code>，段的物理地址的计算公式如下：<br>$$<br>BaseAddress(found In The Descriptor Obtained In The Previous Step) + Offset<br>$$</p>
</li>
<li></li>
</ol>
<p>如下图所示：</p>
<p><img src="/../images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-13%2011.10.19.png" alt="截屏2023-11-13 11.10.19"></p>
<p>从实模式跳转到保护模式的流程如下：</p>
<ul>
<li>禁止中断</li>
<li>通过<code>lgdt</code>命令描述并加载<code>GDT</code></li>
<li>在<code>CR0 (Control Register 0)</code>中配置<code>PE (Protection Enable)</code></li>
<li>跳转到保护模式的代码</li>
</ul>
<p>在跳转到保护模式前，我们需要做一些准备。</p>
<p>阅读<code>arch/x86/boot/main.c</code>，我们会看见一些实现，键盘初始化，堆初始化等等，的函数。</p>
<p>查看<code>main.c</code>中的<code>main</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* First, copy the boot header into the &quot;zeropage&quot; */</span></span><br><span class="line">	copy_boot_params();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize the early-boot console */</span></span><br><span class="line">	console_init();</span><br><span class="line">	<span class="keyword">if</span> (cmdline_find_option_bool(<span class="string">&quot;debug&quot;</span>))</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;early console in setup code\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* End of heap check */</span></span><br><span class="line">	init_heap();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure we have all the proper CPU support */</span></span><br><span class="line">	<span class="keyword">if</span> (validate_cpu()) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Unable to boot - please use a kernel appropriate &quot;</span></span><br><span class="line">		     <span class="string">&quot;for your CPU.\n&quot;</span>);</span><br><span class="line">		die();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Tell the BIOS what CPU mode we intend to run in. */</span></span><br><span class="line">	set_bios_mode();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Detect memory layout */</span></span><br><span class="line">	detect_memory();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set keyboard repeat rate (why?) and query the lock flags */</span></span><br><span class="line">	keyboard_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Query Intel SpeedStep (IST) information */</span></span><br><span class="line">	query_ist();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Query APM information */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_APM) || defined(CONFIG_APM_MODULE)</span></span><br><span class="line">	query_apm_bios();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Query EDD information */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_EDD) || defined(CONFIG_EDD_MODULE)</span></span><br><span class="line">	query_edd();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set the video mode */</span></span><br><span class="line">	set_video();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Do the last things and invoke protected mode */</span></span><br><span class="line">	go_to_protected_mode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Copyinh-boot-parameters-into-the-“zeropage”"><a href="#Copyinh-boot-parameters-into-the-“zeropage”" class="headerlink" title="Copyinh boot parameters into the “zeropage”"></a>Copyinh boot parameters into the “zeropage”</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* First, copy the boot header into the &quot;zeropage&quot; */</span></span><br><span class="line">	copy_boot_params();</span><br></pre></td></tr></table></figure>

<p>该函数将内核配置头拷贝到对应的结构体<code>boot_params</code>（也叫<code>zeropage</code>，定义在<code>arch/x86/include/uapi/asm/bootparam.h</code>）对应的成员<code>setup_header</code>中。</p>
<blockquote>
<p>在Linux内核启动过程中，“kernel setup header”通常指的是一个特定的数据结构，它包含了启动时内核所需的各种参数和信息。这个数据结构在启动早期由引导程序填充，然后由启动加载器（比如GRUB）传递给内核。</p>
<p>“kernel setup header”结构定义了内核如何被加载，包含了以下信息：</p>
<ul>
<li>内核的加载模式（实模式或保护模式）</li>
<li>启动设备</li>
<li>内存布局信息</li>
<li>初始化RAM盘的位置和大小</li>
<li>视频模式选择</li>
<li>其他硬件参数</li>
</ul>
<p>这个头部信息是由启动代码中的一部分，比如Linux的bootsect.S（启动扇区）和setup.S（设置代码）所使用。这些信息对于内核来说非常关键，因为它们告诉内核它被加载到内存中的哪个位置，以及硬件的配置如何。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">struct setup_header &#123;</span><br><span class="line">	__u8	setup_sects;	// 	引导扇区的大小。</span><br><span class="line">	__u16	root_flags;		// 	根文件系统的挂载标志。</span><br><span class="line">	__u32	syssize;			// 	内核映像的大小（单位为16字节段）。</span><br><span class="line">	__u16	ram_size;			//	旧式的RAM大小指示，现在不常用。</span><br><span class="line">	__u16	vid_mode;			//	视频模式标识。</span><br><span class="line">	__u16	root_dev;			//	根设备的编号。</span><br><span class="line">	__u16	boot_flag;		//	引导标志，用来指示有效的引导扇区。</span><br><span class="line">	__u16	jump;					//	引导代码中跳转指令的起始位置。</span><br><span class="line">	__u32	header;				//	Magic Number，用来识别这个结构体。</span><br><span class="line">	__u16	version;			//	结构体的版本号。</span><br><span class="line">	__u32	realmode_swtch;		</span><br><span class="line">	__u16	start_sys_seg;</span><br><span class="line">	__u16	kernel_version;</span><br><span class="line">	__u8	type_of_loader;</span><br><span class="line">	__u8	loadflags;</span><br><span class="line">	__u16	setup_move_size;</span><br><span class="line">	__u32	code32_start;</span><br><span class="line">	__u32	ramdisk_image;</span><br><span class="line">	__u32	ramdisk_size;</span><br><span class="line">	__u32	bootsect_kludge;</span><br><span class="line">	__u16	heap_end_ptr;</span><br><span class="line">	__u8	ext_loader_ver;</span><br><span class="line">	__u8	ext_loader_type;</span><br><span class="line">	__u32	cmd_line_ptr;</span><br><span class="line">	__u32	initrd_addr_max;</span><br><span class="line">	__u32	kernel_alignment;</span><br><span class="line">	__u8	relocatable_kernel;</span><br><span class="line">	__u8	min_alignment;</span><br><span class="line">	__u16	xloadflags;</span><br><span class="line">	__u32	cmdline_size;</span><br><span class="line">	__u32	hardware_subarch;</span><br><span class="line">	__u64	hardware_subarch_data;</span><br><span class="line">	__u32	payload_offset;</span><br><span class="line">	__u32	payload_length;</span><br><span class="line">	__u64	setup_data;</span><br><span class="line">	__u64	pref_address;</span><br><span class="line">	__u32	init_size;</span><br><span class="line">	__u32	handover_offset;</span><br><span class="line">	__u32	kernel_info_offset;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>boot_params</code>结构体包含 <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/x86/boot.txt">linux boot protocol</a>定义的域，这些域会在启动器启动电脑、内核编译时填充。<code>copy_boot_protocal</code>做了以下两件事：</p>
<ol>
<li>将汇编代码<code>header.S</code>中的<code>hdr</code>标签复制到结构体<code>boot_params</code>中的<code>setup_header</code>成员。</li>
<li>如果加载内核时用了旧的命令行工具，它负责跟新指针指向新的内核命令行工具。</li>
</ol>
<p>顺便看一看实现复制<code>hdr</code>功能的<code>memcpy</code>在<code>arch/x86/boot/copy.S</code>中是如何实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Memory copy routines</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">	.code16</span><br><span class="line">	.text</span><br><span class="line"></span><br><span class="line">SYM_FUNC_START_NOALIGN(memcpy)</span><br><span class="line">	pushw	%si						# si 是源索引寄存器</span><br><span class="line">	pushw	%di						#	di 是目标寄存器</span><br><span class="line">	movw	%ax, %di			# ax 通常存放目的地址</span><br><span class="line">	movw	%dx, %si			# dx 通常存放源地址</span><br><span class="line">	pushw	%cx						# cx 计数寄存器</span><br><span class="line">	shrw	$2, %cx</span><br><span class="line">	rep; movsl					# rep 重复执行标志；movsl：move string long。这条指令用于从源地址复制一个双字（32位，或者说4个字节）到目标地址。</span><br><span class="line">	popw	%cx</span><br><span class="line">	andw	$3, %cx</span><br><span class="line">	rep; movsb</span><br><span class="line">	popw	%di</span><br><span class="line">	popw	%si</span><br><span class="line">	retl</span><br><span class="line">SYM_FUNC_END(memcpy)</span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>SYM_FUNC_START_NOALIGN</code>定义在<code>include/linux/linkage.h</code>中，表示这是一个全局函数。其中 <code>w/o</code>表示 <code>without alignment</code>，即无对齐。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SYM_FUNC_START_NOALIGN -- use for global functions, w/o alignment */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SYM_FUNC_START_NOALIGN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYM_FUNC_START_NOALIGN(name)			\</span></span><br><span class="line"><span class="meta">	SYM_START(name, SYM_L_GLOBAL, SYM_A_NONE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>memcpy</code>的汇编代码很简单。</p>
<ul>
<li>首先将<code>%si</code>和<code>%di</code>寄存器中的值压入栈中以保留它们的值，这是因为接下来的操作会改变它们的值。</li>
<li>然后将<code>%ax</code>和<code>%dx</code>的值存储到<code>%di</code>和<code>%si</code>中。</li>
<li>将<code>%cx</code>的值保存在栈中，然后对<code>%cx</code>的值右移2位（除以4）。</li>
<li>循环复制（一次复制4字节）源寄存器<code>si</code>指向的地址中的值，到目的寄存器<code>di</code>指向的地址空间中，直到计数寄存器<code>cx</code>减小为0。</li>
</ul>
<p>因为上面的操作都是4个字节4个字节的复制，而在实际使用<code>memcpy</code>时肯定会出现复制的字节不是4的倍数的情况。</p>
<ul>
<li>这种情况下，我们取出在栈中保存的<code>%cx</code>值，然后重复使用<code>movsb</code>命令（b代表每次复制一个字节）复制剩下的字节。</li>
<li>最后取出保存在<code>%di</code>和<code>%si</code>中的值并返回。</li>
</ul>
<p>在<code>arch/x86/Makefile</code>中的<code>REALMODE_CFLAGS</code>中可以看到，构建内核时通过<code>-mregparm = 3</code>的<code>GCC</code>选项。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How to compile the 16-bit code.  Note we always compile for -march=i386;</span></span><br><span class="line"><span class="comment"># that way we can complain to the user if the CPU is insufficient.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The -m16 option is supported by GCC &gt;= 4.9 and clang &gt;= 3.5. For</span></span><br><span class="line"><span class="comment"># older versions of GCC, include an *assembly* header to make sure that</span></span><br><span class="line"><span class="comment"># gcc doesn&#x27;t play any games behind our back.</span></span><br><span class="line">CODE16GCC_CFLAGS := -m32 -Wa,<span class="variable">$(srctree)</span>/arch/x86/boot/code16gcc.h</span><br><span class="line">M16_CFLAGS	 := <span class="variable">$(<span class="built_in">call</span> cc-option, -m16, <span class="variable">$(CODE16GCC_CFLAGS)</span>)</span></span><br><span class="line"></span><br><span class="line">REALMODE_CFLAGS	:= <span class="variable">$(M16_CFLAGS)</span> -g -Os -DDISABLE_BRANCH_PROFILING -D__DISABLE_EXPORTS \</span><br><span class="line">		   -Wall -Wstrict-prototypes -march=i386 -mregparm=3 \</span><br><span class="line">		   -fno-strict-aliasing -fomit-frame-pointer -fno-pic \</span><br><span class="line">		   -mno-mmx -mno-sse <span class="variable">$(<span class="built_in">call</span> cc-option,-fcf-protection=none)</span></span><br></pre></td></tr></table></figure>

<p>现在我们知道，函数<code>memcpy</code>的三个参数分别存储在<code>ax</code>,<code>dx</code>和<code>cx</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(&amp;boot_params.hdr, &amp;hdr, <span class="keyword">sizeof</span> hdr);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ax</code> 存储<code>boot_params.hdr</code>的地址</li>
<li><code>dx</code> 存储 <code>hdr</code>的地址</li>
<li><code>cx</code> 存储 <code>hdr</code> 的大小</li>
</ul>
<h2 id="Console-initialization"><a href="#Console-initialization" class="headerlink" title="Console initialization"></a>Console initialization</h2><p>使用函数<code>console_init</code>初始化控制台，该函数定义在<code>arch/x86/boot/early_serial_console.c</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">console_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	parse_earlyprintk();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!early_serial_base)</span><br><span class="line">		parse_console_uart8250();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数在启动参数中寻找<code>earlyprintk</code>选项，如果成功找到，则解析端口地址和端口的波特率并初始化端口。<code>earlyprintk</code>命令行的参数是其中的下一个：</p>
<ul>
<li><code>serial, 0x3f8, 115200</code></li>
<li><code>serial, ttyS0, 115200</code></li>
<li><code>ttyS0, 115200</code></li>
</ul>
<p>串行端口初始化成功后，我们会看见第一个输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cmdline_find_option_bool(<span class="string">&quot;debug&quot;</span>))</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;early console in setup code\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>函数<code>puts</code>定义在：<code>arch/x86/boot/tty.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __section(<span class="string">&quot;.inittext&quot;</span>) <span class="built_in">putchar</span>(<span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (ch == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;\r&#x27;</span>);	<span class="comment">/* \n -&gt; \r\n */</span></span><br><span class="line"></span><br><span class="line">	bios_putchar(ch);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (early_serial_base != <span class="number">0</span>)</span><br><span class="line">		serial_putchar(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __section(<span class="string">&quot;.inittext&quot;</span>) <span class="built_in">puts</span>(<span class="type">const</span> <span class="type">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (*str)</span><br><span class="line">		<span class="built_in">putchar</span>(*str++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在c语言中，<code>__section</code>属性告诉编译器将特定的函数或者变量放置在指定的段<code>(section)</code>中。<code>&quot;.inittext&quot;</code>是一个段名，用于指定内核初始化代码的位置。</p>
<p>即，指示连接器将<code>putchar</code>函数放置在<code>ELF</code>二进制文件的<code>.inittext</code>段中。这个段专门用于内核启动时需要执行，但是一旦完成初始化过程后就不再需要的代码。内核通常在启动完成后会释放这些初始化代码占用的内存，因为这段时间内核已经开始运行正常的运行时代码了。</p>
<p>使用这个属性可以帮助减少内核的运行时内存占用，因为初始化代码在它不再需要之后不会占用宝贵的内存资源。这在嵌入式系统中尤其有用，其中内存资源可能非常有限。</p>
</blockquote>
<p>我们在链接文件<code>arch/x86/boot/setup.ld</code>可以看到上述代码的<code>.inittext</code>段的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> */</span><br><span class="line">OUTPUT_FORMAT(&quot;elf32-i386&quot;)</span><br><span class="line">OUTPUT_ARCH(i386)</span><br><span class="line">ENTRY(_start)</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">	. = 0;</span><br><span class="line">	.bstext		: &#123; *(.bstext) &#125;</span><br><span class="line">	.bsdata		: &#123; *(.bsdata) &#125;</span><br><span class="line"></span><br><span class="line">	. = 495;</span><br><span class="line">	.header		: &#123; *(.header) &#125;</span><br><span class="line">	.entrytext	: &#123; *(.entrytext) &#125;</span><br><span class="line">	.inittext	: &#123; *(.inittext) &#125;</span><br><span class="line">	.initdata	: &#123; *(.initdata) &#125;</span><br><span class="line">	__end_init = .;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们回到函数<code>putchar</code>，该函数在将<code>\n</code>转换为<code>\r</code>后。调用<code>bios_putchar</code>，通过<code>0x10</code>中断，在<code>VGA screen</code>上输出。</p>
<blockquote>
<ul>
<li>在计算机术语中，“VGA screen”指的是通过视频图形阵列（Video Graphics Array，VGA）接口显示的屏幕。</li>
<li>BIOS（基本输入输出系统）提供了一系列的中断调用，用于低级别的硬件交互，其中<code>0x10</code>是视频服务的中断号。软件可以通过设置相应的寄存器，然后触发这个中断来执行特定的视频操作，如在屏幕上显示字符。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __section(<span class="string">&quot;.inittext&quot;</span>) bios_putchar(<span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">biosregs</span> <span class="title">ireg</span>;</span></span><br><span class="line"></span><br><span class="line">	initregs(&amp;ireg);</span><br><span class="line">	ireg.bx = <span class="number">0x0007</span>;</span><br><span class="line">	ireg.cx = <span class="number">0x0001</span>;</span><br><span class="line">	ireg.ah = <span class="number">0x0e</span>;</span><br><span class="line">	ireg.al = ch;</span><br><span class="line">	intcall(<span class="number">0x10</span>, &amp;ireg, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>initregs</code>调用<code>memset</code>函数将<code>biosregs ireg</code>置为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initregs</span><span class="params">(<span class="keyword">struct</span> biosregs *reg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(reg, <span class="number">0</span>, <span class="keyword">sizeof</span>(*reg));</span><br><span class="line">	reg-&gt;eflags |= X86_EFLAGS_CF;</span><br><span class="line">	reg-&gt;ds = ds();</span><br><span class="line">	reg-&gt;es = ds();</span><br><span class="line">	reg-&gt;fs = fs();</span><br><span class="line">	reg-&gt;gs = gs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阅读<code>memset</code>的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SYM_FUNC_START_NOALIGN(memset)</span><br><span class="line">	pushw	%di</span><br><span class="line">	movw	%ax, %di</span><br><span class="line">	movzbl	%dl, %eax		# move with Zero-Extend from Byte to Longword	</span><br><span class="line">	imull	$0x01010101,%eax</span><br><span class="line">	pushw	%cx</span><br><span class="line">	shrw	$2, %cx</span><br><span class="line">	rep; stosl</span><br><span class="line">	popw	%cx</span><br><span class="line">	andw	$3, %cx</span><br><span class="line">	rep; stosb</span><br><span class="line">	popw	%di</span><br><span class="line">	retl</span><br><span class="line">SYM_FUNC_END(memset)</span><br></pre></td></tr></table></figure>

<ul>
<li>同样接受三个参数，存放在<code>ax dx cx</code>中。</li>
<li>将8位<code>%dl</code>零扩展到32位并移动到<code>%eax</code>中。</li>
<li>然后通过<code>imull $0x01010101, %eax</code>将高<code>24</code>位全复制为低<code>8</code>位的值。</li>
<li><code>stosl</code>：<code>Store String long</code>（存储字符串长字）。该指令将累加器（<code>AL</code>、<code>AX</code>或<code>EAX</code>）中的数据复制到目标索引寄存器（<code>DI</code>或<code>EDI</code>）指向的内存地址，并根据当前设置的方向标志（Direction Flag）在标志寄存器中自动增加或减少<code>DI</code>&#x2F;<code>EDI</code>的值。直到计数寄存器<code>cx</code>归<code>0</code>。</li>
</ul>
<h2 id="Heap-initialization"><a href="#Heap-initialization" class="headerlink" title="Heap initialization"></a>Heap initialization</h2><p>在<code>header.S</code>中，我们初始化了栈<code>stack</code>和<code>bss</code>段。现在内核需要使用<code>init_heap</code>初始化堆<code>heap</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_heap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *stack_end;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (boot_params.hdr.loadflags &amp; CAN_USE_HEAP) &#123;</span><br><span class="line">		<span class="keyword">asm</span>(<span class="string">&quot;leal %P1(%%esp),%0&quot;</span></span><br><span class="line">		    : <span class="string">&quot;=r&quot;</span> (stack_end) : <span class="string">&quot;i&quot;</span> (-STACK_SIZE));</span><br><span class="line"></span><br><span class="line">		heap_end = (<span class="type">char</span> *)</span><br><span class="line">			((<span class="type">size_t</span>)boot_params.hdr.heap_end_ptr + <span class="number">0x200</span>);</span><br><span class="line">		<span class="keyword">if</span> (heap_end &gt; stack_end)</span><br><span class="line">			heap_end = stack_end;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Boot protocol 2.00 only, no heap available */</span></span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;WARNING: Ancient bootloader, some functionality &quot;</span></span><br><span class="line">		     <span class="string">&quot;may be limited!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先检查启动文件头的<code>loadflag</code>中是否配置了<code>CAN_USE_HEAP</code>，如果配置了<code>CAN_USE_HEAP</code>，使用内链汇编代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;leal %P1(%%esp),%0&quot;</span></span><br><span class="line">		    : <span class="string">&quot;=r&quot;</span> (stack_end) : <span class="string">&quot;i&quot;</span> (-STACK_SIZE));</span><br></pre></td></tr></table></figure>

<p>计算栈的结束位置。也即：<code>stack_end = esp - STACK_SIZE</code></p>
<p>接着是计算堆结束位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap_end = (<span class="type">char</span> *)((<span class="type">size_t</span>)boot_params.hdr.heap_end_ptr + <span class="number">0x200</span>);</span><br></pre></td></tr></table></figure>

<p>最后检查堆结束地址<code>heap_end</code>是否大于栈结束地址<code>stack_end</code>，如果是，则要保持<code>heap_end = stack_end</code>。</p>
<p>堆初始化之后，我们可以使用<code>GET_HEAP</code>方法，在下一章我们会介绍它。</p>
<h2 id="CPU确认"><a href="#CPU确认" class="headerlink" title="CPU确认"></a>CPU确认</h2><p>下一步是确认<code>CPU，函数</code>validate_cpu<code>定义在</code><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/cpu.c"><code>arch/x86/boot/cpu.c</code></a>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">validate_cpu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 *err_flags;</span><br><span class="line">	<span class="type">int</span> cpu_level, req_level;</span><br><span class="line"></span><br><span class="line">	check_cpu(&amp;cpu_level, &amp;req_level, &amp;err_flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cpu_level &lt; req_level) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;This kernel requires an %s CPU, &quot;</span>,</span><br><span class="line">		       cpu_name(req_level));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;but only detected an %s CPU.\n&quot;</span>,</span><br><span class="line">		       cpu_name(cpu_level));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err_flags) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;This kernel requires the following features &quot;</span></span><br><span class="line">		     <span class="string">&quot;not present on the CPU:\n&quot;</span>);</span><br><span class="line">		show_cap_strs(err_flags);</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (check_knl_erratum()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数<code>check_cpu</code>判断当前CPU等级<code>cpu_level</code>和需要的CPU等级<code>req_level</code>是否一致。该函数还检查CPU标志，对于x86_64（64位）CPU，它会检查长模式（long mode）是否存在，检查处理器的供应商，并为特定供应商做准备，比如如果AMD缺失SSE+SSE2，就关闭它们等等。</p>
<p>当cpu被确认后，调用<code>set_bios_mode</code>，该函数告诉<code>BIOS</code>我们会在哪种<code>CPU</code>模式下运行。该函数只在<code>x86_64</code>模式下运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Tell the BIOS what CPU mode we intend to run in.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_bios_mode</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">biosregs</span> <span class="title">ireg</span>;</span></span><br><span class="line"></span><br><span class="line">	initregs(&amp;ireg);</span><br><span class="line">	ireg.ax = <span class="number">0xec00</span>;</span><br><span class="line">	ireg.bx = <span class="number">2</span>;</span><br><span class="line">	intcall(<span class="number">0x15</span>, &amp;ireg, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数通过<code>0x15 BIOS</code>中断告诉<code>BIOS</code>使用长模式<code>long mode</code>。</p>
<blockquote>
<p>在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/X86-64">x86-64</a>处理器架构中，当处于<strong>长模式</strong>（Long mode）时，64位应用程序（或者是操作系统）可以使用64位指令和寄存器，而32位程序将以一种兼容子模式运行。</p>
</blockquote>
<h2 id="Memory-detection"><a href="#Memory-detection" class="headerlink" title="Memory detection"></a>Memory detection</h2><p>接着主函数会调用<code>detect_memory</code>检测内存，该函数为<code>CPU</code>提供了基础的<code>RAM</code>映射表。使用了不同的编程接口<code>0xe820 0xe801</code>和<code>0x88</code>用于内存检测。以<code>0xE820</code>为例，<code>detect_memory_e820</code>定义在<code>arch/x86/boot/memory.c</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">detect_memory_e820</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">biosregs</span> <span class="title">ireg</span>, <span class="title">oreg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">boot_e820_entry</span> *<span class="title">desc</span> =</span> boot_params.e820_table;</span><br><span class="line">	<span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">boot_e820_entry</span> <span class="title">buf</span>;</span> <span class="comment">/* static so it is zeroed */</span></span><br><span class="line"></span><br><span class="line">	initregs(&amp;ireg);</span><br><span class="line">	ireg.ax  = <span class="number">0xe820</span>;</span><br><span class="line">	ireg.cx  = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">	ireg.edx = SMAP;</span><br><span class="line">	ireg.di  = (<span class="type">size_t</span>)&amp;buf;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Note: at least one BIOS is known which assumes that the</span></span><br><span class="line"><span class="comment">	 * buffer pointed to by one e820 call is the same one as</span></span><br><span class="line"><span class="comment">	 * the previous call, and only changes modified fields.  Therefore,</span></span><br><span class="line"><span class="comment">	 * we use a temporary buffer and copy the results entry by entry.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This routine deliberately does not try to account for</span></span><br><span class="line"><span class="comment">	 * ACPI 3+ extended attributes.  This is because there are</span></span><br><span class="line"><span class="comment">	 * BIOSes in the field which report zero for the valid bit for</span></span><br><span class="line"><span class="comment">	 * all ranges, and we don&#x27;t currently make any use of the</span></span><br><span class="line"><span class="comment">	 * other attribute bits.  Revisit this if we see the extended</span></span><br><span class="line"><span class="comment">	 * attribute bits deployed in a meaningful way in the future.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		intcall(<span class="number">0x15</span>, &amp;ireg, &amp;oreg);</span><br><span class="line">		ireg.ebx = oreg.ebx; <span class="comment">/* for next iteration... */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* BIOSes which terminate the chain with CF = 1 as opposed</span></span><br><span class="line"><span class="comment">		   to %ebx = 0 don&#x27;t always report the SMAP signature on</span></span><br><span class="line"><span class="comment">		   the final, failing, probe. */</span></span><br><span class="line">		<span class="keyword">if</span> (oreg.eflags &amp; X86_EFLAGS_CF)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Some BIOSes stop returning SMAP in the middle of</span></span><br><span class="line"><span class="comment">		   the search loop.  We don&#x27;t know exactly how the BIOS</span></span><br><span class="line"><span class="comment">		   screwed up the map at that point, we might have a</span></span><br><span class="line"><span class="comment">		   partial map, the full map, or complete garbage, so</span></span><br><span class="line"><span class="comment">		   just return failure. */</span></span><br><span class="line">		<span class="keyword">if</span> (oreg.eax != SMAP) &#123;</span><br><span class="line">			count = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		*desc++ = buf;</span><br><span class="line">		count++;</span><br><span class="line">	&#125; <span class="keyword">while</span> (ireg.ebx &amp;&amp; count &lt; ARRAY_SIZE(boot_params.e820_table));</span><br><span class="line"></span><br><span class="line">	boot_params.e820_entries = count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数首先为寄存器填充调用<code>0xe820</code>所需的特定值。</p>
<ul>
<li><code>ax</code>：包含了函数的名字。</li>
<li><code>cx</code>：缓存的大小，该缓存将用于存储内存中的数据。</li>
<li><code>edx</code>：包含了<code>SMAP magic number</code>。</li>
<li><code>es:di</code>：指向上面提到的缓存的地址（cx中）。</li>
<li><code>ebx</code>：必须为0.</li>
</ul>
<p>然后是一个循环，该循环收集内存中的数据。首先调用<code>0x15</code>的<code>BIOS</code>中断，该中断从地址分配表中写入一行。为了获取下一行，我们需要再次调用该中断。在下一次调用之前，ebx必须包含之前返回的值。</p>
<p>最终，该函数从地址分配表收集数据，并将这些数据写入e820_entry数组：</p>
<ul>
<li>内存段的起点</li>
<li>内存段的大小</li>
<li>内存段的类型（可用或者保留）</li>
</ul>
<p><code>dmesg</code>的输出是像下面给出的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[    0.000000] e820: BIOS-provided physical RAM map:</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x0000000000000000-0x000000000009fbff] usable</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x000000000009fc00-0x000000000009ffff] reserved</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x00000000000f0000-0x00000000000fffff] reserved</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x0000000000100000-0x000000003ffdffff] usable</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x000000003ffe0000-0x000000003fffffff] reserved</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x00000000fffc0000-0x00000000ffffffff] reserved</span><br></pre></td></tr></table></figure>

<h2 id="Keyboard-initialization"><a href="#Keyboard-initialization" class="headerlink" title="Keyboard initialization"></a>Keyboard initialization</h2><p>接着调用函数<code>keyboard_init</code>初始化键盘，同样通过函数<code>initregs</code>初始化寄存器。然后调用<code>0x16</code>中断查询键盘状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">keyboard_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">biosregs</span> <span class="title">ireg</span>, <span class="title">oreg</span>;</span></span><br><span class="line">	initregs(&amp;ireg);</span><br><span class="line"></span><br><span class="line">	ireg.ah = <span class="number">0x02</span>;		<span class="comment">/* Get keyboard status */</span></span><br><span class="line">	intcall(<span class="number">0x16</span>, &amp;ireg, &amp;oreg);</span><br><span class="line">	boot_params.kbd_status = oreg.al;</span><br><span class="line"></span><br><span class="line">	ireg.ax = <span class="number">0x0305</span>;	<span class="comment">/* Set keyboard repeat rate */</span></span><br><span class="line">	intcall(<span class="number">0x16</span>, &amp;ireg, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此之后，它再次调用0x16来设置重复率和延迟。</p>
<h2 id="Querying"><a href="#Querying" class="headerlink" title="Querying"></a>Querying</h2><p>接下来的几个步骤是对不同参数的查询。我们不会深入研究这些查询的细节，但稍后会回复它们。让我们简要看看这些功能：</p>
<ul>
<li><p><code>query_ist</code>：获取<code>Intel SpeedStep</code>信息。检查<code>CPU</code>的等级，如果正确，调用<code>0x15</code>中断获取信息并存储到<code>boot_params</code>中</p>
<blockquote>
<p>ST（Intel SpeedStep Technology）是英特尔开发的一种处理器技术，旨在优化处理器的性能和电源使用效率。它通过根据当前计算机负载动态调整处理器的频率和电压来实现这一目标。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get Intel SpeedStep (IST) information.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">query_ist</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">biosregs</span> <span class="title">ireg</span>, <span class="title">oreg</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Some older BIOSes apparently crash on this call, so filter</span></span><br><span class="line"><span class="comment">	   it from machines too old to have SpeedStep at all. */</span></span><br><span class="line">	<span class="keyword">if</span> (cpu.level &lt; <span class="number">6</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	initregs(&amp;ireg);</span><br><span class="line">	ireg.ax  = <span class="number">0xe980</span>;	 <span class="comment">/* IST Support */</span></span><br><span class="line">	ireg.edx = <span class="number">0x47534943</span>;	 <span class="comment">/* Request value */</span></span><br><span class="line">	intcall(<span class="number">0x15</span>, &amp;ireg, &amp;oreg);</span><br><span class="line"></span><br><span class="line">	boot_params.ist_info.signature  = oreg.eax;</span><br><span class="line">	boot_params.ist_info.command    = oreg.ebx;</span><br><span class="line">	boot_params.ist_info.event      = oreg.ecx;</span><br><span class="line">	boot_params.ist_info.perf_level = oreg.edx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>query_apm_bios</code>：从<code>BIOS</code>中获取<code>Advanced Power Management</code>信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Query_apm_bios也调用0x15 BIOS中断，但用ah = 0x53检查APM安装。0x15完成执行后，query_apm_bios函数检查PM签名（必须是0x504d）、携带标志（如果支持APM，则必须是0）和cx寄存器的值（如果是0x02，则支持受保护模式接口）。</span><br><span class="line"></span><br><span class="line">接下来，它再次调用0x15，但使用ax = 0x5304断开APM接口并连接32位保护模式接口。最后，它用从BIOS获得的值填充boot_params.apm_bios_info。</span><br><span class="line"></span><br><span class="line">请注意，只有在配置文件中设置了CONFIG_APM或CONFIG_APM_MODULE编译时间标志时，query_apm_bios才会执行：</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>query_edd</code>：查询<code>Enhanced Disk Drive</code>信息。</p>
<p>函数首先从内核命令行中读取<code>edd</code>设置，如果没有该选择则直接退出函数。</p>
<p>如果启用EDD，query_edd会检查BIOS支持的硬盘，并在循环中查询EDD信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">query_edd</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> eddarg[<span class="number">8</span>];</span><br><span class="line">	<span class="type">int</span> do_mbr = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EDD_OFF</span></span><br><span class="line">	<span class="type">int</span> do_edd = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">int</span> do_edd = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span> be_quiet;</span><br><span class="line">	<span class="type">int</span> devno;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">edd_info</span> <span class="title">ei</span>, *<span class="title">edp</span>;</span></span><br><span class="line">	u32 *mbrptr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cmdline_find_option(<span class="string">&quot;edd&quot;</span>, eddarg, <span class="keyword">sizeof</span>(eddarg)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(eddarg, <span class="string">&quot;skipmbr&quot;</span>) || !<span class="built_in">strcmp</span>(eddarg, <span class="string">&quot;skip&quot;</span>)) &#123;</span><br><span class="line">			do_edd = <span class="number">1</span>;</span><br><span class="line">			do_mbr = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(eddarg, <span class="string">&quot;off&quot;</span>))</span><br><span class="line">			do_edd = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(eddarg, <span class="string">&quot;on&quot;</span>))</span><br><span class="line">			do_edd = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	be_quiet = cmdline_find_option_bool(<span class="string">&quot;quiet&quot;</span>);</span><br><span class="line"></span><br><span class="line">	edp    = boot_params.eddbuf;</span><br><span class="line">	mbrptr = boot_params.edd_mbr_sig_buffer;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!do_edd)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Bugs in OnBoard or AddOnCards Bios may hang the EDD probe,</span></span><br><span class="line"><span class="comment">	 * so give a hint if this happens.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!be_quiet)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Probing EDD (edd=off to disable)... &quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (devno = <span class="number">0x80</span>; devno &lt; <span class="number">0x80</span>+EDD_MBR_SIG_MAX; devno++) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Scan the BIOS-supported hard disks and query EDD</span></span><br><span class="line"><span class="comment">		 * information...</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!get_edd_info(devno, &amp;ei)</span><br><span class="line">		    &amp;&amp; boot_params.eddbuf_entries &lt; EDDMAXNR) &#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(edp, &amp;ei, <span class="keyword">sizeof</span>(ei));</span><br><span class="line">			edp++;</span><br><span class="line">			boot_params.eddbuf_entries++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (do_mbr &amp;&amp; !read_mbr_sig(devno, &amp;ei, mbrptr++))</span><br><span class="line">			boot_params.edd_mbr_sig_buf_entries = devno<span class="number">-0x80</span>+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!be_quiet)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ok\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中0x80是第一个硬盘驱动器，EDD_MBR_SIG_MAX宏的值为16。它收集数据到<code>edd_info</code>结构数组中。</p>
<p><code>get_edd_info</code>通过调用0x13中断和<code>ah = 0x41</code>来检查EDD是否存在，如果EDD存在，get_edd_info再次调用0x13中断，但<code>ah=0x48</code>和<code>si</code>包含存储EDD信息的缓冲区地址。</p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/10/24/framewave-study/" rel="prev" title="framewave_study">
      <i class="fa fa-chevron-left"></i> framewave_study
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/11/11/ZNSLinuxKernelSupport/" rel="next" title="ZNSLinuxKernelSupport">
      ZNSLinuxKernelSupport <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Kernel-Inside"><span class="nav-number">1.</span> <span class="nav-text">Kernel Inside!</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Booting"><span class="nav-number">2.</span> <span class="nav-text">Booting</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Kernel-booting-process-Part-1"><span class="nav-number">3.</span> <span class="nav-text">Kernel booting process. Part 1.</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#From-the-boot-loader-to-the-kernel"><span class="nav-number">3.1.</span> <span class="nav-text">From the boot loader to the kernel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Magical-Power-Button-What-happens-next"><span class="nav-number">3.1.1.</span> <span class="nav-text">The Magical Power Button, What happens next?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bootloader"><span class="nav-number">3.1.2.</span> <span class="nav-text">Bootloader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Beginning-of-the-Kernel-Setup-Stage"><span class="nav-number">3.1.3.</span> <span class="nav-text">The Beginning of the Kernel Setup Stage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Aligning-the-Segment-Registers"><span class="nav-number">3.1.4.</span> <span class="nav-text">Aligning the Segment Registers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stack-Setup"><span class="nav-number">3.1.5.</span> <span class="nav-text">Stack Setup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BSS-Setup"><span class="nav-number">3.1.6.</span> <span class="nav-text">BSS Setup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Jump-to-main"><span class="nav-number">3.1.7.</span> <span class="nav-text">Jump to main</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Kernel-booting-process-Part-2"><span class="nav-number">4.</span> <span class="nav-text">Kernel booting process. Part 2.</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#First-steps-in-the-kernel-setup"><span class="nav-number">4.1.</span> <span class="nav-text">First steps in the kernel setup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Protected-mode"><span class="nav-number">4.2.</span> <span class="nav-text">Protected mode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Copyinh-boot-parameters-into-the-%E2%80%9Czeropage%E2%80%9D"><span class="nav-number">4.3.</span> <span class="nav-text">Copyinh boot parameters into the “zeropage”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Console-initialization"><span class="nav-number">4.4.</span> <span class="nav-text">Console initialization</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Heap-initialization"><span class="nav-number">4.5.</span> <span class="nav-text">Heap initialization</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E7%A1%AE%E8%AE%A4"><span class="nav-number">4.6.</span> <span class="nav-text">CPU确认</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Memory-detection"><span class="nav-number">4.7.</span> <span class="nav-text">Memory detection</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Keyboard-initialization"><span class="nav-number">4.8.</span> <span class="nav-text">Keyboard initialization</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Querying"><span class="nav-number">4.9.</span> <span class="nav-text">Querying</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="theLonging"
      src="/images/touxiang.JPG">
  <p class="site-author-name" itemprop="name">theLonging</p>
  <div class="site-description" itemprop="description">不捨晝夜。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/chantchanH7" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chantchanH7" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/562879980@qq.com" title="E-Mail → 562879980@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-07 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">theLonging</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">182k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:45</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
