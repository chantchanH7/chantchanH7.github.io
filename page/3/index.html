<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="不捨晝夜。">
<meta property="og:type" content="website">
<meta property="og:title" content="talk is cheap, show me the code.">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="talk is cheap, show me the code.">
<meta property="og:description" content="不捨晝夜。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="theLonging">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>talk is cheap, show me the code.</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">talk is cheap, show me the code.</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/05/ZNSLiterature02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/05/ZNSLiterature02/" class="post-title-link" itemprop="url">ZNSLiterature02</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-05 08:50:51" itemprop="dateCreated datePublished" datetime="2023-12-05T08:50:51+08:00">2023-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-12 15:52:33" itemprop="dateModified" datetime="2023-12-12T15:52:33+08:00">2023-12-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是第三周2023.12.4-2023.12.10的论文阅读笔记</p>
<h1 id="Performance-Characterization-of-NVMe-Flash-Devices-with-Zoned-Namespaces-ZNS"><a href="#Performance-Characterization-of-NVMe-Flash-Devices-with-Zoned-Namespaces-ZNS" class="headerlink" title="Performance Characterization of NVMe Flash Devices with Zoned Namespaces (ZNS)"></a>Performance Characterization of NVMe Flash Devices with Zoned Namespaces (ZNS)</h1><p>这篇文章大概讲了具有分区命名空间的闪存的性能分析。</p>
<p>本文的贡献:</p>
<ul>
<li><p>系统地描述了一款商业可用的 NVMe ZNS 设备的性能特性（即延迟、带宽和并行管理），包括其追加、读取、写入和区域管理操作（即完成和重置）。</p>
</li>
<li><p>我们分析了 ZNS 独特的重置和追加操作对读取、写入和追加 I&#x2F;O 性能的干扰影响。</p>
</li>
<li><p>我们揭示了最新 ZNS 模拟器性能模型的局限性，并讨论了解决这些问题的建议。</p>
</li>
<li><p>我们根据我们的特性分析，为 ZNS 应用开发者分享了关键建议。</p>
</li>
<li><p>我们在 <a target="_blank" rel="noopener" href="https://github.com/stonet-research/NVMeBenchmarks">https://github.com/stonet-research/NVMeBenchmarks</a> 上发布了我们的基准测试软件和数据集，以鼓励可复现的研究。</p>
</li>
</ul>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem:"></a>Problem:</h2><p>​	缺乏对 ZNS SSD（带有分区命名空间的固态硬盘）的广泛特性分析严重限制了在大数据工作负载中使用和应用 ZNS 设备的能力。这篇文章通过展示一款商业可用的 NVMe ZNS 设备的性能特性来弥补这一差距。</p>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background:"></a>Background:</h2><p>本文中提到的关于闪存的一些背景又和之前了解的概念有些偏差，在此记录下来：</p>
<ul>
<li><p>页<code>(page)</code>需要被顺序写入块中<code>(block)</code>，因此不允许数据随机写入。</p>
</li>
<li><p><code>It is also prone to read-write disturbs that occur when many reads are issued to the same blocks—they cause data loss. </code> </p>
<blockquote>
<p>读写干扰<code>(read-write distrubs)</code>是由于NAND闪存在频繁读取过程中对特定块施加重复电压引起的，这可能导致存储在邻近页中的数据不稳定，进而引发数据丢失或损坏。</p>
</blockquote>
<p>这也是为什么<code>ZNS SSD</code>中同时活跃的区域的数量有限制的原因<code>active zone limits</code>。</p>
<p>同样导致活跃区域的数量限制的原因还有：</p>
<blockquote>
<p>Since each zone operation (e.g., read, write, and append) consumes SSD resources (e.g., internal buffers), there are limits on the number of zones that can be concurrently opened and used.</p>
<p>由于每个区域操作（例如读取、写入和附加）都会消耗SSD资源（例如内部缓冲区），因此可以同时打开和使用的区域数量受到限制。</p>
</blockquote>
</li>
<li><p>追加操作<code>append</code>，类似于<code>nameless write</code>。</p>
<blockquote>
<p>这里追加操作没有固定写入的地址，而是在设备完成写入后返回给主机写入的地址。</p>
<p>即，不像写指令<code>write</code>，接收一个目标块地址。</p>
<p>追加指令<code>append</code>接收一个区域起始逻辑块地址<code>zone starting LBA (ZSLBA)</code>，当<code>append</code>完成后，逻辑块地址<code>LBA</code>返回给应用程序。这使得程序可以对同一个区域发送多个<code>append</code>命令。</p>
</blockquote>
</li>
<li><p>重置操作，显示通知设备某个区域中的数据可以被回收，但不一定是实时的。重置操作可以限制为 FTL（闪存翻译层）元数据映射操作，这会向设备指示该块稍后可以被擦除。</p>
</li>
</ul>
<h2 id="EXPERIMENTS"><a href="#EXPERIMENTS" class="headerlink" title="EXPERIMENTS:"></a>EXPERIMENTS:</h2><h3 id="Benchmarking-setup"><a href="#Benchmarking-setup" class="headerlink" title="Benchmarking setup:"></a><em>Benchmarking setup:</em></h3><ul>
<li><p><code>fio</code>，用来生成工作负载和基准测试。</p>
<blockquote>
<p><code>fio</code> 是一个流行的、灵活的开源工具，全称为 Flexible I&#x2F;O Tester。它被广泛用于执行和分析存储系统的性能和基准测试。<code>fio</code> 可以产生一定的I&#x2F;O负载，并以一种可控制和可预测的方式执行这些负载，使其成为评估和测试存储设备（如硬盘驱动器、固态硬盘、存储区域网络）性能的理想工具。</p>
</blockquote>
</li>
<li><p><code>SPDK</code>，（Storage Performance Development Kit）是一个高性能、用户态的存储开发工具包。它是由英特尔开发的开源项目，旨在提高存储设备，尤其是固态硬盘在数据中心中的性能和效率。SPDK 实现了一系列优化，使得存储操作可以绕过传统的内核栈，直接在用户空间运行，从而显著降低延迟并提高吞吐量。</p>
<blockquote>
<p>The <em>SPDK</em> stack, in contrast, is a bare-bones storage stack without any I&#x2F;O scheduler.</p>
</blockquote>
</li>
<li><p><code>mq-deadline</code> 是一种 I&#x2F;O 调度器，用于管理 Linux 操作系统中的块设备（如硬盘驱动器和固态硬盘）的请求队列。<code>mq-deadline</code> 是对原有 <code>deadline</code> 调度器的改进，专门为支持多队列 (Multi-Queue) 存储接口设计。这种调度器旨在平衡 I&#x2F;O 请求的延迟和吞吐量，特别是在高负载情况下。</p>
<blockquote>
<p>The Linux block layer ships with the <em>mq-deadline</em> scheduler, which buffers multiple write operations to a single zone, merges writes to contiguous LBAs into one or multiple (larger) writes, and sequentially issues the merged requests. Applications can, hence, issue multiple write operations to a single zone.</p>
</blockquote>
</li>
<li><p><code>io_uring</code> 是 Linux 内核中的一个比较新的异步I&#x2F;O接口。它为用户空间程序提供了一种高效的方式来提交和完成I&#x2F;O操作，尤其是在处理大量I&#x2F;O请求时。</p>
</li>
</ul>
<h3 id="Performance-metrics"><a href="#Performance-metrics" class="headerlink" title="Performance metrics:"></a><em>Performance metrics:</em></h3><ul>
<li><code>throughput</code>吞吐量</li>
<li><code>latency</code>延时</li>
</ul>
<h2 id="Observation"><a href="#Observation" class="headerlink" title="Observation:"></a>Observation:</h2><ol>
<li><p><em>The LBA format can have significant impact on both</em> write <em>and</em> append <em>latencies.</em></p>
<blockquote>
<p>导致这一现象的原因主要是硬件可能没有对于小的<code>IO</code>请求进行优化。</p>
</blockquote>
</li>
<li><p><em>Using the SPDK storage stack results in the lowest latencies.</em></p>
<blockquote>
<p>这是因为<code>SPDK</code>绕过内核直接与<code>SSD</code>设备交互。</p>
</blockquote>
</li>
<li><p>Write <em>and</em> append <em>throughput depends on the request size.</em></p>
<blockquote>
<ol>
<li><strong>请求大小与吞吐量的关系</strong>：<ul>
<li>实验显示，写入操作在 4 KiB 和 8 KiB 的请求大小时，IOPS（每秒输入&#x2F;输出操作数）吞吐量最高，达到约 85K IOPS。</li>
<li>而追加操作的性能随着请求大小的增加略有提升，从 66K IOPS 增至 69K IOPS。</li>
</ul>
</li>
<li><strong>字节吞吐量</strong>：<ul>
<li>以字节&#x2F;秒计算的吞吐量在大型请求（例如大于或等于 32 KiB）时最高，这是通过请求大小乘以 IOPS 计算得出的。（虽然每秒的<code>I\O</code>操作的次数减少了，但是每次<code>I\O</code>处理的字节数量提高了）。</li>
</ul>
</li>
<li><strong>请求方式的影响</strong>：<ul>
<li>由于请求是同步发出的，因此吞吐量是请求延迟的倒数。这意味着请求大小对性能的影响因写入和追加操作而异。</li>
</ul>
</li>
<li><strong>追加与写入性能差异</strong>：<ul>
<li>追加操作的吞吐量低于写入操作，并非 ZNS 设计固有的，而是取决于固件。预计新型 ZNS 设备的追加吞吐量会有所提高。</li>
</ul>
</li>
<li><strong>区域并行性的影响</strong>：<ul>
<li>请求大小的影响可能是由于区域并行性（即区域映射到多个闪存通道）造成的，类似于在文献 [44] 中观察到的情况。</li>
</ul>
</li>
<li><strong>最大吞吐量的建议</strong>：<ul>
<li>为了获得最大吞吐量，建议发出大型请求；在评估中使用的 ZNS 设备上，写入和追加操作分别在 4 KiB 和 8 KiB 请求大小时观察到最大的 IOPS 吞吐量，而对于大于 32 KiB 的请求观察到最大的字节吞吐量。</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li><p>write <em>operations have lower I&#x2F;O latencies than</em> append <em>operations.</em></p>
</li>
<li><p>对比了区域内并行<code>(intra-zone)</code>和区域间<code>(inter-zone)</code>并行</p>
<ol>
<li><p>在测试<code>write</code>和<code>read</code>操作时我们发现，区域内并行对比区域间并行，能达到更高的<code>IOPS</code>。</p>
<blockquote>
<p>如果程序需要比同时可打开区域数量更高的可扩展性，更推荐使用区域内并行。</p>
</blockquote>
</li>
<li><p>然而对于<code>append</code>操作来说，区域内和区域间请求并不敏感。</p>
<blockquote>
<p>推测这是由于<code>ZNS</code>设备的限制，而非<code>ZNS</code>设备设计的原因。</p>
</blockquote>
</li>
<li><p>对于大型（即 &gt;&#x3D;8KiB）I&#x2F;O请求，区域内追加和区域间写入操作的性能达到设备极限，并且在不同并发级别下以类似的方式扩展。</p>
</li>
</ol>
</li>
<li><p>区域状态机的转移开销</p>
<ol>
<li>区域的利用率对<code>reset</code>和<code>finish</code>操作有重要的影响。</li>
</ol>
</li>
<li><p><code>I/O</code>干扰：<code>write</code>，<code>append</code>和<code>read</code>的干扰</p>
<ol>
<li>ZNS设备在并发写入触发垃圾收集的情况下提供比普通<code>NVMe device</code>更稳定的读写性能。</li>
<li></li>
</ol>
</li>
</ol>
<h2 id="Recommendation"><a href="#Recommendation" class="headerlink" title="Recommendation:"></a>Recommendation:</h2><ol>
<li>对于低<code>I/O</code>延迟，使用<code>write</code>而不是<code>append</code>操作，并且使用<code>SPDK</code>存储堆栈，因为<code>SPDK</code>提供最低的<code>I/O</code>延迟。</li>
<li>相比于区域间并行性，更推荐使用区域内并行性；前者适用于追加和读取操作，而后者更适合写入操作。使用大型请求尺寸（即 &gt;&#x3D;8KiB，接近内部块大小）发起I&#x2F;O，因为更大的请求在更高并发级别下扩展性更好。</li>
<li>避免使用<code>finish</code>，特别是对于部分写入的区域。最小化需要<code>finish</code>的区域数量，</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/22/ZNSLiterature01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/22/ZNSLiterature01/" class="post-title-link" itemprop="url">ZNSLiterature01</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-22 15:56:24" itemprop="dateCreated datePublished" datetime="2023-11-22T15:56:24+08:00">2023-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-26 11:22:52" itemprop="dateModified" datetime="2023-11-26T11:22:52+08:00">2023-11-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是第二周2023.11.20-2023.11.26的论文阅读笔记</p>
<h1 id="ZNS-Avoiding-the-Block-Interface-Tax-for-Flash-based-SSDs"><a href="#ZNS-Avoiding-the-Block-Interface-Tax-for-Flash-based-SSDs" class="headerlink" title="ZNS: Avoiding the Block Interface Tax for Flash-based SSDs"></a>ZNS: Avoiding the Block Interface Tax for Flash-based SSDs</h1><p><a target="_blank" rel="noopener" href="https://www.usenix.org/conference/atc21/presentation/bjorling">https://www.usenix.org/conference/atc21/presentation/bjorling</a></p>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem:"></a>Problem:</h2><p>传统的<code>SSD</code>的问题：</p>
<ul>
<li><p>额外配置<code>(over-provision)</code>：这是为了在物理地址之间移动数据。</p>
</li>
<li><p>额外的<code>DRAM</code>：为了维护逻辑地址和物理地址之间的不稳定映射，这两个问题被称为<code>Block Interface Tax</code>。</p>
<blockquote>
<p>指使用块接口存储设备时所面临的性能和操作成本的问题。</p>
</blockquote>
</li>
</ul>
<h2 id="Previous-approach"><a href="#Previous-approach" class="headerlink" title="Previous approach:"></a>Previous approach:</h2><ul>
<li><p><code>Stream SSD</code>：主机会在写命令上添加标记<code>hint</code>。<code>Stream SSD</code>会通过这些标记将不同的数据放入不同的擦除块中。</p>
<blockquote>
<p>存在的问题：</p>
<ul>
<li>如果主机不添加标记，则和传统的<code>SSD</code> <code>(black box ssd)</code>没有区别。</li>
<li><code>SSD</code>仍然需要维护资源来管理这些标记的数据，所以不会降低额外配置<code>over provision</code>和额外<code>DRAM</code></li>
</ul>
</blockquote>
</li>
<li><p><code>open channel SSD</code>：主机和<code>SSD</code>共同管理一组连续的逻辑块簇<code>a set of contiguous LBA chunks</code>。这些连续的块簇<code>chunks</code>和物理擦除块<code>physical erased blocks</code>对齐。这样的对齐消除了设备垃圾回收开销<code>GC</code>，额外配置和<code>DRAM</code>。</p>
<blockquote>
<p>存在的问题：</p>
<ul>
<li>增加了主机的工作负担。</li>
<li>需要主机来管理不同<code>SSD</code>实现间的差异性。</li>
<li>需要持续的软件维护来保证其功能。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="Approach"><a href="#Approach" class="headerlink" title="Approach:"></a>Approach:</h2><p>提出了<code>ZNS</code>接口 <code>(Zone Namespace interface)</code>：</p>
<ul>
<li>兼容性：<code>ZNS</code>利用并兼容<code>ZAC/ZBC (Zoned ATA Command / Zoned Block Command)</code>规范中定义的分区存储模型。</li>
<li>增加了可以充分利用闪存特性的功能。</li>
<li>消除了<code>SSD</code>介质和设备接口之间的不匹配。</li>
<li>提供了一个不直接管理特定介质特性的下一代存储接口，这避免了像<code>OCSSD</code>那样直接处理介质特有特性的需要。</li>
</ul>
<p>一种<code>Tax-free Storage with zones</code>：</p>
<ul>
<li><code>zone state</code></li>
<li><code>zone write pointer</code></li>
</ul>
<p>提出上述的两个<code>ZNS</code>的特性，消除了主机软件需要跟踪每个区域最后写入的<code>LBA</code>的需求，简化了在例如不当关机后的恢复过程。</p>
<p><code>ZNS</code>接口在遵循区域存储规范的同时，也给出了两个对应闪存特性的新概念：</p>
<ul>
<li><p><code>writeable zone capability</code>：允许将区域内的<code>LBA</code>分为可写和不可写两部分，允许区域有比区域大小<code>zone size</code>更小的<code>writeable capability</code>。</p>
<blockquote>
<p>目的：使得<code>ZNS SSD</code>的区域大小可以与<code>SMR HDD</code>引入的2的幂次方大小行业标准对齐。</p>
</blockquote>
</li>
<li><p><code>active zone limit</code>：对处于打开或者关闭的区域的数量进行限制了限制。</p>
<blockquote>
<p>原因：基于闪存的介质<code>flash-based media</code>对这一数量有限制。</p>
<p>程序干扰（Program Disturb）是闪存（特别是NAND型闪存）中的一个现象，它对ZNS（区域命名空间）固态硬盘（SSD）的活动区域数量产生限制的方式是比较复杂的。我将为您详细解释这个过程。</p>
<h3 id="程序干扰（Program-Disturb）"><a href="#程序干扰（Program-Disturb）" class="headerlink" title="程序干扰（Program Disturb）"></a>程序干扰（Program Disturb）</h3><ol>
<li><strong>定义与影响</strong>：<ul>
<li>程序干扰是指在对NAND闪存的某个区域进行写操作（编程）时，可能无意中影响到相邻单元的现象。</li>
<li>这种干扰可能导致数据损坏或存储单元性能下降。</li>
</ul>
</li>
<li><strong>发生原因</strong>：<ul>
<li>NAND闪存中的存储单元（单元格）非常紧密排列。</li>
<li>当对一个单元进行写操作（注入电荷）时，相邻单元可能会因电场干扰而受到影响，尤其是在重复写入的情况下。</li>
</ul>
</li>
</ol>
<h3 id="对ZNS-SSD的影响"><a href="#对ZNS-SSD的影响" class="headerlink" title="对ZNS SSD的影响"></a>对ZNS SSD的影响</h3><ol>
<li><strong>ZNS SSD结构</strong>：<ul>
<li>ZNS SSD通过将存储空间划分为多个区域（zones）来优化数据管理和写入效率。</li>
<li>这些区域可独立管理，减少了写入放大（Write Amplification）和垃圾收集（Garbage Collection）的需要。</li>
</ul>
</li>
<li><strong>活动区域限制的必要性</strong>：<ul>
<li>由于程序干扰的存在，如果太多区域同时保持在可写状态（尤其是在高密度存储条件下），可能会增加数据损坏的风险。</li>
<li>限制同时处于打开或关闭状态的活动区域数量，可以减少相邻区域间的干扰，从而降低数据损坏的风险。</li>
</ul>
</li>
<li><strong>管理策略</strong>：<ul>
<li>ZNS SSDs通过限制同时可写的区域数量，从而降低程序干扰的风险。</li>
<li>这种限制有助于提高数据的可靠性和存储介质的寿命。</li>
</ul>
</li>
</ol>
<p>总的来说，程序干扰是一个物理现象，它限制了ZNS SSD中可以同时处于活动（即可写）状态的区域数量，这是为了减少数据损坏的风险并提高整体存储系统的稳定性和可靠性。</p>
<p><em>*<em>更深入的解释参考：Yu Cai, Onur Mutlu, Erich F Haratsch, and Ken Mai. Program Interference in MLC NAND Flash Memory: Characterization, Modeling, and Mitigation. In <em>2013 IEEE 31st International Conference on Computer De- sign (ICCD)</em>, pages 123–130. IEEE, 2013.</em>*</em></p>
</blockquote>
</li>
</ul>
<p>尽管ZNS接口增加了主机软件的责任，我们仍然使用一些方法减轻主机的这种负担。</p>
<h3 id="Evoloving-towards-ZNS"><a href="#Evoloving-towards-ZNS" class="headerlink" title="Evoloving towards ZNS:"></a>Evoloving towards ZNS:</h3><h4 id="对硬件的影响："><a href="#对硬件的影响：" class="headerlink" title="对硬件的影响："></a>对硬件的影响：</h4><p><code>ZNS</code>接口可以将区域的顺序写入转换到不同的擦除块中，从而消灭了接口和媒介之间的不匹配。</p>
<ul>
<li>数据放置在区域的粒度上被管理，这意味着负责在擦除块之间移动有效数据（以释放可写容量）的SSD垃圾收集例程将成为主机的责任。</li>
<li>这意味着设备上的写放大现象被消除，从而消除了对容量过剩配置的需求，同时也提升了介质的整体性能和使用寿命。</li>
</ul>
<blockquote>
<h3 id="ZNS-SSD的核心设计"><a href="#ZNS-SSD的核心设计" class="headerlink" title="ZNS SSD的核心设计"></a>ZNS SSD的核心设计</h3><ol>
<li><strong>顺序区域写入</strong>:<ul>
<li>ZNS SSD将存储空间分割成多个区域（zones），每个区域在一次写入操作中只允许顺序写入。</li>
<li>这种方式与传统的随机写入相比，更加适合NAND闪存的物理特性。</li>
</ul>
</li>
<li><strong>区域与擦除块的对应关系</strong>:<ul>
<li>在ZNS SSD中，顺序写入的区域直接对应于闪存的擦除块。</li>
<li>这样，每个区域的写入操作都直接映射到一个特定的擦除块上，减少了因随机写入造成的额外擦写循环。</li>
</ul>
</li>
</ol>
<h3 id="消除接口-介质不匹配"><a href="#消除接口-介质不匹配" class="headerlink" title="消除接口-介质不匹配"></a>消除接口-介质不匹配</h3><ol>
<li><strong>简化的闪存翻译层（FTL）</strong>:<ul>
<li>传统SSD中的FTL负责管理随机写入和数据在擦除块间的移动。</li>
<li>在ZNS SSD中，由于不支持随机写入，FTL的复杂性大大降低，这意味着更少的数据移动和管理开销。</li>
</ul>
</li>
<li><strong>由主机管理数据放置</strong>:<ul>
<li>在ZNS SSD中，数据的放置和擦除块的重置由主机（而非设备）显式管理。</li>
<li>这种设计使得数据存储更加高效，减少了写放大（Write Amplification）现象。</li>
</ul>
</li>
</ol>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><ul>
<li>减少写放大：由于写操作更加高效，ZNS SSD减少了写放大现象，这直接影响到设备的性能和寿命。</li>
<li>无需容量过剩配备：减少写放大也意味着不再需要为了补偿性能损耗而过度配备存储容量。</li>
<li>提升性能和寿命：整体上，ZNS SSD通过这种设计，提高了性能，并延长了存储介质的使用寿命。</li>
</ul>
<p>总之，ZNS SSD通过其对区域的顺序写入方式和简化的数据管理，有效地消除了传统接口与NAND闪存介质之间的不匹配问题，从而提高了存储效率和设备的整体性能。</p>
</blockquote>
<p><strong>Zone Sizing</strong>：区域写容量<code>zone write capability</code>和<code>SSD</code>的擦除块大小有直接的联系。</p>
<ul>
<li><p>在以块为接口的<code>SSD</code>中，擦除块中的数据是跨越了多个闪存晶圆<code>(flash dies)</code>的。 </p>
<blockquote>
<p>既为了获得更高的读写性能，也为了通过每条带（stripe）的奇偶校验来防止芯片级别和其他介质故障。</p>
</blockquote>
</li>
</ul>
<p><strong>Mapping Table</strong>：传统的<code>SSD</code>中，<code>FTL</code>维护了一个逻辑块到物理块的映射表，这样的映射表在提高垃圾回收效率的同时也占用了很大的空间。</p>
<p>而<code>ZNS SSD</code>的顺序写限制，可以使这种全相连的映射在擦除块级别或者以某种混合方式维护的粗粒度映射。这样做可以显著减少甚至完全消除<code>DRAM</code>（映射表需要提前存放在<code>SSD</code>的<code>DRAM</code>中）。</p>
<p><strong>Device Resources</strong>：部分写入的擦除块会关联一组资源。</p>
<blockquote>
<p>这一套装备包括硬件资源，如异或（XOR）引擎，内存资源，如静态随机存取内存（SRAM）或动态随机存取内存（DRAM），以及用于在断电后保持奇偶校验数据的电源电容器。</p>
</blockquote>
<p>数据和奇偶校验的大小可以从数百千字节到数兆字节不等，例如，这可能是由于两步编程所致。</p>
<blockquote>
<p>在NAND闪存技术中，”Two-Step Programming”（两步编程）是一种数据写入方法。这种方法在写入数据到NAND闪存单元时分为两个阶段进行，以提高数据的可靠性和减少错误。以下是两步编程的主要步骤和特点：</p>
<h3 id="第一步：初步写入"><a href="#第一步：初步写入" class="headerlink" title="第一步：初步写入"></a>第一步：初步写入</h3><ul>
<li>在这一步中，数据首先被写入到闪存单元，但并不是以最终的形态。这个阶段的目的是将数据大致定位到所需的状态。</li>
</ul>
<h3 id="第二步：精细调整"><a href="#第二步：精细调整" class="headerlink" title="第二步：精细调整"></a>第二步：精细调整</h3><ul>
<li>第二步涉及对之前写入的数据进行精细调整。这个阶段确保数据准确地达到其目标状态，从而减少写入错误。</li>
<li>这种方法特别适用于多级单元（MLC）和三级单元（TLC）NAND闪存，其中每个单元存储多个位的数据。</li>
</ul>
<h3 id="为什么使用两步编程"><a href="#为什么使用两步编程" class="headerlink" title="为什么使用两步编程"></a>为什么使用两步编程</h3><ol>
<li><p><strong>提高精确度</strong>：</p>
<ul>
<li>由于NAND闪存单元在存储多个数据位时容易受到干扰，两步编程通过分阶段精细调整来提高写入数据的准确度。</li>
</ul>
</li>
<li><p><strong>减少错误</strong>：</p>
<ul>
<li>分步骤写入减少了数据写入错误的可能性，特别是在高密度存储技术（如MLC和TLC）中。</li>
</ul>
</li>
<li><p><strong>提升可靠性</strong>：</p>
<ul>
<li>通过减少写入错误，两步编程提高了存储的可靠性，这对于保持数据完整性和延长设备寿命非常重要。</li>
</ul>
</li>
</ol>
<p>总体来说，两步编程是NAND闪存中一种重要的数据写入方法，特别是在那些要求高数据密度和可靠性的应用中。通过这种方法，可以有效地减少写入错误，提高整体存储介质的性能和可靠性。</p>
</blockquote>
<p>由于这些要求和相关成本，预计ZNS固态硬盘将拥有8到32个活动区域。尽管通过增加额外的电源电容器、使用动态随机存取内存（DRAM）进行数据移动、减少奇偶校验要求，或部署一种写回缓存的形式，可以进一步增加活动区域的数量。 </p>
<h4 id="Host-Software-Adoption-主机软件的采用情况"><a href="#Host-Software-Adoption-主机软件的采用情况" class="headerlink" title="Host Software Adoption 主机软件的采用情况"></a>Host Software Adoption 主机软件的采用情况</h4><p>三种让主机软件适配<code>ZNS</code>接口的方式。</p>
<p>采用顺序写特性的软件能更好的适配<code>ZNS</code>接口，比如<code>Log Structure Merge (LSM) tree-based database</code>。主要执行原地更新<code>in-place update</code>的应用程序在不对核心数据结构进行根本性修改的情况下，更难以支持。</p>
<ul>
<li><code>Host-side FTL (HFTL)</code>：一种在<code>ZNS SSD</code>写语法和使用随机写和就地更新的程序之间的媒介，类似于<code>SSD</code>的<code>FTL</code>层。</li>
</ul>
<p>  但只负责<code>translation mapping</code>和<code>Garbage collection</code></p>
<blockquote>
<p><strong>缺点：</strong><code>HFTL</code>需要占用<code>CPU</code>和<code>DRAM</code>。</p>
<p><strong>优点：</strong>使集成主机端的信息更加简单，增加了对数据放置和垃圾回收的控制，同时将<code>ZNS SSD</code>当作<code>conventional SSD</code>暴露给应用程序。</p>
</blockquote>
<ul>
<li><p><code>FTL System</code>：更高层次的存储接口允许多个应用程序通过常见的文件语法访问存储系统。</p>
<p>即：将区域与存储堆栈的更高层次集成，以确保顺序写入。</p>
</li>
<li><p><code>End-to-end Data placement</code>端到端数据放置：理想情况下，区域写语法讲与应用程序的现有数据结构保持一致。这将通过允许应用程序管理数据放置来提供最高程度的自由度，同时消除了来自文件系统和翻译层的间接开销。</p>
<blockquote>
<p>虽然端到端的数据放置使应用程序与ZNS固态硬盘之间的协作成为可能，并有潜力实现最佳的写放大、吞吐量和延迟改进，但它就像与原始块设备交互一样令人生畏。</p>
</blockquote>
</li>
</ul>
<h3 id="Implementation-我们已经向四个主要软件项目增加了支持，以评估ZNS的好处。"><a href="#Implementation-我们已经向四个主要软件项目增加了支持，以评估ZNS的好处。" class="headerlink" title="Implementation: 我们已经向四个主要软件项目增加了支持，以评估ZNS的好处。"></a>Implementation: 我们已经向四个主要软件项目增加了支持，以评估ZNS的好处。</h3><ul>
<li>更改<code>Linux</code>内核以支持<code>ZNS SSD</code></li>
<li>更改<code>f2fs file system</code></li>
<li>更改<code>fio benchmark</code>：这是为了测试和评估支持<code>ZNS</code>的存储设备性能</li>
<li>提出<code>ZenFS</code>：一个针对<code>RockDB</code>的新型存储后端，它通过分区来控制设备用以评估端到端集成对分区存储的好处</li>
</ul>
<h4 id="General-Linux-support"><a href="#General-Linux-support" class="headerlink" title="General Linux support"></a>General Linux support</h4><p><strong>Zone Capability:</strong></p>
<p><code>fio</code>和<code>f2fs</code>支持<code>Zone capability</code>，<code>fio</code>只保证不超过<code>zone capability</code>，<code>f2fs</code>管理段，段大小为<code>2MB</code>，多个段位一个区<code>section</code>，一个区<code>section</code>的大小和一个域<code>zone</code>的大小相同。</p>
<p><strong>limiting active zones 打开区域数量限制:</strong></p>
<p><code>fio</code>要求用户遵守打开区域数量这一限制。</p>
<p>对于<code>f2fs</code>来说，这种限制体现在打开的段的数量上。</p>
<h4 id="RocksDB-Zone-Support"><a href="#RocksDB-Zone-Support" class="headerlink" title="RocksDB Zone Support:"></a>RocksDB Zone Support:</h4><p>调整键值数据库<code>RocksBD</code>，使其能够通过使用<code>ZenFS</code>存储后端，将数据端到端地放置到分区存储设备上。<code>ZenFS</code>利用了<code>RocksDB</code>的日志结构合并<code>(LSM)</code>数数据结构，这是<code>RocksDB</code>用来存储和维护其数据的，并且还利用了其相关的不可变的仅限顺序的压缩过程。</p>
<p><code>LSM tree</code>：</p>
<p>最上层的数据是热数据，冷数据会被一直下放到最底层。</p>
<p><img src="/../images/ZNSLiterature01/%E6%88%AA%E5%B1%8F2023-11-25%2018.16.52.png" alt="截屏2023-11-25 18.16.52"></p>
<p><strong>ZenFS Architecture</strong>：</p>
<p><code>ZenFS</code>存储后端实现了一种最小的磁盘上文件系统，并使用<code>RocksDB</code>的文件包装<code>API</code>对其进行集成。</p>
<p><img src="/../images/ZNSLiterature01/%E6%88%AA%E5%B1%8F2023-11-25%2018.35.12.png" alt="截屏2023-11-25 18.35.12"></p>
<p><strong>Journaling and data</strong>：</p>
<ul>
<li>journal：日志区域用于恢复文件系统的状态，维护超级块数据结构，并将写前日志（WAL）和数据文件映射到区域。</li>
<li>data：数据区域存储文件内容。</li>
</ul>
<p><strong>Extents</strong>：</p>
<ul>
<li><code>RocksDB</code>的数据文件被映射并存储到一系列内容<code>a set of content</code>中。</li>
<li><code>content</code>是大小可变，块对齐的。</li>
<li><code>Extents</code>按顺序写入一个数据区域。</li>
<li>包含与特定标识符相关联的数据。</li>
</ul>
<p>每个区域包含很多<code>extents</code>，但是<code>extents</code>不能扩大<code>zone</code>的大小。</p>
<blockquote>
<p>区段的分配和释放事件被记录在内存数据结构中，并在关闭文件或通过<code>fsync</code>调用要求<code>RocksDB</code>持久化数据时写入日志。内存数据结构跟踪区段到区域的映射，一旦一个区域中分配了区段的所有文件都被删除，该区域就可以被重置并重用。</p>
</blockquote>
<p><strong>superblock 超级块</strong>：</p>
<p><strong>Journal 日志</strong>：</p>
<p><strong>Writeable Capacity in Data Zones 数据区域的可写容量</strong>：</p>
<p><strong>Data Zone Selection</strong>：ZenFS采用了一种尽最大努力的算法来选择最佳区域存储RocksDB数据文件。</p>
<blockquote>
<p> A match is only valid if the lifetime of the file is less than the oldest data stored in the zone to avoid prolonging the life of the data in the zone.</p>
<p>目的是为了确保不因为新添加的文件而不必要地延长存储区域中旧数据的存储时间，从而有效管理数据的生命周期和存储区域的使用效率。</p>
</blockquote>
<p><strong>Active Zone limit</strong></p>
<blockquote>
<p>活动区域限制。ZenFS必须遵守分区块设备指定的活动区域限制。要运行ZenFS，至少需要三个活动区域，它们分别被分配给日志、写前日志（WAL）和压缩过程。为了提高性能，用户可以控制并发压缩的数量。我们的实验表明，通过限制并发压缩的数量，RocksDB可以在写性能受限的情况下，只使用最少6个活动区域工作，而超过12个活动区域并不会带来任何显著的性能好处。</p>
</blockquote>
<p><strong>Direct I&#x2F;O and Buffered Writes</strong></p>
<blockquote>
<p>直接I&#x2F;O和缓冲写入。ZenFS利用了写入SST文件是顺序的和不可变的这一事实，并对SST文件执行直接I&#x2F;O写入，绕过了内核页面缓存。对于其他文件，如写前日志（WAL），ZenFS在内存中缓冲写入，并在缓冲区满、文件关闭或RocksDB请求刷新时刷新缓冲区。如果请求了刷新，缓冲区将被填充到下一个块边界，并且一个带有有效字节数的区段将被存储在日志中。这种填充导致了少量的写入放大，但这并非ZenFS独有，传统文件系统中也有类似的做法。</p>
</blockquote>
<h2 id="Regular-data-write-vs-zone-append-data-write"><a href="#Regular-data-write-vs-zone-append-data-write" class="headerlink" title="Regular data write .vs zone append data write"></a>Regular data write .vs zone append data write</h2><h3 id="zone-append-data-write-的优点"><a href="#zone-append-data-write-的优点" class="headerlink" title="zone append data write 的优点"></a>zone append data write 的优点</h3><ol>
<li><strong>锁定和资源分配</strong>：<ul>
<li>在Zone Append Write中，不需要在提交写操作之前分配存储空间（即延迟分配），也不需要锁定块组。这简化了I&#x2F;O提交过程，减少了延迟和开销，因为不需要等待资源的分配和锁定。</li>
<li>相反，Regular Write需要在写操作之前分配和锁定相应的块组，这会增加写操作的复杂性和时间成本。</li>
</ul>
</li>
<li><strong>写入操作的顺序</strong>：<ul>
<li>Zone Append Write不关心BIO（Block I&#x2F;O）的顺序，因为所有写入都是追加到区域末尾的。这允许利用异步校验和，而且无需等待特定的写入顺序，提高了效率。</li>
<li>Regular Write则需要保持写入顺序，因为块的位置是预先确定的。这可能需要对写入操作进行排序和同步，从而增加了复杂性和可能的延迟。</li>
</ul>
</li>
<li><strong>并行性和性能</strong>：<ul>
<li>Zone Append Write由于其简单性，允许更高的并行操作，可以在不同的队列中异步处理校验和计算。</li>
<li>而Regular Write的并行性受到锁定机制和同步需求的限制，对于每个文件范围，必须保持写操作的原子性，这可能限制了性能。</li>
</ul>
</li>
<li><strong>系统复杂性和可靠性</strong>：<ul>
<li>Zone Append Write简化了I&#x2F;O路径，减少了需要管理的元数据数量。在写入完成后，使用的块可以直接从end_bio()回调中检索，简化了块分配元数据的更新。</li>
<li>Regular Write通常涉及更多的系统调用和层次，每个步骤都增加了出错的可能性，也增加了系统资源的使用。</li>
</ul>
</li>
</ol>
<p>总结来说，Zone Append Write的设计减少了I&#x2F;O操作的复杂性，通过简化写入过程、减少锁定和资源分配的需求，以及提高写入操作的并行性来提高效率。这使得Zone Append Write特别适合于现代存储系统，这些系统通常优化了顺序写入操作并能够从这种简化的I&#x2F;O提交过程中受益。</p>
<h3 id="zone-append-data-write-的缺点"><a href="#zone-append-data-write-的缺点" class="headerlink" title="zone append data write 的缺点"></a>zone append data write 的缺点</h3><ol>
<li><p><strong>不支持RAID级别</strong>：</p>
<ul>
<li>Zone Append Writes 是为单个区域化设备设计的，这意味着它们在设计上用于向单个存储区域追加数据。当涉及到RAID（独立磁盘冗余阵列）时，数据通常跨越多个磁盘分布以提供冗余和性能提升。Zone Append Write无法处理发送到不同区域&#x2F;设备的两个写入操作，因为在RAID配置中，这可能导致不一致的逻辑块地址（LBA）位置返回，从而破坏数据的连续性和完整性。</li>
</ul>
</li>
<li><p><strong>仍然使用专用写入路径</strong>：</p>
<ul>
<li>该系统仍然需要专用的写入路径来处理全部延迟分配范围的写入。这是因为正常写入路径可能会跳过某些数据的写入，例如在<code>fdatasync()</code>调用范围之外的数据，导致数据丢失或不完整。在使用正常写入路径时，需要在提交写操作（bio）之前拆分现有的文件范围，这增加了处理复杂性。</li>
</ul>
</li>
<li><p><strong>文件范围的碎片化</strong>：</p>
<ul>
<li>每个I&#x2F;O操作限制在<code>zone_append_max_bytes</code>（例如512KB）这样的最大字节大小，意味着如果文件范围超过这个限制，它需要被拆分成多个I&#x2F;O操作。这导致同一文件的多个范围被创建，增加了文件系统的碎片化。因此，与常规的文件系统（如btrfs）相比，文件范围数量增多，可能导致性能下降和管理上的复杂性。</li>
</ul>
</li>
</ol>
<p>总的来说，虽然Zone Append Write在顺序数据写入方面具有效率优势，但它在一些特定的系统配置和操作上存在限制。这些限制主要是由于Zone Append Write设计的固有特性，它们在多设备（如RAID配置）、需要维护数据完整性和减少碎片化的环境中可能不是最佳选择。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/13/ZNSSSDliterature/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/13/ZNSSSDliterature/" class="post-title-link" itemprop="url">ZNSSSDliterature</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-13 19:38:51" itemprop="dateCreated datePublished" datetime="2023-11-13T19:38:51+08:00">2023-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-21 14:38:20" itemprop="dateModified" datetime="2023-11-21T14:38:20+08:00">2023-11-21</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Critical-Thinking-Reading"><a href="#Critical-Thinking-Reading" class="headerlink" title="Critical Thinking - Reading"></a>Critical Thinking - Reading</h1><h2 id="Read-a-paper-and-consider"><a href="#Read-a-paper-and-consider" class="headerlink" title="Read a paper and consider:"></a>Read a paper and consider:</h2><h3 id="Do-I-like-it-Hate-it-opinion"><a href="#Do-I-like-it-Hate-it-opinion" class="headerlink" title="Do I like it? Hate it? (opinion)"></a>Do I like it? Hate it? (opinion)</h3><h3 id="What-problem-is-it-trying-to-solve"><a href="#What-problem-is-it-trying-to-solve" class="headerlink" title="What problem is it trying to solve"></a>What problem is it trying to solve</h3><h3 id="How-does-their-approach-differ-from-previous-ones"><a href="#How-does-their-approach-differ-from-previous-ones" class="headerlink" title="How does their approach differ from previous ones"></a>How does their approach differ from previous ones</h3><h3 id="how-much-previous-work-do-I-know-about-read-it-reference-chaining"><a href="#how-much-previous-work-do-I-know-about-read-it-reference-chaining" class="headerlink" title="(how much previous work do I know about - read it! (reference chaining))"></a>(how much previous work do I know about - read it! (reference chaining))</h3><h3 id="Does-it-work"><a href="#Does-it-work" class="headerlink" title="Does it work?"></a>Does it work?</h3><h3 id="What-could-be-improved"><a href="#What-could-be-improved" class="headerlink" title="What could be improved"></a>What could be improved</h3><h1 id="Optimizing-Data-Migration-for-Garbage-Collection-in-ZNS-SSDs"><a href="#Optimizing-Data-Migration-for-Garbage-Collection-in-ZNS-SSDs" class="headerlink" title="Optimizing Data Migration for Garbage Collection in ZNS SSDs"></a>Optimizing Data Migration for Garbage Collection in ZNS SSDs</h1><h2 id="Problem-to-be-solved"><a href="#Problem-to-be-solved" class="headerlink" title="Problem to be solved"></a>Problem to be solved</h2><p>在<code>zns ssd</code>中，程序被允许以一种高效的数据放置方法连续的写入不同的区域<code>zone</code>中。然而，在一个区域<code>zone</code>中的<strong>无效数据<code>invalid data</code>只有在整个区域的数据被擦除时才能被释放</strong>，这导致了空间低利用率。</p>
<p>现阶段的研究集中在降低数据迁移的次数，但是他们的数据迁移方式并不高效。</p>
<p>一方面，<code>ZNS SSD</code>中的数据迁移会导致不必要的端到端开销。</p>
<blockquote>
<p>这是因为在<code>ZNS SSD</code>的数据迁移由<code>host</code>管理，迁移时要先将数据读取到内存中，再由主机指定写入对应的区域<code>zone</code>中去。</p>
</blockquote>
<p>另一方面，两个区域<code>zone</code>之间，进行块到块<code>block-to-block</code>的数据迁移的开销也很大，会导致巨大的重写开销。</p>
<p><strong>一种理想的方法是</strong>，将受害区域<code>victim zone</code>中的包含有效数据的块<code>blocks with valid data</code>重新映射到目标区域中<code>target zone</code>（通过这种映射，我们只需要擦除受害区域<code>victim zone</code>中的<code>blocks with invalid data </code>擦除，然后在目标区域<code>target zone</code>中开辟新的<code>block</code>并写入<code>blocks with invalid data</code>块中的有效数据即可）。</p>
<p>仍然，<code>ZNS SSD</code>中的区域和块之间的映射基于芯片间的并行提前被定义好了。</p>
<h2 id="Approaches"><a href="#Approaches" class="headerlink" title="Approaches"></a>Approaches</h2><p>提出一种新的<code>ZNS SSD</code>垃圾回收方式，<code>IS_AR</code>：</p>
<ul>
<li><h3 id="Zone-MD：提出的新ZNS命令，用于实现存储内部数据迁移in-storage-data-migration，以避免端到端的传输开销。"><a href="#Zone-MD：提出的新ZNS命令，用于实现存储内部数据迁移in-storage-data-migration，以避免端到端的传输开销。" class="headerlink" title="Zone_MD：提出的新ZNS命令，用于实现存储内部数据迁移in-storage data migration，以避免端到端的传输开销。"></a><code>Zone_MD</code>：提出的新<code>ZNS</code>命令，用于实现存储内部数据迁移<code>in-storage data migration</code>，以避免端到端的传输开销。</h3><p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-13%2020.27.34.png" alt="截屏2023-11-13 20.27.34"></p>
<p>如图所示，函数<code>Zone_MD(Src, Dst, Size)</code>接收三个参数：</p>
<ul>
<li><code>Src</code>：表示受害区域<code>victim zone</code>中的有效数据<code>valid data</code>的逻辑起始地址<code>starting logic address</code>。</li>
<li><code>Dst</code>：表示目标区域<code>target zone</code>的写指针<code>write pointer</code>地址。</li>
<li><code>Size</code>：表示要迁移的连续有效数据<code>continuous valid data</code>的大小。</li>
</ul>
<p>整个存储内数据迁移<code>in-storage data migration</code>在存储的内部通道<code>internal channel</code>的帮助下完成，避免了端到端传输。</p>
<blockquote>
<p><code>internal channel</code>是指固态硬盘（SSD）内部用于数据传输的通道。这个通道在硬盘的控制器内部进行操作，而不是通过主机的数据总线。这意味着数据迁移是在SSD设备内部完成的，而不需要数据经过主机（即计算机的CPU和主内存）。</p>
<p>这种内部数据迁移通道通常由SSD的固件和控制器逻辑来管理。它能够直接访问闪存存储单元，执行读取、传输和写入操作。使用这样的通道，可以有效地将数据从一个区域（源区域，Src）移动到另一个区域（目标区域，Dst），而不必通过外部接口传输数据，这样可以极大地减少数据迁移的延迟和带宽消耗。</p>
</blockquote>
</li>
<li><h3 id="AR：一种重映射策略remapping-strategy，该策略基于并行物理块，以减少block-to-block重写的开销。"><a href="#AR：一种重映射策略remapping-strategy，该策略基于并行物理块，以减少block-to-block重写的开销。" class="headerlink" title="AR：一种重映射策略remapping strategy，该策略基于并行物理块，以减少block-to-block重写的开销。"></a><code>AR</code>：一种重映射策略<code>remapping strategy</code>，该策略基于并行物理块，以减少<code>block-to-block</code>重写的开销。</h3></li>
</ul>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-13%2020.39.07.png" alt="截屏2023-11-13 20.39.07"></p>
<p>为保证对一个区域<code>zone</code>的并行写操作<code>parallelism of writing</code>，提出了一种基于并行块组<code>parallel block groups (PBGs)</code>动态的区域映射方法。</p>
<blockquote>
<p>上文中的每个block不是指NAND闪存内部的物理块，而是一个逻辑上的映射单元，它可能跨越多个芯片（chip）。</p>
</blockquote>
<ul>
<li>首先将<code>SSD</code>中的芯片分组，形成多个并行芯片组<code>mutiple parallel chip groups (PCG)</code>。通过<code>PCG</code>，读写操作可以并行的执行。</li>
<li>在每个并行芯片组<code>PCG</code>中，拥有相同偏移量<code>offset</code>的块被分到相同的并行块组中<code>PBG</code>，同样并行块组中的读写操作也能被并行的执行。</li>
<li>我们把并行块组<code>(PBG)</code>作为最小的重映射单位，并保证了区域内的并行性。</li>
<li>当一个区域被分配时，我们动态的将<code>PBGs</code>映射到区域上。</li>
</ul>
<p>现在我们讨论重映射策略。</p>
<p>在受害区域<code>victim zone</code>中，有两种<code>PBG</code>区域需要被迁移：</p>
<ul>
<li><code>V1</code>：整个并行块组<code>PBG</code>都是合法数据。</li>
<li><code>V2</code>：并行块组<code>PBG</code>的一部分是合法数据。</li>
</ul>
<p>在目标区域<code>target zone</code>，并行块组也分为两类：</p>
<ul>
<li><code>T1</code>：并行块组的所有部分均会被写入。</li>
<li><code>T2</code>：并行块组只有一部分会被写入。</li>
</ul>
<p>两辆组合，产生四种重映射方法：</p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-14%2008.44.24.png" alt="截屏2023-11-14 08.44.24"></p>
<ul>
<li><p><code>Fig.3.(1),(2)</code>：<code>V1</code>被重映射到包含<code>T1</code>或<code>T2</code>的区域<code>zone</code>。</p>
<ul>
<li><p><code>V1-&gt;T1</code>：<code>V1</code>的逻辑地址和物理地址直接重映射（这里的关键是没有提到数据从物理上的一个位置被复制到另一个位置，而是提到了逻辑空间（LS）到物理空间（PS）的映射直接重映射到目标区域，这通常涉及更新映射表（MT）而不是实际的数据移动。）到目标区域。同时，<code>Write Point</code>移动到<code>WP* = (WP + V1_Size)</code>，并在映射表<code>Mapping Table</code>上更新物理地址和逻辑地址。</p>
</li>
<li><p><code>V1-&gt;T2</code>：为了提高<code>T2</code>的空间利用率，<code>P1-P2</code>这段未被使用的空间的物理地址将被重映射到逻辑地址中去，其位置会在写指针<code>WP*</code>后面的<code>CW</code>处，长度不变。</p>
<blockquote>
<p><code>RT (Remapping Table)</code>：为了保持正确的索引关系，添加了一个新的重新映射表（RT），以记录逻辑地址与范围内的物理地址的偏移量（即具有相同偏移量相同的LS的连续段）粒度。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>Fig.3.(3),(4)</code>：<code>V2</code>被重映射到包含<code>T1</code>或<code>T2</code>的区域<code>zone</code>。</p>
<ul>
<li><p><code>V2</code>的整个物理地址直接被重映射到目标区域的物理地址中。然而，只有<code>V2</code>中的有效数据的逻辑地址被重映射到目标区域，因为目标区域只需要有效数据。</p>
<blockquote>
<p>V2中的无效数据空间被保留，直到目标区域重置（即部分无效空间被目标区域暂时占据）。</p>
</blockquote>
<p>因此，我们使用<code>ZNS SSD</code>的当前空间占用率<code>current space utilization (su)</code>作为基准<code>benchmark</code>。</p>
<p>如果<code>V2</code>中的有效数据的百分占比大于<code>su</code>，我们执行重映射。</p>
<p>否则我们直接重写<code>V2</code>中的所有有效数据。</p>
</li>
</ul>
</li>
</ul>
<p>​	通过上述方法，我们平衡了空间利用率和性能。</p>
<h2 id="Does-it-work-1"><a href="#Does-it-work-1" class="headerlink" title="Does it work?"></a>Does it work?</h2><p>将<code>IS-AR</code>和传统的数据迁移策略<code>Trad-DM</code>（没有实现数据内迁移和重映射）进行比较。具体的实验参数如下：</p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-14%2010.00.17.png" alt="截屏2023-11-14 10.00.17"></p>
<p>表格上看，数据迁移的延迟确实降低了，而且提高了<code>ZNS SSD</code>的寿命。</p>
<h2 id="What-could-be-improved？"><a href="#What-could-be-improved？" class="headerlink" title="What could be improved？"></a>What could be improved？</h2><p>论文中提到的<code>current space utilization</code>是如何选择的。</p>
<h1 id="A-New-LSM-style-Garbage-Collection-Scheme-for-ZNS-SSDs"><a href="#A-New-LSM-style-Garbage-Collection-Scheme-for-ZNS-SSDs" class="headerlink" title="A New LSM-style Garbage Collection Scheme for ZNS SSDs"></a>A New LSM-style Garbage Collection Scheme for ZNS SSDs</h1><h2 id="Problem-to-be-solved-1"><a href="#Problem-to-be-solved-1" class="headerlink" title="Problem to be solved"></a>Problem to be solved</h2><p><code>ZNS SSD</code>的两面性：</p>
<ul>
<li>Pro：通过将不同的工作负载分类到不同的区域中减少写放大<code>WAF</code></li>
<li>Cons：主机需要直接管理ZNS SSD，例如区域重置，并且它们具有顺序写入约束。</li>
</ul>
<p>简单的垃圾回收策略：</p>
<ul>
<li><code>LFS (log-structured File System)</code>：日志结构文件系统使用的段清理。</li>
<li><code>FTL (Flash Transition Layer)</code>：闪存层使用的垃圾回收策略</li>
</ul>
<p>上述策略的区别是将垃圾回收应用在区域<code>zone</code>还是段<code>segment</code>中。然而，这种简单的垃圾回收策略会因为区域的大小而导致更长的延迟，相比段大小而言。</p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><ul>
<li>如下图所示，要解决的问题还是：区域间的垃圾回收策略导致的时间开销过大。并且，最好选择利用利用率低的区域作为垃圾回收的区域。</li>
</ul>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-14%2015.11.12.png" alt="截屏2023-11-14 15.11.12"></p>
<ul>
<li><p>另一个观察是，在读取一个区域时，对块进行单独读取的耗时比对块进行组读取的模式的耗时更高。</p>
<blockquote>
<p>结果显示，以组的方式访问比单独访问要快得多。这是因为它不仅可以减少请求的数量，而且还可以利用ZNS固态硬盘内部的并行性。一般来说，ZNS固态硬盘中的一个区域会分布在多个通道上，这使得可以并行处理连续块的请求，就像开放通道固态硬盘（OCSSDs）那样。这一观察激励我们设计我们的LSM风格垃圾收集方案。</p>
</blockquote>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-14%2015.20.00.png" alt="截屏2023-11-14 15.20.00"></p>
</li>
</ul>
<h2 id="Approaches-1"><a href="#Approaches-1" class="headerlink" title="Approaches"></a>Approaches</h2><p>为了应对上文中提到的问题，提出了一个新的垃圾回收策略<code>LSM_ZGC</code>：</p>
<ul>
<li><code>LSM_ZGC</code>将区域分割为多个段，并分别管理这些段的信息。</li>
<li>以<code>LSM</code>的风格进行垃圾回收，读取候选区域的所有数据，识别冷数据，将它们合并到一个区域，同时将剩余数据合并到另一个区域。</li>
</ul>
<p>以下是<code>LSM_ZGC</code>的优点：</p>
<ul>
<li>采用基于段<code>segment</code>（而不是基于区域<code>zone</code>）的方式，有利于冷热数据分割，并可以用流水线的方式实现策略。</li>
<li>读取段中所有有效和无效的数据，可以通过利用区域中的内部并行性来减少垃圾收集开销。</li>
<li>将冷热数据放入不同的区域，可以增加找到利用率较低的区域的机会。</li>
</ul>
<p>在<code>ZNS SSD</code>的垃圾回收策略中，最简单的方式<code>Basic_ZGC</code>是：</p>
<ul>
<li>选择一个利用率最低的区域。</li>
<li>读取该区域中有效数据块并将它们写入新的区域中去。</li>
<li>最后通过<code>reset command</code>重置选择的块。</li>
</ul>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-14%2015.26.30.png" alt="截屏2023-11-14 15.26.30"></p>
<p>而<code>LSM_ZGC</code>的策略有三个不同之处：</p>
<ul>
<li><p>对于一个区域<code>zone</code>的垃圾回收会在段<code>segment</code>上实现。此外，它允许使用细粒度段单元执行区域垃圾收集，其中可以以管道方式读取、合并和写入段。</p>
</li>
<li><p>在垃圾回收阶段，它以<code>128KB</code>大小<code>IO</code>，不仅读取有效块，也读取无效块，而<code>Basic_ZGC</code>只读取有效块。</p>
<blockquote>
<p>读取所有快的原因是，我们在Figure 2中观察到，<code>in group manner</code>利用芯片的并行性提高读取速度。</p>
<p>因此当块数量大于16时，我们采取全部读取的方式。（由于16个128KB大小的请求可以覆盖整个2MB的段数据，它会读取所有块。）</p>
</blockquote>
</li>
<li><p><code>LSM_ZGC</code>通过鉴别冷数据<code>cold data</code>，并将冷数据合并到一个单独的区域中。</p>
<p>为了到达这个目的，我们定义四种区域的状态：</p>
<ul>
<li><p><code>C0_zone</code></p>
</li>
<li><p><code>C1C_zone</code>：</p>
<blockquote>
<p>我们将利用率高于阈值的段（称为门槛冷）定义为冷。这一决定基于我们的观察，即具有相似寿命的数据显示出强大的空间局部性。<br>可能的原因：段中大部分空间被占用通常意味着其中的数据已经稳定下来，且变动不大。</p>
</blockquote>
</li>
<li><p><code>C1H_zone</code></p>
</li>
<li><p><code>C2_zone</code></p>
</li>
</ul>
<p>新到达的数据按顺序写入状态为<code>C0</code>区域的区域，删除的数据将离开图中所示的状态。</p>
<ul>
<li><p>将冷数据写入<code>C1C_zone</code>。</p>
</li>
<li><p>将其他数据写入<code>C1H_zone</code>中。</p>
</li>
</ul>
<p>而当要回收的区域状态是<code>C1C_zone</code>或者<code>C1H_zone</code>时，<code>LSM_ZGC</code>将读取所有段，并把所有有效块看作冷数据。这是因为这些有效块在连续两次垃圾回收操作后都被保留了。最后这些块中的数据会被写入<code>C2_zone</code>中。</p>
<p>我们预计这种机制能够将冷数据与其他数据隔离开来，从而增加在垃圾收集期间找到利用率较低的候选区的机会。</p>
</li>
</ul>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-14%2015.42.42.png" alt="截屏2023-11-14 15.42.42"></p>
<h1 id="InDeF-An-Advanced-Defragmenter-Supporting-Migration-Offloading-on-ZNS-SSD"><a href="#InDeF-An-Advanced-Defragmenter-Supporting-Migration-Offloading-on-ZNS-SSD" class="headerlink" title="InDeF: An Advanced Defragmenter Supporting Migration Offloading on ZNS SSD"></a>InDeF: An Advanced Defragmenter Supporting Migration Offloading on ZNS SSD</h1><h2 id="Problem-to-be-solved-2"><a href="#Problem-to-be-solved-2" class="headerlink" title="Problem to be solved"></a>Problem to be solved</h2><p><code>ZNS SSD</code>由于其不恰当的更新和应用程序的多线程写作行为，它脆弱地能够碎片化。</p>
<blockquote>
<p>碎片化是指<code>SSD</code>中的数据不是连续存储在<code>SSD</code>上的，而是分散到不同的区域。</p>
</blockquote>
<p>由于碎片化，<code>I/O</code>请求会被分割（要读取不同的区域，所以将一个<code>I/O</code>分割成多个的<code>I/O</code>）。</p>
<blockquote>
<p>为什么说<code>ZNS SSD</code>更容易碎片化？</p>
<p>由于<code>ZNS SSD</code>的顺序写特性，访存需要使用一种<code>log-structured file system (LFS)</code>，如<code>F2FS</code>。</p>
</blockquote>
<p>传统的<code>Defragmentation tool</code>有如下缺点：</p>
<ul>
<li><p>由于大多数<code>Defragmentation tool</code>是为传统<code>SSD</code>设计的，它们无法处理物理碎片（这是因为传统SSD不会将物理地址暴露给主机）。而<code>ZNS SSD</code>将逻辑地址组织成一个个区域，且区域与物理介质的边界对齐。因此，我们可以通过这种特性在主机端判断物理碎片化。</p>
</li>
<li><p>传统的碎片整理工具<code>defragmentation tool</code>，如<code>defrag.f2fs</code>，在整理碎片时的开销很大。</p>
<blockquote>
<p>这是因为<code>defrag.f2fs</code>会把底层设备的所有内容读入主机内存中去，然后再将数据写入设备中的连续空间。这会导致大量的<code>I/O</code>开销。</p>
</blockquote>
</li>
<li><p>并且对于不熟悉系统编程的用户来说，使用这样的工具<code>defrag.f2fs</code>是困难的。</p>
</li>
<li><p>闪存设备的擦除次数有限，过多的数据迁移会降低<code>ZNS SSD</code>的寿命。</p>
</li>
<li><p>碎片整理会消耗大量的时间，且会降低前端应用的性能（由于额外的<code>I/O</code>操作）</p>
</li>
</ul>
<h2 id="How-to-find-these-problems"><a href="#How-to-find-these-problems" class="headerlink" title="How to find these problems?"></a>How to find these problems?</h2><ul>
<li><p><strong>在多线程模式的工作负荷下，数据读取的吞吐量显著降低，如图1所示：</strong></p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2010.19.07.png" alt="截屏2023-11-15 10.19.07"></p>
<ul>
<li><p><strong>I&#x2F;O请求碎片化的定义:</strong><br>由于文件系统的碎片化和闪存<code>SSD</code>的内部操作，一部分访存数据的分布变得更加随机，导致内部资源的冲突。</p>
<p>我们定义<code>I/O</code>请求的逻辑碎片<code>logical fragmentation</code>和物理碎片<code>physical fragmentation</code>，如图2所示：</p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2010.27.43.png" alt="截屏2023-11-15 10.27.43"></p>
</li>
</ul>
</li>
<li><p>**<code>Request splitting</code>**：由于碎片数据的逻辑地址不连续，向碎片数据发出的大型顺序I&#x2F;O被拆分为多个小型随机I&#x2F;O。</p>
</li>
<li><p>**<code>DoLF</code>**：<code>degree of logical fragmentation</code>，一个<code>I/O</code>范围中的逻辑碎片的数量。</p>
</li>
<li><p>**<code>DoPF</code>**：<code>degree of physical fragmentation</code>， 我们通过I&#x2F;O范围内的数据在闪存并行单元之间的均匀分布来衡量I&#x2F;O请求的物理碎片程度。</p>
<blockquote>
<p>这是因为在<code>SSD</code>中，物理碎片的定义和在磁盘上的不同（物理地址上连续），这是因为<code>SSD</code>上的芯片可以被并行的访问。如图2所示，我们把具有相同偏移量（即只能被同一芯片顺序访问的地址定义为物理碎片）。</p>
</blockquote>
<p>$$<br>DoPF &#x3D; \frac{\sum_{i&#x3D;1}^{L} \left(N_i - \frac{M}{L}\right)^2}{L}<br>$$</p>
<ul>
<li><code>M</code>：<code>I/O</code>请求访问的数据块的数量</li>
<li><code>L</code>：闪存的并行芯片数量</li>
<li><code>N_i</code>：<code>N</code>表示位于<code>i</code>平行单元（平行芯片）的数据块数量</li>
</ul>
<p>综上，较大的<code>DoPF</code>表明物理碎片程度较高，<code>I/O</code>并行程度较低。</p>
</li>
<li><p><strong>物理碎片和逻辑碎片对<code>I/O</code>性能的影响</strong></p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2011.03.09.png" alt="截屏2023-11-15 11.03.09"></p>
</li>
</ul>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2011.03.57.png" alt="截屏2023-11-15 11.03.57"></p>
<blockquote>
<p><strong>当芯片数量少于6个时，I&#x2F;O并行性对I&#x2F;O性能有显著影响，DoPF值显著增加，而I&#x2F;O性能大幅下降。然而，当DoPF值较小时，例如小于40，物理碎片化对I&#x2F;O性能的影响可以忽略不计。这是因为当I&#x2F;O的物理并行度超过一定程度时，软件开销主导了总的I&#x2F;O延迟。</strong></p>
</blockquote>
<ul>
<li><strong>如何寻找合适的碎片进行处理？</strong></li>
</ul>
<blockquote>
<p>碎片化程度低或很少访问的冷数据碎片整理数据几乎没有性能提升。</p>
</blockquote>
<p>​	<code>IODP</code>，<code>I/O data defragmentation priority</code>:<br>$$<br>IODP &#x3D; (\alpha \cdot DoLF + \beta \cdot DoPF) \times \text{readcount}<br>$$</p>
<ul>
<li><p><strong>传统固态硬盘碎片处理时的开销</strong></p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2011.20.51.png" alt="截屏2023-11-15 11.20.51"></p>
<ul>
<li><p>内存页面分配</p>
</li>
<li><p>读数据</p>
<blockquote>
<p>对内存的大量读取可能会导致主机内存使用量显著增加，并调用页面帧回收</p>
</blockquote>
</li>
<li><p>分配连续空间</p>
</li>
<li><p>写数据</p>
<blockquote>
<p>其次，在将所有目标数据读入页面缓存之前，defrag.f2fs分配一个连续的可用空间，并按顺序将所有数据写入SSD，从而导致SSD中的芯片空闲间隔很大。</p>
</blockquote>
</li>
<li><p>元数据<code>metadata</code>更新</p>
</li>
</ul>
</li>
</ul>
<h2 id="Approaches-2"><a href="#Approaches-2" class="headerlink" title="Approaches"></a>Approaches</h2><p><code>InDeF</code>的两个目标：</p>
<ul>
<li><p>一个是尽量减少用于碎片整理的迁移数据量，以减少底层设备的写入流量。</p>
</li>
<li><p>另一个是利用ZENS SSD的内部并行性来减少碎片整理的时间。</p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2011.34.18.png" alt="截屏2023-11-15 11.34.18"></p>
<ul>
<li><p><em>Fagmentation Information Management Module</em>：</p>
<ul>
<li><p>I&#x2F;O Monitor. 通过<code>I/O</code>访问的文件的<code>inode</code>确定文件块的范围</p>
</li>
<li><p>I&#x2F;O Information Management：</p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2017.08.59.png" alt="截屏2023-11-15 17.08.59"></p>
</li>
<li><p>Fagmentation Information Management.</p>
</li>
</ul>
</li>
<li><p><em>Fragmentation Calculation Module</em></p>
<ul>
<li><p>Zone Mapping in ZNS SSD</p>
<p><code>F2FS</code>通常使用<code>2MB</code>大小的段管理逻辑地址空间，图八中是区域映射到闪存块的例子：</p>
<p>图中<code>ZNS SSD</code>有四个并行芯片，一个逻辑块对应一个物理闪存页。</p>
<p>一个区域对应<code>F2FS</code>的两个连续的段。</p>
<p>根据区域大小，物理区域由一组分布在并行芯片中的块组成。</p>
<p>物理区域中的页面以交错的方式放置在不同的芯片中。</p>
<p>这样的方式能完全利用闪存操作的并行性。</p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2017.15.40.png" alt="截屏2023-11-15 17.15.40"></p>
</li>
<li><p>Calculating the degree of Fragmentation</p>
<p>首先将<code>I/O</code>范围内的文件块索引转换为文件的物理块地址。</p>
<p><code>DoLF</code>由逻辑块碎片计算。</p>
<p><code>DoPF</code>由物理块碎片计算。</p>
<p>图9是计算碎片化程度的一个例子</p>
<p>通过文件到存储的映射表，将文件<code>inode</code>中的索引号转换为文件系统的逻辑块地址。</p>
<ul>
<li><code>(32, 48, 3)</code>分别表示起始索引，结束索引，和读计数<code>read count</code></li>
<li><code>Inode# = 7</code>表示文件7</li>
</ul>
<p>索引对应了16个文件系统块。</p>
<p>我们会发现有在<code>File-system Block</code>，也就是所谓的逻辑块中，有6组碎片。所以<code>DoLF = 6</code></p>
<p>对于物理碎片，我们首先需要通过段号和段内偏移量获取闪存设备中每个逻辑块的位置。</p>
<p>例如，对于逻辑块<code>801</code>我们首先计算<code>In-segment offset = 801 - 800 = 1</code></p>
<p><code>1 mode 4 = 1</code>，现在我们知道逻辑块<code>801</code>会在芯片1上被处理。</p>
<p>最终，我们通过计算可以得到<code>DoPF</code>的值为2.5。</p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2018.52.28.png" alt="截屏2023-11-15 18.52.28"></p>
</li>
</ul>
</li>
<li><p>Defragmentation Module</p>
<p>选择需要迁移的数据过滤掉对<code>I/O</code>性能影响不大的碎片。</p>
<p>其次，毗连空间分配从该区域分配毗连的自由空间。</p>
<p>第三，主机的数据迁移任务被卸载到SSD。</p>
<p>最后，文件系统会保留迁移数据的元数据块。</p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2019.15.20.png" alt="截屏2023-11-15 19.15.20"></p>
<ul>
<li><p>Fragments filter.</p>
</li>
<li><p>Migration offloading.</p>
<ul>
<li><p>Command generating</p>
<p>InDeF将源数据分为两组，其中一组需要从主机内存传输到设备，另一组通过迁移卸载进行处理。</p>
<blockquote>
<p>这是因为：对于I&#x2F;O范围内的每个块，首先要检查它是否缓存在页面缓存中。如果它已经被缓存并且页面很脏，则需要将该块排除在迁移卸载之外，并从内存写入设备。如果缓存的页面干净或未缓存，则可以通过迁移卸载在内部复制。</p>
</blockquote>
</li>
<li><p>Command sending:</p>
<p> <code>In_Device_Defragment</code> 命令实现存储内数据迁移</p>
<blockquote>
<p>它包含一组源LBA和一组目标LBA。该命令非常高效，因为每个4KB逻辑块被两个4字节块地址替换。</p>
</blockquote>
</li>
<li><p>Command processing:</p>
<p>SSD内部控制器根据区域的写入策略处理迁移卸载和主机请求。</p>
<ul>
<li><p>如果源块和目标块属于同一芯片，则使用<code>copyback</code>命令在芯片内进行传输。</p>
</li>
<li><p>否则，先将数据块读入<code>SSD</code>中的<code>DRAM</code>，再写到目标位置。</p>
<blockquote>
<p>即使是对迁移卸载数据的读取请求，它们也可以通过SSD上的DRAM或闪存芯片正常处理。由于异地更新策略，对迁移卸载数据的写入请求不受影响。最后，文件系统会保留迁移到设备的数据的元数据块。F2FS实施检查点以提供一致的恢复点。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Slides"><a href="#Slides" class="headerlink" title="Slides:"></a>Slides:</h1><iframe src="../../../../pdf_file/ZNS00/ZNS_11.18.pdf" style="width:100%; height:800px;" frameborder="0"></iframe>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/11/ZNSLinuxKernelSupport/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/11/ZNSLinuxKernelSupport/" class="post-title-link" itemprop="url">ZNSLinuxKernelSupport</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-11 12:01:17" itemprop="dateCreated datePublished" datetime="2023-11-11T12:01:17+08:00">2023-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-16 13:16:53" itemprop="dateModified" datetime="2023-11-16T13:16:53+08:00">2023-11-16</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux-Zoned-Storage-Support-Overview"><a href="#Linux-Zoned-Storage-Support-Overview" class="headerlink" title="Linux Zoned Storage Support Overview"></a>Linux Zoned Storage Support Overview</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>​	应用程序开发者可以通过多种 I&#x2F;O 路径使用分区块设备，可以用不同的编程接口来控制它们，并且可以以不同的方式暴露分区块设备。下面的图表简单表示了各种访问路径。</p>
<blockquote>
<ul>
<li><code>POSIX</code>：<code>Portable Operating System Interface</code>，它是一系列 IEEE 标准，旨在确保不同操作系统之间的兼容性。</li>
</ul>
</blockquote>
<p><img src="/../images/ZNSLinuxKernelSupport/%E6%88%AA%E5%B1%8F2023-11-11%2013.15.44.png" alt="截屏2023-11-11 13.15.44"></p>
<ul>
<li><code>File Access Interface</code>：文件访问接口。上图中<code>Legacy Application</code>有两种文件访问方式：<ul>
<li><code>ZBD Compliant File System</code>：文件系统被修改，可以将随机写转换为适合<code>Zoned Block Devices</code>的顺序写。例如，<code>F2FS</code>。</li>
<li><code>Legacy File System</code>：文件系统未经修改，设备的顺序写入限制由一个设备映射器目标处理器<code>dm-zoned</code>处理。</li>
</ul>
</li>
<li><code>Raw Block Access Interface</code>：应用程序直接访问设备上的数据，该接口类似于<code>legacy File System</code>，使用<code>dm-zoned</code>设备映射器目标驱动实现的，以便对应用程序隐藏顺序写入的限制。</li>
</ul>
<p>​	为遵守分区块设备的顺序写入约束而编写或修改的应用程序可以使用三个额外的接口。这些接口直接将设备约束暴露给应用程序，这些应用程序必须确保数据使用从区域的写入指针位置开始的顺序流进行写入。</p>
<ul>
<li><code>File Access Interface</code>：该接口专门适配<a target="_blank" rel="noopener" href="https://zonedstorage.io/docs/linux/fs#zonefs"><code>zonefs</code></a>文件系统。该文件系统将<code>zoned block device</code>的每一个<code>zone</code>作为一个文件。但有所不同的是，设备中的顺序写不由<code>zonefs</code>管理，区域的顺序写应交给上层的应用程序负责。</li>
<li><code>Zoned Raw Block Access Interface</code>：该接口没有任何中间驱动来处理设备限制。应用程序可以直接打开分区块设备的设备文件来使用这个接口，以获取对区块信息和块层提供的管理操作的访问。</li>
<li><code>Passthrough Device Access Interface</code>：该接口由<code>SCSI</code>通用驱动<code>SG</code>和<code>NVMe</code>驱动提供，它允许应用程序直接向设备发送<code>SCSI</code>和<code>NVMe</code>命令。在这个接口中，内核对应用程序发送的命令干预非常小，这导致需要应用程序自己处理所有的设备限制（例如，逻辑和物理扇区大小，区域边界，命令超时，命令重试次数等）。如<code>libzbc</code>和<code>libnvme</code>这样的用户级库可以大大简化使用这个接口的应用程序的实现。</li>
</ul>
<h2 id="Kernel-Versions"><a href="#Kernel-Versions" class="headerlink" title="Kernel Versions"></a>Kernel Versions</h2><p><img src="/../images/ZNSLinuxKernelSupport/%E6%88%AA%E5%B1%8F2023-11-11%2014.07.43.png" alt="截屏2023-11-11 14.07.43"></p>
<ul>
<li><code>Passthrough Access Support (SG Access)</code>：内核支持通过<code>SCSI</code>通用<code>(SG)</code>接口访问主机管理的<code>ZBC/ZAC</code>硬盘。对于符合条件的 SCSI 硬盘或连接到兼容 SAS HBA 的 SATA 硬盘，用户可以通过 SG 驱动创建的节点文件来访问这些主机管理的磁盘。这允许用户通过 SG 接口与这些磁盘交互。</li>
<li><code>Zoned Block Device Access and F2FS Support</code>：4.10以后的内核支持主机以管理常规磁盘的方式将ZBC&#x2F;ZAC<code>磁盘当作block device files</code>管理。</li>
<li><code>Device Mapper and dm-zoned Support</code>：在内核4.13.0中，对分区块设备的支持被添加到了设备映射器基础架构中。这项支持允许在分区块设备之上使用 dm-linear 和 dm-flakey 设备映射器目标。此外，还添加了 dm-zoned 设备映射器目标驱动程序。</li>
<li><code>Block multi-queue and SCSI multi-queue Support</code>：支持块多队列和SCSI多队列。</li>
<li><code>zonefs</code>：支持<code>zonefs file system</code>，将分区块设备的区域作为常规文件暴露出来，支持所有类型的分区块设备。</li>
<li><code>Zone Append Operation Support</code>：追加写操作。</li>
<li><code>NVM Express Zoned Namespaces</code>：支持<code>NVMe ZNS</code>命令集。</li>
</ul>
<h1 id="Kernel-Configuration"><a href="#Kernel-Configuration" class="headerlink" title="Kernel Configuration"></a>Kernel Configuration</h1><p>内核中一些关于zoned block device 的配置</p>
<h2 id="Block-Layer"><a href="#Block-Layer" class="headerlink" title="Block Layer"></a>Block Layer</h2><h3 id="Zoned-Block-Devices-Core-Support"><a href="#Zoned-Block-Devices-Core-Support" class="headerlink" title="Zoned Block Devices Core Support"></a>Zoned Block Devices Core Support</h3><p>通过make menuconfig 打开Linux配置菜单，选择 <code>Zoned block device support</code>。</p>
<h3 id="Write-Ordering-Control"><a href="#Write-Ordering-Control" class="headerlink" title="Write Ordering Control"></a>Write Ordering Control</h3><p>​	写入顺序控制通过<code>deadline</code>（遗留的单队列块I&#x2F;O路径）和mq-deadkine（多队列块I&#x2F;O路径）块 I&#x2F;O 调度器实现的（见写入顺序控制）。如果设置了 CONFIG_BLK_DEV_ZONED 配置选项，则自动启用 deadline 和 mq-deadline 分区块设备支持。</p>
<p>​	对于分区块设备，启用这个调度器是必须的。配置选项 CONFIG_MQ_IOSCHED_DEADLINE 启用 mq-deadline 调度器。配置选项 CONFIG_IOSCHED_DEADLINE 启用 deadline 调度器。这两个选项都可以从 IO 调度器顶级菜单中选择。</p>
<p>​	不过在后续的版本中，<code>CONFIG_MQ_IOSCHED_DEADLINE</code>会随着<code>CONFIG_BLK_DEV_ZONED</code>配置而配置。</p>
<h2 id="Device-Drivers-Configuration"><a href="#Device-Drivers-Configuration" class="headerlink" title="Device Drivers Configuration"></a>Device Drivers Configuration</h2><ul>
<li><code>null_blk</code> Logic Device</li>
<li><code>ZBC</code> and &#96;ZAC Hard-Disks Support</li>
<li><code>NVMe Zoned Namespace Solid State Disks Support</code></li>
</ul>
<h2 id="Device-Mapper"><a href="#Device-Mapper" class="headerlink" title="Device Mapper"></a>Device Mapper</h2><p>设置了 CONFIG_BLK_DEV_ZONED 选项时，设备映射器子系统对分区块设备的支持会自动启用。这使得 dm-linear 和 dm-flakey 目标得到支持。请注意，必须启用 dm-zoned 设备映射器目标才能使用。</p>
<p>通过在菜单“设备驱动程序 –&gt; 多设备驱动支持（RAID 和 LVM）–&gt; 设备映射器支持 –&gt; 驱动管理的分区块设备目标支持”中选择 CONFIG_DM_ZONED 选项来启用 dm-zoned 目标。</p>
<h2 id="File-Systems"><a href="#File-Systems" class="headerlink" title="File Systems"></a>File Systems</h2><h3 id="F2fs"><a href="#F2fs" class="headerlink" title="F2fs"></a>F2fs</h3><p>当<code>CONFIG_BLK_DEV_ZONED</code>配置时，<code>f2fs file system</code>也自动被配置。</p>
<h3 id="zonefs"><a href="#zonefs" class="headerlink" title="zonefs"></a>zonefs</h3><p>这个要在 <code>menu File system -&gt; zonefs</code>中手动配置</p>
<h3 id="Kernel-Installation"><a href="#Kernel-Installation" class="headerlink" title="Kernel Installation"></a>Kernel Installation</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo make modules_install install</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo make headers_install</span><br></pre></td></tr></table></figure>

<h1 id="Zoned-Block-Device-user-Interface"><a href="#Zoned-Block-Device-user-Interface" class="headerlink" title="Zoned Block Device user Interface"></a>Zoned Block Device user Interface</h1><p>用户程序可以通过两种接口访问<code>zone information</code>和管理<code>zoned block device</code>中的<code>zones</code></p>
<ol>
<li><code>sysfs attribute files</code>：可以直接作为常规文件由应用程序访问，或者通过脚本语言访问。</li>
<li><code>ioctl() system call</code>：适用于从 C 程序或其他具有等效系统调用绑定的编程语言中使用。</li>
</ol>
<h2 id="Sysfs-Interface"><a href="#Sysfs-Interface" class="headerlink" title="Sysfs Interface"></a>Sysfs Interface</h2><table>
<thead>
<tr>
<th align="center">File</th>
<th>Kernel version</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x2F;sys&#x2F;block&#x2F;<em>dev name</em>&#x2F;queue&#x2F;zoned</td>
<td>4.10.0</td>
<td>Device zoned model</td>
</tr>
<tr>
<td align="center">&#x2F;sys&#x2F;block&#x2F;<em>dev name</em>&#x2F;queue&#x2F;chunk_sectors</td>
<td>4.10.0</td>
<td>Device zone size</td>
</tr>
<tr>
<td align="center">&#x2F;sys&#x2F;block&#x2F;<em>dev name</em>&#x2F;queue&#x2F;nr_zones</td>
<td>4.20.0</td>
<td>Total number of zones</td>
</tr>
<tr>
<td align="center">&#x2F;sys&#x2F;block&#x2F;<em>dev name</em>&#x2F;queue&#x2F;zone_append_max_bytes</td>
<td>5.8.0</td>
<td>Maximum size in bytes of a zone append write operation</td>
</tr>
<tr>
<td align="center">&#x2F;sys&#x2F;block&#x2F;<em>dev name</em>&#x2F;queue&#x2F;max_open_zones</td>
<td>5.9.0</td>
<td>Maximum number of open zones</td>
</tr>
<tr>
<td align="center">&#x2F;sys&#x2F;block&#x2F;<em>dev name</em>&#x2F;queue&#x2F;max_active_zones</td>
<td>5.9.0</td>
<td>Maximum number of active zones</td>
</tr>
</tbody></table>
<h3 id="Device-Zoned-Model"><a href="#Device-Zoned-Model" class="headerlink" title="Device Zoned Model"></a>Device Zoned Model</h3><p><code>zone model</code>（<code>host-managed</code>和<code>host-awared</code>）可以通过<code>zoned</code>设备队列 查看，例如，如果一个<code>zoned block device</code>叫做<code>sdb</code>，则通过命令查看模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /sys/block/sdb/queue/zoned</span></span><br><span class="line">host-managed</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>Regular block device, including drive-managed SMR disks</td>
</tr>
<tr>
<td>host-aware</td>
<td>Host-aware device model</td>
</tr>
<tr>
<td>host-managed</td>
<td>Host-managed device model</td>
</tr>
</tbody></table>
<h3 id="Zone-Size"><a href="#Zone-Size" class="headerlink" title="Zone Size"></a>Zone Size</h3><p>设备的区域大小<code>zone size</code>可以从<code>sysfs</code>队列属性文件读取，命令如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /sys/block/sdb/queue/chunk_sectors</span></span><br><span class="line">524288</span><br></pre></td></tr></table></figure>

<p>该值以512字节扇区的数量显示，不论设备的实际逻辑和物理大小如何。在上文中，设备分区的大小为<code>524288 * 512 = 256 MB</code></p>
<h3 id="Number-of-Zones"><a href="#Number-of-Zones" class="headerlink" title="Number of Zones"></a>Number of Zones</h3><p>同样，<code>zoned device</code>的<code>zones</code>的数量可以通过如下命令获取</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /sys/block/sdb/queue/nr_zones</span></span><br><span class="line">55880</span><br></pre></td></tr></table></figure>

<p>对于普通块设备，这个参数为0。</p>
<h3 id="Zone-Resources"><a href="#Zone-Resources" class="headerlink" title="Zone Resources"></a>Zone Resources</h3><p>设备区域资源可以从<code>sysfs queue</code>参数文件中读取，分别是<code>max_open_zones</code>和<code>max_active_zones</code>。</p>
<p>命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /sys/block/sdb/queue/max_open_zones</span></span><br><span class="line">128</span><br></pre></td></tr></table></figure>

<p>该命令给出了能被显示或者隐示打开的<code>zones</code>的数量为<code>128</code>。如果为0，则表示设备没有限制最大zones的打开数量。</p>
<p>接下来的命令给出了<code>zones</code>是<code>active</code>状态<code>(open or closed state)</code>的最大数量，同上，0表示没有限制：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /sys/block/sdb/queue/max_active_zones</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>当我们通过<code>null_blk</code>,<code>QEMU</code>,或者<code>tcmu-runner</code>模拟一个<code>zoned device</code>，以上参数是可以被人工设置的。</p>
<h2 id="ioctl-Application-Programming-Interface"><a href="#ioctl-Application-Programming-Interface" class="headerlink" title="ioctl() Application Programming Interface"></a><em>ioctl()</em> Application Programming Interface</h2><p>用户可以通过头文件<del>&#x2F;usr&#x2F;include&#x2F;linux&#x2F;blkzoned.h</del>，在kernel 5.10中，头文件在<code>include/uapi/linux/blkzone.h</code>，中定义的宏和数据结构获取<code>zoned block device</code>的信息并管理他们。</p>
<h3 id="Zone-Information-Data-Structures"><a href="#Zone-Information-Data-Structures" class="headerlink" title="Zone Information Data Structures"></a>Zone Information Data Structures</h3><p><code>struct blk_zone</code>定义了一个<code>zone-descriptor</code>结构，该结构包含了zone的所有描述。</p>
<ul>
<li><code>zone&#39;s location on device</code></li>
<li><code>zone type</code></li>
<li><code>zone state</code></li>
<li><code>position of zone write pointer</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct blk_zone - Zone descriptor for BLKREPORTZONE ioctl.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @start: Zone start in 512 B sector units </span></span><br><span class="line"><span class="comment"> * @len: Zone length in 512 B sector units</span></span><br><span class="line"><span class="comment"> * @wp: Zone write pointer location in 512 B sector units</span></span><br><span class="line"><span class="comment"> * @type: see enum blk_zone_type for possible values</span></span><br><span class="line"><span class="comment"> * @cond: see enum blk_zone_cond for possible values</span></span><br><span class="line"><span class="comment"> * @non_seq: Flag indicating that the zone is using non-sequential resources</span></span><br><span class="line"><span class="comment"> *           (for host-aware zoned block devices only).</span></span><br><span class="line"><span class="comment"> * @reset: Flag indicating that a zone reset is recommended.</span></span><br><span class="line"><span class="comment"> * @resv: Padding for 8B alignment.</span></span><br><span class="line"><span class="comment"> * @capacity: Zone usable capacity in 512 B sector units</span></span><br><span class="line"><span class="comment"> * @reserved: Padding to 64 B to match the ZBC, ZAC and ZNS defined zone</span></span><br><span class="line"><span class="comment"> *            descriptor size.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * start, len, capacity and wp use the regular 512 B sector unit, regardless</span></span><br><span class="line"><span class="comment"> * of the device logical block size. The overall structure size is 64 B to</span></span><br><span class="line"><span class="comment"> * match the ZBC, ZAC and ZNS defined zone descriptor and allow support for</span></span><br><span class="line"><span class="comment"> * future additional zone information.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_zone</span> &#123;</span></span><br><span class="line">	__u64	start;		<span class="comment">/* 分区的起始扇区。这是一个64位无符号整数，表示分区在存储设备上的起始位置，以512字节的扇区为单位计量。 */</span></span><br><span class="line">	__u64	len;		<span class="comment">/* 分区的长度，用扇区的数量表示。这同样是一个64位无符号整数，指示该分区包含多少个512字节的扇区。 */</span></span><br><span class="line">	__u64	wp;		<span class="comment">/* 分区的写入指针位置。这个值指示当前可写入数据的位置，在存储设备中也是以512字节扇区为单位表示。 */</span></span><br><span class="line">	__u8	type;		<span class="comment">/* 分区的类型。这是一个8位无符号整数，其值根据 enum blk_zone_type 中定义的类型来确定，比如常规分区、顺序写入分区等。 */</span></span><br><span class="line">	__u8	cond;		<span class="comment">/* 分区的状态。这个字段根据 enum blk_zone_cond 定义的值来确定分区的当前状态，例如空闲、满、只读等。*/</span></span><br><span class="line">	__u8	non_seq;	<span class="comment">/* 非顺序写入资源的标志。这是一个8位的标志位，用于指示该分区是否使用了非顺序写入资源，这通常仅适用于主动感知分区的块设备。 */</span></span><br><span class="line">	__u8	reset;		<span class="comment">/* 重置写入指针的推荐标志。这个字段表示是否推荐对该分区执行写入指针重置操作。 */</span></span><br><span class="line">	__u8	resv[<span class="number">4</span>];	<span class="comment">/*	 为了实现8字节对齐而设置的保留字段。	*/</span></span><br><span class="line">	__u64	capacity;	<span class="comment">/* 分区的可用容量，以512字节扇区为单位计量。*/</span></span><br><span class="line">	__u8	reserved[<span class="number">24</span>]; <span class="comment">/* 额外的保留字段，用来填充结构体大小，以确保整个结构体与 ZBC（Zoned Block Commands）、ZAC（Zoned ATA Commands）和 ZNS（Zoned Namespace）定义的分区描述符大小相匹配，即64字节。	*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	正如这个数据结构定义中的注释所指出的，用来表示（1）分区的起始位置、（2）分区的大小和（3）写入指针位置的单位是‘512字节的扇区大小’。这一点不受设备实际逻辑块大小的影响。即使是具有4KB逻辑扇区的设备，上述分区描述符字段也使用512字节扇区大小单位。”</p>
<h3 id="Zone-Type"><a href="#Zone-Type" class="headerlink" title="Zone Type"></a>Zone Type</h3><p>一个zone的discriptor只有一种类别：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * enum blk_zone_type - Types of zones allowed in a zoned device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_TYPE_CONVENTIONAL: The zone has no write pointer and can be writen</span></span><br><span class="line"><span class="comment"> *                              randomly. Zone reset has no effect on the zone.</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_TYPE_SEQWRITE_REQ: The zone must be written sequentially</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_TYPE_SEQWRITE_PREF: The zone can be written non-sequentially</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Any other value not defined is reserved and must be considered as invalid.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">blk_zone_type</span> &#123;</span></span><br><span class="line">	BLK_ZONE_TYPE_CONVENTIONAL	= <span class="number">0x1</span>,</span><br><span class="line">	BLK_ZONE_TYPE_SEQWRITE_REQ	= <span class="number">0x2</span>,</span><br><span class="line">	BLK_ZONE_TYPE_SEQWRITE_PREF	= <span class="number">0x3</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Zone-Condition"><a href="#Zone-Condition" class="headerlink" title="Zone Condition"></a>Zone Condition</h3><p>每个zone也只有一种状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * enum blk_zone_cond - Condition [state] of a zone in a zoned device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_COND_NOT_WP: The zone has no write pointer, it is conventional.</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_COND_EMPTY: The zone is empty.</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_COND_IMP_OPEN: The zone is open, but not explicitly opened.</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_COND_EXP_OPEN: The zones was explicitly opened by an</span></span><br><span class="line"><span class="comment"> *                          OPEN ZONE command.</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_COND_CLOSED: The zone was [explicitly] closed after writing.</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_COND_FULL: The zone is marked as full, possibly by a zone</span></span><br><span class="line"><span class="comment"> *                      FINISH ZONE command.</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_COND_READONLY: The zone is read-only.</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_COND_OFFLINE: The zone is offline (sectors cannot be read/written).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The Zone Condition state machine in the ZBC/ZAC standards maps the above</span></span><br><span class="line"><span class="comment"> * deinitions as:</span></span><br><span class="line"><span class="comment"> *   - ZC1: Empty         | BLK_ZONE_COND_EMPTY</span></span><br><span class="line"><span class="comment"> *   - ZC2: Implicit Open | BLK_ZONE_COND_IMP_OPEN</span></span><br><span class="line"><span class="comment"> *   - ZC3: Explicit Open | BLK_ZONE_COND_EXP_OPEN</span></span><br><span class="line"><span class="comment"> *   - ZC4: Closed        | BLK_ZONE_COND_CLOSED</span></span><br><span class="line"><span class="comment"> *   - ZC5: Full          | BLK_ZONE_COND_FULL</span></span><br><span class="line"><span class="comment"> *   - ZC6: Read Only     | BLK_ZONE_COND_READONLY</span></span><br><span class="line"><span class="comment"> *   - ZC7: Offline       | BLK_ZONE_COND_OFFLINE</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Conditions 0x5 to 0xC are reserved by the current ZBC/ZAC spec and should</span></span><br><span class="line"><span class="comment"> * be considered invalid.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">blk_zone_cond</span> &#123;</span></span><br><span class="line">	BLK_ZONE_COND_NOT_WP	= <span class="number">0x0</span>,</span><br><span class="line">	BLK_ZONE_COND_EMPTY	= <span class="number">0x1</span>,</span><br><span class="line">	BLK_ZONE_COND_IMP_OPEN	= <span class="number">0x2</span>,</span><br><span class="line">	BLK_ZONE_COND_EXP_OPEN	= <span class="number">0x3</span>,</span><br><span class="line">	BLK_ZONE_COND_CLOSED	= <span class="number">0x4</span>,</span><br><span class="line">	BLK_ZONE_COND_READONLY	= <span class="number">0xD</span>,</span><br><span class="line">	BLK_ZONE_COND_FULL	= <span class="number">0xE</span>,</span><br><span class="line">	BLK_ZONE_COND_OFFLINE	= <span class="number">0xF</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，<code>BLK_ZONE_COND_OFFLINE</code>和<code>BLK_ZONE_COND_READONLY</code>只能被设备本身设置，用来指示因硬件缺陷而能力受限的分区。</p>
<p>用户操作可能导致状态的转变。使用内核<code>ioctl()</code>接口的应用程序可以发出分区管理命令。</p>
<blockquote>
<p>The SCSI Zoned Block Command specification (ZBC), the ATA Zoned Device ATA Command Set specification (ZAC) and the NVM Express Zoned Namespace Command Set specification (ZNS) define a zone condition state machine that governs the possible transitions of a zone from one condition to another depending on the commands executed.</p>
</blockquote>
<h3 id="ioctl-Commands"><a href="#ioctl-Commands" class="headerlink" title="ioctl() Commands"></a>ioctl() Commands</h3><p>下面是 ioctl()命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Zoned block device ioctl&#x27;s:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @BLKREPORTZONE: Get zone information. Takes a zone report as argument.</span></span><br><span class="line"><span class="comment"> *                 The zone report will start from the zone containing the</span></span><br><span class="line"><span class="comment"> *                 sector specified in the report request structure.</span></span><br><span class="line"><span class="comment"> * @BLKRESETZONE: Reset the write pointer of the zones in the specified</span></span><br><span class="line"><span class="comment"> *                sector range. The sector range must be zone aligned.</span></span><br><span class="line"><span class="comment"> * @BLKGETZONESZ: Get the device zone size in number of 512 B sectors.</span></span><br><span class="line"><span class="comment"> * @BLKGETNRZONES: Get the total number of zones of the device.</span></span><br><span class="line"><span class="comment"> * @BLKOPENZONE: Open the zones in the specified sector range.</span></span><br><span class="line"><span class="comment"> *               The 512 B sector range must be zone aligned.</span></span><br><span class="line"><span class="comment"> * @BLKCLOSEZONE: Close the zones in the specified sector range.</span></span><br><span class="line"><span class="comment"> *                The 512 B sector range must be zone aligned.</span></span><br><span class="line"><span class="comment"> * @BLKFINISHZONE: Mark the zones as full in the specified sector range.</span></span><br><span class="line"><span class="comment"> *                 The 512 B sector range must be zone aligned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLKREPORTZONE	_IOWR(0x12, 130, struct blk_zone_report)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLKRESETZONE	_IOW(0x12, 131, struct blk_zone_range)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLKGETZONESZ	_IOR(0x12, 132, __u32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLKGETNRZONES	_IOR(0x12, 133, __u32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLKOPENZONE	_IOW(0x12, 134, struct blk_zone_range)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLKCLOSEZONE	_IOW(0x12, 135, struct blk_zone_range)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLKFINISHZONE	_IOW(0x12, 136, struct blk_zone_range)</span></span><br></pre></td></tr></table></figure>

<p>以下是内核支持的命令：</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Kernel version</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>BLKREPORTZONE</td>
<td>4.10.0</td>
<td>Get zone information</td>
</tr>
<tr>
<td>BLKRESETZONE</td>
<td>4.10.0</td>
<td>Reset a zone write pointer</td>
</tr>
<tr>
<td>BLKGETZONESZ</td>
<td>4.20.0</td>
<td>Get a device zone size</td>
</tr>
<tr>
<td>BLKGETNRZONES</td>
<td>4.20.0</td>
<td>Get the total number of zones of a device</td>
</tr>
<tr>
<td>BLKOPENZONE</td>
<td>5.5.0</td>
<td>Explicitly open a zone</td>
</tr>
<tr>
<td>BLKCLOSEZONE</td>
<td>5.5.0</td>
<td>Close a zone</td>
</tr>
<tr>
<td>BLKFINISHZONE</td>
<td>5.5.0</td>
<td>Finish a zone</td>
</tr>
</tbody></table>
<h3 id="Obtaining-Zone-Information"><a href="#Obtaining-Zone-Information" class="headerlink" title="Obtaining Zone Information"></a>Obtaining Zone Information</h3><p><code>BLKREPORTZONE</code>命令允许应用以分区描述符数组的形式获取设备的分区消息，<code>struct blk_zone_report</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct blk_zone_report - BLKREPORTZONE ioctl request/reply</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @sector: starting sector of report</span></span><br><span class="line"><span class="comment"> * @nr_zones: IN maximum / OUT actual</span></span><br><span class="line"><span class="comment"> * @flags: one or more flags as defined by enum blk_zone_report_flags.</span></span><br><span class="line"><span class="comment"> * @zones: Space to hold @nr_zones @zones entries on reply.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The array of at most @nr_zones must follow this structure in memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_zone_report</span> &#123;</span></span><br><span class="line">	__u64		sector;</span><br><span class="line">	__u32		nr_zones;</span><br><span class="line">	__u8    reserved[<span class="number">4</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blk_zone</span> <span class="title">zones</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sector</code>：代表报告的起始扇区。指定分区报告应该从哪个扇区开始。</li>
<li><code>nr_zones</code>：作为输入，指定调用者希望检索信息的最大分区数。作为输出，表示设备响应<code>BLKREPORTZONE</code>命令后报告的实际分区数。</li>
<li><code>zones[0]</code>：这是一个灵活数组成员（由<code>[0]</code>表示），用于存储分区描述符。此数组中的元素数量由<code>nr_zones</code>指定。这个数组将包含设备返回的实际分区信息。数组中的每个元素都是<code>struct blk_zone</code>类型，其中包含了关于单个分区的详细信息。</li>
</ul>
<p>下面是一个简单的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/blkzoned.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> start_sector = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_zone_report</span> *<span class="title">hdr</span>;</span></span><br><span class="line"><span class="type">size_t</span> hdr_len;</span><br><span class="line"><span class="type">int</span> nr_zones = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 	文件头的长度 	*/</span></span><br><span class="line">hdr_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> blk_zone_report) + nr_zones * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> blkzone);</span><br><span class="line"><span class="comment">/* 	为文件头分配空间	 */</span></span><br><span class="line">hdr = <span class="built_in">malloc</span>(hdr_len);</span><br><span class="line"><span class="comment">/*	检查是否分配成功	*/</span></span><br><span class="line"><span class="keyword">if</span> (!hdr)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">/*	文件头的起始扇区	*/</span></span><br><span class="line">    hdr-&gt;sector = start_sector;</span><br><span class="line">    <span class="comment">/*	最大分区数	*/</span></span><br><span class="line">    hdr-&gt;nr_zones = nr_zones;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*	通过`ioctl`调用，使用BLKREPORTZONE命令获取分区信息	*/</span></span><br><span class="line">    ret = ioctl(fd, BLKREPORTZONE, hdr);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*	如果没有报告任何分区，结束	*/</span></span><br><span class="line">    <span class="keyword">if</span> (!hdr-&gt;nr_zones) &#123;</span><br><span class="line">        <span class="comment">/* Done */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got %u zone descriptors\n&quot;</span>, hdr-&gt;nr_zones);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The next report must start after the last zone reported */</span></span><br><span class="line">    <span class="comment">/*	更新 start_sector 以便下一次报告从上一次报告的最后一个分区之后的扇区开始	*/</span></span><br><span class="line">    start_sector = hdr-&gt;zones[hdr-&gt;nr_zones - <span class="number">1</span>].start +</span><br><span class="line">               hdr-&gt;zones[hdr-&gt;nr_zones - <span class="number">1</span>].len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>zone</code>描述符的数量存储在结构体<code>blk_zone_report</code>中的<code>nr_zones</code>并返回。 </p>
<p>在5.9内核中，定义有所不同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * enum blk_zone_report_flags - Feature flags of reported zone descriptors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_REP_CAPACITY: Zone descriptor has capacity field.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">blk_zone_report_flags</span> &#123;</span></span><br><span class="line">	BLK_ZONE_REP_CAPACITY	= (<span class="number">1</span> &lt;&lt; <span class="number">0</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct blk_zone_report - BLKREPORTZONE ioctl request/reply</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @sector: starting sector of report</span></span><br><span class="line"><span class="comment"> * @nr_zones: IN maximum / OUT actual</span></span><br><span class="line"><span class="comment"> * @flags: one or more flags as defined by enum blk_zone_report_flags.</span></span><br><span class="line"><span class="comment"> * @zones: Space to hold @nr_zones @zones entries on reply.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The array of at most @nr_zones must follow this structure in memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_zone_report</span> &#123;</span></span><br><span class="line">    __u64       sector;</span><br><span class="line">    __u32       nr_zones;</span><br><span class="line">    __u32       flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_zone</span> <span class="title">zones</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>flags</code>：包含一个或者多个<code>blk_zone_report_flags</code>的枚举类，枚举量为<code>BLK_ZONE_REP_CAPACITY</code>，</p>
<p>如果该值为1，则<code>zone</code>描述符结构<code>blk_zone</code>体会设置<code>capacity</code>域可用。否则忽略该成员。</p>
<p>下面的代码实例展示应用程序如何通过<code>autotool</code>构建环境中检查特定头文件和结构体成员的存在：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># less configure.ac</span><br><span class="line">...</span><br><span class="line">AC_CHECK_HEADER(linux/blkzoned.h, [],</span><br><span class="line">                [AC_MSG_ERROR([Couldn&#x27;t find linux/blkzoned.h. Kernel too old ?])],</span><br><span class="line">                [[#include &lt;linux/blkzoned.h&gt;]])</span><br><span class="line"></span><br><span class="line">AC_CHECK_MEMBER([struct blk_zone.capacity],</span><br><span class="line">                [AC_DEFINE(HAVE_BLK_ZONE_REP_V2, [1], [report zones includes zone capacity])],</span><br><span class="line">                [], [[#include &lt;linux/blkzoned.h&gt;]])</span><br></pre></td></tr></table></figure>

<p>在一些较新的Linux内核版本中，特别是从5.9版本开始，增加了对分区容量信息的支持。这意味着内核可以提供每个分区的容量信息。对于这些内核，宏<code>HAVE_BLK_ZONE_REP_V2</code>被定义，它的应用如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Handle kernel zone capacity support</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HAVE_BLK_ZONE_REP_V2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLK_ZONE_REP_CAPACITY   (1 &lt;&lt; 0)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_zone_v2</span> &#123;</span></span><br><span class="line">        __u64   start;          <span class="comment">/* Zone start sector */</span></span><br><span class="line">        __u64   len;            <span class="comment">/* Zone length in number of sectors */</span></span><br><span class="line">        __u64   wp;             <span class="comment">/* Zone write pointer position */</span></span><br><span class="line">        __u8    type;           <span class="comment">/* Zone type */</span></span><br><span class="line">        __u8    cond;           <span class="comment">/* Zone condition */</span></span><br><span class="line">        __u8    non_seq;        <span class="comment">/* Non-sequential write resources active */</span></span><br><span class="line">        __u8    reset;          <span class="comment">/* Reset write pointer recommended */</span></span><br><span class="line">        __u8    resv[<span class="number">4</span>];</span><br><span class="line">        __u64   capacity;       <span class="comment">/* Zone capacity in number of sectors */</span></span><br><span class="line">        __u8    reserved[<span class="number">24</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> blk_zone blk_zone_v2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_zone_report_v2</span> &#123;</span></span><br><span class="line">        __u64   sector;</span><br><span class="line">        __u32   nr_zones;</span><br><span class="line">        __u32   flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_zone</span> <span class="title">zones</span>[0];</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> blk_zone_report blk_zone_report_v2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* HAVE_BLK_ZONE_REP_V2 */</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>对于不支持报告分区容量的内核，通过上述代码重新定义<code>blk_zone</code>。</p>
<p>再次以libzbd库的源代码为例，分区报告回复的分区描述符可以按照以下方式处理。我们在上文中提到，结构体<code>struct blk_zone</code>内的成员的长度，都是以<code>512B</code>扇区计数的。而在函数<code>zbd_parse_zone</code>中，我们通过将<code>blk_zone</code>内的成员左移9位（即乘以512）得到对应的字节数量，并存储到对应的<code>struct zbd_zone * zone</code>中。</p>
<p>这是因为，在内核层面，分区的起始位置、长度、容量和写入指针通常以扇区为单位进行存储和报告，而在许多高级应用和系统调用中，使用字节作为更通用和精确的度量单位更为常见。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * zbd_parse_zone - Fill a zone descriptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*	</span></span><br><span class="line"><span class="comment"> 	*	zbd_zone 	用于存储解析后的分区信息</span></span><br><span class="line"><span class="comment"> 	*	blk_zone	指向原始从内核获取的分区信息</span></span><br><span class="line"><span class="comment"> 	*	blk_zone_report 指向分区报告的结构体指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">zbd_parse_zone</span><span class="params">(<span class="keyword">struct</span> zbd_zone *zone, <span class="keyword">struct</span> blk_zone *blkz,</span></span><br><span class="line"><span class="params">                                  <span class="keyword">struct</span> blk_zone_report *rep)</span></span><br><span class="line">&#123;</span><br><span class="line">				<span class="comment">/*	将分区的起始扇区转换为字节单位存储在 zbd_zone	中	*/</span></span><br><span class="line">        zone-&gt;start = blkz-&gt;start &lt;&lt; SECTOR_SHIFT;</span><br><span class="line">        <span class="comment">/*	将分区的长度(以扇区为单位)转换为以字节为单位	SECTOR_SHIFT = 9，扇区大小为512B	*/</span></span><br><span class="line">        zone-&gt;len = blkz-&gt;len &lt;&lt; SECTOR_SHIFT;</span><br><span class="line">        <span class="comment">/*	判断capacity	*/</span></span><br><span class="line">        <span class="keyword">if</span> (rep-&gt;flags &amp; BLK_ZONE_REP_CAPACITY)</span><br><span class="line">                zone-&gt;capacity = blkz-&gt;capacity &lt;&lt; SECTOR_SHIFT;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                zone-&gt;capacity = zone-&gt;len;</span><br><span class="line">        </span><br><span class="line">        zone-&gt;wp = blkz-&gt;wp &lt;&lt; SECTOR_SHIFT;</span><br><span class="line"></span><br><span class="line">        zone-&gt;type = blkz-&gt;type;</span><br><span class="line">        zone-&gt;cond = blkz-&gt;cond;</span><br><span class="line">        zone-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (blkz-&gt;reset)</span><br><span class="line">                zone-&gt;flags |= ZBD_ZONE_RWP_RECOMMENDED;</span><br><span class="line">        <span class="keyword">if</span> (blkz-&gt;non_seq)</span><br><span class="line">                zone-&gt;flags |= ZBD_ZONE_NON_SEQ_RESOURCES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命令行工具blkzone，作为util-linux项目的一部分，使用BLKREPORTZONE命令来实现其报告功能。其代码类似于上述方法进行了修改，以确保无论使用的是哪个版本的内核，都能正确编译和执行。</p>
<h3 id="Resetting-a-Zone-Write-Pointer"><a href="#Resetting-a-Zone-Write-Pointer" class="headerlink" title="Resetting a Zone Write Pointer"></a>Resetting a Zone Write Pointer</h3><p>一个或多个连续写区域的写指针可以通过命令<code>BLKRESETZONE</code>重置，在重置一个写指针的时候，区域的状态同样会被更改为<code>BLK_ZONE_COND_EMPTY</code>。</p>
<p>当多个区域需要被重置时，使用结构体<code>blk_zone_range</code>追踪这些区域，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct blk_zone_range - BLKRESETZONE/BLKOPENZONE/</span></span><br><span class="line"><span class="comment"> *                         BLKCLOSEZONE/BLKFINISHZONE ioctl</span></span><br><span class="line"><span class="comment"> *                         requests</span></span><br><span class="line"><span class="comment"> * @sector: Starting sector of the first zone to operate on.</span></span><br><span class="line"><span class="comment"> * @nr_sectors: Total number of sectors of all zones to operate on.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_zone_range</span> &#123;</span></span><br><span class="line">	__u64		sector;</span><br><span class="line">	__u64		nr_sectors;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同样，该结构体也可以在，打开区域<code>BLKOPENZONE</code>，关闭区域<code>BLKCLOSEZONE</code>，完成区域<code>BLKFINISHZONE</code> <code>ioctl</code>中使用。</p>
<p>下面是一个简单的例子，该例子重置一个区域起始在274726912位置，该区域大小为256MiB(524288 sectors of 512B)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/blkzoned.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_zone_range</span> <span class="title">zrange</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">zrange.sector = <span class="number">274726912</span>;</span><br><span class="line">zrange.nr_sectors = <span class="number">524288</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*	调用BLKRESETZONE	*/</span></span><br><span class="line">ret = ioctl(fd, BLKRESETZONE, &amp;zrange);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>其中，<code>fd</code>为设备描述符，必须保证该设备是打开的。</p>
<p>命令行工具blkzone使用BLKRESETZONE命令来实现其重置功能。</p>
<h3 id="Opening-Closing-and-Finishing-Zones"><a href="#Opening-Closing-and-Finishing-Zones" class="headerlink" title="Opening. Closing and Finishing Zones"></a>Opening. Closing and Finishing Zones</h3><ul>
<li><code>BLKOPENZONE</code>命令的参数和<code>BLKRESETZONE</code>的命令一样。</li>
<li><code>BLKCLOSEZONE</code>命令关闭一个区域；<code>BLKFINISHZONE</code>会结束一个区域，这意味着将该区域的状态设置为满<code>BLK_ZONE_COND_FULL</code>。以上两个命令均需要指向<code>blk_zone_range</code>的指针，用来表明操作的区域范围。</li>
</ul>
<h3 id="Zone-Size-and-Number-of-Zones"><a href="#Zone-Size-and-Number-of-Zones" class="headerlink" title="Zone Size and Number of Zones"></a>Zone Size and Number of Zones</h3><ul>
<li><code>BLKGETZONESZ</code>：获取分区设备的分区大小<code>zoned device&#39;s zone size</code>。</li>
<li><code>BLKGETNRZONES</code>：获取设备的总分区数。</li>
</ul>
<p>以上两个命令均接受一个指向32位无符号整型的指针， 并返回对应的数量。下面给出例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/blkzoned.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> nr_zones, zone_size;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = ioctl(fd, ,BLKGETZONESZ, &amp;zone_size);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">ret = ioctl(fd, ,BLKGETNRZONES, &amp;nr_zones);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Device has %u zones of %u 512-Bytes sectors\n&quot;</span>,</span><br><span class="line">       nr_zones, zone_size);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们发现，在调用<code>BLKGETNRZONES</code>等函数时，需要通过<code>ioctl</code>。</p>
<p><code>BLKGETNRZONES</code>命令特别适用于分配足够大的分区描述符数组，以便对设备上所有分区进行分区报告</p>
<h1 id="Write-Ordering-Control-1"><a href="#Write-Ordering-Control-1" class="headerlink" title="Write Ordering Control"></a>Write Ordering Control</h1><p>以前，Linux内核块<code>I/O</code>堆栈<code>Linux kernel block I/O stack</code>（例如，块层和<code>SCSI</code>层），并不会保证块<code>I/O</code>请求的执行顺序。不能保证块<code>I/O</code>请求的执行顺序的原因是因为块I&#x2F;O请求内核中执行的异步性质和设备请求队列需要细粒度锁模型的必要性。（当多个上下文同时向块设备发出I&#x2F;O请求时，最大限度地减少锁定竞争开销）。</p>
<p>这种设计直接导致的结果是，<code>well-behaving ZBD-compliant application</code>在沿着<code>LBA</code>顺序进行的写命令无法保证齐顺序性。</p>
<p>为了解决这个问题，内核<code>ZBD</code>支持添加区域写锁<code>zone write locking</code>以保证写请求在每一个区域中的执行顺序。</p>
<h2 id="Zone-Write-Locking"><a href="#Zone-Write-Locking" class="headerlink" title="Zone Write Locking"></a>Zone Write Locking</h2><p>区域写入锁<code>Zone write locking</code>实现了对于每个区域的写锁定，以顺序执行每一个对相同区域的写请求。此功能不保证写入命令始终在区域写入指针的位置发出：这是写<code>I/O</code>发出者的责任。区域写入锁定只保证应用程序，文件系统，设备映射器目标发出的写命令的顺序将被块<code>I/O</code>堆栈所遵守。因此，优秀的区域块设备用户将避免为对齐的写入命令失败。</p>
<p>区域写入锁定不会影响读命令。因为读命令不是顺序的。</p>
<h2 id="Initial-Implementation"><a href="#Initial-Implementation" class="headerlink" title="Initial Implementation"></a>Initial Implementation</h2><p>区域写锁定的第一次实现在内核版本为4.10的<code>SCSI</code>硬盘驱动上（在块层之下），对块<code>I/O</code>调度器已传递给设备调度队列的请求进行操作。</p>
<p>这种早期实现依赖于SCSI层可能会延迟向设备发出任何请求的事实。</p>
<p>通过维护每个区域一个位的位图，SCSI磁盘驱动程序每当看到写入命令时都会将区域标记为锁定。此算法在此更详细地介绍：</p>
<ol>
<li>如果下一个派遣给设备的命令不是写命令，则该命令会被直接派遣。</li>
<li>如果下一个派遣给设备的命令是写命令，则写命令的目标区域的区域写入锁定位<code>zone write lock bit</code>会被检查。<ol>
<li>如果写命令的目标区域未被写锁定（即<code>zone write lock bit is not set</code>），则锁定区域并将写命令发送给设备。写锁定操作和命令发送操作都是在设备请求队列旋转锁下原子执行的。</li>
<li>如果区域已被锁定（即<code>zone write lock bit is set</code>），则<code>SCSI</code>磁盘驱动会延迟发送该命令直到区域写入锁被释放。</li>
<li>当写命令完成时，区域写入锁被释放，调度过程会恢复。意味着如果派遣队列中的头命令（第一个命令）如果指向同一个区域（上述区域写入锁定被释放的区域），该命令会被发出。</li>
</ol>
</li>
</ol>
<p>尽管这种实现为遗留的单对列块<code>I/O</code>路径提供了写顺序的保障，并且不依赖于任何特定的HBA，它仍有一些缺点。</p>
<blockquote>
<p>“HBA” 指的是 “Host Bus Adapter”。HBA 是一种硬件设备，通常以插卡的形式存在，用于连接计算机主机（如服务器或工作站）与外部存储设备，比如硬盘阵列、磁带库或SAN（存储区域网络）设备。HBA 卡负责处理输入&#x2F;输出 (I&#x2F;O) 请求和数据传输，从而将主机与存储设备之间的通信和数据交换工作负载从 CPU 上卸载出来。</p>
<p>在许多高性能计算和数据密集型环境中，HBA 卡是至关重要的组件，因为它们可以提高数据传输速率，减少主机 CPU 的负担，并提高整体系统的 I&#x2F;O 性能。在上下文中提到的“write-ordering guarantees for the legacy single-queue block I&#x2F;O path”与 HBA 的独立性表明，该实现不依赖于特定的 HBA 硬件，从而具有更广泛的兼容性。</p>
</blockquote>
<ul>
<li><p>潜在的性能退化：任何写入任何区域的命令都会导致命令调度处理停止。这阻止了所有其他命令被发送，包括读取命令。这可能会限制在高队列深度操作设备时可以通过设备级命令重新排序获得的性能优势。极端情况是应用程序向具有异步I&#x2F;O系统调用的区域发出写流（例如io_submit()）。在这种情况下，顺序写入命令将在设备调度队列中按顺序排队，导致驱动器在一次一个写入命令的队列深度运行。</p>
</li>
<li><p>不支持块多队列<code>I/O</code>路径：不像遗留的单对列块<code>I/O</code>接口，多队列块<code>I/O</code>的实现并不过多的依赖于设备队列自旋锁来处理磁盘用户（应用程序或者内核组件）发出的多队列块<code>I/O</code>请求。这导致在请求传递到设备调度队列之前发生潜在的块I&#x2F;O请求重新排序，并且区域写入锁定无效。</p>
<blockquote>
<ol>
<li><strong>I&#x2F;O 请求重排序</strong>：由于不是所有的 I&#x2F;O 请求都通过单一的、受自旋锁保护的队列来处理，因此不同队列中的请求可能会出现重排序现象。这意味着即使应用程序或内核组件按照特定的顺序发出 I&#x2F;O 请求，这些请求到达设备调度队列时的顺序可能已经改变。</li>
<li><strong>区域写锁定的无效性</strong>：在支持区域块设备（ZBD）的环境中，维持写操作的顺序是非常重要的，特别是对于顺序写入区域。由于多队列实现可能导致 I&#x2F;O 请求的重排序，区域写锁定机制（旨在保证写操作顺序）可能无法有效地工作。在多队列环境中，即使应用程序尝试按照正确的顺序发出写命令，由于请求在到达设备之前可能被重排序，因此无法保证这些写操作遵循 ZBD 的顺序写入约束。</li>
</ol>
</blockquote>
</li>
</ul>
<p>这些限制导致使用块层I&#x2F;O调度器在I&#x2F;O堆栈中更高级别开发区域写入锁定的新实现。</p>
<h2 id="Improved-Implementation-Block-I-x2F-O-Scheduler"><a href="#Improved-Implementation-Block-I-x2F-O-Scheduler" class="headerlink" title="Improved Implementation: Block I&#x2F;O Scheduler"></a>Improved Implementation: Block I&#x2F;O Scheduler</h2><p>于是我们将区域写入锁定的实现移动到<code>I/O</code>堆栈的更高层级，块多队列（以及 SCSI 多队列）基础设施也得到了支持。这一改进在内核版本 4.16 中被添加，同时移除了 SCSI 层的区域写锁定实现。</p>
<p>这一新的区域写入锁定的实现依赖于块层的<code>deadline</code>和<code>mq-deadline</code> <code>I/O</code>调度器，并解决了之前的实现的缺点。</p>
<p>这种新的算法细节如下：</p>
<ol>
<li>如果调度器正在处理读命令：<ul>
<li>读取命令列表中排队的第一个命令允许继续并提交给设备调度队列。</li>
<li>如果没有可用的读命令，则激活写命令。</li>
<li>如果读命令的处理时间达到限制，切换处理写命令，以避免写命令饥饿。</li>
<li>如果读命令可用，则继续步骤1</li>
</ul>
</li>
<li>在处理写命令时，按从LBA有序列表头部的命令或到达时间有序列表中的第一个命令开始扫描调度器中排队的写命令列表（当存在饥饿命令的风险时）。<ul>
<li>如果第一个写命令的目标区域没有被写锁定，该区域被锁定，然后把写命令发送到设备中。这两个操作都是在调度器维护的自旋锁下原子执行的。</li>
<li>如果目标区域已被锁定（位设置），则跳过该命令，并在LBA有序的写入命令列表中搜索针对不同区域的第一个写入命令。如果找到这样的命令，则再次执行步骤2。</li>
<li>如果所有排队的写入命令都针对锁定区域，则调度器操作模式（批处理模式）将切换到<em>读取</em>并调用步骤1。</li>
</ul>
</li>
<li>当写命令完成后，命令目标区域的区域写锁将被释放，调度程序将被激活。根据当前的批处理模式，在第1或2步恢复操作。</li>
</ol>
<p>从这个算法中，很明显，该设备现在可以在更高的队列深度下操作，只有顺序写入目标同一区域才会受到限制。所有读取命令都可以继续，并编写针对不同区域不会相互影响的命令。</p>
<blockquote>
<p>该实现并不保障所有的命令都是有序的。它只保障对于同一区域的写命令是顺序执行的。调度器可能会更改针对不同区域的写入命令的调度顺序。对于任何单个顺序区域，在任何时候，总是最多执行一个写入命令。当有读取访问和同时写入多个区域时，可以在高队列深度进行整体磁盘操作。</p>
</blockquote>
<h2 id="Block-I-x2F-O-Scheduler-Configuration"><a href="#Block-I-x2F-O-Scheduler-Configuration" class="headerlink" title="Block I&#x2F;O Scheduler Configuration"></a>Block I&#x2F;O Scheduler Configuration</h2><h3 id="null-blk-Logical-Device"><a href="#null-blk-Logical-Device" class="headerlink" title="null_blk Logical Device"></a><code>null_blk</code> Logical Device</h3><p><code>CONFIG_BLK_DEV_ZONED</code>配置选项会自动支持使用<code>null_blk</code>设备驱动程序的区域块设备仿真。</p>
<h3 id="ZBC-and-ZAC-Hard-Disks-Support"><a href="#ZBC-and-ZAC-Hard-Disks-Support" class="headerlink" title="ZBC and ZAC Hard-Disks Support"></a>ZBC and ZAC Hard-Disks Support</h3><p>使用CONFIG_BLK_DEV_ZONED配置选项自动启用对ZBC和ZAC SMR磁盘的SCSI子系统支持。</p>
<h3 id="NVMe-Zoned-Namespace-Solid-State-Disks-Support"><a href="#NVMe-Zoned-Namespace-Solid-State-Disks-Support" class="headerlink" title="NVMe Zoned Namespace Solid State Disks Support"></a>NVMe Zoned Namespace Solid State Disks Support</h3><p>NVM Express分区命名空间命令集依赖于CONFIG_BLK_DEV_ZONED和CONFIG_NVME_CORE。如果启用这两个配置选项，它会自动构建。</p>
<p>此驱动程序要求设备支持Zone Append命令才能成功绑定到分区命名空间。它不支持区域游览。有关这些功能的更多详细信息，请参阅Zoned Namespace（ZNS）SSD。</p>
<h2 id="Device-Mapper-1"><a href="#Device-Mapper-1" class="headerlink" title="Device Mapper"></a>Device Mapper</h2><p>当<code>CONFIG_BLK_DEV_ZONED </code>选项被设置，设备映射器子系统也会自动的启用。这支持dm线性和dmflakey目标。请注意，必须启用dm分区的设备映射器目标才能使用。</p>
<p>通过从菜单设备驱动程序中选择CONFIG_DM_ZONED选项来启用dm分区目标–&gt;多个设备驱动程序支持（RAID和LVM）–&gt;设备映射器支持–&gt;驱动器管理的分区块设备目标支持。</p>
<h2 id="File-Systems-1"><a href="#File-Systems-1" class="headerlink" title="File Systems"></a>File Systems</h2><h3 id="f2fs"><a href="#f2fs" class="headerlink" title="f2fs"></a>f2fs</h3><p>使用CONFIG_BLK_DEV_ZONED配置选项自动启用对f2fs文件系统中分区块设备的支持。</p>
<h3 id="zonefs-1"><a href="#zonefs-1" class="headerlink" title="zonefs"></a>zonefs</h3><p>通过从菜单文件系统-&gt;zonefs文件系统支持中选择CONFIG_ZONEFS_FS选项来启用zonefs文件系统的编译。仅当CONFIG_BLK_DEV_ZONED选项设置为启用分区块设备支持时，此选项才可用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/10/kernelInside/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/10/kernelInside/" class="post-title-link" itemprop="url">kernelInside</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-10 18:35:09" itemprop="dateCreated datePublished" datetime="2023-11-10T18:35:09+08:00">2023-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-15 20:34:32" itemprop="dateModified" datetime="2023-11-15T20:34:32+08:00">2023-11-15</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>35k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>32 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Kernel-Inside"><a href="#Kernel-Inside" class="headerlink" title="Kernel Inside!"></a>Kernel Inside!</h1><p>说是要做<code>zns ssd</code>存储开发，但是好像离不开<code>linux</code>内核，既然如此，那就开始<del>愉快的</del>Linux内核之旅吧！</p>
<p>用到的参考资料包括（其实就是kernel inside 的学习笔记）：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://0xax.gitbooks.io/linux-insides/content/">Kernel Inside</a> </li>
<li>深入理解Linux内核</li>
</ul>
<h1 id="Booting"><a href="#Booting" class="headerlink" title="Booting"></a>Booting</h1><p>启动！</p>
<h1 id="Kernel-booting-process-Part-1"><a href="#Kernel-booting-process-Part-1" class="headerlink" title="Kernel booting process. Part 1."></a>Kernel booting process. Part 1.</h1><h2 id="From-the-boot-loader-to-the-kernel"><a href="#From-the-boot-loader-to-the-kernel" class="headerlink" title="From the boot loader to the kernel"></a>From the boot loader to the kernel</h2><h3 id="The-Magical-Power-Button-What-happens-next"><a href="#The-Magical-Power-Button-What-happens-next" class="headerlink" title="The Magical Power Button, What happens next?"></a>The Magical Power Button, What happens next?</h3><p>​	当按下开机键后，计算机首先会唤醒<code>cpu</code>，<code>80386</code>及之后的<code>cpu</code>会在其寄存器中定义如下数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP						0xfff0</span><br><span class="line">CS selector		0xf000</span><br><span class="line">CS base				0xffff0000</span><br></pre></td></tr></table></figure>

<p>​	处理器会在实模式<code>(real mode)</code>下运行</p>
<blockquote>
<ul>
<li><code>real mode</code>：所有的<code>x86</code>机器支持实模式，<code>8086</code>处理器的总线地址有20位，能处理<code>0 - 0xfffff</code>地址空间，但是该处理器的寄存器只有<code>16 bit</code>，只能处理<code>0-0xffff</code>位。</li>
<li><code>Memory segmentation</code>：使得所有地址空间都可以被访问，内存被分为小的，固定的<code>65536 bytes (64KB) segments</code>。但由于我们无法通过<code>16-bit</code>寻址<code>64KB</code>地址，下面会给出一个解决方法。</li>
<li><code>IP</code>： instruction pointer</li>
<li><code>CS selector</code>：Code Segment Selector</li>
<li><code>CS Base</code>：Code Segment Base Address</li>
</ul>
</blockquote>
<p>因此，一个<code>address</code>包括：<code>a segment selector</code>，<code>offset</code>；物理地址的计算公式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhysicalAddress = Segment Selector * 16 + Offset</span><br></pre></td></tr></table></figure>

<p>但如果<code>segment selector</code>和<code>offset</code>太大了，就会发生溢出，如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hex((0xffff &lt;&lt; 4) + 0xffff) = 0x10ffef</span><br></pre></td></tr></table></figure>

<p>由于实模式下只有20位地址位，所以<code>0x10ffef</code>会变成<code>0x00ffef</code>，这叫作<code>A20 line disabled</code>。</p>
<p>回到开机后的寄存器值：</p>
<p><code>CS register</code>包含：</p>
<ul>
<li><code>the visible segment selector</code></li>
<li><code>the hidden base address</code></li>
</ul>
<p>结合之前定义的<code>CS</code>基址和<code>IP</code>值，<code>CS:IP</code>是<code>0xf000:0xfff0</code>，经过物理地址公式的计算得到<code>0xfff0</code>.</p>
<p>该物理地址加上基址我们最终得到·存储在 <code>EIP register</code>中的值：<code>0xfffffff0</code>。</p>
<blockquote>
<ul>
<li><code>Extended Instruction Pointer</code>：该寄存器的作用是存储CPU当前正在执行的指令的地址。当CPU执行程序时，EIP寄存器会连续更新，以指向下一条要执行的指令。这对于程序的流程控制至关重要。</li>
</ul>
</blockquote>
<p>得到的值<code>0xfffffff0</code>被叫做复位向量<code>reset vector</code>，该内存地址是CPU在重置后希望找到第一个指令的地方。该内存地址包含一个<code>jump</code>指令，该指令通常指向<code>BIOS(Basic Input/ Output System)</code>入口。看看源代码，我们这里看的是 <a target="_blank" rel="noopener" href="https://www.coreboot.org`src/cpu/x86/16bit/reset16.inc%60%EF%BC%9A">https://www.coreboot.org`src/cpu/x86/16bit/reset16.inc`：</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> .section &quot;.reset&quot;, &quot;ax&quot;, %progbits</span><br><span class="line">    .code16</span><br><span class="line">.globl    _start</span><br><span class="line">_start:</span><br><span class="line">    .byte  0xe9</span><br><span class="line">    .int   _start16bit - ( . + 2 )</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p><code>0xe9</code>是<code>jump</code>指令的<code>opcode</code>，目的地址是<code>_start16bit - ( . + 2 )</code>。</p>
<p>同样，我们能找到之前说的其实地址是如何计算的<code>0xfffffff0 (src/cpu/x86/16bit/reset16.ld):</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    /* Trigger an error if I have an unuseable start address */</span><br><span class="line">    _bogus = ASSERT(_start16bit &gt;= 0xffff0000, &quot;_start16bit too low. Please report.&quot;);</span><br><span class="line">    _ROMTOP = 0xfffffff0;</span><br><span class="line">    . = _ROMTOP;</span><br><span class="line">    .reset . : &#123;</span><br><span class="line">        *(.reset);</span><br><span class="line">        . = 15;</span><br><span class="line">        BYTE(0x00);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<code>BIOS</code>启动，在检查完硬件后，<code>BIOS</code>需要找到一个可启动的设备，启动顺序是设定在<code>BIOS</code>中的，当尝试从硬盘中启动时，<code>BIOS</code>需要找到一个启动扇区<code>boot sector</code>。在硬盘上有一个分区叫作主引导记录<code>Main Boot Record</code>，<code>boot sector</code>在该分区的前<code>446</code>个字节，每个扇区有<code>512 bytes</code>，第一个扇区的最后两个字节为<code>0x55, 0xaa</code>，向<code>BIOS</code>说明该设备是可启动的。</p>
<p>​	下表给出实模式下的内存映射：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0x00000000 - 0x000003FF - Real Mode Interrupt Vector Table</span><br><span class="line">0x00000400 - 0x000004FF - BIOS Data Area</span><br><span class="line">0x00000500 - 0x00007BFF - Unused</span><br><span class="line">0x00007C00 - 0x00007DFF - Our Bootloader</span><br><span class="line">0x00007E00 - 0x0009FFFF - Unused</span><br><span class="line">0x000A0000 - 0x000BFFFF - Video RAM (VRAM) Memory</span><br><span class="line">0x000B0000 - 0x000B7777 - Monochrome Video Memory</span><br><span class="line">0x000B8000 - 0x000BFFFF - Color Video Memory</span><br><span class="line">0x000C0000 - 0x000C7FFF - Video ROM BIOS</span><br><span class="line">0x000C8000 - 0x000EFFFF - BIOS Shadow Area</span><br><span class="line">0x000F0000 - 0x000FFFFF - System BIOS</span><br></pre></td></tr></table></figure>

<p>​	之前我们说<code>CPU</code>尝试执行的第一个指令是存储在地址<code>0xffff fff0</code>中的，这比上表的地址大的多。<code>CPU</code>如何访问改地址？在<a target="_blank" rel="noopener" href="https://www.coreboot.org/Developer_Manual/Memory_map">coreboot</a>文档中给出了答案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xFFFE_0000 - 0xFFFF_FFFF: 128 kilobyte ROM mapped into address space</span><br></pre></td></tr></table></figure>

<p>​	现在我们知道，<code>BIOS</code>程序是存储在<code>ROM</code>中的。</p>
<h3 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h3><blockquote>
<p>​	现在 BIOS 已经选择了一个启动设备，并且将控制权转移给了启动扇区中的代码，在我们的例子中，启动扇区代码是 <a target="_blank" rel="noopener" href="http://git.savannah.gnu.org/gitweb/?p=grub.git;a=blob;f=grub-core/boot/i386/pc/boot.S;hb=HEAD">boot.img</a>。因为这段代码只能占用一个扇区，因此非常简单，只做一些必要的初始化，然后就跳转到 GRUB 2’s core image 去执行。 Core image 的代码请参考 <a target="_blank" rel="noopener" href="http://git.savannah.gnu.org/gitweb/?p=grub.git;a=blob;f=grub-core/boot/i386/pc/diskboot.S;hb=HEAD">diskboot.img</a>，一般来说 core image 在磁盘上存储在启动扇区之后到第一个可用分区之前。core image 的初始化代码会把整个 core image （包括 GRUB 2的内核代码和文件系统驱动） 引导到内存中。 引导完成之后，<a target="_blank" rel="noopener" href="http://git.savannah.gnu.org/gitweb/?p=grub.git;a=blob;f=grub-core/kern/main.c">grub_main</a>将被调用。</p>
<p>​	<code>grub_main</code> 初始化控制台，计算模块基地址，设置 root 设备，读取 grub 配置文件，加载模块。最后，将 GRUB 置于 normal 模式，在这个模式中，<code>grub_normal_execute</code>(from <code>grub-core/normal/main.c</code>) 将被调用以完成最后的准备工作，然后显示一个菜单列出所用可用的操作系统。当某个操作系统被选择之后，<code>grub_menu_execute_entry</code> 开始执行，它将调用 GRUB 的 <code>boot</code> 命令，来引导被选中的操作系统。</p>
<p>​	就像 kernel boot protocol 所描述的，引导程序必须填充 kernel setup header （位于 kernel setup code 偏移 <code>0x01f1</code> 处） 的必要字段。kernel setup header的定义开始于<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S">arch&#x2F;x86&#x2F;boot&#x2F;header.S</a>：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	.globl	hdr</span><br><span class="line">hdr:</span><br><span class="line">setup_sects:	.byte 0			/* Filled in by build.c */</span><br><span class="line">root_flags:	.word ROOT_RDONLY</span><br><span class="line">syssize:	.long 0			/* Filled in by build.c */</span><br><span class="line">ram_size:	.word 0			/* Obsolete */</span><br><span class="line">vid_mode:	.word SVGA_MODE</span><br><span class="line">root_dev:	.word 0			/* Filled in by build.c */</span><br><span class="line">boot_flag:	.word 0xAA55</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>.globl hdr</code>: <code>hdr</code>是一个全局符号，全局符号对程序的所有部分都是可见的，同时它也是一个标签，标记当前位置。</li>
<li>在后续的数据中遵循：<code>varible: .type value</code>，即<code>变量：类型 值</code>的形式。<ul>
<li><code>boot_flag:	.word 0xAA55</code>：<code>0xAA55</code>是可启动标志。</li>
</ul>
</li>
</ul>
</blockquote>
<p>​	我们将在<code>kernel boot protocol</code>中看到，内存在加载内核后是如何映射的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">         | Protected-mode kernel  |</span><br><span class="line">100000   +------------------------+</span><br><span class="line">         | I/O memory hole        |</span><br><span class="line">0A0000   +------------------------+</span><br><span class="line">         | Reserved for BIOS      | Leave as much as possible unused</span><br><span class="line">         ~                        ~</span><br><span class="line">         | Command line           | (Can also be below the X+10000 mark)</span><br><span class="line">X+10000  +------------------------+</span><br><span class="line">         | Stack/heap             | For use by the kernel real-mode code.</span><br><span class="line">X+08000  +------------------------+</span><br><span class="line">         | Kernel setup           | The kernel real-mode code.</span><br><span class="line">         | Kernel boot sector     | The kernel legacy boot sector.</span><br><span class="line">       X +------------------------+</span><br><span class="line">         | Boot loader            | &lt;- Boot sector entry point 0x7C00</span><br><span class="line">001000   +------------------------+</span><br><span class="line">         | Reserved for MBR/BIOS  |</span><br><span class="line">000800   +------------------------+</span><br><span class="line">         | Typically used by MBR  |</span><br><span class="line">000600   +------------------------+</span><br><span class="line">         | BIOS use only          |</span><br><span class="line">000000   +------------------------+</span><br></pre></td></tr></table></figure>

<p>当启动程序把控制权交给内核后，内核将从:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X + sizeof(KernelBootSector) + 1</span><br></pre></td></tr></table></figure>

<p><code>X</code>是内核启动扇区被加载的地址。启动程序现在加载<code>Linux</code>内核到内存中去，填充好头文件，然后跳转到相应的内存地址中去，我们去看内核建立程序。</p>
<h3 id="The-Beginning-of-the-Kernel-Setup-Stage"><a href="#The-Beginning-of-the-Kernel-Setup-Stage" class="headerlink" title="The Beginning of the Kernel Setup Stage"></a>The Beginning of the Kernel Setup Stage</h3><p>​	首先内核需要建立，这包括一些配置，如解压器和一些内存管理相关的东西，仅举几例。完成所有这些事情之后，内核设置部分将解压实际的内核并跳转到它。在代码<code>arch/x86/boot/header.S</code>的 <code>__start</code>标签是<code>setup part</code>。</p>
<pre><code> 为了能够作为`bootloader`来使用，`header.S`在开始处定义了 `MZ`，并且定义了`PE`头文件。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_EFI_STUB</span><br><span class="line">	# &quot;MZ&quot;, MS-DOS header</span><br><span class="line">	.word	MZ_MAGIC</span><br><span class="line">#endif</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">#ifdef CONFIG_EFI_STUB</span><br><span class="line">pe_header:</span><br><span class="line">	.long	PE_MAGIC</span><br></pre></td></tr></table></figure>

<p> 之所以代码需要这样写，这个是因为遵从 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">UEFI</a> 的硬件需要这样的结构才能正常引导操作系统。</p>
<p>除开这些作为<code>bootloader</code>的代码，真正的内核建立从下面开始：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// header.S line 299</span><br><span class="line">_start:</span><br><span class="line">		# Explicitly enter this as bytes, or the assembler</span><br><span class="line">		# tries to generate a 3-byte jump here, which causes</span><br><span class="line">		# everything else to push off to the wrong offset.</span><br><span class="line">		.byte	0xeb		# short (2-byte) jump</span><br><span class="line">		.byte	start_of_setup-1f</span><br></pre></td></tr></table></figure>

<p>bootloader 知道这个开始点，并且直接跳转到该点， 因此， bootloader将不会再从<code>.bstext section</code>开始。因为我们会在<code>arch/x86/boot/setup.ld</code>中看见：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// arch/x86/boot/setup.ld</span><br><span class="line">//</span><br><span class="line">. = 0;                    // current position</span><br><span class="line">.bstext : &#123; *(.bstext) &#125;  // put .bstext section to position 0</span><br><span class="line">.bsdata : &#123; *(.bsdata) &#125;</span><br></pre></td></tr></table></figure>

<p>​	这段代码是一个连接器脚本的一部分，用于指定程序编译后在内存中的布局。</p>
<blockquote>
<ul>
<li>设置当前位置：<code>. = 0;</code>设置连接器的当前位置指针为0。意味着紧接着的定义段将从内存地址0开始放置。</li>
<li>定义了<code>.bstext</code>段：<code>.bstext : &#123; *(.bstext) &#125;</code>，这行代码定义了一个名为 <code>.bstext</code> 的段。<code>&#123; *(.bstext) &#125;</code> 的意思是将所有标记为 <code>.bstext</code> 的部分（即汇编代码中用 <code>.section &quot;.bstext&quot;</code> 定义的部分）集中到这个段里。由于当前位置已经设置为0，所以这个段的内容将被放置在内存的开始位置。</li>
<li>定义了<code>.bsdata</code>段：<code>.bsdata : &#123; *(.bsdata) &#125;</code>：这行代码定义了一个名为 <code>.bsdata</code> 的段，并将所有标记为 <code>.bsdata</code> 的部分集中到这个段里。这允许链接器将这些数据放置在内存中的特定位置。</li>
</ul>
</blockquote>
<p>接着我们来看看内核设置的进入点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	# offset 512, entry point</span><br><span class="line"></span><br><span class="line">	.globl	_start</span><br><span class="line">_start:</span><br><span class="line">		# Explicitly enter this as bytes, or the assembler</span><br><span class="line">		# tries to generate a 3-byte jump here, which causes</span><br><span class="line">		# everything else to push off to the wrong offset.</span><br><span class="line">		.byte	0xeb		# short (2-byte) jump</span><br><span class="line">		.byte	start_of_setup-1f</span><br><span class="line">1:</span><br><span class="line"></span><br><span class="line">	# Part 2 of the header, from the old setup.S</span><br><span class="line"></span><br><span class="line">		.ascii	&quot;HdrS&quot;		# header signature</span><br><span class="line">		.word	0x020f		# header version number (&gt;= 0x0105)</span><br></pre></td></tr></table></figure>

<p>上述代码中， <code>0xeb</code>是<code>jmp</code>指令的<code>opcode</code>，表示将要跳转到<code>start_of_setup - 1f</code>。</p>
<p><code>Nf</code>声明：<code>2f</code>表示<code>local label 2</code>。在上述代码中，<code>1f</code>就是后面的<code>1:</code>，这部分代码包含了剩余的<code>setup header</code>，当<code>setup header</code>结束后，我们会看见<code>.entrytext</code>代码段，在<code>start_of_setup</code>标签处开始。	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># End of setup header #####################################################</span><br><span class="line">	.section &quot;.entrytext&quot;, &quot;ax&quot;</span><br><span class="line">start_of_setup:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这是第一段实际运行的代码。当内核配置<code>kernel setup</code>部分收到来自启动程序<code>bootloader</code>，第一个<code>jump</code>指令跳转到离内核起始点<code>(kernel real mode)``0x200 offset</code>。</p>
<p>终于，代码跳转到了<code>start_of_setup</code>，接着内核会做如下几件事：</p>
<ul>
<li><p>保证所有的段寄存器<code>segment register</code>值是相等的。</p>
</li>
<li><p>如果需要的话，建配置一个正确的栈。</p>
</li>
<li><p>配置bss</p>
<blockquote>
<p>BSS（Block Started by Symbol）是一个用来描述可执行文件或内存中的一部分的术语，它代表了一个程序中未初始化的全局变量和静态变量的集合。在程序的二进制文件中，BSS段通常不占用实际的磁盘空间，因为它只是一系列的零值。然而，在程序加载到内存时，操作系统为BSS段分配内存，并将其全部初始化为零。</p>
<p>BSS段的主要特点和作用包括：</p>
<ol>
<li><strong>未初始化的变量</strong>：BSS段用于存储程序中未显式初始化为特定值的全局变量和静态变量。这些变量在程序启动时默认被初始化为零。</li>
<li><strong>节省空间</strong>：由于BSS段中的数据默认为零，因此在程序的磁盘文件中不需要为它们分配空间。这有助于减少程序的文件大小。</li>
<li><strong>内存中的初始化</strong>：虽然在磁盘上不占用空间，但在程序加载到内存时，操作系统会为BSS段中的变量分配内存，并将它们初始化为零。</li>
<li><strong>与数据段的区别</strong>：BSS段通常与数据段（用于存储已初始化的全局变量和静态变量）相区分。数据段中的变量在程序的二进制文件中会占用相应的存储空间，以保持它们的初始值。</li>
</ol>
</blockquote>
</li>
<li><p>调转到c代码<code>arch/x86/boot/main.c</code></p>
</li>
</ul>
<h3 id="Aligning-the-Segment-Registers"><a href="#Aligning-the-Segment-Registers" class="headerlink" title="Aligning the Segment Registers"></a>Aligning the Segment Registers</h3><p>首先，内核保证，<code>ds</code>和<code>es</code>段寄存器指向同一个地址。接着使用<code>cld</code>指令，清除方向标志<code>direction flag</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Force %es = %ds</span><br><span class="line">	movw	%ds, %ax</span><br><span class="line">	movw	%ax, %es</span><br><span class="line">	cld</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>Direction Flag：在x86架构的CPU中，direction flag是标志寄存器（Flags Register）的一部分，用于控制字符串操作指令（如 <code>movsb</code>, <code>movsw</code>, <code>movsd</code>, <code>stosb</code>, <code>stosw</code>, <code>stosd</code>, <code>lodsb</code>, <code>lodsw</code>, <code>lodsd</code>, <code>scasb</code>, <code>scasw</code>, <code>scasd</code> 等）的处理方向。</p>
<p><code>direction flag = 1</code>时，这些操作指令处理字符串时会从高地址向底地址移动。为0时则相反。</p>
</li>
<li><p><code>cld</code>指令：<code>clear Direction Flag</code>，会将<code>Direction Flag</code>置为0。</p>
</li>
<li><p><code>es</code>：附加段寄存器</p>
</li>
<li><p><code>ds</code>：数据段寄存器</p>
</li>
<li><p><code>cs</code>：代码段寄存器</p>
</li>
<li><p><code>ss</code>：段寄存器</p>
</li>
<li><p><code>sp</code>：堆栈指针寄存器</p>
</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">segment = grub_linux_real_target &gt;&gt; 4;</span><br><span class="line">state.gs = state.fs = state.es = state.ds = state.ss = segment;</span><br><span class="line">state.cs = segment + 0x20; // cs = 0x1000 + 0x20 = 0x1020</span><br></pre></td></tr></table></figure>

<p><code>grub2</code>默认将<code>kernel setup</code>代码，加载到地址<code>0x10000</code>处，而<code>cs</code>是在<code>0x1020</code>处，这是因为代码的执行不会在文件的起始位置开始，而是跳转到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br><span class="line">    .byte 0xeb</span><br><span class="line">    .byte start_of_setup-1f</span><br></pre></td></tr></table></figure>

<p>这段代码是位于 <code>4d 5a</code>的<code>512 bytes</code>偏移处。之后开始配置栈。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> We will have entered with %cs = %ds+0x20, normalize %cs so</span><br><span class="line"># it is on par with the other segments.</span><br><span class="line">	pushw	%ds</span><br><span class="line">	pushw	$6f</span><br><span class="line">	lretw</span><br></pre></td></tr></table></figure>

<p>这段代码将 <code>ds</code>的值推入栈，紧跟着的是标签<code>6</code>的地址也推入栈，然后执行<code>lretw</code>。当执行<code>lretw</code>时，它将标签<code>6</code>的地址加载到<code>instruction pointer register</code>中，将<code>ds</code>的值加载到<code>cs</code>中。最终，<code>cs</code>和<code>ds</code>的值会保持一致。</p>
<blockquote>
<p><code>lretw</code>：这是一个远返回指令，用于从子程序返回。<code>lretw</code> 会从堆栈中弹出返回地址，并将其加载到指令指针寄存器（%ip）中。同时，它还会从堆栈中弹出一个值加载到代码段寄存器（%cs）中，这是远调用和远返回的特性。</p>
</blockquote>
<h3 id="Stack-Setup"><a href="#Stack-Setup" class="headerlink" title="Stack Setup"></a>Stack Setup</h3><p>​	几乎所有的配置代码是为了准备实模式下的<code>c</code>语言环境。下一个步骤是判断并纠正<code>ss</code>寄存器的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Force %es = %ds</span><br><span class="line">	movw	%ds, %ax</span><br><span class="line">	movw	%ax, %es</span><br><span class="line">	cld</span><br><span class="line"></span><br><span class="line"># Apparently some ancient versions of LILO invoked the kernel with %ss != %ds,</span><br><span class="line"># which happened to work by accident for the old code.  Recalculate the stack</span><br><span class="line"># pointer if %ss is invalid.  Otherwise leave it alone, LOADLIN sets up the</span><br><span class="line"># stack behind its own code, so we can&#x27;t blindly put it directly past the heap.</span><br><span class="line"></span><br><span class="line">	movw	%ss, %dx</span><br><span class="line">	cmpw	%ax, %dx	# %ds == %ss?</span><br><span class="line">	movw	%sp, %dx 	# move %sp to %dx</span><br></pre></td></tr></table></figure>

<p>我们首先要保证<code>%ss == %ds</code>，会出现三种情况：</p>
<p><code>ss</code>值合法</p>
<p><code>ss</code>值不合法且<code>CAN_USE_HEAP</code>被设置。</p>
<p><code>ss</code>值不合法且<code>CAN_USE_HEAP</code>未被设置。</p>
<ul>
<li>当<code>ss</code>值<code>(0x1000)</code>合法时，程序跳转到标签2：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2:	# Now %dx should point to the end of our stack space</span><br><span class="line">	andw	$~3, %dx	# dword align (might as well...)</span><br><span class="line">	jnz	3f					# jump if not zero</span><br><span class="line">	movw	$0xfffc, %dx	# Make sure we&#x27;re not zero</span><br><span class="line">3:	movw	%ax, %ss</span><br><span class="line">	movzwl	%dx, %esp	# Clear upper half of %esp</span><br><span class="line">	sti			# Now we should have a working stack</span><br></pre></td></tr></table></figure>

<p>​	首先将3取反得到<code>1111 1111 1111 1111 1111 1111 1111 1100</code> 之后和<code>%dx</code>做与运算，这将使 <code>%dx</code>的最后两位为0，以达到<code>dword align</code>双字对齐。即如果一个地址是4的倍数，我们就可以说它是双字对齐的。接着判断<code>andw</code>操作后的结果是否为0。如果为0，我们要将<code>%dx</code>的值设置为<code>0xfffc</code>（这是在 <code>64KB segment</code> 下的最大按四字对齐的地址）以保证<code>%dx</code>不为0。反之直接跳转到标签3。</p>
<p>​	标签3将<code>%ax</code>的值赋值给<code>%ss</code>。得到一个正确的栈：</p>
<p>​	<img src="/../images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-11%2010.58.21.png" alt="截屏2023-11-11 10.58.21"></p>
<ul>
<li>当<code>ss</code>值不合法且<code>CAN_USE_HEAP</code>被设置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Invalid %ss, make up a new stack</span><br><span class="line">	movw	$_end, %dx</span><br><span class="line">	testb	$CAN_USE_HEAP, loadflags</span><br><span class="line">	jz	1f</span><br><span class="line">	movw	heap_end_ptr, %dx</span><br><span class="line">1:	addw	$STACK_SIZE, %dx</span><br><span class="line">jnc	2f</span><br><span class="line">xorw	%dx, %dx	# Prevent wraparound</span><br></pre></td></tr></table></figure>

<p>我们首先将<code>$_end</code>赋值给 <code>%dx</code>，然后检查 <code>loadflag</code>中的 <code> $CAN_USE_HEAP</code>位。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S#L320">loadflags</a> is a bitmask header defined as:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOADED_HIGH     (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUIET_FLAG      (1&lt;&lt;5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEEP_SEGMENTS   (1&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_USE_HEAP    (1&lt;&lt;7)</span></span><br></pre></td></tr></table></figure>

<p>我们在<code>boot protocol</code>中了解到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Field name: loadflags</span><br><span class="line"></span><br><span class="line">  This field is a bitmask.</span><br><span class="line"></span><br><span class="line">  Bit 7 (write): CAN_USE_HEAP</span><br><span class="line">    Set this bit to 1 to indicate that the value entered in the</span><br><span class="line">    heap_end_ptr is valid.  If this field is clear, some setup code</span><br><span class="line">    functionality will be disabled.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>因此，如果<code>CAN_USE_HEAP</code>为1时 ，代表<code>heap_end_ptr</code>是合法的（指向栈底：<code>_end</code>）。然后将<code>%dx</code>加上一个<code>$STACK_SIZE</code>（这可能使得<code>%dx</code>指向栈顶）。如果没有溢出，则跳转到标签2，继续配置一个正确的栈。</p>
<p><img src="/../images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-11%2011.14.17.png" alt="截屏2023-11-11 11.14.17"></p>
<ul>
<li>当<code>ss</code>值不合法且<code>CAN_USE_HEAP</code>未被设置。那就只能用一个最小的栈，大小为from <code>_end</code> to <code>_end + STACK_SIZE</code></li>
</ul>
<p><img src="/../images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-11%2011.16.57.png" alt="截屏2023-11-11 11.16.57"></p>
<h3 id="BSS-Setup"><a href="#BSS-Setup" class="headerlink" title="BSS Setup"></a>BSS Setup</h3><p>在我们能跳向<code>main C code</code>之前，还有两个步骤需要配置，一个是配置<code>BSS</code>，第二个是检查<code>magic</code>签名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Check signature at end of setup</span><br><span class="line">	cmpl	$0x5a5aaa55, setup_sig</span><br><span class="line">	jne	setup_bad</span><br></pre></td></tr></table></figure>

<p>检查签名，如果不对，会报告一个<code>fatal error</code>。</p>
<p>签名匹配后，我们拥有了正确的段寄存器和栈，现在只需要配置正确的<code>BSS</code>段就可以跳转到<code>C</code>代码了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Zero the bss</span><br><span class="line">	movw	$__bss_start, %di</span><br><span class="line">	movw	$_end+3, %cx</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	subw	%di, %cx</span><br><span class="line">	shrw	$2, %cx</span><br><span class="line">	rep; stosl</span><br></pre></td></tr></table></figure>

<p><code>__bss_start</code>的地址赋值给<code>%di</code>，接着<code>__end + 3</code>的结果赋值给<code>%cx</code>。通过异或操作清空<code>%eax</code>的值。计算<code>cx -di</code>得到<code>bss section</code>的大小并存储到<code>cx</code>中。 <code>cx</code>除以4（右移2位）并重复执行<code>stosl</code>，该命令将持续把<code>eax</code>中的值（这里是0）存到<code>di</code>指向的地址中去，并将<code>di</code>的值增加4（这也是为什么<code>cx</code>要除以4的原因）。直到<code>cx</code>的值递减到0。以上的操作将<code>BSS section</code>的所有内存赋值为0：</p>
<p><img src="/../images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-11%2011.32.50.png" alt="截屏2023-11-11 11.32.50"></p>
<h3 id="Jump-to-main"><a href="#Jump-to-main" class="headerlink" title="Jump to main"></a>Jump to main</h3><p>现在我们跳转到主函数，<code>arch/x86/boot/main.c</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Jump to C code (should not return)</span><br><span class="line">	calll	main</span><br></pre></td></tr></table></figure>

<h1 id="Kernel-booting-process-Part-2"><a href="#Kernel-booting-process-Part-2" class="headerlink" title="Kernel booting process. Part 2."></a>Kernel booting process. Part 2.</h1><h2 id="First-steps-in-the-kernel-setup"><a href="#First-steps-in-the-kernel-setup" class="headerlink" title="First steps in the kernel setup"></a>First steps in the kernel setup</h2><p>现在我们将继续阅读<code>arch/x86/boot/main.c</code>，将学习如下内容：</p>
<ul>
<li>保护模式<code>protected mode</code>是什么。</li>
<li>计算机是怎样进入保护模式。</li>
<li>堆<code>heap</code>和控制台<code>console</code>的初始化。</li>
<li>内存检测，CPU确认，键盘初始化。</li>
<li><code>and much much more</code>。</li>
</ul>
<p>So, let‘s go ahead!</p>
<h2 id="Protected-mode"><a href="#Protected-mode" class="headerlink" title="Protected mode"></a>Protected mode</h2><p>在我们在进入<code>intel Long Mode</code>之前，内核需要将<code>CPU</code>转换到保护模式。</p>
<blockquote>
<ul>
<li><p>在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/X86-64">x86-64</a>处理器架构中，当处于<strong>长模式</strong>（Long mode）时，64位应用程序（或者是操作系统）可以使用64位指令和寄存器，而32位程序将以一种兼容子模式运行。<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC86%E6%A8%A1%E5%BC%8F">虚拟86模式</a>在长模式下不可用，也就是说，长模式不兼容16位程序。</p>
</li>
<li><p>不在长模式下运行时，处理器支持<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AE%9E%E6%A8%A1%E5%BC%8F">实模式</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BF%9D%E8%AD%B7%E6%A8%A1%E5%BC%8F">保护模式</a>两个子模式，在这两个模式下的x86-64处理器与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/X86-32">x86-32</a>处理器运行方式完全相同。</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CPUID">CPUID</a>扩展属性域中的一个位可以令运行在实模式或者保护模式的程序得知处理器能否转换到长模式，这使得程序能够检测是否使用了x86-64处理器。这类似于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Intel">Intel</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IA-64">IA-64</a>处理器使用CPUID中的一个属性位来让程序检测自己是否运行在IA-32仿真模式下。</p>
</li>
<li><p>保护模式在1982年第一次加入到<code>x86</code>架构，并在<code>intel 64</code>和长模式出现之前，一直是<code>intel</code>处理器的主模式。</p>
</li>
</ul>
</blockquote>
<p>从实模式<code>Real Mode</code>跳转出来的原因主要是实模式只提供非常有限的<code>RAM</code>访问。在前一章我们提到实模式只支持<code>1MB</code>，有时甚至只支持<code>640KB</code>的<code>RAM</code>。</p>
<p>保护模式带来了很多改变，其中最重要的是内存管理。实模式中20位地址总线被32位地址总线所替代。因此，它允许访问<code>4GB</code>的内存。同样，分页技术在保护模式中也可用。</p>
<p>实模式中的内存管理被分为两个部分：</p>
<ul>
<li>分段<code>Segmentation</code></li>
<li>分页<code>Paging</code></li>
</ul>
<p>在本节先讨论分段<code>segmentation</code>。在下一章我们会讨论分页<code>Paging</code>。</p>
<p>在之前我们介绍了实模式下的地址包含如下两部分：</p>
<ul>
<li>段基址<code>Base address of the segment</code></li>
<li>从段基址的偏移量<code>Offset from the segment base</code></li>
</ul>
<p>我们可以通过上述两部分获得物理地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhysicalAddress = Segment_Base * <span class="number">16</span> + Offset</span><br></pre></td></tr></table></figure>

<p>在保护模式，内存分段的方式则完全不同。不同于实模式下的固定<code>64KB</code>分段，保护模式中的段大小和位置被一个特殊的数据结构<code>Segment Descriptor</code>描述。这些段描述符<code>Segment Descriptor</code>存储在<code>Global Descriptor Table (GDT)</code>中。</p>
<p><code>GDT</code>常驻于内存中，但它在内存中没有固定的位置，因此它的地址存储在一个叫<code>GDTR</code>的寄存器中。</p>
<p>接着，我们介绍<code>GDT</code>是如何被加载到Linux内核代码中的。会有一个将它从内存中加载的操作，就像下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lgdt gdt	#	load global descriptor table 	</span><br></pre></td></tr></table></figure>

<p><code>lgdt</code>命令加载<code>GDT(global descriptor table)</code>的基址和大小加载到<code>GDTR</code>寄存器中，<code>GDTR</code>寄存器占48位：</p>
<ul>
<li><code>16</code>位表示<code>global descriptor table</code>的大小。</li>
<li><code>32</code>位表示<code>global descriptor table</code>的地址。</li>
</ul>
<p>之前提到，<code>GDT</code>包含<code>segment descriptors</code>，这是内存段的描述符。每个描述符占<code>64</code>位。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 63         56         51   48    45           39        32 </span><br><span class="line">------------------------------------------------------------</span><br><span class="line">|             | |B| |A|       | |   | |0|E|W|A|            |</span><br><span class="line">| BASE 31:24  |G|/|L|V| LIMIT |P|DPL|S|  TYPE | BASE 23:16 |</span><br><span class="line">|             | |D| |L| 19:16 | |   | |1|C|R|A|            |</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"> 31                         16 15                         0 </span><br><span class="line">------------------------------------------------------------</span><br><span class="line">|                             |                            |</span><br><span class="line">|        BASE 15:0            |       LIMIT 15:0           |</span><br><span class="line">|                             |                            |</span><br><span class="line">------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>51:48</code>和<code>15:0</code>表示段大小<code>length_of_segment - 1</code>，总共<code>20</code>位，同时段大小还取决于第<code>55</code>位<code>G (Granularity)</code>。</p>
<ul>
<li>当<code>G = 0</code>且<code>(segment) Limit = 0</code>时，段大小为<code>1 B</code>。</li>
<li>当<code>G = 1</code>且<code>(segment) Limit = 1</code>时，段大小为<code>4096 B</code>。</li>
<li>当<code>G = 0</code>且<code>(segment) Limit = 0xfffff</code>时，段大小为<code>1 MB。</code></li>
<li>当<code>G = 1</code>且<code>(segment) Limit = 0xfffff</code>时，段大小为<code>4 GB</code>。</li>
</ul>
<p>从上面的例子可以知道：</p>
<ul>
<li><code>G = 0</code>时，<code>Limit</code>被解释为<code>1 B</code>。</li>
<li><code>G = 1</code>时，<code>Limit</code>被解释为<code>4096 B = 4 KB = 1 页(page)</code>。</li>
</ul>
</li>
<li><p><code>Base</code>是<code>32位</code>，占<code>63:56</code>，<code>39:32</code>和<code>31:16</code>。表示段的起始物理地址。</p>
</li>
<li><p><code>Type/Attribute</code>为<code>5位</code>，占<code>44:40</code>，确定的段的属性。</p>
<ul>
<li><code>44位</code>的<code>S = 0</code>时，表示该段为系统段；<code>S = 1</code>时代表该段为数据段（栈段也属于数据段，且支持读和写）。</li>
<li><code>43位</code>的<code>Ex</code>规定该段是数据段还是代码段，<code>Ex = 0</code>表示数据段，反之为代码段。</li>
</ul>
</li>
</ul>
<p>下面列出所有类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">|           Type Field        | Descriptor Type | Description                        |</span><br><span class="line">|-----------------------------|-----------------|------------------------------------|</span><br><span class="line">| Decimal                     |                 |                                    |</span><br><span class="line">|             0    E    W   A |                 |                                    |</span><br><span class="line">| 0           0    0    0   0 | Data            | Read-Only                          |</span><br><span class="line">| 1           0    0    0   1 | Data            | Read-Only, accessed                |</span><br><span class="line">| 2           0    0    1   0 | Data            | Read/Write                         |</span><br><span class="line">| 3           0    0    1   1 | Data            | Read/Write, accessed               |</span><br><span class="line">| 4           0    1    0   0 | Data            | Read-Only, expand-down             |</span><br><span class="line">| 5           0    1    0   1 | Data            | Read-Only, expand-down, accessed   |</span><br><span class="line">| 6           0    1    1   0 | Data            | Read/Write, expand-down            |</span><br><span class="line">| 7           0    1    1   1 | Data            | Read/Write, expand-down, accessed  |</span><br><span class="line">|                  C    R   A |                 |                                    |</span><br><span class="line">| 8           1    0    0   0 | Code            | Execute-Only                       |</span><br><span class="line">| 9           1    0    0   1 | Code            | Execute-Only, accessed             |</span><br><span class="line">| 10          1    0    1   0 | Code            | Execute/Read                       |</span><br><span class="line">| 11          1    0    1   1 | Code            | Execute/Read, accessed             |</span><br><span class="line">| 12          1    1    0   0 | Code            | Execute-Only, conforming           |</span><br><span class="line">| 14          1    1    0   1 | Code            | Execute-Only, conforming, accessed |</span><br><span class="line">| 13          1    1    1   0 | Code            | Execute/Read, conforming           |</span><br><span class="line">| 15          1    1    1   1 | Code            | Execute/Read, conforming, accessed |</span><br><span class="line">--------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p><code>40, 41, 42</code>位表示<code>EXW</code>：<code>(Expansion, Writable, Accessiable)</code>或<code>CRA</code>：<code>(Conforming Readable Accesible)</code>。</p>
<ul>
<li><p><code>E = 0</code>，表示<code>expand up</code>，反之表示<code>expand down</code></p>
<blockquote>
<ul>
<li><strong>Expand Up</strong> 当一个内存段被定义为 “expand up” 时，这意味着段的大小可以向上扩展，也就是说，段的起始地址保持不变，而它的结束地址可以增大。在段描述符中，如果一个段是 “expand up” 类型的，当执行如堆（heap）内存分配这样的操作时，可以不断地向高地址扩展，增加段的大小。</li>
<li><strong>Expand Down</strong> 相反，”expand down” 段是指其结束地址固定，而起始地址可以减小（即向更低的内存地址扩展）。这通常用于如栈（stack）这样的数据结构，它们在增长时是向低地址扩展的。例如，在x86架构中，栈是向下增长的，这意味着如果栈需要更多空间，它的起始地址会向内存地址更低的方向移动。</li>
<li>在保护模式下的段描述符中，可以通过设置特定的标志位来定义段是 “expand up” 还是 “expand down”。这些标志位告诉处理器段的界限是如何随着数据的增长而变化的。</li>
</ul>
</blockquote>
</li>
<li><p><code>W = 1</code>，表示该段是写允许的；反之，该段为只读。</p>
</li>
<li><p><code>A = 1</code>，表示该段可被处理器访问。</p>
</li>
<li><p><code>C = 1</code>，该位仅在<code>43</code>位为1时有效，表示段代码可以被更低优先级的状态（例如用户态）执行。</p>
</li>
<li><p><code>R = 1</code>，表示可以从该段读取数据。</p>
</li>
</ul>
<ol>
<li><p><code>DPL[2 bits], (Descriptor privilege Level)</code>，占<code>46:45</code>两位。表示段的优先级，其中0为最高优先级。</p>
</li>
<li><p><code>47</code>位的<code>P</code>标志，表示该段是否存在内存中。<code>p = 0</code>表示该段不在内存中，如果处理器尝试访问一个不在内存中的段，会产生一个段不存在的异常。</p>
</li>
<li><p><code>52</code>位的<code>AVL</code>：保留位。</p>
</li>
<li><p><code>53</code>位的<code>L</code>表示该代码段是否包含<code>native 64-bit code</code>，如果包含，该代码段会在<code>64 bit</code>模式下执行。</p>
<blockquote>
<p>“Native 64-bit code”指的是为64位处理器架构专门编写和编译的程序代码。这些代码直接利用64位处理器能提供的特性，如更广泛的寄存器集合、更大的地址空间以及64位数据宽度，从而可以更高效地执行指令和处理数据。</p>
<p>当段描述符中的L标志（位53）被设置时，它表明该代码段包含的是原生的64位代码，且将在64位模式下执行。这与32位代码不同，后者即使在64位处理器上运行，也仅能使用32位架构的特性。</p>
</blockquote>
</li>
<li><p><code>54</code>位的<code>D/B</code>标志<code>(Default/Big flag)</code>表示操作数大小<code>32/16</code>位。</p>
<blockquote>
<p>操作数大小（Operand Size）是指在计算机架构中，CPU执行指令时所能处理的数据的位宽。这涉及到CPU指令能直接操作的数据单元的大小，例如，16位、32位或64位整数。</p>
<p>例如，在x86架构中：</p>
<ul>
<li>如果操作数大小是16位，那么CPU指令将会操作16位的数据单元，即它可以一次性读取、写入或处理16位（2字节）的数据。</li>
<li>如果操作数大小是32位，那么CPU指令将操作32位的数据单元，即它可以一次性读取、写入或处理32位（4字节）的数据。</li>
</ul>
</blockquote>
</li>
</ol>
<p>在实模式<code>real mode</code>下，段寄存器包<code>segment register</code>含了段选择器<code>segment selector</code>。然而在保护模式<code>protected mode</code>下，段选择器有所不同。每个段描述符拥有一个<code>16</code>位的段选择器<code>segment selector</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 15             3 2  1     0</span><br><span class="line">-----------------------------</span><br><span class="line">|      Index     | TI | RPL |</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Index</code>：存储描述符在<code>Gobal Descriptor Table</code>中的索引。</li>
<li><code>TI (Table Indicator)</code>：表示在什么地方寻找描述符。当<code>TI = 0</code>时，在<code>GDT</code>中寻找<code>Descriptor</code>。否则，在<code>Local Descriptor Table (LDT)</code>中寻找。</li>
<li><code>RPL</code>：存储请求者的优先级。</li>
</ul>
<p>每个段寄存器都有可见<code>visible</code>的和不可见<code>hidden</code>的部分：</p>
<ul>
<li><code>Visible</code>：存储段选择器。</li>
<li><code>Hidden</code>：存储段描述符（base, limit, attributes &amp; flags）</li>
</ul>
<p>在保护模式下，获取物理地址的步骤是：</p>
<ol>
<li><p>将段选择器<code>segment selector</code>加载到任意一个段寄存器<code>segment register</code>中。</p>
</li>
<li><p><code>CPU</code>从选择器<code>selector</code>中通过偏移<code>GDT address + Index</code>找到段描述符。然后将描述符加载到寄存器的不可见<code>hidden</code>部分。</p>
</li>
<li><p>如果不允许分页<code>paging disabled</code>，段的物理地址的计算公式如下：<br>$$<br>BaseAddress(found In The Descriptor Obtained In The Previous Step) + Offset<br>$$</p>
</li>
<li></li>
</ol>
<p>如下图所示：</p>
<p><img src="/../images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-13%2011.10.19.png" alt="截屏2023-11-13 11.10.19"></p>
<p>从实模式跳转到保护模式的流程如下：</p>
<ul>
<li>禁止中断</li>
<li>通过<code>lgdt</code>命令描述并加载<code>GDT</code></li>
<li>在<code>CR0 (Control Register 0)</code>中配置<code>PE (Protection Enable)</code></li>
<li>跳转到保护模式的代码</li>
</ul>
<p>在跳转到保护模式前，我们需要做一些准备。</p>
<p>阅读<code>arch/x86/boot/main.c</code>，我们会看见一些实现，键盘初始化，堆初始化等等，的函数。</p>
<p>查看<code>main.c</code>中的<code>main</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* First, copy the boot header into the &quot;zeropage&quot; */</span></span><br><span class="line">	copy_boot_params();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize the early-boot console */</span></span><br><span class="line">	console_init();</span><br><span class="line">	<span class="keyword">if</span> (cmdline_find_option_bool(<span class="string">&quot;debug&quot;</span>))</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;early console in setup code\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* End of heap check */</span></span><br><span class="line">	init_heap();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure we have all the proper CPU support */</span></span><br><span class="line">	<span class="keyword">if</span> (validate_cpu()) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Unable to boot - please use a kernel appropriate &quot;</span></span><br><span class="line">		     <span class="string">&quot;for your CPU.\n&quot;</span>);</span><br><span class="line">		die();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Tell the BIOS what CPU mode we intend to run in. */</span></span><br><span class="line">	set_bios_mode();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Detect memory layout */</span></span><br><span class="line">	detect_memory();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set keyboard repeat rate (why?) and query the lock flags */</span></span><br><span class="line">	keyboard_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Query Intel SpeedStep (IST) information */</span></span><br><span class="line">	query_ist();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Query APM information */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_APM) || defined(CONFIG_APM_MODULE)</span></span><br><span class="line">	query_apm_bios();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Query EDD information */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_EDD) || defined(CONFIG_EDD_MODULE)</span></span><br><span class="line">	query_edd();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set the video mode */</span></span><br><span class="line">	set_video();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Do the last things and invoke protected mode */</span></span><br><span class="line">	go_to_protected_mode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Copyinh-boot-parameters-into-the-“zeropage”"><a href="#Copyinh-boot-parameters-into-the-“zeropage”" class="headerlink" title="Copyinh boot parameters into the “zeropage”"></a>Copyinh boot parameters into the “zeropage”</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* First, copy the boot header into the &quot;zeropage&quot; */</span></span><br><span class="line">	copy_boot_params();</span><br></pre></td></tr></table></figure>

<p>该函数将内核配置头拷贝到对应的结构体<code>boot_params</code>（也叫<code>zeropage</code>，定义在<code>arch/x86/include/uapi/asm/bootparam.h</code>）对应的成员<code>setup_header</code>中。</p>
<blockquote>
<p>在Linux内核启动过程中，“kernel setup header”通常指的是一个特定的数据结构，它包含了启动时内核所需的各种参数和信息。这个数据结构在启动早期由引导程序填充，然后由启动加载器（比如GRUB）传递给内核。</p>
<p>“kernel setup header”结构定义了内核如何被加载，包含了以下信息：</p>
<ul>
<li>内核的加载模式（实模式或保护模式）</li>
<li>启动设备</li>
<li>内存布局信息</li>
<li>初始化RAM盘的位置和大小</li>
<li>视频模式选择</li>
<li>其他硬件参数</li>
</ul>
<p>这个头部信息是由启动代码中的一部分，比如Linux的bootsect.S（启动扇区）和setup.S（设置代码）所使用。这些信息对于内核来说非常关键，因为它们告诉内核它被加载到内存中的哪个位置，以及硬件的配置如何。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">struct setup_header &#123;</span><br><span class="line">	__u8	setup_sects;	// 	引导扇区的大小。</span><br><span class="line">	__u16	root_flags;		// 	根文件系统的挂载标志。</span><br><span class="line">	__u32	syssize;			// 	内核映像的大小（单位为16字节段）。</span><br><span class="line">	__u16	ram_size;			//	旧式的RAM大小指示，现在不常用。</span><br><span class="line">	__u16	vid_mode;			//	视频模式标识。</span><br><span class="line">	__u16	root_dev;			//	根设备的编号。</span><br><span class="line">	__u16	boot_flag;		//	引导标志，用来指示有效的引导扇区。</span><br><span class="line">	__u16	jump;					//	引导代码中跳转指令的起始位置。</span><br><span class="line">	__u32	header;				//	Magic Number，用来识别这个结构体。</span><br><span class="line">	__u16	version;			//	结构体的版本号。</span><br><span class="line">	__u32	realmode_swtch;		</span><br><span class="line">	__u16	start_sys_seg;</span><br><span class="line">	__u16	kernel_version;</span><br><span class="line">	__u8	type_of_loader;</span><br><span class="line">	__u8	loadflags;</span><br><span class="line">	__u16	setup_move_size;</span><br><span class="line">	__u32	code32_start;</span><br><span class="line">	__u32	ramdisk_image;</span><br><span class="line">	__u32	ramdisk_size;</span><br><span class="line">	__u32	bootsect_kludge;</span><br><span class="line">	__u16	heap_end_ptr;</span><br><span class="line">	__u8	ext_loader_ver;</span><br><span class="line">	__u8	ext_loader_type;</span><br><span class="line">	__u32	cmd_line_ptr;</span><br><span class="line">	__u32	initrd_addr_max;</span><br><span class="line">	__u32	kernel_alignment;</span><br><span class="line">	__u8	relocatable_kernel;</span><br><span class="line">	__u8	min_alignment;</span><br><span class="line">	__u16	xloadflags;</span><br><span class="line">	__u32	cmdline_size;</span><br><span class="line">	__u32	hardware_subarch;</span><br><span class="line">	__u64	hardware_subarch_data;</span><br><span class="line">	__u32	payload_offset;</span><br><span class="line">	__u32	payload_length;</span><br><span class="line">	__u64	setup_data;</span><br><span class="line">	__u64	pref_address;</span><br><span class="line">	__u32	init_size;</span><br><span class="line">	__u32	handover_offset;</span><br><span class="line">	__u32	kernel_info_offset;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>boot_params</code>结构体包含 <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/x86/boot.txt">linux boot protocol</a>定义的域，这些域会在启动器启动电脑、内核编译时填充。<code>copy_boot_protocal</code>做了以下两件事：</p>
<ol>
<li>将汇编代码<code>header.S</code>中的<code>hdr</code>标签复制到结构体<code>boot_params</code>中的<code>setup_header</code>成员。</li>
<li>如果加载内核时用了旧的命令行工具，它负责跟新指针指向新的内核命令行工具。</li>
</ol>
<p>顺便看一看实现复制<code>hdr</code>功能的<code>memcpy</code>在<code>arch/x86/boot/copy.S</code>中是如何实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Memory copy routines</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">	.code16</span><br><span class="line">	.text</span><br><span class="line"></span><br><span class="line">SYM_FUNC_START_NOALIGN(memcpy)</span><br><span class="line">	pushw	%si						# si 是源索引寄存器</span><br><span class="line">	pushw	%di						#	di 是目标寄存器</span><br><span class="line">	movw	%ax, %di			# ax 通常存放目的地址</span><br><span class="line">	movw	%dx, %si			# dx 通常存放源地址</span><br><span class="line">	pushw	%cx						# cx 计数寄存器</span><br><span class="line">	shrw	$2, %cx</span><br><span class="line">	rep; movsl					# rep 重复执行标志；movsl：move string long。这条指令用于从源地址复制一个双字（32位，或者说4个字节）到目标地址。</span><br><span class="line">	popw	%cx</span><br><span class="line">	andw	$3, %cx</span><br><span class="line">	rep; movsb</span><br><span class="line">	popw	%di</span><br><span class="line">	popw	%si</span><br><span class="line">	retl</span><br><span class="line">SYM_FUNC_END(memcpy)</span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>SYM_FUNC_START_NOALIGN</code>定义在<code>include/linux/linkage.h</code>中，表示这是一个全局函数。其中 <code>w/o</code>表示 <code>without alignment</code>，即无对齐。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SYM_FUNC_START_NOALIGN -- use for global functions, w/o alignment */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SYM_FUNC_START_NOALIGN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYM_FUNC_START_NOALIGN(name)			\</span></span><br><span class="line"><span class="meta">	SYM_START(name, SYM_L_GLOBAL, SYM_A_NONE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>memcpy</code>的汇编代码很简单。</p>
<ul>
<li>首先将<code>%si</code>和<code>%di</code>寄存器中的值压入栈中以保留它们的值，这是因为接下来的操作会改变它们的值。</li>
<li>然后将<code>%ax</code>和<code>%dx</code>的值存储到<code>%di</code>和<code>%si</code>中。</li>
<li>将<code>%cx</code>的值保存在栈中，然后对<code>%cx</code>的值右移2位（除以4）。</li>
<li>循环复制（一次复制4字节）源寄存器<code>si</code>指向的地址中的值，到目的寄存器<code>di</code>指向的地址空间中，直到计数寄存器<code>cx</code>减小为0。</li>
</ul>
<p>因为上面的操作都是4个字节4个字节的复制，而在实际使用<code>memcpy</code>时肯定会出现复制的字节不是4的倍数的情况。</p>
<ul>
<li>这种情况下，我们取出在栈中保存的<code>%cx</code>值，然后重复使用<code>movsb</code>命令（b代表每次复制一个字节）复制剩下的字节。</li>
<li>最后取出保存在<code>%di</code>和<code>%si</code>中的值并返回。</li>
</ul>
<p>在<code>arch/x86/Makefile</code>中的<code>REALMODE_CFLAGS</code>中可以看到，构建内核时通过<code>-mregparm = 3</code>的<code>GCC</code>选项。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How to compile the 16-bit code.  Note we always compile for -march=i386;</span></span><br><span class="line"><span class="comment"># that way we can complain to the user if the CPU is insufficient.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The -m16 option is supported by GCC &gt;= 4.9 and clang &gt;= 3.5. For</span></span><br><span class="line"><span class="comment"># older versions of GCC, include an *assembly* header to make sure that</span></span><br><span class="line"><span class="comment"># gcc doesn&#x27;t play any games behind our back.</span></span><br><span class="line">CODE16GCC_CFLAGS := -m32 -Wa,<span class="variable">$(srctree)</span>/arch/x86/boot/code16gcc.h</span><br><span class="line">M16_CFLAGS	 := <span class="variable">$(<span class="built_in">call</span> cc-option, -m16, <span class="variable">$(CODE16GCC_CFLAGS)</span>)</span></span><br><span class="line"></span><br><span class="line">REALMODE_CFLAGS	:= <span class="variable">$(M16_CFLAGS)</span> -g -Os -DDISABLE_BRANCH_PROFILING -D__DISABLE_EXPORTS \</span><br><span class="line">		   -Wall -Wstrict-prototypes -march=i386 -mregparm=3 \</span><br><span class="line">		   -fno-strict-aliasing -fomit-frame-pointer -fno-pic \</span><br><span class="line">		   -mno-mmx -mno-sse <span class="variable">$(<span class="built_in">call</span> cc-option,-fcf-protection=none)</span></span><br></pre></td></tr></table></figure>

<p>现在我们知道，函数<code>memcpy</code>的三个参数分别存储在<code>ax</code>,<code>dx</code>和<code>cx</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(&amp;boot_params.hdr, &amp;hdr, <span class="keyword">sizeof</span> hdr);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ax</code> 存储<code>boot_params.hdr</code>的地址</li>
<li><code>dx</code> 存储 <code>hdr</code>的地址</li>
<li><code>cx</code> 存储 <code>hdr</code> 的大小</li>
</ul>
<h2 id="Console-initialization"><a href="#Console-initialization" class="headerlink" title="Console initialization"></a>Console initialization</h2><p>使用函数<code>console_init</code>初始化控制台，该函数定义在<code>arch/x86/boot/early_serial_console.c</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">console_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	parse_earlyprintk();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!early_serial_base)</span><br><span class="line">		parse_console_uart8250();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数在启动参数中寻找<code>earlyprintk</code>选项，如果成功找到，则解析端口地址和端口的波特率并初始化端口。<code>earlyprintk</code>命令行的参数是其中的下一个：</p>
<ul>
<li><code>serial, 0x3f8, 115200</code></li>
<li><code>serial, ttyS0, 115200</code></li>
<li><code>ttyS0, 115200</code></li>
</ul>
<p>串行端口初始化成功后，我们会看见第一个输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cmdline_find_option_bool(<span class="string">&quot;debug&quot;</span>))</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;early console in setup code\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>函数<code>puts</code>定义在：<code>arch/x86/boot/tty.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __section(<span class="string">&quot;.inittext&quot;</span>) <span class="built_in">putchar</span>(<span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (ch == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;\r&#x27;</span>);	<span class="comment">/* \n -&gt; \r\n */</span></span><br><span class="line"></span><br><span class="line">	bios_putchar(ch);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (early_serial_base != <span class="number">0</span>)</span><br><span class="line">		serial_putchar(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __section(<span class="string">&quot;.inittext&quot;</span>) <span class="built_in">puts</span>(<span class="type">const</span> <span class="type">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (*str)</span><br><span class="line">		<span class="built_in">putchar</span>(*str++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在c语言中，<code>__section</code>属性告诉编译器将特定的函数或者变量放置在指定的段<code>(section)</code>中。<code>&quot;.inittext&quot;</code>是一个段名，用于指定内核初始化代码的位置。</p>
<p>即，指示连接器将<code>putchar</code>函数放置在<code>ELF</code>二进制文件的<code>.inittext</code>段中。这个段专门用于内核启动时需要执行，但是一旦完成初始化过程后就不再需要的代码。内核通常在启动完成后会释放这些初始化代码占用的内存，因为这段时间内核已经开始运行正常的运行时代码了。</p>
<p>使用这个属性可以帮助减少内核的运行时内存占用，因为初始化代码在它不再需要之后不会占用宝贵的内存资源。这在嵌入式系统中尤其有用，其中内存资源可能非常有限。</p>
</blockquote>
<p>我们在链接文件<code>arch/x86/boot/setup.ld</code>可以看到上述代码的<code>.inittext</code>段的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> */</span><br><span class="line">OUTPUT_FORMAT(&quot;elf32-i386&quot;)</span><br><span class="line">OUTPUT_ARCH(i386)</span><br><span class="line">ENTRY(_start)</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">	. = 0;</span><br><span class="line">	.bstext		: &#123; *(.bstext) &#125;</span><br><span class="line">	.bsdata		: &#123; *(.bsdata) &#125;</span><br><span class="line"></span><br><span class="line">	. = 495;</span><br><span class="line">	.header		: &#123; *(.header) &#125;</span><br><span class="line">	.entrytext	: &#123; *(.entrytext) &#125;</span><br><span class="line">	.inittext	: &#123; *(.inittext) &#125;</span><br><span class="line">	.initdata	: &#123; *(.initdata) &#125;</span><br><span class="line">	__end_init = .;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们回到函数<code>putchar</code>，该函数在将<code>\n</code>转换为<code>\r</code>后。调用<code>bios_putchar</code>，通过<code>0x10</code>中断，在<code>VGA screen</code>上输出。</p>
<blockquote>
<ul>
<li>在计算机术语中，“VGA screen”指的是通过视频图形阵列（Video Graphics Array，VGA）接口显示的屏幕。</li>
<li>BIOS（基本输入输出系统）提供了一系列的中断调用，用于低级别的硬件交互，其中<code>0x10</code>是视频服务的中断号。软件可以通过设置相应的寄存器，然后触发这个中断来执行特定的视频操作，如在屏幕上显示字符。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __section(<span class="string">&quot;.inittext&quot;</span>) bios_putchar(<span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">biosregs</span> <span class="title">ireg</span>;</span></span><br><span class="line"></span><br><span class="line">	initregs(&amp;ireg);</span><br><span class="line">	ireg.bx = <span class="number">0x0007</span>;</span><br><span class="line">	ireg.cx = <span class="number">0x0001</span>;</span><br><span class="line">	ireg.ah = <span class="number">0x0e</span>;</span><br><span class="line">	ireg.al = ch;</span><br><span class="line">	intcall(<span class="number">0x10</span>, &amp;ireg, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>initregs</code>调用<code>memset</code>函数将<code>biosregs ireg</code>置为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initregs</span><span class="params">(<span class="keyword">struct</span> biosregs *reg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(reg, <span class="number">0</span>, <span class="keyword">sizeof</span>(*reg));</span><br><span class="line">	reg-&gt;eflags |= X86_EFLAGS_CF;</span><br><span class="line">	reg-&gt;ds = ds();</span><br><span class="line">	reg-&gt;es = ds();</span><br><span class="line">	reg-&gt;fs = fs();</span><br><span class="line">	reg-&gt;gs = gs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阅读<code>memset</code>的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SYM_FUNC_START_NOALIGN(memset)</span><br><span class="line">	pushw	%di</span><br><span class="line">	movw	%ax, %di</span><br><span class="line">	movzbl	%dl, %eax		# move with Zero-Extend from Byte to Longword	</span><br><span class="line">	imull	$0x01010101,%eax</span><br><span class="line">	pushw	%cx</span><br><span class="line">	shrw	$2, %cx</span><br><span class="line">	rep; stosl</span><br><span class="line">	popw	%cx</span><br><span class="line">	andw	$3, %cx</span><br><span class="line">	rep; stosb</span><br><span class="line">	popw	%di</span><br><span class="line">	retl</span><br><span class="line">SYM_FUNC_END(memset)</span><br></pre></td></tr></table></figure>

<ul>
<li>同样接受三个参数，存放在<code>ax dx cx</code>中。</li>
<li>将8位<code>%dl</code>零扩展到32位并移动到<code>%eax</code>中。</li>
<li>然后通过<code>imull $0x01010101, %eax</code>将高<code>24</code>位全复制为低<code>8</code>位的值。</li>
<li><code>stosl</code>：<code>Store String long</code>（存储字符串长字）。该指令将累加器（<code>AL</code>、<code>AX</code>或<code>EAX</code>）中的数据复制到目标索引寄存器（<code>DI</code>或<code>EDI</code>）指向的内存地址，并根据当前设置的方向标志（Direction Flag）在标志寄存器中自动增加或减少<code>DI</code>&#x2F;<code>EDI</code>的值。直到计数寄存器<code>cx</code>归<code>0</code>。</li>
</ul>
<h2 id="Heap-initialization"><a href="#Heap-initialization" class="headerlink" title="Heap initialization"></a>Heap initialization</h2><p>在<code>header.S</code>中，我们初始化了栈<code>stack</code>和<code>bss</code>段。现在内核需要使用<code>init_heap</code>初始化堆<code>heap</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_heap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *stack_end;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (boot_params.hdr.loadflags &amp; CAN_USE_HEAP) &#123;</span><br><span class="line">		<span class="keyword">asm</span>(<span class="string">&quot;leal %P1(%%esp),%0&quot;</span></span><br><span class="line">		    : <span class="string">&quot;=r&quot;</span> (stack_end) : <span class="string">&quot;i&quot;</span> (-STACK_SIZE));</span><br><span class="line"></span><br><span class="line">		heap_end = (<span class="type">char</span> *)</span><br><span class="line">			((<span class="type">size_t</span>)boot_params.hdr.heap_end_ptr + <span class="number">0x200</span>);</span><br><span class="line">		<span class="keyword">if</span> (heap_end &gt; stack_end)</span><br><span class="line">			heap_end = stack_end;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Boot protocol 2.00 only, no heap available */</span></span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;WARNING: Ancient bootloader, some functionality &quot;</span></span><br><span class="line">		     <span class="string">&quot;may be limited!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先检查启动文件头的<code>loadflag</code>中是否配置了<code>CAN_USE_HEAP</code>，如果配置了<code>CAN_USE_HEAP</code>，使用内链汇编代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;leal %P1(%%esp),%0&quot;</span></span><br><span class="line">		    : <span class="string">&quot;=r&quot;</span> (stack_end) : <span class="string">&quot;i&quot;</span> (-STACK_SIZE));</span><br></pre></td></tr></table></figure>

<p>计算栈的结束位置。也即：<code>stack_end = esp - STACK_SIZE</code></p>
<p>接着是计算堆结束位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap_end = (<span class="type">char</span> *)((<span class="type">size_t</span>)boot_params.hdr.heap_end_ptr + <span class="number">0x200</span>);</span><br></pre></td></tr></table></figure>

<p>最后检查堆结束地址<code>heap_end</code>是否大于栈结束地址<code>stack_end</code>，如果是，则要保持<code>heap_end = stack_end</code>。</p>
<p>堆初始化之后，我们可以使用<code>GET_HEAP</code>方法，在下一章我们会介绍它。</p>
<h2 id="CPU确认"><a href="#CPU确认" class="headerlink" title="CPU确认"></a>CPU确认</h2><p>下一步是确认<code>CPU，函数</code>validate_cpu<code>定义在</code><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/cpu.c"><code>arch/x86/boot/cpu.c</code></a>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">validate_cpu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 *err_flags;</span><br><span class="line">	<span class="type">int</span> cpu_level, req_level;</span><br><span class="line"></span><br><span class="line">	check_cpu(&amp;cpu_level, &amp;req_level, &amp;err_flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cpu_level &lt; req_level) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;This kernel requires an %s CPU, &quot;</span>,</span><br><span class="line">		       cpu_name(req_level));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;but only detected an %s CPU.\n&quot;</span>,</span><br><span class="line">		       cpu_name(cpu_level));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err_flags) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;This kernel requires the following features &quot;</span></span><br><span class="line">		     <span class="string">&quot;not present on the CPU:\n&quot;</span>);</span><br><span class="line">		show_cap_strs(err_flags);</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (check_knl_erratum()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数<code>check_cpu</code>判断当前CPU等级<code>cpu_level</code>和需要的CPU等级<code>req_level</code>是否一致。该函数还检查CPU标志，对于x86_64（64位）CPU，它会检查长模式（long mode）是否存在，检查处理器的供应商，并为特定供应商做准备，比如如果AMD缺失SSE+SSE2，就关闭它们等等。</p>
<p>当cpu被确认后，调用<code>set_bios_mode</code>，该函数告诉<code>BIOS</code>我们会在哪种<code>CPU</code>模式下运行。该函数只在<code>x86_64</code>模式下运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Tell the BIOS what CPU mode we intend to run in.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_bios_mode</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">biosregs</span> <span class="title">ireg</span>;</span></span><br><span class="line"></span><br><span class="line">	initregs(&amp;ireg);</span><br><span class="line">	ireg.ax = <span class="number">0xec00</span>;</span><br><span class="line">	ireg.bx = <span class="number">2</span>;</span><br><span class="line">	intcall(<span class="number">0x15</span>, &amp;ireg, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数通过<code>0x15 BIOS</code>中断告诉<code>BIOS</code>使用长模式<code>long mode</code>。</p>
<blockquote>
<p>在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/X86-64">x86-64</a>处理器架构中，当处于<strong>长模式</strong>（Long mode）时，64位应用程序（或者是操作系统）可以使用64位指令和寄存器，而32位程序将以一种兼容子模式运行。</p>
</blockquote>
<h2 id="Memory-detection"><a href="#Memory-detection" class="headerlink" title="Memory detection"></a>Memory detection</h2><p>接着主函数会调用<code>detect_memory</code>检测内存，该函数为<code>CPU</code>提供了基础的<code>RAM</code>映射表。使用了不同的编程接口<code>0xe820 0xe801</code>和<code>0x88</code>用于内存检测。以<code>0xE820</code>为例，<code>detect_memory_e820</code>定义在<code>arch/x86/boot/memory.c</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">detect_memory_e820</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">biosregs</span> <span class="title">ireg</span>, <span class="title">oreg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">boot_e820_entry</span> *<span class="title">desc</span> =</span> boot_params.e820_table;</span><br><span class="line">	<span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">boot_e820_entry</span> <span class="title">buf</span>;</span> <span class="comment">/* static so it is zeroed */</span></span><br><span class="line"></span><br><span class="line">	initregs(&amp;ireg);</span><br><span class="line">	ireg.ax  = <span class="number">0xe820</span>;</span><br><span class="line">	ireg.cx  = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">	ireg.edx = SMAP;</span><br><span class="line">	ireg.di  = (<span class="type">size_t</span>)&amp;buf;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Note: at least one BIOS is known which assumes that the</span></span><br><span class="line"><span class="comment">	 * buffer pointed to by one e820 call is the same one as</span></span><br><span class="line"><span class="comment">	 * the previous call, and only changes modified fields.  Therefore,</span></span><br><span class="line"><span class="comment">	 * we use a temporary buffer and copy the results entry by entry.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This routine deliberately does not try to account for</span></span><br><span class="line"><span class="comment">	 * ACPI 3+ extended attributes.  This is because there are</span></span><br><span class="line"><span class="comment">	 * BIOSes in the field which report zero for the valid bit for</span></span><br><span class="line"><span class="comment">	 * all ranges, and we don&#x27;t currently make any use of the</span></span><br><span class="line"><span class="comment">	 * other attribute bits.  Revisit this if we see the extended</span></span><br><span class="line"><span class="comment">	 * attribute bits deployed in a meaningful way in the future.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		intcall(<span class="number">0x15</span>, &amp;ireg, &amp;oreg);</span><br><span class="line">		ireg.ebx = oreg.ebx; <span class="comment">/* for next iteration... */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* BIOSes which terminate the chain with CF = 1 as opposed</span></span><br><span class="line"><span class="comment">		   to %ebx = 0 don&#x27;t always report the SMAP signature on</span></span><br><span class="line"><span class="comment">		   the final, failing, probe. */</span></span><br><span class="line">		<span class="keyword">if</span> (oreg.eflags &amp; X86_EFLAGS_CF)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Some BIOSes stop returning SMAP in the middle of</span></span><br><span class="line"><span class="comment">		   the search loop.  We don&#x27;t know exactly how the BIOS</span></span><br><span class="line"><span class="comment">		   screwed up the map at that point, we might have a</span></span><br><span class="line"><span class="comment">		   partial map, the full map, or complete garbage, so</span></span><br><span class="line"><span class="comment">		   just return failure. */</span></span><br><span class="line">		<span class="keyword">if</span> (oreg.eax != SMAP) &#123;</span><br><span class="line">			count = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		*desc++ = buf;</span><br><span class="line">		count++;</span><br><span class="line">	&#125; <span class="keyword">while</span> (ireg.ebx &amp;&amp; count &lt; ARRAY_SIZE(boot_params.e820_table));</span><br><span class="line"></span><br><span class="line">	boot_params.e820_entries = count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数首先为寄存器填充调用<code>0xe820</code>所需的特定值。</p>
<ul>
<li><code>ax</code>：包含了函数的名字。</li>
<li><code>cx</code>：缓存的大小，该缓存将用于存储内存中的数据。</li>
<li><code>edx</code>：包含了<code>SMAP magic number</code>。</li>
<li><code>es:di</code>：指向上面提到的缓存的地址（cx中）。</li>
<li><code>ebx</code>：必须为0.</li>
</ul>
<p>然后是一个循环，该循环收集内存中的数据。首先调用<code>0x15</code>的<code>BIOS</code>中断，该中断从地址分配表中写入一行。为了获取下一行，我们需要再次调用该中断。在下一次调用之前，ebx必须包含之前返回的值。</p>
<p>最终，该函数从地址分配表收集数据，并将这些数据写入e820_entry数组：</p>
<ul>
<li>内存段的起点</li>
<li>内存段的大小</li>
<li>内存段的类型（可用或者保留）</li>
</ul>
<p><code>dmesg</code>的输出是像下面给出的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[    0.000000] e820: BIOS-provided physical RAM map:</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x0000000000000000-0x000000000009fbff] usable</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x000000000009fc00-0x000000000009ffff] reserved</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x00000000000f0000-0x00000000000fffff] reserved</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x0000000000100000-0x000000003ffdffff] usable</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x000000003ffe0000-0x000000003fffffff] reserved</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x00000000fffc0000-0x00000000ffffffff] reserved</span><br></pre></td></tr></table></figure>

<h2 id="Keyboard-initialization"><a href="#Keyboard-initialization" class="headerlink" title="Keyboard initialization"></a>Keyboard initialization</h2><p>接着调用函数<code>keyboard_init</code>初始化键盘，同样通过函数<code>initregs</code>初始化寄存器。然后调用<code>0x16</code>中断查询键盘状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">keyboard_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">biosregs</span> <span class="title">ireg</span>, <span class="title">oreg</span>;</span></span><br><span class="line">	initregs(&amp;ireg);</span><br><span class="line"></span><br><span class="line">	ireg.ah = <span class="number">0x02</span>;		<span class="comment">/* Get keyboard status */</span></span><br><span class="line">	intcall(<span class="number">0x16</span>, &amp;ireg, &amp;oreg);</span><br><span class="line">	boot_params.kbd_status = oreg.al;</span><br><span class="line"></span><br><span class="line">	ireg.ax = <span class="number">0x0305</span>;	<span class="comment">/* Set keyboard repeat rate */</span></span><br><span class="line">	intcall(<span class="number">0x16</span>, &amp;ireg, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此之后，它再次调用0x16来设置重复率和延迟。</p>
<h2 id="Querying"><a href="#Querying" class="headerlink" title="Querying"></a>Querying</h2><p>接下来的几个步骤是对不同参数的查询。我们不会深入研究这些查询的细节，但稍后会回复它们。让我们简要看看这些功能：</p>
<ul>
<li><p><code>query_ist</code>：获取<code>Intel SpeedStep</code>信息。检查<code>CPU</code>的等级，如果正确，调用<code>0x15</code>中断获取信息并存储到<code>boot_params</code>中</p>
<blockquote>
<p>ST（Intel SpeedStep Technology）是英特尔开发的一种处理器技术，旨在优化处理器的性能和电源使用效率。它通过根据当前计算机负载动态调整处理器的频率和电压来实现这一目标。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get Intel SpeedStep (IST) information.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">query_ist</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">biosregs</span> <span class="title">ireg</span>, <span class="title">oreg</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Some older BIOSes apparently crash on this call, so filter</span></span><br><span class="line"><span class="comment">	   it from machines too old to have SpeedStep at all. */</span></span><br><span class="line">	<span class="keyword">if</span> (cpu.level &lt; <span class="number">6</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	initregs(&amp;ireg);</span><br><span class="line">	ireg.ax  = <span class="number">0xe980</span>;	 <span class="comment">/* IST Support */</span></span><br><span class="line">	ireg.edx = <span class="number">0x47534943</span>;	 <span class="comment">/* Request value */</span></span><br><span class="line">	intcall(<span class="number">0x15</span>, &amp;ireg, &amp;oreg);</span><br><span class="line"></span><br><span class="line">	boot_params.ist_info.signature  = oreg.eax;</span><br><span class="line">	boot_params.ist_info.command    = oreg.ebx;</span><br><span class="line">	boot_params.ist_info.event      = oreg.ecx;</span><br><span class="line">	boot_params.ist_info.perf_level = oreg.edx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>query_apm_bios</code>：从<code>BIOS</code>中获取<code>Advanced Power Management</code>信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Query_apm_bios也调用0x15 BIOS中断，但用ah = 0x53检查APM安装。0x15完成执行后，query_apm_bios函数检查PM签名（必须是0x504d）、携带标志（如果支持APM，则必须是0）和cx寄存器的值（如果是0x02，则支持受保护模式接口）。</span><br><span class="line"></span><br><span class="line">接下来，它再次调用0x15，但使用ax = 0x5304断开APM接口并连接32位保护模式接口。最后，它用从BIOS获得的值填充boot_params.apm_bios_info。</span><br><span class="line"></span><br><span class="line">请注意，只有在配置文件中设置了CONFIG_APM或CONFIG_APM_MODULE编译时间标志时，query_apm_bios才会执行：</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>query_edd</code>：查询<code>Enhanced Disk Drive</code>信息。</p>
<p>函数首先从内核命令行中读取<code>edd</code>设置，如果没有该选择则直接退出函数。</p>
<p>如果启用EDD，query_edd会检查BIOS支持的硬盘，并在循环中查询EDD信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">query_edd</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> eddarg[<span class="number">8</span>];</span><br><span class="line">	<span class="type">int</span> do_mbr = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EDD_OFF</span></span><br><span class="line">	<span class="type">int</span> do_edd = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">int</span> do_edd = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span> be_quiet;</span><br><span class="line">	<span class="type">int</span> devno;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">edd_info</span> <span class="title">ei</span>, *<span class="title">edp</span>;</span></span><br><span class="line">	u32 *mbrptr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cmdline_find_option(<span class="string">&quot;edd&quot;</span>, eddarg, <span class="keyword">sizeof</span>(eddarg)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(eddarg, <span class="string">&quot;skipmbr&quot;</span>) || !<span class="built_in">strcmp</span>(eddarg, <span class="string">&quot;skip&quot;</span>)) &#123;</span><br><span class="line">			do_edd = <span class="number">1</span>;</span><br><span class="line">			do_mbr = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(eddarg, <span class="string">&quot;off&quot;</span>))</span><br><span class="line">			do_edd = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(eddarg, <span class="string">&quot;on&quot;</span>))</span><br><span class="line">			do_edd = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	be_quiet = cmdline_find_option_bool(<span class="string">&quot;quiet&quot;</span>);</span><br><span class="line"></span><br><span class="line">	edp    = boot_params.eddbuf;</span><br><span class="line">	mbrptr = boot_params.edd_mbr_sig_buffer;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!do_edd)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Bugs in OnBoard or AddOnCards Bios may hang the EDD probe,</span></span><br><span class="line"><span class="comment">	 * so give a hint if this happens.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!be_quiet)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Probing EDD (edd=off to disable)... &quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (devno = <span class="number">0x80</span>; devno &lt; <span class="number">0x80</span>+EDD_MBR_SIG_MAX; devno++) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Scan the BIOS-supported hard disks and query EDD</span></span><br><span class="line"><span class="comment">		 * information...</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!get_edd_info(devno, &amp;ei)</span><br><span class="line">		    &amp;&amp; boot_params.eddbuf_entries &lt; EDDMAXNR) &#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(edp, &amp;ei, <span class="keyword">sizeof</span>(ei));</span><br><span class="line">			edp++;</span><br><span class="line">			boot_params.eddbuf_entries++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (do_mbr &amp;&amp; !read_mbr_sig(devno, &amp;ei, mbrptr++))</span><br><span class="line">			boot_params.edd_mbr_sig_buf_entries = devno<span class="number">-0x80</span>+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!be_quiet)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ok\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中0x80是第一个硬盘驱动器，EDD_MBR_SIG_MAX宏的值为16。它收集数据到<code>edd_info</code>结构数组中。</p>
<p><code>get_edd_info</code>通过调用0x13中断和<code>ah = 0x41</code>来检查EDD是否存在，如果EDD存在，get_edd_info再次调用0x13中断，但<code>ah=0x48</code>和<code>si</code>包含存储EDD信息的缓冲区地址。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/24/framewave-study/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/24/framewave-study/" class="post-title-link" itemprop="url">framewave_study</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-24 19:49:26" itemprop="dateCreated datePublished" datetime="2023-10-24T19:49:26+08:00">2023-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-25 19:00:37" itemprop="dateModified" datetime="2023-10-25T19:00:37+08:00">2023-10-25</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Framewave-tutorial"><a href="#Framewave-tutorial" class="headerlink" title="Framewave tutorial"></a>Framewave tutorial</h1><h2 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h2><p>​	去官网下载压缩包，解压后打开<code>readme</code>按照readme里面的步骤来就好了。</p>
<ul>
<li>提示：<code>readme</code>里面的<code>ExampleDir</code>直接换成绝对路径。</li>
<li>提示：后面那个<code>export</code>操作笔者没做出来，不过大概意思是把这个链接放到全局链接里去</li>
</ul>
<h2 id="Framewave-FW-是做什么的："><a href="#Framewave-FW-是做什么的：" class="headerlink" title="Framewave(FW)是做什么的："></a>Framewave(FW)是做什么的：</h2><p>​	Framewave (FW) is a collection of libraries that contain highly-optimized functions for use in a variety of programming domains. All implementations of the libraries provide C and C++ programmers ANSI C style interfaces.</p>
<p>​	Framewave consists of the following libraries:</p>
<ul>
<li>The <a target="_blank" rel="noopener" href="https://framewave.sourceforge.net/Manual/fw_section_010.html#fw_section_010">Base Library</a> functions are essential for primary tasks such as memory allocation and functions that manage the performance of other library functions.</li>
<li>The <a target="_blank" rel="noopener" href="https://framewave.sourceforge.net/Manual/fw_section_020.html#fw_section_020">Image Processing Library</a> functions perform a variety of tasks related to image processing.</li>
<li>The <a target="_blank" rel="noopener" href="https://framewave.sourceforge.net/Manual/fw_section_030.html#fw_section_030">JPEG Library</a> functions perform a variety of tasks related to Joint Photographic Experts Group image manipulation.</li>
<li>The <a target="_blank" rel="noopener" href="https://framewave.sourceforge.net/Manual/fw_section_040.html#fw_section_040">Signal Processing Library</a> functions perform a variety of tasks related to signal processing.</li>
<li>The <a target="_blank" rel="noopener" href="https://framewave.sourceforge.net/Manual/fw_section_050.html#fw_section_050">Video Library</a> functions perform video manipulation, encoding and decoding.</li>
</ul>
<h1 id="RTFM！！！！！"><a href="#RTFM！！！！！" class="headerlink" title="RTFM！！！！！"></a>RTFM！！！！！</h1><p>​	现在的任务就是读手册，手册里写的很清楚了！！！</p>
<p>​	</p>
<h2 id="Base-Library："><a href="#Base-Library：" class="headerlink" title="Base Library："></a>Base Library：</h2><p>​	This chapter provides an overview of the information contained in the functional descriptions. Base library functional descriptions include the following types of information.</p>
<h3 id="Data-Structures"><a href="#Data-Structures" class="headerlink" title="Data Structures"></a>Data Structures</h3><ul>
<li><strong>FwLibraryVersion</strong> Library version information.</li>
<li><strong>FwRoundMode</strong> Rounding mode used in data type conversion.</li>
<li><strong>FwWinType</strong> Type of window used to generate FIR filter coefficients.</li>
</ul>
<h3 id="Enumerator"><a href="#Enumerator" class="headerlink" title="Enumerator"></a>Enumerator</h3><ul>
<li><strong>FwBool</strong> Type of Boolean values.</li>
<li><strong>FwCmpOp</strong> Type of comparison operation.</li>
<li><strong>FwCpuType</strong> Type of CPU with presence of streaming SIMD extensions.</li>
<li><strong>FwHintAlgorithm</strong> Hint to favor speed or accuracy.</li>
</ul>
<h3 id="Parameter-Glossary"><a href="#Parameter-Glossary" class="headerlink" title="Parameter Glossary"></a>Parameter Glossary</h3><ul>
<li><em>StsCode</em> Specifies the status code used by the FwStatus function</li>
<li><em>alignBytes</em> Specifies the number of bytes for alignment, must be a power of 2. NULL is returned if the value is less than 2.</li>
<li><em>cpu</em> Specifies a CPU type.</li>
<li><em>length</em> Specifies a number of bytes to be allocated.</li>
<li><em>numThr</em>  Specifies the maximum number of threads that can be used by any Framewave function.</li>
<li><em>param</em> Specifies some parameter.</li>
<li><em>ptr</em>  Pointer to a memory buffer.</li>
<li><em>workFn</em> Specifies work function.</li>
</ul>
<h3 id="Core-Function"><a href="#Core-Function" class="headerlink" title="Core Function:"></a>Core Function:</h3><p>​	好像被标上<code>This function is reserved for FW internal use.</code>（此功能保留给FW内部使用）和程序员的关系不大。</p>
<ul>
<li><h4 id="GetStatusString"><a href="#GetStatusString" class="headerlink" title="GetStatusString"></a>GetStatusString</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> *	获取状态信息字符串</span><br><span class="line"> *  StsCode 指定FwStatus函数使用的状态代码。</span><br><span class="line"> *	返回一个字符串，该字符串描述了任何FwStatus枚举整数的含义。</span><br><span class="line"> */</span><br><span class="line">const char * fwGetStatusString ( FwStatus StsCode );</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="GetCpuType"><a href="#GetCpuType" class="headerlink" title="GetCpuType"></a>GetCpuType</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	获取 CPU 类型</span><br><span class="line"> *	返回存在的SSE支持级别。</span><br><span class="line"> *  它可用于识别CPU类型。</span><br><span class="line">*/</span><br><span class="line">FwCpuType fwGetCpuType();</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="GetCpuClocks"><a href="#GetCpuClocks" class="headerlink" title="GetCpuClocks"></a>GetCpuClocks</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 获取 CPU 时钟周期</span><br><span class="line"> * Fw64u 表示 64位 unsigned int 类型</span><br><span class="line"> * 此功能返回自CPU开机以来经过的CPU时钟周期数。</span><br><span class="line"> * 可以通过在两个不同点调用函数，然后从第二个返回值中减去第一个返回值来计时代码段。</span><br><span class="line">*/</span><br><span class="line">Fw64u fwGetCpuClocks();</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="StaticInit"><a href="#StaticInit" class="headerlink" title="StaticInit"></a>StaticInit</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 初始化为适当的CPU类型</span><br><span class="line"> * 此功能初始化FW内部调度器，</span><br><span class="line"> * 以使用最合适的CPU类型。</span><br><span class="line">*/</span><br><span class="line">FwStatus fwStaticInit();</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="StaticInitCpu"><a href="#StaticInitCpu" class="headerlink" title="StaticInitCpu"></a>StaticInitCpu</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	初始化为指定的CPU类型</span><br><span class="line"> *  参数cpu： 初始化为指定的CPU类型</span><br><span class="line"> *	此函数初始化FW内部调度器以使用指定的CPU类型。</span><br><span class="line">*/</span><br><span class="line">FwStatus	 	fwStaticInitCpu	(	FwCpuType cpu );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="SetNumThreads"><a href="#SetNumThreads" class="headerlink" title="SetNumThreads"></a>SetNumThreads</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *  设置线程数</span><br><span class="line"> *  参数numThr：指定任何Framewave函数可以使用的最大线程数。</span><br><span class="line"> *  此函数定义了任何FW函数可以使用的最大线程数。将numThr设置为1以关闭线程。</span><br><span class="line">*/</span><br><span class="line">FwStatus	 	fwSetNumThreads	(	unsigned int numThr );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="GetNumThreads"><a href="#GetNumThreads" class="headerlink" title="GetNumThreads"></a>GetNumThreads</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	获取线程数</span><br><span class="line"> *	此函数返回任何FW函数可以使用的最大线程数。</span><br><span class="line">*/</span><br><span class="line">Fw32u	 	fwGetNumThreads	(	  );</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="Allocate-memory"><a href="#Allocate-memory" class="headerlink" title="Allocate memory"></a>Allocate memory</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	分配空间</span><br><span class="line"> *	参数length:	指定分配的字节数量</span><br><span class="line"> *	此函数分配一个长度字节的内存缓冲区，并返回一个指针。</span><br><span class="line">*/</span><br><span class="line">void *	 	fwMalloc	(	int length );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="Free"><a href="#Free" class="headerlink" title="Free"></a>Free</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	释放空间</span><br><span class="line"> *	ptr	 	Pointer to a memory buffer.</span><br><span class="line"> *	此函数释放ptr指向的内存缓冲区。</span><br><span class="line">*/</span><br><span class="line">void	 	fwFree	(	void * ptr );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="AlignPtr"><a href="#AlignPtr" class="headerlink" title="AlignPtr"></a>AlignPtr</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	对齐缓冲区</span><br><span class="line"> *	alignBytes	指定对齐的字节数，必须是2的幂。如果值小于2，则返回NULL。 </span><br><span class="line"> *  ptr	指向内存缓冲区的指针。</span><br><span class="line"> *	此函数将ptr指向的缓冲区对齐到指定的对齐边界。</span><br><span class="line"> */</span><br><span class="line"> void *	 	fwAlignPtr	(	void * ptr, int alignBytes );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="SetNumThreads-local"><a href="#SetNumThreads-local" class="headerlink" title="SetNumThreads_local"></a>SetNumThreads_local</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	设置局部的线程数量</span><br><span class="line"> *	numThr	指定任何Framewave函数可以使用的最大线程数。</span><br><span class="line"> *	此功能保留给FW内部使用。</span><br><span class="line">*/</span><br><span class="line">FwStatus	 	fwSetNumThreads_local	(	unsigned int numThr );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	运行？</span><br><span class="line"> *	param	 	Specifies some parameter.</span><br><span class="line"> *	workFn	 	Specifies work function.</span><br><span class="line"> * 	此功能保留给FW内部使用。</span><br><span class="line">*/</span><br><span class="line">void	 	fwRun	(	WorkFn workFn, void* param );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	等待</span><br><span class="line"> *  此功能保留给FW内部使用。</span><br><span class="line">*/</span><br><span class="line">void	 	fwWait	(	  );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="GetInitType"><a href="#GetInitType" class="headerlink" title="GetInitType"></a>GetInitType</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	GetInitType</span><br><span class="line"> *	此功能保留给FW内部使用</span><br><span class="line">*/</span><br><span class="line">int	 	fwGetInitType	(	  );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="BaseData"><a href="#BaseData" class="headerlink" title="BaseData"></a>BaseData</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	BaseData</span><br><span class="line"> *	This function is reserved for FW internal use.</span><br><span class="line">*/</span><br><span class="line">void *	 	fwBaseData	(	  );</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Signal-Processing-Library"><a href="#Signal-Processing-Library" class="headerlink" title="Signal Processing Library:"></a>Signal Processing Library:</h2><p>​	这个库里面的函数大概就是本次作业的重点了，大部分是关于向量加减乘除法的，现在我们看着lab1的代码，直接在手册中找到对应的代码进行替换就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fwsCosh_64f_A53					  MT</span><br><span class="line">fwsAddC_64f_I							MT</span><br><span class="line">fwsMalloc_64f					not	MT</span><br><span class="line">fwsAdd_64f								MT</span><br><span class="line">fwsMulC_64f_I							MT</span><br><span class="line">fwsSqrt_64f								MT</span><br><span class="line">fwsFree								not	MT</span><br><span class="line">fwsThreshold_LT_64f				MT</span><br><span class="line">fwSetNumThreads				not	MT</span><br><span class="line">fwsDivC_64f_I							MT</span><br><span class="line">fwsCopy_64fc							MT</span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/20/parallelComputingLab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/20/parallelComputingLab/" class="post-title-link" itemprop="url">parallelComputingLab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-20 15:35:46" itemprop="dateCreated datePublished" datetime="2023-10-20T15:35:46+08:00">2023-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-21 14:39:53" itemprop="dateModified" datetime="2023-11-21T14:39:53+08:00">2023-11-21</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>48</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Parallel-Computing-Lab-1"><a href="#Parallel-Computing-Lab-1" class="headerlink" title="Parallel Computing Lab_1"></a>Parallel Computing Lab_1</h2><iframe src="../../../../pdf_file/parallelComputingLab/Lab1_report.pdf" style="width:100%; height:800px;" frameborder="0"></iframe>

<h2 id="Parallel-Computing-Lab-2"><a href="#Parallel-Computing-Lab-2" class="headerlink" title="Parallel Computing Lab_2"></a>Parallel Computing Lab_2</h2><iframe src="../../../../pdf_file/parallelComputingLab/Lab2_report.pdf" style="width:100%; height:800px;" frameborder="0"></iframe>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/18/FEMU-STUDY/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/18/FEMU-STUDY/" class="post-title-link" itemprop="url">FEMU_STUDY</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-18 15:40:36" itemprop="dateCreated datePublished" datetime="2023-10-18T15:40:36+08:00">2023-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-21 14:37:39" itemprop="dateModified" datetime="2023-11-21T14:37:39+08:00">2023-11-21</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>31k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>28 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="The-CASE-of-FEMU-Cheap-Accurate-Scalable-and-Extensible-Flash-Emulator"><a href="#The-CASE-of-FEMU-Cheap-Accurate-Scalable-and-Extensible-Flash-Emulator" class="headerlink" title="The CASE of FEMU: Cheap, Accurate, Scalable and Extensible Flash Emulator"></a>The CASE of FEMU: Cheap, Accurate, Scalable and Extensible Flash Emulator</h1><h2 id="FEMU是什么："><a href="#FEMU是什么：" class="headerlink" title="FEMU是什么："></a><code>FEMU</code>是什么：</h2><p>​	<code>femu</code>是一个基于 <code>QEMU</code> 的闪存仿真器，旨在促进未来的全栈软件&#x2F;硬件SSD研究。</p>
<h3 id="问题1-硬件SSD和闪存有什么关系吗？为什么闪存模拟器可以促进全栈软件-x2F-硬件SSD研究？"><a href="#问题1-硬件SSD和闪存有什么关系吗？为什么闪存模拟器可以促进全栈软件-x2F-硬件SSD研究？" class="headerlink" title="问题1:硬件SSD和闪存有什么关系吗？为什么闪存模拟器可以促进全栈软件&#x2F;硬件SSD研究？"></a>问题1:硬件SSD和闪存有什么关系吗？为什么闪存模拟器可以促进全栈软件&#x2F;硬件SSD研究？</h3><blockquote>
<p>​		SSD(固态硬盘)是一种数据存储设备，它使用闪存作为其主要的存储介质</p>
</blockquote>
<h3 id="问题2-为什么要模拟闪存？"><a href="#问题2-为什么要模拟闪存？" class="headerlink" title="问题2:为什么要模拟闪存？"></a>问题2:为什么要模拟闪存？</h3><blockquote>
<p>​		模拟闪存为研究者、开发者和工程师提供了一个灵活、可控的环境，使他们能够在没有实际硬件的情况下进行研究、测试和开发。</p>
</blockquote>
<h3 id="问题3-现有哪些闪存-x2F-SSD仿真器-x2F-模拟器？"><a href="#问题3-现有哪些闪存-x2F-SSD仿真器-x2F-模拟器？" class="headerlink" title="问题3: 现有哪些闪存&#x2F;SSD仿真器&#x2F;模拟器？"></a>问题3: 现有哪些闪存&#x2F;SSD仿真器&#x2F;模拟器？</h3><blockquote>
<ol>
<li><p>DiskSim’s SSD：</p>
<ul>
<li>DiskSim是一个相当受欢迎的、由微软研究院开发的磁盘系统仿真器。</li>
<li>它最初是为磁盘驱动器设计的，但后来又增加了对固态硬盘(SSD)的仿真支持。</li>
<li>DiskSim可以仿真现实中的磁盘驱动器或SSD的性能，并帮助研究人员和工程师进行存储系统设计、优化和评估。</li>
</ul>
</li>
<li><p>FlashSim</p>
<ul>
<li>FlashSim是一个针对NAND闪存的仿真器。</li>
<li>它仿真闪存的基本操作，如读、写和擦除，以及其他与闪存有关的特性和行为。</li>
<li>FlashSim是为了研究和开发针对闪存的管理策略和算法（如垃圾收集和擦写均衡）而设计的。</li>
</ul>
</li>
<li><p>SSDSim</p>
<ul>
<li>SSDSim是一个专门为固态硬盘(SSD)设计的仿真器。</li>
<li>它考虑了SSD的各种组件和特性，如控制器、缓存和多通道&#x2F;多飞道操作。</li>
<li>与FlashSim不同，SSDSim更关注整个SSD设备的仿真，而不仅仅是闪存。</li>
</ul>
</li>
<li><p>FPGA boards</p>
<ul>
<li>PGA（Field-Programmable Gate Array）是一种可以由用户在购买后进行配置的集成电路。</li>
<li>FPGA板卡通常包含一个或多个FPGA芯片、电源、记忆体、I&#x2F;O接口以及其他必要的电子元件。</li>
<li>FPGA被广泛应用于原型设计、硬件加速、数字信号处理、嵌入式系统等领域，因为它们提供了一种在硬件级别自定义设计的能力。</li>
</ul>
</li>
<li><p>OpenSSD</p>
<ul>
<li>OpenSSD项目是一个开源项目，提供了关于固态硬盘(SSD)控制器的参考设计和源代码。</li>
<li>该项目旨在推动学术界和工业界对SSD技术的研究和创新。</li>
<li>OpenSSD为研究者提供了一个实验平台，使他们能够开发和测试新的算法、策略和技术，而无需从零开始构建SSD控制器。</li>
</ul>
</li>
<li><p>OpenChannel SSD</p>
</li>
</ol>
<ul>
<li>OpenChannel SSD是一种新的SSD架构，它允许主机操作系统直接管理SSD的物理块。</li>
<li>传统的SSD随机地在内部闪存块之间移动数据来实现擦除均衡和性能优化，这是通过一个称为Flash Translation Layer (FTL)的软件组件来实现的。OpenChannel SSD通过移除或简化FTL，允许更直接的控制，从而为应用提供更高的性能和更低的延迟。</li>
<li>OpenChannel SSD需要特殊的驱动和支持，如Linux内核中的LightNVM。</li>
</ul>
<ol start="7">
<li><p>基于QEMU的VSSIM</p>
<p>​	is a QEMU&#x2F;KVM-based platform that emulates NAND flash latencies on a RAM disk, and has been used in several papers. The major drawback of VSSIM is that it is built within QEMU’s IDE interface im- plementation, which is not scalable. The upper-left red line (IDE line) in Figure 2a shows the user-perceived IO read latency through VSSIM without any NAND-delay emulation added. More concurrent IO threads (x-axis) easily multiply the average IO latency (y-axis). For ex- ample from 1 to 4 IO threads, the average latency spikes up from 152 to 583μs. The root cause is that IDE is not supported with virtualization optimizations.</p>
</li>
<li><p>FlashEm</p>
<p>​	is an emulator built in the Linux block level layer, hence less portable; it is rigidly tied to its Linux version; to make changes, one must modify Linux kernel. FlashEm is not open-sourced and its development stopped two years ago (confirmed by the creators).</p>
</li>
<li><p>LightNVM的QEMU </p>
<p>​	is still in its early stage. Currently, it cannot emulate multiple channels (as in OpenChannel SSD) and is only used for basic testing of 1 target (1 chip behind 1 channel). Worse, LightNVM’s QEMU performance is not scalable to emulate NAND latencies as it depends on vanilla QEMU NVMe interface.</p>
</li>
</ol>
</blockquote>
<h3 id="问题4-既然已经有这些多仿真器了，那我们为什么要提出FEMU？"><a href="#问题4-既然已经有这些多仿真器了，那我们为什么要提出FEMU？" class="headerlink" title="问题4: 既然已经有这些多仿真器了，那我们为什么要提出FEMU？"></a>问题4: 既然已经有这些多仿真器了，那我们为什么要提出<code>FEMU</code>？</h3><blockquote>
<p>因为上述1-3的模拟器均<strong>only support internal-SSD research but not kernel-level extensions.</strong></p>
<p>这句话的原因是：</p>
<ul>
<li><p>这些仿真器重点关注的是如何在SSD内部处理请求、如何进行数据放置、垃圾收集、擦除均衡等。它们为研究者提供了一个详细、精确的工具，以研究和优化这些内部过程。</p>
</li>
<li><p>然而，SSD的性能和行为不仅仅是由其内部结构决定的。当一个应用或操作系统向SSD发出I&#x2F;O请求时，该请求首先会经过操作系统的I&#x2F;O堆栈，包括文件系统、块层、驱动等。操作系统中的这些组件也会影响I&#x2F;O的性能和行为。</p>
</li>
</ul>
<p> 所以对这句话更详细的解释应该是：</p>
<ul>
<li>当我们说这些仿真器”only support internal-SSD research but not kernel-level extensions”时，我们是指<strong>它们不模拟整个I&#x2F;O路径，特别是操作系统层面的部分。这意味着，如果你想研究如何修改文件系统或块层来优化SSD性能，这些仿真器可能不会为你提供足够的信息或支持。</strong></li>
</ul>
<p>而上述4-6的模拟器则<strong>support full-stack software&#x2F;hardware research but their high costs (thousands of dollars per de- vice) impair large-scale SSD research.</strong></p>
<p>最后提到的7-9硬件平台虽然更经济，但<strong>它们要么已经过时，要么不可扩展，要么并不是开源的</strong>。其中，对于可扩展的理解是，<code>VSSIM</code>只支持<code>IDE(Integrated Drive Electronics)</code>硬件接口技术，我们或许需要增加SATA、NVMe等接口。</p>
<p>所以我们要提出的<code>FEMU</code>，有下述优点:</p>
<ol>
<li><p><strong>Cheap:</strong> open-sourced software</p>
</li>
<li><p>**(relatively) Accurate: ** 0.5-38% variance in our tests</p>
</li>
<li><p><strong>Scalable:</strong> 由于我们使用了各种技术来优化QEMU栈，例如无退出中断和跳过QEMU AIO组件，FEMU可以扩展到32个IO线程，同时仍然实现低延迟（在2.3GHz的CPU下延迟低至52微秒）。因此，FEMU可以准确地模拟32个并行通道&#x2F;芯片，而不会产生不希望的排队延迟。</p>
</li>
<li><p><strong>Extensible:</strong> 对于可扩展性，我的理解是，在使用<code>FEMU</code>模拟器时会有一个<code>guest os</code>(即运行在虚拟机中的操作系统)和一个<code>host os</code>(即宿主操作系统)。如下图所示，<code>FEMU</code>基于<code>QEMU</code>运行在<code>host os</code>，我们要模拟的<code>guest os</code>运行在虚拟机(VM)上，通过’NVMe(Non-Volatile Memory express)’接口访问<code>FEMU</code>（因为<code>FEMU</code>是一个<code>NVMe SSD</code>的模拟器）。因此 <code>FEMU</code>运行研究人员在<code>guest os</code>上进行内核级的改变，借口级的改变，和<code>FTL（Flash Translation Layer</code>）级的改变。</p>
<p><img src="/../images/FEMU-STUDY/%E6%88%AA%E5%B1%8F2023-10-21%2010.12.04.png" alt="截屏2023-10-21 10.12.04"></p>
<p>同时，<strong>FEMU also provides many new features not existent in other emulators, such as OpenChannel and multi-device&#x2F;RAID support, extensible interfaces via NVMe commands, and page-level latency variability.</strong></p>
</li>
</ol>
</blockquote>
<p>​	</p>
<h2 id="设计FEMU的主要挑战和解决办法："><a href="#设计FEMU的主要挑战和解决办法：" class="headerlink" title="设计FEMU的主要挑战和解决办法："></a>设计<code>FEMU</code>的主要挑战和解决办法：</h2><ol>
<li><h3 id="scalability："><a href="#scalability：" class="headerlink" title="scalability："></a>scalability：</h3><ul>
<li><strong>问题1：</strong><code>QEMU</code> 通过传统的 <code>trap-and-emulate</code>方式仿真IO<code>。当客户机的</code>NVMe<code>驱动向设备</code>(QEMU)这里的情况是因为客户机(guest os)是运行在QEMU仿真的环境上<code>发出</code>ring the doorbell<code>的信号，用于表示设备队列中有一些IO请求。由于该</code>doorbell<code>表示一个</code>memory mapped input output<code>操作，这将会导致 </code>VM-exit(word switch)<code> 即从客户机到</code>QEMU<code>的转换。同样，当</code>IO&#96;请求完成时，也会存在一样的切换。</li>
<li><strong>问题2：</strong><code>QEMU</code>使用<code>异步IO（AIO）</code>执行实际读&#x2F;写（字节传输）到备份图像文件。此AIO组件用来避免QEMU被缓慢的IO（例如，在磁盘映像上）阻止。然而，当存储后端是RAM支持的映像时，AIO开销变得很重要。</li>
<li><strong>解决办法</strong>：<ol>
<li>首先将<code>QEMU</code>的中断转换为基于轮询的设计，并在<code>guest os</code>中禁止通过<code>doorbell write</code>的操作。并在<code>QEMU</code>中创建一个专门的线程，用来持续轮询设备队列的状态。以这种方式，<code>guest os</code> 仍将控制权交给<code>QEMU</code>并且不会有昂贵的<code>word switch</code>。</li>
<li>同样，我们将不使用<code>virual image file</code>（这一思想是为了避免进入<code>AIO</code>模块），我们通过在<code>QEMU&#39;s heap space</code>创建一个 <code>RAM-backed storage</code> (笔者认为这个操作类似于在安装操作系统时为操作系统划分物理空间)。然后修改<code>QEMU</code>中的<code>DMA emulator logic</code>，将数据读取或者写入到上面模拟的<code>RAM-backed storage</code>，在整个过程中，<code>guest os</code>并不会意识到它已经将数据写到了我们规定的<code>RAM-backed storage</code>中。</li>
</ol>
</li>
<li><strong>实验结果：</strong>在1-32个IO线程之间，<code>FEMU</code>可以在低于52μs的时间内保持IO延迟的稳定，甚至在64个IO线程下保持在90μs以下。 </li>
<li><strong>遗留问题：</strong>剩余的可扩展性瓶颈现在只来自QEMU的单线程“事件循环”，它执行主要的IO例程，如取消设备队列，触发DMA仿真，并将终端IO完成发送到<code>guest os</code>。最近的作品解决了这些限制（有重大变化），但尚未简化为QEMU的主要属性。我们将探索在未来FEMU开发中整合其他解决方案的可能性。</li>
</ul>
</li>
<li><h3 id="accuracy"><a href="#accuracy" class="headerlink" title="accuracy"></a>accuracy</h3><ol>
<li><p><strong>Delay Emulation:</strong></p>
<p>​	<code>FEMU</code>中对<code>IO</code>的延迟模拟采用了一种专用的<code>end-io queue</code>，该队列基于IO完成时间进行排序。当队列中<code>IO</code>的模拟完成时间超过当前时间，将该<code>IO</code>从队列中取出。例如，模拟的<code>IO</code>完成时间是在<code>IO</code>进入时间的基础上加<code>50us</code>。</p>
</li>
<li><p><strong>Basic Delay Model:</strong></p>
<ul>
<li><p>那该如何给出一个准确的<code>IO</code>模拟完成时间呢?</p>
</li>
<li><p><code>channel1</code>的下一次空闲时间，其中 <code>Ttransfer</code>表示给定的页在通道上的传输时间。<br>$$<br>T_{freeOfChannel1}&#x3D;T_{now}+T_{transfer}<br>$$<br>而plane2的下一次空闲时间如下，其中<code>Twrite</code>是给定的一个NAND页面的写&#x2F;program时间<br>$$<br>T_{freeOfPlane2}&#x3D;T_{now}+T_{transfer}+T_{write}<br>$$<br>于是该写操作的<code>end-io time</code>等于 <code>TfreeOfPlane2</code></p>
</li>
<li><p>假设当写操作正在进行时，到同一平面的页面读取到达。在这里，我们会将TfreeOfPlane2增加Tread的值，其中Tread是一个可配置的NAND页面的读取时间，并将TfreeOfChannel1增加Ttransfer的值。这次读取的结束时间将是Tendio&#x3D;TfreeOfChannel1（因为这是一个读取操作，而不是写操作）。</p>
</li>
<li><p>这只是一个简单的延迟模型，模拟了一个单寄存器，统一页面延迟的模型。即每一个plane只有一个页寄存器，因此不支持多IO的并行操作。同时，传输时间，读写时间也被设置为固定的值。</p>
</li>
</ul>
</li>
<li><p><strong>Advanced “OC” Delay Model:</strong></p>
<p>展示了如何扩展我们的模型，并实现对OpenChannel SSD更准确的延迟模拟。</p>
<ul>
<li><p>openChannel的每一个<code>plane</code>使用了两个寄存器<code>(data + cache registers)</code>。<code>data register</code>用于读写、擦除数据。<code>cache register</code>用于传输数据。例如，当数据从NAND页面读取到数据寄存器时，另一组数据可以从缓存寄存器传输到通道，或者相反。这种设计增加了并行性，因为两个操作可以在同一个时间段内同时进行，而不是顺序进行。</p>
</li>
<li><p>第二，OpenChannel (OC) 使用一个非均匀页面延迟模型。具体来说，映射到MLC单元的上位位（“上层”页面）的页面比映射到下位位（“下层”页面）的页面具有更高的延迟。例如，下层&#x2F;上层页面的读取时间分别为48&#x2F;64微秒，而写入时间则为900&#x2F;2400微秒。更为复杂的是，每个NAND块中的512个页面并不是以“LuLuLuLu…”的方式均匀交错映射的，而是以特定的方式映射，即“LLLLLLuLLuLLuu…”。其中，页面#0-6是映射到下层页面，页面#7和#10到#8-9是映射到上层页面，其余的页面有“LLuu”的重复模式。</p>
</li>
<li><p>“lower bits” 和 “lower” pages 指的是MLC（Multi-Level Cell）NAND闪存中的较低电压状态或较低的存储位。MLC闪存可以在每个单元中存储多个比特，通常是2比特。这些比特可以表示四种不同的电压状态，从而允许存储4个不同的值。</p>
<p>在MLC中，每个单元有两个比特：一个是“upper bit”（上位比特），另一个是“lower bit”（下位比特）。由于读取和编程的方式，这两个比特可能具有不同的延迟特性。</p>
<ul>
<li>“lower pages”：与MLC单元的“lower bits”相关联的页面。</li>
<li>“upper pages”：与MLC单元的“upper bits”相关联的页面。</li>
</ul>
<p>由于MLC的物理和电气特性，通常“upper”页面的读取和写入延迟要比“lower”页面的延迟更高。这是由于MLC的工作机制，特别是在编程和读取多个电压状态时的复杂性。这种差异经常需要在闪存管理和调度策略中进行特别处理，以最大化性能并平衡耐用性。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="increasing-usability-and-extensibility"><a href="#increasing-usability-and-extensibility" class="headerlink" title="increasing usability and extensibility"></a>increasing usability and extensibility</h3><h3 id="FEMU是可以被扩展的："><a href="#FEMU是可以被扩展的：" class="headerlink" title="FEMU是可以被扩展的："></a><code>FEMU</code>是可以被扩展的：</h3><ul>
<li><p>FTL and GC schemes：<code>FTL</code>使用<code>dynamic mapping</code>。可以用 <code>FEMU</code>对比不同的 <code>garbage collection</code>策略，如 <code>controller-blocking</code>，<code>channel-blocking</code>，<code>plane-blocking</code>。</p>
</li>
<li><p>White-box vs. Black-box：FEMU 可以被用来模拟白盒设备，例如<code>OpenChannel SSD</code>，即设备将物理页面地址直接暴露给操作系统，且<code>FTL</code>层被操作系统管理，例如Linux LightNVM。而黑盒设备，如商用SSDs，FTL层驻留在FEMU中，只有逻辑地址被暴露给操作系统。</p>
</li>
<li><p>Multi-device support for flash-array research: FEMU可配置为在<code>guest os</code>中显示为多个设备。例如，如果FEMU暴露了4个SSD，在FEMU内部，单个QEMU实例中将有4个单独的NVMe实例和FTL结构（没有重叠通道）。以前的模拟器（VSSIM和LightNVM的QEMU）不支持这一点。</p>
</li>
<li><p>Extensible OS-SSD NVMe commands:</p>
<p>可以为NVMe添加更多的OS-to-SSD 命令。</p>
</li>
<li><p>Page-level latency variability:</p>
</li>
</ul>
<p>  FEMU支持页面级别的延迟可变性。</p>
<ul>
<li><p>Distributed SSDs: FEMU的多个实例可以很容易地部署在多台机器上（就像运行Linux虚拟机管理程序KVM一样简单），这促进了更大规模的SSD研究。</p>
</li>
<li><p>Page-level fault injection: FEMU除了支持性能相关的研究，也支持闪存可靠性的研究。（例如，通过注入页面级损坏和故障，并观察高级软件堆栈的反应）。</p>
</li>
<li><p>Limitations: FEMU是DRAM支持的，因此无法模拟大容量SSD。此外，对于崩溃一致性研究，FEMU用户必须手动emu-后期“软”崩溃，因为硬重启将擦除DRAM中的数据。此外，如前所述（§3.2），还有提高准确性的空间。</p>
</li>
</ul>
</li>
</ol>
<h2 id="Research-Papers-using-FEMU"><a href="#Research-Papers-using-FEMU" class="headerlink" title="Research Papers using FEMU"></a>Research Papers using FEMU</h2><ol>
<li><p><strong>Holistic and Opportunistic Scheduling of Background I&#x2F;Os in Flash-based SSDs</strong>. <strong>(TC’23)</strong>. Yu Wang, You Zhou, Fei Wu, Yu Zhong, Jian Zhou, Zhonghai Lu, Shu Li, Zhenghong Wang, Changsheng Xie</p>
<blockquote>
<p>​	在从应用程序到基于闪存的SSD的多个存储系统层中，背景 (BG) 任务是不可或缺的。它们发起大量的I&#x2F;O操作，与前台（FG）I&#x2F;O性能产生显著的干扰。我们的关键洞察是，为了减轻这种干扰，需要在整个系统范围内对多源背景I&#x2F;O进行全面调度，而这只能在底层的SSD层实现。只有SSD对所有的FG和BG I&#x2F;O以及关于闪存存储资源的直接信息和控制都有一个全局的视图。因此，我们受到启发，提出了一个新颖的I&#x2F;O调度架构，称为HuFu。它为主机软件提供了一个框架，用于注册BG任务并将其I&#x2F;O调度卸载到SSD。然后，SSD内部的I&#x2F;O调度器优先处理FG I&#x2F;O，而BG I&#x2F;O则通过利用闪存并行性和闲置来有机会地进行调度。为了验证HuFu，我们对RocksDB进行了案例研究，并将其与几种最先进的主机端I&#x2F;O调度方案进行了比较。实验结果显示，HuFu可以显著减轻由BG I&#x2F;O引起的性能干扰并提高SSD带宽利用率，从而提高FG吞吐量、平均和尾部延迟（例如，在写入密集型工作负载中约提高18%）。</p>
</blockquote>
</li>
<li><p><strong>NVMeVirt: A Versatile Software-defined Virtual NVMe Device</strong>. <strong>(FAST’23)</strong>. Sang-Hoon Kim, Jaehoon Shim, Seongyeop Jeong, Jin-Soo Kim</p>
<blockquote>
<p>​	 近期，存储设备领域发生了剧烈的变化。在多种存储景观的中心是NVMe接口，它允许这些新一代设备类型所需的高性能和灵活的通信模型。然而，其以硬件为中心的定义和规范正成为新的革命性存储设备的开发和评估周期的瓶颈。在本文中，我们提出了NVMeVirt，一种促进软件定义NVMe设备的新方法。用户可以定义带有自定义功能的任何NVMe设备类型，而NVMeVirt则允许在软件中将主机I&#x2F;O堆栈和虚拟NVMe设备之间的差距进行桥接。我们通过实现各种存储类型和配置来展示NVMeVirt的优点和功能，例如传统SSD、低延迟高带宽NVM SSD、分区命名空间SSD以及支持PCI对等DMA和NVMe-oF目标卸载的键值SSD。我们还利用NVMeVirt进行存储研究，如研究数据库引擎的性能特征和扩展NVMe规范以提高键值SSD性能。</p>
</blockquote>
</li>
<li><p><strong>DECC: Differential ECC for Read Performance Optimization on High-Density NAND Flash Memory</strong>. <strong>(ASPDAC ‘23)</strong>. Yunpeng Song, Yina Lv, Liang Shi</p>
<blockquote>
<p>​	由于其高密度，采用 先进的多电平单元技术的3D NAND闪存已被广泛采用，但其可靠性明显降低。为了解决这一可靠性问题，闪存通常采用低密度奇偶校验码（LDPC）作为纠错码（ECC）来编码数据并提供容错能力。对于低码率的LDPC，它可以提供强大的纠错能力，但能耗较高。为避免这一成本，通常采用较高码率的LDPC。当访问的数据未成功解码时，LDPC将依赖读重试操作来提高纠错能力。但是，读重试操作会导致读取性能下降。在这项工作中，我们提出了一种差分ECC（DECC）方法来提高读取性能。DECC的基本思想是为具有不同访问特性的数据采用不同码率的LDPC。具体来说，当数据因可靠性而被热读和重试时，将采用低码率的LDPC来优化性能。通过这种方法，最大程度地减少了低码率LDPC的成本并优化了性能。通过在3D三电平单元（TLC）NAND闪存上对真实工作负载的仔细设计和评估，DECC实现了鼓舞人心的读取性能优化。</p>
</blockquote>
</li>
<li><p><strong>ConfZNS : A Novel Emulator for Exploring Design Space of ZNS</strong>. <strong>(SYSTOR’23)</strong>. Inho Song, Myounghoon Oh, Bryan S. Kim, Seehwan Yoo, Jaedong Lee, Jongmoo Choi</p>
<blockquote>
<p>​	ZNS（分区命名空间）接口将大部分存储维护责任从底层的SSD（固态驱动器）转移到了主机。此外，它为在硬件和软件级别利用SSD的内部并行性提供了新的机会。通过调整区域与SSD内部资源之间的映射并控制线程之间的区域分配，ZNS SSD在并行性和隔离性之间提供了明显的性能权衡。为了理解和探索ZNS SSD的设计空间，我们提出了基于QEMU的易于配置和时序精确的模拟器ConfZNS（可配置的ZNS）。ConfZNS允许用户研究各种ZNS SSD的内部架构以及它如何与现有的主机软件配合工作。我们使用真实的ZNS SSD验证了ConfZNS的准确性，并探索了使用诸如RocksDB、F2FS和Docker环境等真实应用程序的不同ZNS SSD设计的性能特性。</p>
</blockquote>
</li>
<li><p><strong>Optimizing Data Migration for Garbage Collection in ZNS SSDs</strong>. <strong>(DATE’23)</strong>. Zhenhua Tan, Linbo Long, Renping Liu, Congming Gao, Yi Jiang, Yan Liu</p>
<blockquote>
<p>ZNS SSD将垃圾回收（GC）的责任转移到了主机。然而，在GC中的数据迁移需要先将数据移至主机的缓冲区，然后再写回到新的位置，导致了不必要的端到端传输开销。此外，由于区域和块之间的预配置映射，GC需要在区域之间执行大量不必要的块到块的数据迁移。为了解决这些问题，本文提出了一种简单且高效的数据迁移方法，名为IS-AR，具有存储内数据迁移和地址重映射功能。基于全栈SSD模拟器，我们的评估显示IS-AR平均降低了6.78倍的GC延迟，并提高了1.17倍的SSD寿命。</p>
</blockquote>
</li>
<li><p><strong>zCeph: Achieving High Performance On Storage System Using Small Zoned ZNS SSD</strong>. <strong>(SAC’23)</strong>. Jin Yong Ha, Heon Young Yeom</p>
<blockquote>
<p>​	ZNS SSD（分区命名空间SSD）是块设备，通过强制顺序写入提供稳定的性能和低价格，但用户必须付出代价来保证强烈的写入顺序。此外，为了从给予用户对设备内部并行元素的控制的小分区ZNS SSD中获得最佳性能，用户需要详细地使用SSD。由于这些开销，与使用传统SSD相比，使用ZNS SSD的分布式存储系统之一Ceph的性能降低了高达69%。在本文中，我们提出了zCeph，它解决了在存储系统中使用小分区ZNS SSD时出现的问题。我们基于传统的Ceph实现了zCeph，并使用合成和真实工作负载对其进行了评估，结果显示，与使用ZNS SSD的传统Ceph相比，性能分别提高了最多4.1倍和7倍。</p>
</blockquote>
</li>
<li><p><strong>Design of a High-Performance, High-Endurance Key-Value SSD for Large-Key Workloads</strong>. <strong>(IEEE CAL’23)</strong>. Chanyoung Park, Chun-Yi Liu, Kyungtae Kang, Mahmut Kandemir, Wonil Choi</p>
<blockquote>
<p>​	当前的KV-SSD设计假设了一定范围的典型工作负载，其中值的大小相对较大，而键的大小相对较小。然而，我们发现：(i) 存在另一种工作负载，其键的大小相对于其值的大小较大；(ii) 在这种大键工作负载下，当前的KV-SSD设计遭受长尾延迟和低存储利用率的问题。为此，我们提出了一种新颖的KV-SSD设计（称为LK-SSD），它可以在大键工作负载下减少尾部延迟并提高存储利用率，并为其增加了增强功能以延长设备寿命。通过广泛的实验，我们展示了LK-SSD更适合大键工作负载，同时也适用于典型工作负载。</p>
</blockquote>
</li>
<li><p><strong>CFIO: A conflict-free I&#x2F;O mechanism to fully exploit internal parallelism for Open-Channel SSDs</strong>. <strong>(JSA’23)</strong>. Jinbin Zhu, Liang Wang, Limin Xiao, Lei Liu, Guangjun Qi</p>
<blockquote>
<p>​	I&#x2F;O访问冲突严重降低了NVMe SSDs的利用率，导致其性能损失不可预测。尽管现有的研究采用I&#x2F;O隔离或冲突感知的I&#x2F;O调度来避免访问冲突，但它们可能导致利用率不平衡并减少NVMe SSDs的寿命。在本文中，我们设计并实现了CFIO，一个低开销的冲突感知I&#x2F;O机制，实现了无冲突的I&#x2F;O，以利用NVMe SSDs中的内部并行性。CFIO通过两种新颖的机制提高了PU利用率并减少了I&#x2F;O延迟。首先，提出了一个无冲突（CF）通道，通过根据物理地址将I&#x2F;O请求划分到无冲突的PU队列中，以消除冲突。这些PU队列对应于NVMe SSDs内的PU资源。其次，设计了一个k-RR调度器，批量地并分别将读写请求分派到NVMe SSDs。K-RR调度器可以充分利用NVMe SSDs的内部并行性，并基于PU的双寄存器形成一个I&#x2F;O流水线。最后，我们将CFIO集成到带有Open-Channel NVMe SSD (OCSSD) 的LightNVM中，并与几种现有的解决方案进行比较。我们的评估显示，与最先进的方法相比，CFIO提高了OCSSD的吞吐量19.32%，并将其尾部延迟降低了23.71%。</p>
</blockquote>
</li>
<li><p><strong>An Efficient F2FS GC Scheme for Improving I&#x2F;O Latency of Foreground Application</strong>. <strong>(ICCE’23)</strong>. Manjong Lee, Jonggyu Pa, Young Ik Eom</p>
<blockquote>
<p>​	近年来，由于其迷人的功能，ZNS吸引了移动设备制造商，并预计将合并到移动I&#x2F;O子系统中。与此同时，由于F2FS采用了只追加写入策略，因此它是支持移动设备中ZNS的可行选项之一。然而，F2FS在文件系统级的垃圾收集（GC）上表现不佳，这增加了前台应用的尾部延迟。为了克服这个问题，我们提出了一种新的F2FS GC方案，当这样做有利时，该方案会抢占正在进行的GC，以防止前台应用等待过长时间。我们的评估表明，与传统的F2FS GC方案相比，我们的方案将前台应用的尾部延迟减少了高达87%。</p>
</blockquote>
</li>
<li><p><strong>SimBricks: End-to-End Network System Evaluation with Modular Simulation</strong>. <strong>(SIGCOMM’22)</strong>. Hejing Li, Jialin Li, Antoine Kaufmann</p>
<blockquote>
<p>​	在物理测试环境中进行的全系统“端到端”测量是网络系统评估的金标准，但往往不可行。当没有物理测试环境时，我们经常转向仿真进行评估。遗憾的是，现有的模拟器对于端到端评估来说是不足够的，因为它们要么不能模拟所有组件，要么模拟它们的细节不足。我们通过模块化仿真来解决这个问题，灵活地组合和连接多个现有的模拟器，用于不同的组件，包括处理器和内存、设备和网络，形成针对每个用例调优的虚拟端到端测试环境。我们的架构，SimBricks，结合了明确定义的组件接口，用于扩展性和模块化，高效的通信通道，用于本地和分布式仿真，以及一个共同设计的高效同步机制，用于跨模拟器的精确时序。我们展示SimBricks可以扩展到1000个模拟主机，每个都运行着完整的软件堆栈，包括Linux，而且它可以模拟具有现有NIC和交换机RTL实现的测试环境。我们还在SimBricks中再现了先前关于拥塞控制、NIC架构和网络内计算的关键发现。</p>
</blockquote>
</li>
<li><p><strong>Meta-Block: Exploiting Cross-Layer and Direct Storage Access for Decentralized Blockchain Storage Systems</strong>. <strong>(TC’22)</strong>. Yi Wang, Jing Liao, Jing Yang, Zhengda Li, Chenlin Ma, Rui Mao</p>
<blockquote>
<p>​	去中心化存储系统，如基于区块链的存储应用，采用分布式存储技术，并使用分布式存储节点存储持久数据。对于每个链下存储节点，通常使用键值（KV）存储来管理数据。作为KV存储的最常见数据结构，日志结构化合并树（LSM-Tree）消除了随机写操作，同时保持了可接受的读性能。尽管基于LSM-Tree的去中心化存储系统可以提供安全可靠的存储平台，但区块链应用的独特特性并没有得到充分利用。在区块链存储应用中，KV存储的键的生成是基于加密数据的。一个固态硬盘（SSD）中的物理块可能会被不同系统用户的数据填充，这种混合工作负载会导致SSD物理空间的低效使用，并为LSM-Tree引起额外的压缩操作。本文提出了Meta-Block，一种针对去中心化区块链存储应用的跨层和高效的存储管理策略。目标是捕获区块链存储应用的特点，并减少不同存储层之间不必要的读写操作。作为一个跨层设计，Meta-Block重新设计了LSM-Tree的组织，可以有效地减少写放大。我们还设计了一个数据预取策略，以加速索引并启用直接存储访问。通过一系列广泛的实验，我们展示了所提技术的可行性。实验结果表明，与代表性方案相比，Meta-Block可以有效地减少写放大并延长SSD的寿命。</p>
</blockquote>
</li>
<li><p><strong>Improving the Reliability of Next Generation SSDs using WOM-v Codes</strong>. <strong>(FAST’22)</strong>. Shehbaz Jaffer, Kaveh Mahdaviani, Bianca Schroeder. <strong>(Best Paper Award)</strong></p>
<blockquote>
<p>​	高密度固态硬盘，如QLC驱动器，提供了增加的存储容量，但其编程和擦除（P&#x2F;E）周期减少了一个数量级，限制了它们的耐用性和可用性。我们介绍了非二进制的基于电压的一次性存储（WOM-v）代码的设计和实现，以提高QLC驱动器的使用寿命。首先，我们开发了一个基于FEMU的模拟器测试平台，以评估WOM-v代码在实际工作负载上的收益。其次，我们提出并实施了两种优化，一个高效的垃圾收集机制和一个编码优化，以极大地提高WOM-v代码的耐用性，同时不影响性能。通过仔细评估，包括微基准测试和基于迹线的评估，结果表明WOM-v代码可以为实际工作负载减少QLC驱动器的擦除周期4.4 x-11.1 x，带有最小的性能开销，从而提高QLC SSD的使用寿命。</p>
</blockquote>
</li>
<li><p><strong>Generating Realistic Wear Distributions for SSDs</strong>. <strong>(HotStorage’22)</strong>. Ziyang Jiao, Bryan S. Kim</p>
<blockquote>
<p>​	我们介绍了FF-SSD，一个基于机器学习的SSD老化框架，可以生成代表性的未来磨损状态。FF-SSD准确性高（相似度高达99%）、效率高（加速模拟时间2倍）、并且模块化（可以与现有的模拟器和仿真器集成）。</p>
</blockquote>
</li>
<li><p><strong>When F2FS Meets Address Remapping</strong>. <strong>(HotStorage’22)</strong>. Yongmyung Lee, Jong-Hyeok Park, Jonggyu Park, Hyunho Gwak, Dongkun Shin, Young Ik Eom, Sang-Won Lee</p>
<blockquote>
<p>​	虽然在移动设备中越来越受欢迎，但F2FS（一个针对闪存友好的日志结构文件系统变种）揭示了三个缺点：段清理开销、元数据更新开销和文件碎片化，这在随机更新工作负载下变得尤为明显。本文首次建议在闪存中利用地址重映技术来弥补F2FS中的这些缺陷。我们的方法在保留日志结构写入的好处的同时，可以实现就地更新的最终效果，完全防止F2FS的三个缺陷。因此，它在随机更新工作负载下可以显著优于ext4和原始F2FS。配备了另一种写入模式，F2FS将在更广泛的应用范围内变得有竞争力。</p>
</blockquote>
</li>
<li><p><strong>TailCut: Improving Performance and Lifetime of SSDs Using Pattern-Aware State Encoding</strong>. <strong>(DAC’22)</strong>. Jaeyong Lee, Myungsunk Kim, Wonil Choi, Sanggu Lee, Jihong Kim</p>
<blockquote>
<p>​	尽管在3D NAND闪存中，横向电荷扩散被视为主要的误差来源，但我们对其在存储系统级别的详细特性知之甚少。从设备特性研究中，我们观察到横向电荷扩散强烈依赖垂直相邻的状态模式，并且少数特定模式对于横向电荷扩散的位错误负有很大的责任。我们提出了一种新的状态编码方案，称为TailCut，它通过修改编码状态来删除容易受到影响的状态模式。通过删除容易受到影响的模式，TailCut可以分别提高SSD的使用寿命和读取延迟，增长率达到80%和25%。</p>
</blockquote>
</li>
<li><p><strong>Selective Power-Loss-Protection Method for Write Buffer in ZNS SSDs</strong>. <strong>(Electronics’22)</strong>. Junseok Yang, Seokjun Lee, Sungyong Ahn</p>
<blockquote>
<p>​	大多数SSD（固态硬盘）使用内部DRAM（动态随机存取内存）来提高I&#x2F;O性能，并通过吸收写请求来延长SSD的寿命。然而，在突然断电的情况下，这种易失性存储器不能保证缓冲数据的持久性。因此，高可靠性的企业级SSD采用断电保护（PLP）逻辑，利用电容的备用电源来确保缓冲数据的耐久性。SSD必须根据易失性缓冲区的大小为PLP提供足够的电容。与此同时，新兴的ZNS（分区命名空间）SSD正受到关注，因为它们可以支持多租户系统中有用的多个I&#x2F;O流。虽然ZNS SSD不使用内部映射表，与传统的块接口SSD不同，但需要一个大的写缓冲区来提供多个I&#x2F;O流。原因是每个I&#x2F;O流都需要自己的写缓冲区来进行写缓冲，其中主机可以为不同的I&#x2F;O流分配不同的区域。此外，ZNS SSD支持的容量越大，I&#x2F;O流越多，所需的写缓冲区就越大。然而，写缓冲区的大小取决于电容量，这不仅受到SSD内部空间的限制，而且受到成本的限制。因此，在本文中，我们提出了一套技术，它可以在确保在突然断电时缓冲数据的耐久性的同时，显著减少ZNS SSD所需的电容量。首先，我们注意到现代文件系统或数据库都有自己的数据恢复解决方案，如WAL（预写式日志）和日志。因此，我们提出了一种选择性断电保护方法，只确保数据恢复所需的WAL或日志的耐久性，而不是整个缓冲数据。其次，为了最小化PLP所需的时间，我们提出了一种平衡刷新方法，该方法将缓冲数据暂时写入多个区域以最大化并行性，并在恢复电源时保留数据在其原始位置。所提出的方法通过修改FEMU（基于QEMU的Flash仿真器）和RocksDB来实现和评估。根据实验结果，所提出的选择性PLP在保持ZNS SSD的可靠性的同时，将电容量减少了50%到90%。此外，平衡刷新方法将PLP延迟减少了高达96%。</p>
</blockquote>
</li>
<li><p><strong>CoDiscard: A Revenue Model based Cross-layer Cooperative Discarding Mechanism for Flash Memory Devices</strong>. <strong>(JSA’22)</strong>. Xiaoliu Feng, Xianzhang Chen, Ruolan Li, Jiali Li, Chunlin Song, Duo Liu, Yujuan Tan, Lei Qiao</p>
<blockquote>
<p>​	在闪存中的写放大是一个严重的问题，它缩短了闪存的寿命并降低了其性能。TRIM命令被提出来通过避免在闪存设备中进行不必要的重定位来减少写放大。然而，巨大的开销导致当I&#x2F;O忙时，常见的文件系统完全禁止使用TRIM命令。这种完全禁止的TRIM策略不仅影响了闪存设备的寿命，而且由于巨大的写放大，降低了性能。在本文中，我们提出了CoDiscard，一个基于收益模型的跨层协作丢弃机制，用于优化I&#x2F;O性能并在密集工作负载下减少写放大。CoDiscard的核心思想是将高性价比的TRIM命令筛选到闪存设备，因为它们可以显著减少写放大，从而提高性能。为了识别这样的TRIM命令，我们提出了一个收益模型来预测写放大减少和相应的开销。基于收益模型，CoDiscard采用了一个跨层协作方案来调度TRIM命令。文件系统中的CoDiscard调度器负责做出决策。闪存设备中的CoDiscard监视器用于监控与收益模型相关的信息变化。我们在真实工作负载下进行了实验。结果显示，性能提高了113%和118.4%，写放大减少了最多12.12和8.18。</p>
</blockquote>
</li>
<li><p><strong>NASA: NVM-Assisted Secure Deletion for Flash Memory</strong>. <strong>(TCAD’22)</strong>. Weidong Zhu, Kevin R. B. Butler</p>
<blockquote>
<p>​	在基于闪存的存储中，安全删除对于数据安全至关重要。然而，现有的针对闪存的安全删除方案存在性能下降和可靠性问题，无法提供安全删除保证。尽管新兴的非易失性内存（NVM）允许就地更新并提供高性能，但它无法完全替代闪存，因此无法解决安全删除问题。在本文中，我们提出了一个针对闪存的NVM辅助安全删除方案（NASA），这是一个没有陈旧数据的存储系统，它结合了NVM和闪存，旨在为SSDs提供即时的安全删除，而不会导致显著的性能下降。NASA使用块擦除为闪存提供安全删除保证，并利用NVM来隐藏耗时的擦除操作。我们证明，除非考虑到NVM的独特特性，否则仅实现现有的安全删除方法的方案最终将在其存储介质中留下陈旧的数据副本。此外，我们使用不同的真实工作负载评估NASA，并证明与LRU相比，NASA增加了0.01%的平均延迟，并比FIFO缓存策略减少了2.1%的平均延迟。NASA是一个提供强大的安全删除保证和高性能的新型存储系统。</p>
</blockquote>
</li>
<li><p><strong>Understanding and Exploiting the Full Potential of SSD Address Remapping</strong>. <strong>(TCAD’22)</strong>. Qiulin Wu, You Zhou, Fei Wu, Hong Jiang, Jian Zhou, Changsheng Xie.</p>
<blockquote>
<p>​	存储系统中的重复写入是普遍存在的，来源于数据重复、日志记录和数据重新定位等。由于基于闪存的固态硬盘（SSDs）已被广泛部署，重复写入可以显著降低其性能和使用寿命。先前的研究提出了创新的方法，利用SSD内部的地址重映射工具消除重复写入。然而，重映射操作修改了逻辑到物理（L2P）的地址映射表，而在闪存上持续的物理到逻辑（P2L）映射保持不变。L2P和P2L映射之间的这种不一致性可能导致数据损坏，并长期以来一直是使用SSD地址重映射的主要障碍。</p>
<p>​	在本文中，我们提出了一个新颖的SSD设计，称为Remap-SSD-LH，实现了SSD地址重映射的全部潜力。它提供了一个重映射原语，允许主机软件和SSD固件以几乎零成本执行重复数据的逻辑写入。为了确保映射一致性以及快速的映射查找，Remap-SSD-LH采用基于混合存储的本地日志方案。每个闪存垃圾收集单元都维护一个本地日志，用于记录由重映射操作引起的相关P2L映射更改。日志存储在小型的非易失性RAM（NVRAM）中，例如电容保护的DRAM，并且如果NVRAM已满，可以将其写入闪存。</p>
<p>​	我们在一个软件SSD模拟器上验证了Remap-SSD-LH，并进行了三个案例研究：1）SSD内部去重；2）SQLite日志记录；以及3）F2FS清理。实验结果显示，Remap-SSD-LH可以最大限度地并高效地利用地址重映射来提高SSD的性能和使用寿命。</p>
</blockquote>
</li>
<li><p><strong>Finding the Optimal Execution Scheme of External Mergesort on Solid State Drives</strong>. <strong>(World Wide Web 2021)</strong>. Yubiao Chen, Jianzhong Li, Hong Gao</p>
<blockquote>
<p>​	随着基于闪存的固态硬盘(SSDs)逐渐取代机械硬盘(HDDs)成为主流存储，与HDDs不同，SSDs具有丰富的内部并行性，这使得它具有HDDs所没有的出色特性。外部合并排序作为许多系统和算法中采用的外部排序的经典算法，对整体性能有着重要的影响。因此，优化并提高外部合并排序算法的效率具有重要意义。针对SSDs上的原始外部合并排序算法的优化研究相对较少。因此，针对外部合并排序问题，基于SSDs的特点，本文提出了SortDecision算法，该算法可以计算其最优执行方案，包括决定外部合并排序执行过程的合并方式、读缓冲区大小和写缓冲区大小。利用上述最优执行方案，外部合并排序可以获得更好的效率。在SortDecision算法中，SSDs上的外部合并排序问题被形式化并转化为分段凸优化问题。然后，通过枚举每个子凸问题的解来获得最优的外部合并排序方案。实验结果表明，在提供有限内存的情况下，由SortDecision算法指导的外部合并排序与传统的外部合并排序算法相比，可以实现16.7倍的加速。SSDs内部并行资源越丰富，SortDecision的加速效果越好。</p>
</blockquote>
</li>
<li><p><strong>SW-WAL: Leveraging Address Remapping of SSDs to Achieve Single-Write Write-Ahead Logging</strong>, <strong>(DATE’21)</strong>. Qiulin Wu, You Zhou, Fei Wu, Ke Wang, Hao Lv, Jiguang Wan, Changsheng Xie</p>
<blockquote>
<p>​	写前日志 (WAL) 在数据库中被广泛使用，如SQLite和MySQL&#x2F;InnoDB，以提供事务的原子性。然而，WAL导入了重复的写入，即在WAL文件中记录的更改随后会写入到数据库文件中，这称为检查点写入。另一方面，基于NAND闪存的SSDs有一个固有的间接软件层，称为闪存转换层 (FTL)，它在现代存储系统中变得很普遍。已经提出了创新的SSD设计，通过利用FTL来消除WAL的开销，例如提供一个原子写入接口或利用其地址重映射。然而，这些设计引入了维护和持续保存额外的事务信息的显著性能开销，以保证事务的原子性或映射一致性。</p>
<p>​	在本文中，我们提出了单写WAL (SW-WAL)，一个新的跨层设计，用于在SSDs上消除WAL引入的重复写入，带有最小的开销。SSD向主机公开一个地址重映射接口，通过该接口，检查点写入可以在不进行真实数据写入的情况下完成。为了确保事务的原子性和映射一致性，我们让SSD知道对WAL文件的事务写入。具体来说，当事务数据被写入WAL文件时，事务和映射语义从主机传递到SSD，并持久化在相关的闪存页面中作为管理元数据，没有任何额外的开销。我们实现了一个SW-WAL的原型，在一个模拟的NVMe SSD上运行流行的数据库SQLite。实验结果显示，与承受WAL开销的原始SQLite相比，SW-WAL提高了数据库性能高达62%，与消除WAL开销的最新设计相比，提高了高达32%。</p>
</blockquote>
</li>
<li><p><strong>IODA: A Host&#x2F;Device Co-Design for Strong Predictability Contract on Modern Flash Storage</strong>, <strong>(SOSP’21)</strong>. Huaicheng Li, Martin L. Putra, Ronald Shi, Xing Lin, Gregory R. Ganger, Haryadi S. Gunawi</p>
<blockquote>
<p>​	在闪存存储上预测延迟一直是一个长期追求的目标，但由于许多众所周知的SSD内部活动带来的不可避免的干扰，这种不可预测性仍然存在。为了应对这个问题，最近的NVMe IO确定性（IOD）接口主张对SSD内部管理任务进行主机级控制。尽管这很有前景，但如何利用它实现真正可预测的性能仍然面临挑战。</p>
<p>​	我们提出了IODA，一个建立在IOD接口之上的I&#x2F;O确定性闪存阵列设计，通过强大但简单的扩展便于部署。IODA利用IOD上下文中的数据冗余来提供强大的延迟可预测性合约。在IODA中，SSDs预期会故意迅速地使I&#x2F;O失败，以便通过主动的数据重构允许可预测的I&#x2F;O。在并发内部操作的情况下，IODA引入了繁忙剩余时间暴露和可预测延迟窗口的制定，以保证可预测的数据重构。总体上，IODA只增加了5个新字段到NVMe接口和闪存固件中的一个小修改，同时保持主机OS中的大部分复杂性。我们的评估显示，IODA将95-99.99th的延迟提高了高达75倍。与7种最新的抢占、暂停、GC协调、分区、微小尾部闪存控制器、预测和主动方法相比，IODA也是最接近理想的无干扰情况。</p>
</blockquote>
</li>
<li><p><strong>Lightweight Data Lifetime Classification using Migration Counts to Improve Performance and Lifetime of Flash-based SSDs</strong>, <strong>(APSys’21)</strong>. Hyunseung Park, Eunjae Lee, Jaeho Kim, Sam H. Noh</p>
<blockquote>
<p>本文提出了一种策略，有效地根据其寿命对固态硬盘(SSD)中的数据进行分类，以减少基于闪存的存储的写放大。虽然已有许多研究针对数据的生命周期或热度进行分离，但它们要么需要硬件接口支持，要么产生不小的管理开销。特别地，最近提出的多流技术存在一个限制，即数据流必须由主机给出。此外，数据流分离需要用户程序实现或额外的计算。在本文中，我们提出了\sys（基于迁移计数的数据年龄分类），这是一种轻量级且有效的数据生命周期分离策略。具体来说，它利用闪存块的数据移动模式，因此只需可忽略的开销即可有效地进行分类。它是在存储设备级别上实现的，从而不需要对主机进行任何修改。使用各种合成和真实世界的数据库工作负载，我们在FEMU上评估了这种技术，这是一个NVMe SSD模拟器。我们发现它既提高了基于闪存的SSD的性能，也提高了其寿命。</p>
</blockquote>
</li>
<li><p><strong>ZNS+: Advanced Zoned Namespace Interface for Supporting In-Storage Zone Compaction</strong>, <strong>(OSDI’21)</strong>. Kyuhwa Han, Hyunho Gwak, Dongkun Shin, Joo-Young Hwang.</p>
<blockquote>
<p>​	NVMe分区命名空间(ZNS)正逐渐成为一种新的存储接口，其中逻辑地址空间被划分为固定大小的区域，每个区域必须顺序写入以实现对闪存友好的访问。由于ZNS的顺序写入只区域方案，需要日志结构文件系统(LFS)来访问ZNS固态硬盘(SSD)。尽管在当前的ZNS接口下SSD可以被简化，但其对应的LFS必须承受段合并的开销。为了解决这个问题，我们提出了一个新的LFS感知ZNS接口，称为ZNS+，以及其实现，其中主机可以将数据复制操作卸载到SSD以加速段合并。ZNS+还允许每个区域使用稀疏的顺序写请求进行覆盖写入，这使得LFS可以使用基于线程日志的块回收代替段合并。我们还提出了两种针对ZNS+感知LFS的文件系统技术。考虑到SSD内部不同复制路径上的不同复制成本，提出了copyback-aware块分配。混合段回收根据它们的成本，在段合并和线程日志之间选择适当的块回收策略。我们在一个SSD模拟器和一个真实的SSD上实现了ZNS+ SSD。所提出的ZNS+存储系统的文件系统性能比正常的基于ZNS的存储系统好1.33-2.91倍。</p>
</blockquote>
</li>
<li><p><strong>Remap-SSD: Safely and Efficiently Exploiting SSD Address Remapping to Eliminate Duplicate Writes</strong>, <strong>(FAST’21)</strong>. You Zhou, Qiulin Wu, Fei Wu, Hong Jiang, Jian Zhou, Changsheng Xie.</p>
<blockquote>
<p>​	在各种存储系统中，重复写入是普遍存在的，起源于数据重复、日志记录和数据重新定位等。随着基于闪存的SSD被广泛部署，这些写入操作会显著降低其性能和使用寿命。为了消除重复的写入，先前的研究已提出了利用SSD内部地址重映射工具的创新方法。然而，重映射操作导致了映射不一致问题，这可能会导致数据丢失，并且在现有研究中尚未得到妥善解决。在本文中，我们提出了一种名为Remap-SSD的新型SSD设计，具有两个显著特点。首先，它提供了一个重映射原语，允许主机软件和SSD固件以几乎零成本执行重复数据的逻辑写入。其次，采用了混合存储架构来保持映射一致性。小字节可寻址的非易失性RAM（NVRAM）用于以日志结构方式持久化重映射元数据，并与闪存协同管理。我们在一个软件SSD模拟器上验证了Remap-SSD，并进行了三个案例研究：SSD内部去重、SQLite日志记录和F2FS清理。实验结果显示，Remap-SSD可以实现地址重映射的全部潜力，以提高SSD的性能和使用寿命。</p>
</blockquote>
</li>
<li><p><strong>Prolonging 3D NAND SSD Lifetime via Read Latency Relaxation</strong>, <strong>(ASPLOS’21)</strong>. Chun-Yi Liu, Yunju Lee, Myoungsoo Jung, Mahmut Taylan Kandemir, Wonil Choi.</p>
<blockquote>
<p>​	3D NAND的采用显著提高了SSD的密度；然而，如多层电池层的堆叠等3D NAND密度增加技术可能会放大读取干扰并缩短SSD的使用寿命。从我们对8个最先进的SSD的寿命影响特性分析中，我们观察到，由于背景中执行了大量因读干扰引起的重写，3D TLC&#x2F;QLC SSD可能会在其保修期内由低读取工作负载磨损。为了了解其他的读干扰缓解机会，我们还对另外2个没有背景重写机制的SSD进行了读取延迟特性分析。收集的结果表明，没有背景重写，随着数据的读取次数增加，大多数数据的读取延迟都会增加。受到这两种特性分析的启发，本文提议放宽高密度3D SSD上的短读取延迟约束。具体而言，我们的提议依赖于从应用程序传递到SSD的提示信息，该信息指定了预期的读取性能。这样，由读取引起的写入造成的寿命消耗就可以减少，从而延长SSD的使用寿命。详细的实验评估显示，我们的提议可以在文件服务器应用程序下，减少多达56%的重写引起的已用寿命，而性能仅降低2%。</p>
</blockquote>
</li>
<li><p><strong>QBLKe: Host-side flash translation layer management for Open-Channel SSDs</strong>, <strong>Journal of Systems Architecture (2021)</strong>, Hongwei Qin, Dan Feng, Wei Tong, Yutong Zhao, Mengye Peng, Jingning Liu</p>
<blockquote>
<p>​	开放通道SSD (OCSSD) 在高性能存储系统中展现出巨大潜力。现有的应用程序或文件系统依赖基于主机的Flash转换层(FTL)来使用OCSSDs。然而，现有解决方案在多线程工作负载下不能充分发挥OCSSD的性能。在读&#x2F;写关键路径上，我们发现三个组件（环形缓冲区、转换映射和DMA内存池）使用全局自旋锁来实现原子性。自旋锁耗尽CPU时间，从而损害系统的可扩展性。此外，随着OCSSD并行单元数量的增加，现有解决方案的垃圾收集（GC）的粒度也增加。这导致GC期间不必要的页面迁移。在本文中，我们提出QBLKe作为OCSSD基于主机的FTL。QBLKe采用三种技术来提高可扩展性并最小化软件开销：(1) 每CPU环形缓冲区，(2) 无锁转换映射，和(3) 每CPU DMA池。为了进一步减少GC页面迁移和对I&#x2F;O性能的影响，QBLKe实现了每通道GC和一种称为基于评分的速率限制器的新方案。实验结果显示，与现有解决方案相比，QBLKe将写带宽提高了高达78.9%。它还将峰值读IOPS提高了139.31%，GC效率提高了49.11%。</p>
</blockquote>
</li>
<li><p><strong>Better Atomic Writes by Exposing the Flash Out-of-Band Area to File Systems</strong>, <strong>(LCTES’21)</strong>. Hongwei Qin, Dan Feng, Wei Tong, Yutong Zhao, Sheng Qiu, Fei Liu, Shu Li</p>
<blockquote>
<p>​	移动设备的文件系统通常通过有序I&#x2F;O来保持数据的一致性。然而，维护I&#x2F;O顺序阻碍了应用程序充分利用设备的并行性，从而降低了存储性能。在本文中，我们提出NBStack，旨在在不妥协数据一致性的情况下消除有序I&#x2F;O。首先，我们增强现有的块接口，以将Flash的带外区域暴露给文件系统。其次，我们构建了一个增强的块设备原型，支持新的接口。第三，我们开发了NBFS，一个Linux文件系统，利用新的块接口实现原子写入，而不需要强制I&#x2F;O排序。实验结果显示，NBStack的性能是F2FS的两倍，同时提供了强有力的一致性和持久性保证。如果应用程序愿意牺牲持久性，NBStack可以进一步大幅提高性能。</p>
</blockquote>
</li>
<li><p><strong>Determinizing Crash Behavior with a Verified Snapshot-Consistent Flash Translation Layer</strong>, <strong>(OSDI’20)</strong>. Yun-Sheng Chang, Yao Hsiao, Tzu-Chi Lin, Che-Wei Tsao, Chun-Feng Wu, Yuan-Hao Chang, Hsiang-Shang Ko, Yu-Fang Chen.</p>
<blockquote>
<p>​	本文介绍了一个为闪存磁盘设计的快照一致性的闪存转换层(SCFTL)。它比传统设计提供了更强的关于崩溃后可能的行为的保证。具体来说，SCFTL的flush操作还具有制作“磁盘快照”的功能。当发生崩溃时，闪存磁盘保证恢复到最后一次flush操作之前的状态。SCFTL的主要优点是它允许在存储堆栈的上层设计得更高效。例如，建立在SCFTL上的文件系统不需要使用日志进行崩溃恢复。相反，它只需要在每个原子事务结束时执行SCFTL的flush操作。我们使用一个证明助手、一个符号执行器和一个SMT求解器，正式验证我们的SCFTL实现的正确性。我们修改了xv6文件系统以支持组提交，并利用SCFTL更强的崩溃保证。我们使用文件系统基准测试进行评估，结果显示，修改后的xv6在SCFTL上的速度比在传统FTLs上使用日志的xv6快3到30倍，并且在最坏的情况下只比最先进的设置慢两倍：ext4文件系统在物理块设备(pblk) FTL上。</p>
</blockquote>
</li>
<li><p><strong>LeapIO: Efficient and Portable Virtual NVMe Storage on ARM SoCs</strong>, <strong>(ASPLOS’20)</strong>. Huaicheng Li, Mingzhe Hao, Stanko Novakovic, Vaibhav Gogte, Sriram Govindan, Dan R. K. Ports, Irene Zhang, Ricardo Bianchini, Haryadi S. Gunawi, Anirudh Badam.</p>
<blockquote>
<p>​	今天的云存储堆栈对资源的需求极高，消耗了数据中心x86核心的10-20%，这是云服务提供商必须支付的主要”存储税”。然而，复杂的云存储堆栈并不完全适用于当今的IO加速器。我们介绍了LeapIO，一个新的云存储堆栈，它利用基于ARM的协处理器来卸载复杂的存储服务。LeapIO解决了许多部署挑战，如硬件的可替换性、软件的可移植性、可虚拟化性、可组合性和效率。它使用了一套操作系统&#x2F;软件技术和新的硬件属性，这些属性为x86和ARM核心提供了统一的地址空间，并将虚拟NVMe存储暴露给未修改的客户虚拟机，其性能与裸机服务器相媲美。</p>
</blockquote>
</li>
<li><p><strong>DualFS: A Coordinative Flash File System with Flash Block Dual-mode Switching</strong>, <strong>(ICCD’20)</strong>. Bing Wu, Mengye Peng, Dan Feng, Wei Tong.</p>
<blockquote>
<p>​	随着用户对大容量存储的需求持续增长，广泛使用的NAND闪存始终采用每个单元的多位和3D堆叠技术来提高存储密度，但这会损害闪存的性能。现代闪存芯片允许闪存块在多位每单元和一位每单元之间切换，这为从单级单元(SLC，即一位每单元)的高性能中受益提供了可能性。然而，由块I&#x2F;O接口和闪存转换层(FTL)引起的语义差距阻止了底层闪存的性能得到充分利用。在本文中，我们提出了一个日志结构文件系统，称为DualFS。DualFS允许闪存块自由地在原始模式和SLC模式之间切换，并使用这些SLC块来加速关键请求。DualFS根据有效数据的总大小动态调整SLC模式区域的容量，以保持设备的容量损耗可以忽略不计。此外，DualFS利用Open-Channel固态硬盘(SSD)的优点，使用软件语义信息来指导数据的放置和管理。特别是，由于向SLC块写入相同数量的数据会损害更多的耐久性，DualFS提出了一种新颖的生命周期管理方案，它在一定的窗口内限制了写入SLC模式区域的比率，从而准确地控制了SSD的耐久性。最后，DualFS整合了由文件系统直接驱动的垃圾收集(GC)过程，并合并了SLC模式区域和原始模式区域的GC。实验结果表明，与基于开放通道SSD的最新闪存文件系统相比，DualFS提供了平均22.2%的性能提升。与基于闪存块双模式切换特性的其他存储系统相比，DualFS的平均性能也表现出13.3%到24.6%的显著改善。此外，DualFS在不同的读&#x2F;写比率下有效地减少了读响应时间，并精确地管理了设备的耐久性。</p>
</blockquote>
</li>
<li><p><strong>HMB-I&#x2F;O: Fast Track for Handling Urgent I&#x2F;Os inNonvolatile Memory Express Solid-State Drives</strong>, <strong>(Appl. Sci. 2020)</strong>. Kyusik Kim, Seongmin Kim, Taeseok Kim.</p>
<blockquote>
<p>​	为满足各自需求的应用程序提供差异化的I&#x2F;O服务对于用户满意度非常重要。非易失性内存快速通道（NVMe）固态硬盘（SSD）架构可以通过其众多的提交队列来提高I&#x2F;O带宽，但每个I&#x2F;O请求的服务质量（QoS）从未得到保证。特别是，如果由于突发的I&#x2F;O工作负载，在提交队列中有很多I&#x2F;O请求待处理，紧急的I&#x2F;O请求可能会被延迟，因此，需要快速服务的应用程序的QoS要求可能无法得到满足。本文提出了一种处理紧急I&#x2F;O请求的方案，即使有很多挂起的I&#x2F;O请求，也不会延迟。由于提交队列中的待处理I&#x2F;O请求不能由主机控制，所以使用主机内存缓冲区（HMB）——这是可以从控制器访问的主机的DRAM的一部分——来处理紧急的I&#x2F;O请求。该方案并不是通过传统的I&#x2F;O路径将紧急I&#x2F;O请求发送到SSD中，而是通过直接将它们插入HMB来消除延迟。模拟器实验表明，该方案可以将平均延迟和尾部延迟分别降低高达99%和86%。</p>
</blockquote>
</li>
<li><p><strong>QBLK: Towards Fully Exploiting the Parallelism of Open-Channel SSDs</strong>, <strong>(DATE’19)</strong>. Hongwei Qin, Dan Feng, Wei Tong, Jingning Liu, Yutong Zhao.</p>
<blockquote>
<p>​	通过将物理通道暴露给主机软件，Open-Channel SSD在未来的高性能存储系统中展现出巨大的潜力。然而，现有的方案在重负载下无法达到令人满意的性能。主要原因不仅在于其单一缓冲体系结构，更重要的是其基于行的物理地址管理。此外，在重负载下，地址映射表的锁也是一个性能负担。我们提出了QBLK，一个开源驱动程序，试图更好地利用Open-Channel SSDs的并行性。特别地，QBLK采用了四个关键技术，分别是：（1）基于多队列的缓冲，（2）基于每个通道的地址管理，（3）无锁地址映射，以及（4）细粒度的排放。实验结果显示，与现有的最先进的PBLK方案相比，QBLK实现了高达97.4%的带宽提升。</p>
</blockquote>
</li>
<li><p><strong>An Efficient Design and Implementation of Deduplication on Open-Channel SSDs</strong>, <strong>(HPCC’19)</strong>. Qiqi Hu, Jianxi Chen, Dan Feng, Qing Yang, Bo Liu.</p>
<blockquote>
<p>​	由于NAND闪存的写入周期达到上限，数据无法可靠地存储。因此，固态硬盘（SSDs）的寿命受到限制，使其无法成为写入密集型数据中心的可靠存储设备。数据去重可以有效减少写入流量并延长SSDs的使用寿命。但是，传统数据去重方案中的指纹计算开销太大，这将降低SSDs的写入性能。在本文中，我们提出了一种基于Open-Channel SSDs (OCSSDs)的新的去重方案D-pblk，它可以配合现代高性能CPU来减少指纹计算的开销。在D-pblk中，我们使用轻量级的哈希CRC32来过滤大部分非重复数据，当CRC32首次被命中时，我们从Open-Channel SSDs中读取数据并计算重量级的哈希SHA-1进行精确比较，这减少了指纹计算的开销，几乎不影响工作负载的去重率。我们还使用多线程并行计算指纹，进一步减少了指纹计算的开销。此外，我们使用双环缓冲区来解决去重后的数据大小可能不匹配闪存页面大小的问题。我们使用FEMU模拟Open-Channel SSDs进行评估。实验结果显示，D-pblk可以实现从4.61%到31.63%的去重率，写入延迟提高了高达29倍。</p>
</blockquote>
</li>
</ol>
<h2 id="Slides："><a href="#Slides：" class="headerlink" title="Slides："></a>Slides：</h2><iframe src="../../../../pdf_file/FEMU_STUDY/FEMU_10.23.pdf" style="width:100%; height:800px;" frameborder="0"></iframe>

<h2 id="Appendix："><a href="#Appendix：" class="headerlink" title="Appendix："></a>Appendix：</h2><h3 id="一些名词解释："><a href="#一些名词解释：" class="headerlink" title="一些名词解释："></a>一些名词解释：</h3><blockquote>
<ul>
<li><p><strong>virtio</strong>：<code>virtio</code> 是一个虚拟化标准，用于提供一种高效、标准化的方式在宿主（host）和虚拟机（guest）之间进行 IO 操作。它是一个设备抽象标准，但不依赖于任何特定的虚拟化环境或物理硬件，通常用于改进网络和磁盘性能。使用 <code>virtio</code>，虚拟机与一个“虚拟化的”设备通信，而不是模拟实际的硬件设备，从而提高性能。</p>
</li>
<li><p>**dataplane (或称 data plane)**：数据平面通常指的是网络设备（如路由器或交换机）中处理数据包转发的部分。与之相对的是控制平面，它决定数据如何转发。在虚拟化语境中，当我们谈论 “dataplane”，我们通常指的是为了提高性能而进行优化的数据处理路径，例如 <code>vhost-user</code> 或 <code>dpdk</code> 在 <code>QEMU/KVM</code> 环境中。这些优化路径旨在减少不必要的上下文切换和缓冲，从而提供接近本机的 IO 性能。</p>
</li>
<li><p><strong>“trap-and-emulate”</strong> 是虚拟化技术中的一个术语。</p>
<ol>
<li><strong>Trap</strong>：在虚拟化中，当虚拟机（guest）尝试执行某些特定的、不能在其权限级别下直接执行的操作时，会触发一个异常或中断。这种异常或中断被称为“陷阱”（trap）。</li>
<li><strong>Emulate</strong>：一旦产生了这种陷阱，虚拟机监控器（如QEMU、KVM等）会接管控制权，然后在更高的权限级别上模拟或解释执行那些操作，就像真实硬件上的操作一样，但是实际上是通过软件来完成的。</li>
</ol>
<p>所以，“trap-and-emulate”意味着：当虚拟机尝试执行某些它没有权限直接执行的操作时，这些操作会被陷阱捕获，并由宿主机上的虚拟机监控器以模拟的方式执行。这是传统虚拟化技术的基本工作原理。</p>
</li>
<li><p><strong>rings the doorbell</strong>：“rings the doorbell”是一个比喻，用于描述一种通知或信号机制。在NVMe协议中，当驱动程序想要通知控制器有新的命令已经放入命令队列中，准备被处理时，它会写入一个特定的内存映射输入&#x2F;输出（MMIO）寄存器。这个动作被称为”ringing the doorbell”，就好像是敲门铃一样，通知某人来处理某事。简而言之，当Guest OS的NVMe驱动有IO请求准备发送时，它通过“敲门铃”来通知设备（在这种情况下是QEMU）开始处理这些IO请求。</p>
</li>
<li><p>**MMIO:**是 “Memory-Mapped Input&#x2F;Output” 的缩写，翻译为“内存映射输入&#x2F;输出”。在计算机系统中，MMIO 是一种将设备的寄存器映射到主存储器地址空间的技术，这样CPU可以通过访问这个内存地址来读写设备的寄存器，而不是使用专门的I&#x2F;O指令。</p>
<p>​	当提到“doorbell”是一个 MMIO 操作时，意思是说，为了通知设备有新的IO请求，驱动程序会写入一个特定的内存地址，这个地址实际上是映射到设备寄存器的。然后这个写操作会被设备捕获并做出响应。</p>
<p>​	“会导致一个昂贵的VM-exit”部分则表示，当虚拟机的Guest OS进行这样的MMIO操作时，它实际上需要从Guest OS切换到宿主机的上下文（在这种情况下是QEMU），这个上下文切换过程是有性能开销的，因此被称为“昂贵”。</p>
</li>
<li><p><strong>为什么说：然而，当存储后端是RAM支持的映像时，AIO的开销变得非常显著。</strong></p>
<p>​	当存储后端是RAM支持的映像时，数据访问速度非常快，因为RAM（随机存取存储器）是计算机中最快的存储介质。与硬盘或SSD相比，从RAM读取或写入数据的延迟是非常低的。</p>
<p>​	AIO（异步I&#x2F;O）的主要优势是允许系统在等待I&#x2F;O操作完成时进行其他工作，从而提高效率。但这个优势主要在于处理慢速存储设备时更为明显，例如传统硬盘，因为这时I&#x2F;O操作可能需要很长时间。</p>
<p>​	但是，当后端存储是RAM时，由于RAM的快速响应，同步I&#x2F;O操作的完成时间非常短，几乎可以立即完成。因此，引入AIO的额外开销（如设置和管理异步操作）可能不仅不会提高性能，反而可能导致性能降低。简而言之，为了处理非常快速的RAM操作，引入AIO可能会增加不必要的复杂性和开销，这就是为什么说在这种情况下，AIO的开销变得非常显著。</p>
</li>
<li><p><strong>end-to-end IO time</strong>:是指从输入&#x2F;输出操作开始到完成的总时间。在计算机领域中，”端到端”通常指的是一个过程从开始到结束的整个周期。所以，端到端的IO时间是指从IO请求发起（例如，应用程序请求读取或写入数据）到请求被完全处理并得到响应的总时间。这包括了所有中间过程，如数据传输、数据转换、系统调度和任何其他可能的延迟。</p>
</li>
<li><p>**Lantency tail:**（延迟尾）指的是在性能测量中，尤其是分布式系统或网络服务中，某些请求的响应时间比大多数请求都要长的那部分请求。在很多场景下，这些高延迟的请求，即使只是很小的一部分，也可能对系统的整体性能和用户体验产生显著的负面影响。</p>
<p>例如，考虑一个在线服务，其中99%的请求在10毫秒内得到响应，但1%的请求需要1秒。这1%的请求就构成了延迟的尾部。尽管它们的比例很小，但它们的延迟对用户体验产生的负面影响可能与其它99%的请求一样大，甚至更大。</p>
</li>
<li><p><strong>Plane</strong>: 在NAND闪存中，一个plane代表存储芯片中的一个独立存储区域。每个plane可以独立地执行读、写和擦除操作。一个NAND芯片可以有一个或多个plane，多plane架构可以提高存储的并行性和性能。</p>
</li>
<li><p><strong>Channel</strong>: 通道是连接NAND闪存和控制器之间的接口，用于数据传输。多通道架构允许同时访问多个NAND芯片，从而提高数据读取和写入的速度。每个通道可能连接到一个或多个NAND芯片。</p>
</li>
<li><p><strong>MLC：</strong><code>(multi-level Cell)</code>它是一种 NAND 闪存存储技术。<code>MLC</code> 可以在每个存储单元中存储多于一位的数据，通常是2位。这与 <code>SLC (Single-Level Cell)</code> 闪存不同，<code>SLC </code>每个单元只存储1位数据。</p>
</li>
<li><p><strong>controller-blocking GC</strong>：这是最具侵入性的GC类型。当垃圾回收在整个存储控制器上进行时，其他所有操作（如读取或写入）都会被阻塞，直到GC完成。这可以对性能产生显著的负面影响，因为它停止了所有其他I&#x2F;O操作。</p>
</li>
<li><p><strong>channel-blocking GC</strong>：在这种情况下，当某个特定的通道正在进行垃圾回收时，该通道上的其他操作会被阻塞。但是，其他通道上的操作可以继续进行，从而允许一定程度的并行性。这减少了GC对整体性能的影响，但在被GC阻塞的通道上仍可能会看到性能下降。</p>
</li>
<li><p><strong>plane-blocking GC</strong>：这是最具局部性的GC，仅在特定的平面上阻塞操作。其他平面上的操作可以正常进行，使得性能影响最小化。由于仅影响特定的平面，这种方法可能是对性能影响最小的。</p>
</li>
<li><p><strong>FTL 指的是“Flash Translation Layer”</strong>。这是固态硬盘（SSD）和其他基于闪存的存储设备中的一个关键组件。FTL 的主要任务是管理如何在物理NAND闪存上存储数据，同时为上层应用提供一个标准的块设备接口。</p>
<p>以下是 FTL 的主要功能和特点：</p>
<ol>
<li><strong>地址转换</strong>：FTL 负责将逻辑块地址（LBA，通常由操作系统提供）转换为物理块地址（PBA），从而隐藏闪存的物理细节。</li>
<li><strong>Wear Leveling</strong>：由于NAND闪存单元有限的擦除周期（通常是几千到几万次），FTL 通过均匀分布写入和擦除操作来确保所有的闪存块都具有相似的使用寿命。这就是所谓的“wear leveling”。</li>
<li><strong>Garbage Collection</strong>：当数据被重写或删除时，其旧版本在闪存上不会被立即删除。相反，这些块会被标记为“无效”。FTL 会定期运行垃圾回收，移动有效数据并擦除包含大量无效块的块。</li>
<li><strong>Bad Block Management</strong>：由于制造缺陷或使用过程中的损耗，NAND闪存可能会有坏块。FTL 负责检测这些坏块并将它们从使用中排除。</li>
<li><strong>随机到顺序的转换</strong>：闪存优先处理顺序写入，因为它们可以更高效地处理大量的连续数据。FTL 试图将随机写入转化为顺序写入，从而优化性能。</li>
</ol>
<p>FTL 的实现和策略可能会因不同的SSD制造商和模型而异。FTL 的效率和策略对SSD的整体性能、寿命和可靠性都有着直接的影响</p>
</li>
<li><p><strong>NVMe（Non-Volatile Memory Express）</strong>是一种协议，专为高速固态存储驱动器（如使用NAND闪存的SSDs）设计，以最大化其性能并减少延迟。它被设计为替代旧的AHCI协议，AHCI最初是为HDDs设计的，因此它在管理SSDs时存在一些效率和性能的瓶颈。</p>
<p>以下是NVMe的主要特点和优势：</p>
<ol>
<li><strong>接口</strong>：NVMe通常使用PCI Express (PCIe)总线作为其物理接口，这允许更高的带宽和更低的延迟。</li>
<li><strong>并行性</strong>：NVMe支持多个命令队列，每个队列可容纳上千个命令。这与AHCI的单一队列形成了对比，AHCI的队列只能容纳32个命令。这种高度的并行性尤其适合现代多核处理器。</li>
<li><strong>低延迟</strong>：NVMe协议被优化，减少了命令处理的总体开销，这使得存储I&#x2F;O操作的延迟得到了显著的减少。</li>
<li><strong>针对SSD优化</strong>：与AHCI相比，NVMe专为固态存储优化，省略了许多与旋转硬盘相关的冗余操作。</li>
<li><strong>扩展性</strong>：NVMe为未来的存储技术，如3D XPoint等，提供了良好的扩展性。</li>
<li><strong>功能丰富</strong>：NVMe提供了许多先进的特性，如支持多路径、安全擦除和更细粒度的功耗管理。</li>
</ol>
<p>由于上述优势，NVMe SSDs在许多应用场景中，特别是需要高性能和低延迟的场景中，已经成为首选。不过，值得注意的是，为了充分利用NVMe SSDs的优势，系统需要一个支持NVMe的主板和操作系统。</p>
</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/25/computerSystemDesignLab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/25/computerSystemDesignLab/" class="post-title-link" itemprop="url">computerSystemDesignLab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-25 09:19:19" itemprop="dateCreated datePublished" datetime="2023-09-25T09:19:19+08:00">2023-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-15 10:15:46" itemprop="dateModified" datetime="2023-11-15T10:15:46+08:00">2023-11-15</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>122</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Computer-System-Design-Lab-1"><a href="#Computer-System-Design-Lab-1" class="headerlink" title="Computer System Design Lab_1"></a>Computer System Design Lab_1</h2><iframe src="../../../../pdf_file/computerSystemDesignLab/Lab1_report.pdf" style="width:100%; height:800px;" frameborder="0"></iframe>

<h2 id="Computer-System-Design-Lab-2"><a href="#Computer-System-Design-Lab-2" class="headerlink" title="Computer System Design Lab_2"></a>Computer System Design Lab_2</h2><iframe src="../../../../pdf_file/computerSystemDesignLab/Lab2_report.pdf" style="width:100%; height:800px;" frameborder="0"></iframe>

<h2 id="Computer-System-Design-Lab-3"><a href="#Computer-System-Design-Lab-3" class="headerlink" title="Computer System Design Lab_3"></a>Computer System Design Lab_3</h2><iframe src="../../../../pdf_file/computerSystemDesignLab/Lab3_report.pdf" style="width:100%; height:800px;" frameborder="0"></iframe>

<h2 id="Computer-System-Design-Lab-4"><a href="#Computer-System-Design-Lab-4" class="headerlink" title="Computer System Design Lab_4"></a>Computer System Design Lab_4</h2><iframe src="../../../../pdf_file/computerSystemDesignLab/lab4_report.pdf" style="width:100%; height:800px;" frameborder="0"></iframe>

<h2 id="coursework"><a href="#coursework" class="headerlink" title="coursework"></a>coursework</h2><iframe src="../../../../pdf_file/computerSystemDesignLab/coursework.pdf" style="width:100%; height:800px;" frameborder="0"></iframe>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/14/PA1-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0%E7%9A%84%E7%AF%87%E7%AB%A0-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/14/PA1-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0%E7%9A%84%E7%AF%87%E7%AB%A0-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="post-title-link" itemprop="url">PA1 - 开天辟地的篇章: 最简单的计算机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-14 19:17:02" itemprop="dateCreated datePublished" datetime="2023-09-14T19:17:02+08:00">2023-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-20 16:10:05" itemprop="dateModified" datetime="2023-10-20T16:10:05+08:00">2023-10-20</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="PA1-开天辟地的篇章-最简单的计算机"><a href="#PA1-开天辟地的篇章-最简单的计算机" class="headerlink" title="PA1 - 开天辟地的篇章: 最简单的计算机"></a>PA1 - 开天辟地的篇章: 最简单的计算机</h1><blockquote>
<p><strong>世界诞生的故事 - 第一章</strong></p>
<p>先驱已经准备好了创造计算机世界的工具. 为了迈出第一步, 他运用了一些数字电路的知识, 就已经创造出了一个最小的计算机 – 图灵机. 让我们来看看其中的奥妙.</p>
</blockquote>
<h2 id="在开始愉快的PA之旅之前"><a href="#在开始愉快的PA之旅之前" class="headerlink" title="在开始愉快的PA之旅之前"></a>在开始愉快的PA之旅之前</h2><blockquote>
<p><strong>随时记录实验心得</strong>	</p>
<p>我们已经在你学长学姐的实验报告中多次看到类似的悔恨: 因为没有及时记录实验心得而在编写实验报告的时候忘记了自己经历趣事的细节. 为了和助教们分享你的各种实验经历, 我们建议你在实验过程中随时记录实验心得, 比如自己踩过的大坑, 或者是调了一周之后才发现的一个弱智bug, 等等.</p>
<p>我们相信, 当你做完PA回过头来阅读这些心得的时候, 就会发现这对你来说是一笔宝贵的财富.</p>
</blockquote>
<h2 id="开天辟地的篇章"><a href="#开天辟地的篇章" class="headerlink" title="开天辟地的篇章"></a>开天辟地的篇章</h2><h3 id="任务-尝试理解计算机如何计算"><a href="#任务-尝试理解计算机如何计算" class="headerlink" title="任务 尝试理解计算机如何计算"></a>任务 尝试理解计算机如何计算</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// PC: instruction    | // label: statement</span><br><span class="line">0: mov  r1, 0         |  pc0: r1 = 0;</span><br><span class="line">1: mov  r2, 0         |  pc1: r2 = 0;</span><br><span class="line">2: addi r2, r2, 1     |  pc2: r2 = r2 + 1;</span><br><span class="line">3: add  r1, r1, r2    |  pc3: r1 = r1 + r2;</span><br><span class="line">4: blt  r2, 100, 2    |  pc4: if (r2 &lt; 100) goto pc2;   // branch if less than</span><br><span class="line">5: jmp 5              |  pc5: goto pc5;</span><br></pre></td></tr></table></figure>

<p>在看到上述例子之前, 你可能会觉得指令是一个既神秘又难以理解的概念. 不过当你看到对应的C代码时, 你就会发现指令做的事情竟然这么简单! 而且看上去还有点蠢, 你随手写一个for循环都要比这段C代码看上去更高级.</p>
<p>不过你也不妨站在计算机的角度来理解一下, 计算机究竟是怎么通过这种既简单又笨拙的方式来计算<code>1+2+...+100</code>的. 这种理解会使你建立”程序如何在计算机上运行”的最初原的认识.</p>
</blockquote>
<p>​	我理解的计算机执行计算的方式是：不断的更新PC，读取对应地址，从中取出指令并执行。</p>
<h2 id="RTFSC"><a href="#RTFSC" class="headerlink" title="RTFSC"></a>RTFSC</h2><h3 id="代码框架初探"><a href="#代码框架初探" class="headerlink" title="代码框架初探"></a>代码框架初探</h3><blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ics2023</span><br><span class="line">├── abstract-machine   # 抽象计算机</span><br><span class="line">├── am-kernels         # 基于抽象计算机开发的应用程序</span><br><span class="line">├── fceux-am           # 红白机模拟器</span><br><span class="line">├── init.sh            # 初始化脚本</span><br><span class="line">├── Makefile           # 用于工程打包提交</span><br><span class="line">├── nemu               # NEMU</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure>

<p>​	目前只需要关心nemu目录下的代码：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">nemu</span><br><span class="line">├── configs                    # 预先提供的一些配置文件</span><br><span class="line">├── include                    # 存放全局使用的头文件</span><br><span class="line">│   ├── common.h               # 公用的头文件</span><br><span class="line">│   ├── config                 # 配置系统生成的头文件, 用于维护配置选项更新的时间戳</span><br><span class="line">│   ├── cpu</span><br><span class="line">│   │   ├── cpu.h</span><br><span class="line">│   │   ├── decode.h           # 译码相关</span><br><span class="line">│   │   ├── difftest.h</span><br><span class="line">│   │   └── ifetch.h           # 取指相关</span><br><span class="line">│   ├── debug.h                # 一些方便调试用的宏</span><br><span class="line">│   ├── device                 # 设备相关</span><br><span class="line">│   ├── difftest-def.h</span><br><span class="line">│   ├── generated</span><br><span class="line">│   │   └── autoconf.h         # 配置系统生成的头文件, 用于根据配置信息定义相关的宏</span><br><span class="line">│   ├── isa.h                  # ISA相关</span><br><span class="line">│   ├── macro.h                # 一些方便的宏定义</span><br><span class="line">│   ├── memory                 # 访问内存相关</span><br><span class="line">│   └── utils.h</span><br><span class="line">├── Kconfig                    # 配置信息管理的规则</span><br><span class="line">├── Makefile                   # Makefile构建脚本</span><br><span class="line">├── README.md</span><br><span class="line">├── resource                   # 一些辅助资源</span><br><span class="line">├── scripts                    # Makefile构建脚本</span><br><span class="line">│   ├── build.mk</span><br><span class="line">│   ├── config.mk</span><br><span class="line">│   ├── git.mk                 # git版本控制相关</span><br><span class="line">│   └── native.mk</span><br><span class="line">├── src                        # 源文件</span><br><span class="line">│   ├── cpu</span><br><span class="line">│   │   └── cpu-exec.c         # 指令执行的主循环</span><br><span class="line">│   ├── device                 # 设备相关</span><br><span class="line">│   ├── engine</span><br><span class="line">│   │   └── interpreter        # 解释器的实现</span><br><span class="line">│   ├── filelist.mk</span><br><span class="line">│   ├── isa                    # ISA相关的实现</span><br><span class="line">│   │   ├── mips32</span><br><span class="line">│   │   ├── riscv32</span><br><span class="line">│   │   ├── riscv64</span><br><span class="line">│   │   └── x86</span><br><span class="line">│   ├── memory                 # 内存访问的实现</span><br><span class="line">│   ├── monitor</span><br><span class="line">│   │   ├── monitor.c</span><br><span class="line">│   │   └── sdb                # 简易调试器</span><br><span class="line">│   │       ├── expr.c         # 表达式求值的实现</span><br><span class="line">│   │       ├── sdb.c          # 简易调试器的命令处理</span><br><span class="line">│   │       └── watchpoint.c   # 监视点的实现</span><br><span class="line">│   ├── nemu-main.c            # 你知道的...</span><br><span class="line">│   └── utils                  # 一些公共的功能</span><br><span class="line">│       ├── log.c              # 日志文件相关</span><br><span class="line">│       ├── rand.c</span><br><span class="line">│       ├── state.c</span><br><span class="line">│       └── timer.c</span><br><span class="line">└── tools                      # 一些工具</span><br><span class="line">    ├── fixdep                 # 依赖修复, 配合配置系统进行使用</span><br><span class="line">    ├── gen-expr</span><br><span class="line">    ├── kconfig                # 配置系统</span><br><span class="line">    ├── kvm-diff</span><br><span class="line">    ├── qemu-diff</span><br><span class="line">    └── spike-diff</span><br></pre></td></tr></table></figure>
</blockquote>
<p>提示：</p>
<ul>
<li><code>nemu/include/generated/autoconf.h</code>, 阅读C代码时使用</li>
<li><code>nemu/include/config/auto.conf</code>, 阅读Makefile时使用</li>
</ul>
<h4 id="准备第一个程序"><a href="#准备第一个程序" class="headerlink" title="准备第一个程序"></a>准备第一个程序</h4><blockquote>
<p>我们已经知道, NEMU是一个用来执行客户程序的程序, 但客户程序一开始并不存在于客户计算机中. 我们需要将客户程序读入到客户计算机中, 这件事是monitor来负责的. 于是NEMU在开始运行的时候, 首先会调用<code>init_monitor()</code>函数(在<code>nemu/src/monitor/monitor.c</code>中定义) 来进行一些和monitor相关的初始化工作.</p>
</blockquote>
<h4 id="运行第一个客户程序"><a href="#运行第一个客户程序" class="headerlink" title="运行第一个客户程序"></a>运行第一个客户程序</h4><blockquote>
<p>Monitor的初始化工作结束后, <code>main()</code>函数会继续调用<code>engine_start()</code>函数 (在<code>nemu/src/engine/interpreter/init.c</code>中定义). 代码会进入简易调试器(Simple Debugger)的主循环<code>sdb_mainloop()</code> (在<code>nemu/src/monitor/sdb/sdb.c</code>中定义), 并输出NEMU的命令提示符:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(nemu)</span><br></pre></td></tr></table></figure>

<p>简易调试器是monitor的核心功能, 我们可以在命令提示符中输入命令, 对客户计算机的运行状态进行监控和调试. 框架代码已经实现了几个简单的命令, 它们的功能和GDB是很类似的.</p>
<p>在命令提示符后键入<code>c</code>后, NEMU开始进入指令执行的主循环<code>cpu_exec()</code> (在<code>nemu/src/cpu/cpu-exec.c</code>中定义). <code>cpu_exec()</code>又会调用<code>execute()</code>, 后者模拟了CPU的工作方式: 不断执行指令. 具体地, 代码将在一个for循环中不断调用<code>exec_once()</code>函数, 这个函数的功能就是我们在上一小节中介绍的内容: 让CPU执行当前PC指向的一条指令, 然后更新PC.</p>
</blockquote>
<h4 id="任务：优美的退出"><a href="#任务：优美的退出" class="headerlink" title="任务：优美的退出"></a>任务：优美的退出</h4><blockquote>
<p>为了测试大家是否已经理解框架代码, 我们给大家设置一个练习: 如果在运行NEMU之后直接键入<code>q</code>退出, 你会发现终端输出了一些错误信息. 请分析这个错误信息是什么原因造成的, 然后尝试在NEMU中修复它.</p>
</blockquote>
<p>​	当我们执行任务中的流程后，终端显示错误信息，我们如何通过错误信息找到解决方法呢？</p>
<p><img src="/../images/PA1-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0%E7%9A%84%E7%AF%87%E7%AB%A0-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%88%AA%E5%B1%8F2023-09-21%2008.38.12-5256718.png" alt="截屏2023-09-21 08.38.12"></p>
<p>​	先试试阅读make显示的出错位置的信息，大概了解到在执行NEMU的时候出错，但笔者在漫长的查找下并没有找到出错的原因：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run: run-env</span><br><span class="line">	$(call git_commit, &quot;run NEMU&quot;)</span><br><span class="line">	$(NEMU_EXEC)</span><br></pre></td></tr></table></figure>

<p>​	换个思路：试一试神奇的GDB，首先我们通过<code>make menuconfig</code>命令，进入<code>config</code>页面，勾选<code>Build Options</code>中的<code>Enable debug information</code>，退出后执行<code>make clean</code>，<code>make gdb</code>进入gdb，通过执行gdb我们发现gdb输出<code>Inferior 1 (process 10465) exited with code 01</code>，RTFW后我们知道： “Exited with code N” just refers to the value returned from <code>main()</code>. 同时，<code>return is_exit_status_bad()</code> 暗示了<code>main</code>的返回值，<del>按照之前写代码的经验，main函数通常在最后返回的是0</del>。<img src="/../images/PA1-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0%E7%9A%84%E7%AF%87%E7%AB%A0-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%88%AA%E5%B1%8F2023-09-21%2009.09.15-5258561-5258563.png" alt="截屏2023-09-21 09.09.15"></p>
<p>​	现在明确目标，找到<code>is_exit_status_bad()</code>并弄清它做了什么。在linux中，我们使用grep命令在文件中查找：<img src="/../images/PA1-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0%E7%9A%84%E7%AF%87%E7%AB%A0-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%88%AA%E5%B1%8F2023-09-21%2009.16.40.png" alt="截屏2023-09-21 09.16.40"></p>
<p>​	查阅函数，在包含的头文件中弄清函数中的宏表示什么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// src/utils/state.c</span><br><span class="line"></span><br><span class="line">#include &lt;utils.h&gt;</span><br><span class="line"></span><br><span class="line">NEMUstate nemu_state = &#123; .state = NEMU_STOP&#125;</span><br><span class="line">int good = (nemu_state.state == NEMU_END &amp;&amp; nemu_state.alt_ret == 0) || (nemu_state.state == NEMU_QUIT);</span><br><span class="line"></span><br><span class="line">return !good;</span><br></pre></td></tr></table></figure>

<p>​	<code>utils.h</code>中<code>enum &#123;NEMU_RUNNING, NEMU_STOP, NEMU_END, NEMU_ABORT, NEMU_QUIT&#125;</code> 。</p>
<p>​	当退出状态是“好”的，<code>good == 1</code>，返回0，反之，返回1。</p>
<p>​	现在，使用gdb设置断点，打印信息，笔者发现，在从nemu_state声明后到程序执行结束时，nemu_state.state &#x3D;&#x3D; 1且nemu_state.halt_ret &#x3D;&#x3D; 0，明显，此时good被置为0。那么，但NEMU状态为stop时，也是一个可以退出的“好”状态，修改代码，完成优美地退出。<img src="/../images/PA1-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0%E7%9A%84%E7%AF%87%E7%AB%A0-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%88%AA%E5%B1%8F2023-09-21%2012.37.11-5271038.png" alt="截屏2023-09-21 12.37.11"></p>
<h2 id="基础设施-简易调试器"><a href="#基础设施-简易调试器" class="headerlink" title="基础设施: 简易调试器"></a>基础设施: 简易调试器</h2><p>后面的任务是要在monitor里面完成下图的功能：</p>
<blockquote>
<p><img src="/../images/PA1-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0%E7%9A%84%E7%AF%87%E7%AB%A0-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%88%AA%E5%B1%8F2023-10-10%2016.13.38-6925623.png" alt="截屏2023-10-10 16.13.38"></p>
</blockquote>
<h3 id="解析命令"><a href="#解析命令" class="headerlink" title="解析命令"></a>解析命令</h3><p>​	第一步是解析命令，其实就是处理字符串，等到下面实现操作的时候详细说明。</p>
<h3 id="单步执行"><a href="#单步执行" class="headerlink" title="单步执行"></a>单步执行</h3><blockquote>
<p>单步执行的功能十分简单, 而且框架代码中已经给出了模拟CPU执行方式的函数, 你只要使用相应的参数去调用它就可以了. 如果你仍然不知道要怎么做, RTFSC.</p>
</blockquote>
<h3 id="打印寄存器"><a href="#打印寄存器" class="headerlink" title="打印寄存器"></a>打印寄存器</h3><blockquote>
<p>打印寄存器就更简单了. 不过既然寄存器的结构是ISA相关的, 我们希望能为简易调试器屏蔽ISA的差异. 框架代码已经为大家准备了如下的API:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// nemu/src/isa/$ISA/reg.c</span><br><span class="line">void isa_reg_display(void);</span><br></pre></td></tr></table></figure>

<p>执行<code>info r</code>之后, 就调用<code>isa_reg_display()</code>, 在里面直接通过<code>printf()</code>输出所有寄存器的值即可. 如果你从来没有使用过<code>printf()</code>, 请RTFM或者STFW. 如果你不知道要输出什么, 你可以参考GDB中的输出.</p>
</blockquote>
<h3 id="扫描内存"><a href="#扫描内存" class="headerlink" title="扫描内存"></a>扫描内存</h3><blockquote>
<p>扫描内存的实现也不难, 对命令进行解析之后, 先求出表达式的值. 但你还没有实现表达式求值的功能, 现在可以先实现一个简单的版本: 规定表达式<code>EXPR</code>中只能是一个十六进制数, 例如</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x 10 0x80000000</span><br></pre></td></tr></table></figure>

<p>这样的简化可以让你暂时不必纠缠于表达式求值的细节. 解析出待扫描内存的起始地址之后, 就可以使用循环将指定长度的内存数据通过十六进制打印出来. 如果你不知道要怎么输出, 同样的, 你可以参考GDB中的输出. 问题是, 我们要如何访问客户计算机的内存数据呢? (答案早就说了喂)</p>
<p>实现了扫描内存的功能之后, 你可以打印<code>0x80000000</code>或者<code>0x100000</code>附近的内存, 你应该会看到程序的代码, 和内置客户程序的内容进行对比, 检查你的实现是否正确.</p>
</blockquote>
<h3 id="任务-实现单步执行-打印寄存器-扫描内存"><a href="#任务-实现单步执行-打印寄存器-扫描内存" class="headerlink" title="任务 实现单步执行, 打印寄存器, 扫描内存"></a>任务 实现单步执行, 打印寄存器, 扫描内存</h3><p>​	实现单步执行前，我们先看看程序是如何接收用户输入的。讲义给出相关代码在<code>nemu/src/monitor/sdb</code>下，观察nemu&#x2F;src&#x2F;monitor&#x2F;sdb&#x2F;sdb.c，首先看<code>main_loop</code>函数，该函数将用户的输入分解成了命令cmd和参数args，并通过便利cmd_table判断命令是否合法，然后通过handler传入参数并调用命令。在 cmd_table中添加命令，如下图所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">static struct &#123;</span><br><span class="line">  const char *name;</span><br><span class="line">  const char *description;</span><br><span class="line">  int (*handler) (char *);</span><br><span class="line">&#125; cmd_table [] = &#123;</span><br><span class="line">  &#123; &quot;help&quot;, &quot;Display information about all supported commands&quot;, cmd_help &#125;,</span><br><span class="line">  &#123; &quot;c&quot;, &quot;Continue the execution of the program&quot;, cmd_c &#125;,</span><br><span class="line">  &#123; &quot;q&quot;, &quot;Exit NEMU&quot;, cmd_q &#125;,</span><br><span class="line"></span><br><span class="line">  /* TODO: Add more commands */</span><br><span class="line">  &#123;&quot;si&quot;, &quot;Continue the excution of the program by 1 or N step&quot;, cmd_single_n_step&#125;,</span><br><span class="line">  &#123;&quot;info&quot;, &quot;Info r prints all registers, info w prints watchpoints&quot;, cmd_info_r_w&#125;,</span><br><span class="line">  &#123;&quot;x&quot;, &quot;X N EXPR scan memory at EXPR and Output N consecutive four byte numbers in hexadecimal&quot;, cmd_scan_mem&#125;,</span><br><span class="line">  &#123;&quot;p&quot;, &quot;p EXPR prints the value of EXPR&quot;, cmd_get_expr_val&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">void sdb_mainloop() &#123;</span><br><span class="line">  if (is_batch_mode) &#123;</span><br><span class="line">    cmd_c(NULL);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (char *str; (str = rl_gets()) != NULL; ) &#123;</span><br><span class="line">    char *str_end = str + strlen(str);</span><br><span class="line"></span><br><span class="line">    /* extract the first token as the command */</span><br><span class="line">    char *cmd = strtok(str, &quot; &quot;);</span><br><span class="line">    if (cmd == NULL) &#123; continue; &#125;</span><br><span class="line"></span><br><span class="line">    /* treat the remaining string as the arguments,</span><br><span class="line">     * which may need further parsing</span><br><span class="line">     */</span><br><span class="line">    char *args = cmd + strlen(cmd) + 1;</span><br><span class="line">    if (args &gt;= str_end) &#123;</span><br><span class="line">      args = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_DEVICE</span><br><span class="line">    extern void sdl_clear_event_queue();</span><br><span class="line">    sdl_clear_event_queue();</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; NR_CMD; i ++) &#123;</span><br><span class="line">      if (strcmp(cmd, cmd_table[i].name) == 0) &#123;</span><br><span class="line">        if (cmd_table[i].handler(args) &lt; 0) &#123; return; &#125;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (i == NR_CMD) &#123; printf(&quot;Unknown command &#x27;%s&#x27;\n&quot;, cmd); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	我们以单步打印为例，给出解析命令处理字符串的操作，程序已经帮我们分割了命令和参数，我们只需要处理参数即可，即 <code>si N</code>中的<code>N</code>。我们使用<code>strtok</code>处理字符串，分割空格。<code>argument</code>用来存储合法的变量。argc用来记录参数能被空格分割出多少字符。如果该参数大于1则说明输入错误并返回。如果等于1，则说明单步执行。如何找到单步执行的呢？在源码中我们发现，项目已经给出了继续执行程序需要用到的<code>cmd_c</code>，函数里调用了<code>cpu_exec</code> 然后通过grep查找该函数的实现，我们知道了这个函数就是用来实现单步&#x2F;多步打印的功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static int cmd_single_n_step(char* args ) &#123;</span><br><span class="line">	</span><br><span class="line">	// count how many arguments in args and store the number in argc</span><br><span class="line">	// store the arguments in vector argv</span><br><span class="line">	char * argument;</span><br><span class="line">	int argc = 0;</span><br><span class="line">	argument = strtok(args, &quot; &quot;);</span><br><span class="line">	if(argument != NULL) argc++;</span><br><span class="line">	char * arg = argument;</span><br><span class="line">	while(argument != NULL) &#123;</span><br><span class="line">		argument = strtok(NULL, &quot; &quot;);</span><br><span class="line">		if(argument != NULL) argc++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// if no arguments, execute 1 step</span><br><span class="line">	if(argc == 0) &#123;</span><br><span class="line">		cpu_exec(1);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if(argc &gt; 1) &#123;</span><br><span class="line">		printf(&quot;si N need only 1 argument\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i = 0; i &lt; strlen(arg); ++i) &#123;</span><br><span class="line">		if(!isdigit(arg[i])) &#123;</span><br><span class="line">			printf(&quot;arguments in si N should be a non-zero number\n&quot;);</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int step_num = atoi(arg);</span><br><span class="line">	cpu_exec(step_num);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	单&#x2F;多步打印的结果展示：</p>
<p><img src="/../images/PA1-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0%E7%9A%84%E7%AF%87%E7%AB%A0-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%88%AA%E5%B1%8F2023-10-11%2013.38.21.png" alt="截屏2023-10-11 13.38.21"></p>
<p>​	接下来实现打印寄存器，命令的解析过程就不再重复，打开<code>nemu/src/isa/riscv32/reg.c</code>,发现寄存器的名字已经给出了，我们需要找到寄存器的值存储在什么位置。寄存器是cpu的一个组成部分，通过grep命令检索cpu，发现其类型为<code>CPU_state</code>，接着检索<code>CPU_state</code>，在<code>include/isa.h</code>中发现他的定义，最终我们找到结构体的定义，数组<code>gpr</code>就是我们所需的寄存器的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  word_t gpr[MUXDEF(CONFIG_RVE, 16, 32)];</span><br><span class="line">  vaddr_t pc;</span><br><span class="line">&#125; MUXDEF(CONFIG_RV64, riscv64_CPU_state, riscv32_CPU_state);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	接着，实现简单的打印步骤就好。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;isa.h&gt;</span><br><span class="line">#include &quot;local-include/reg.h&quot;</span><br><span class="line"></span><br><span class="line">const char *regs[] = &#123;</span><br><span class="line">  &quot;$0&quot;, &quot;ra&quot;, &quot;sp&quot;, &quot;gp&quot;, &quot;tp&quot;, &quot;t0&quot;, &quot;t1&quot;, &quot;t2&quot;,</span><br><span class="line">  &quot;s0&quot;, &quot;s1&quot;, &quot;a0&quot;, &quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;, &quot;a4&quot;, &quot;a5&quot;,</span><br><span class="line">  &quot;a6&quot;, &quot;a7&quot;, &quot;s2&quot;, &quot;s3&quot;, &quot;s4&quot;, &quot;s5&quot;, &quot;s6&quot;, &quot;s7&quot;,</span><br><span class="line">  &quot;s8&quot;, &quot;s9&quot;, &quot;s10&quot;, &quot;s11&quot;, &quot;t3&quot;, &quot;t4&quot;, &quot;t5&quot;, &quot;t6&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void isa_reg_display() &#123;</span><br><span class="line">	for(int i = 0; i &lt; 32; ++i) &#123;</span><br><span class="line">		printf(&quot;reg:\t %s\t\t\t %x\n&quot;, regs[i], cpu.gpr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	打印寄存器的结果：<br>​	</p>
<p><img src="/../images/PA1-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0%E7%9A%84%E7%AF%87%E7%AB%A0-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%88%AA%E5%B1%8F2023-10-11%2013.39.41-7789397.png" alt="截屏2023-10-11 13.39.41"></p>
<p>​	实现扫描内存的关键在于如何访问计算机的内存数据，回顾<code>RTFSC</code>一节，内存相关代码在<code>nemu/src/memory</code>当中，那就继续阅读源码，尝试能否找到答案。我们知道<code>nemu</code>是一个运行在主机上的虚拟机，<code>host.h</code>用于判断物理机器的机器字长并修改虚拟机的相关字长。<code>paddr.c</code>的作用是对<code>NEMU</code>和主机上的内存进行映射。项目已经实现了读取内存的函数<code>vaddr_read()</code>和判断内存地址是否合法的函数<code>in_pmem()</code>，我们只需要传入对应的参数即可完成扫描内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static int cmd_scan_mem(char * args) &#123;</span><br><span class="line">	int argc = 0;</span><br><span class="line">	char * argv[2];</span><br><span class="line">	argv[argc] = strtok(args, &quot; &quot;);</span><br><span class="line">	if(argv[argc]) ++argc;</span><br><span class="line">	while(argv[argc] != NULL) &#123;</span><br><span class="line">		argv[argc] = strtok(NULL, &quot; &quot;);</span><br><span class="line">		if(argv[argc]) ++argc;</span><br><span class="line">	&#125;</span><br><span class="line">	if(argc == 0 || argc &gt; 2) &#123;</span><br><span class="line">		printf(&quot;command x N EXPR, needs 2 arguments\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i = 0; i &lt; strlen(argv[0]); ++i) &#123;</span><br><span class="line">		if(!isdigit(argv[0][i])) &#123;</span><br><span class="line">			printf(&quot;N in command x N EXPR must be digit\n&quot;);</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	paddr_t addr_val = 0;</span><br><span class="line">	if(!hexStr2Dec(argv[1], &amp;addr_val)) &#123;</span><br><span class="line">		printf(&quot;EXPR in command x N EXPR must be hex type\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	// printf(&quot;DEBUG hexStr2Val: argv[1]: %s\taddr_val: %x\n&quot;, argv[1], addr_val);</span><br><span class="line">	</span><br><span class="line">	// judge if addr is legal </span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	for(int i = 0; i &lt; atoi(argv[0]); ++i) &#123;</span><br><span class="line">		if(!in_pmem(addr_val + 4 * i)) &#123;</span><br><span class="line">			printf(&quot;addr_val: 0x%x is illegal\n&quot;, addr_val + 4 * i);</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		word_t mem_output = paddr_read(addr_val + 4 * i, 4);</span><br><span class="line">		printf(&quot;0x%8x:\t0x%8x\n&quot;, addr_val + 4 * i, mem_output);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	内存扫描的结果：</p>
<p><img src="/../images/PA1-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0%E7%9A%84%E7%AF%87%E7%AB%A0-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%88%AA%E5%B1%8F2023-10-11%2013.41.22-7002890.png" alt="截屏2023-10-11 13.41.22"></p>
<h2 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h2><h3 id="任务-实现算术表达式的词法分析"><a href="#任务-实现算术表达式的词法分析" class="headerlink" title="任务 实现算术表达式的词法分析"></a>任务 实现算术表达式的词法分析</h3><blockquote>
<p>你需要完成以下的内容:</p>
<ul>
<li>为算术表达式中的各种token类型添加规则, 你需要注意C语言字符串中转义字符的存在和正则表达式中元字符的功能.</li>
<li>在成功识别出token后, 将token的信息依次记录到<code>tokens</code>数组中.</li>
</ul>
</blockquote>
<p>​	这个比较简单，把常用的一些字符按照正则表达式的形式写入<code>enmu</code>和<code>rules</code>就好了，其实这里注意<code>enum</code>中的变量名需要和下文<code>switch</code>中的变量名保持一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">  TK_NOTYPE = 256, </span><br><span class="line">  TK_ADD, </span><br><span class="line">  TK_EQ,</span><br><span class="line"></span><br><span class="line">  /* TODO: Add more token types */</span><br><span class="line">  TK_SUB, </span><br><span class="line">  TK_MUL, </span><br><span class="line">  TK_LB, </span><br><span class="line">  TK_RB, </span><br><span class="line">  TK_DEC,</span><br><span class="line">  TK_DIV,</span><br><span class="line">  TK_NEG,</span><br><span class="line">  TK_POINT, // 指针解引用 *p</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct rule &#123;</span><br><span class="line">  const char *regex;</span><br><span class="line">  int token_type;</span><br><span class="line">&#125; rules[] = &#123;</span><br><span class="line"></span><br><span class="line">  /* TODO: Add more rules.</span><br><span class="line">   * Pay attention to the precedence level of different rules.</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  &#123;&quot; +&quot;, TK_NOTYPE&#125;,    // spaces</span><br><span class="line">  &#123;&quot;\\+&quot;, TK_ADD&#125;,         // plus</span><br><span class="line">  &#123;&quot;==&quot;, TK_EQ&#125;,        // equal</span><br><span class="line">  &#123;&quot;-&quot;, TK_SUB&#125;,	// sub</span><br><span class="line">  &#123;&quot;\\*&quot;, TK_MUL&#125;,	// multiply</span><br><span class="line">  &#123;&quot;/&quot;, TK_DIV&#125;,		// divide</span><br><span class="line">  &#123;&quot;\\(&quot;, TK_LB&#125;,		// left bracket</span><br><span class="line">  &#123;&quot;\\)&quot;, TK_RB&#125;,		// right bracket</span><br><span class="line">  &#123;&quot;[0-9]+&quot;, TK_DEC&#125;, // decimal number</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="任务-实现算术表达式的递归求值"><a href="#任务-实现算术表达式的递归求值" class="headerlink" title="任务 实现算术表达式的递归求值"></a>任务 实现算术表达式的递归求值</h3><p>​	这算一个比较难得步骤，我们要实现<code>eval(p,q)</code>和<code>check_parentheses()</code>函数。讲义给出了<code>eval</code>的框架。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">eval(p, q) &#123;</span><br><span class="line">  if (p &gt; q) &#123;</span><br><span class="line">    /* Bad expression */</span><br><span class="line">  &#125;</span><br><span class="line">  else if (p == q) &#123;</span><br><span class="line">    /* Single token.</span><br><span class="line">     * For now this token should be a number.</span><br><span class="line">     * Return the value of the number.</span><br><span class="line">     */</span><br><span class="line">  &#125;</span><br><span class="line">  else if (check_parentheses(p, q) == true) &#123;</span><br><span class="line">    /* The expression is surrounded by a matched pair of parentheses.</span><br><span class="line">     * If that is the case, just throw away the parentheses.</span><br><span class="line">     */</span><br><span class="line">    return eval(p + 1, q - 1);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    /* We should do more things here. */</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	第一二种情况就不再赘述。从第三种情况开始，我们先实现括号匹配函数<code>check_parentheses()</code>，大概思路就是判断位置<code>p</code>的括号是否和位置<code>q</code>的括号相匹配。我们用一个栈来实现，不过需要注意的是，不同于处理字符串的括号匹配算法，我们需要将括号<code>p</code>的位置也存入栈中，以便将来出栈时判断和左括号<code>p</code>匹配的右括号是否为<code>q</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool check_parentheses(int p, int q) &#123;</span><br><span class="line">	if(tokens[p].type != TK_LB || tokens[q].type != TK_RB) return false;</span><br><span class="line">	SqStack *S = (SqStack*)malloc(sizeof(SqStack));</span><br><span class="line">	initStack(S);</span><br><span class="line"></span><br><span class="line">	for(int i = p; i &lt;= q; ++i) &#123;</span><br><span class="line">		if(tokens[i].type == TK_LB) &#123;</span><br><span class="line">			push(S, &#x27;(&#x27;, i);</span><br><span class="line">		&#125; else if(tokens[i].type == TK_RB) &#123;</span><br><span class="line">			char* x = (char*)malloc(sizeof(char));</span><br><span class="line">			int* pos = (int*)malloc(sizeof(int));</span><br><span class="line">			if(!pop(S, x, pos)) &#123; return false; &#125; </span><br><span class="line">			if( *pos == p &amp;&amp; i == q) return true;</span><br><span class="line">			else if(*pos == p || i == q) return false;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	if(!isEmpty(S)) return false;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	如果匹配成功，则丢掉这两个匹配的括号继续递归求值。</p>
<p>​	<code>else</code>中的内容是笔者借鉴的，确实没有想出来如何找到主元素。</p>
<blockquote>
<p>​	上面的框架已经考虑了BNF中算术表达式的开头两种定义, 接下来我们来考虑剩下的情况(即上述伪代码中最后一个<code>else</code>中的内容). 一个问题是, 给出一个最左边和最右边不同时是括号的长表达式, 我们要怎么正确地将它分裂成两个子表达式? 我们定义”主运算符”为表达式人工求值时, 最后一步进行运行的运算符, 它指示了表达式的类型(例如当一个表达式的最后一步是减法运算时, 它本质上是一个减法表达式). 要正确地对一个长表达式进行分裂, 就是要找到它的主运算符. </p>
<p>…</p>
<p>…</p>
<p>通过上面这个简单的例子, 我们就可以总结出如何在一个token表达式中寻找主运算符了:</p>
<ul>
<li>非运算符的token不是主运算符.</li>
<li>出现在一对括号中的token不是主运算符. 注意到这里不会出现有括号包围整个表达式的情况, 因为这种情况已经在<code>check_parentheses()</code>相应的<code>if</code>块中被处理了.</li>
<li>主运算符的优先级在表达式中是最低的. 这是因为主运算符是最后一步才进行的运算符.</li>
<li>当有多个运算符的优先级都是最低时, 根据结合性, 最后被结合的运算符才是主运算符. 一个例子是<code>1 + 2 + 3</code>, 它的主运算符应该是右边的<code>+</code>.</li>
</ul>
</blockquote>
<p>​	照着讲义的思路，给出以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/* find the position of main operator in token expression using recursion */</span><br><span class="line">		int op = 0;	// 主元素的位置</span><br><span class="line">		int minPriority = 5;	// 初始时最小优先级设为 5</span><br><span class="line">		int curPriority = 0;  // 当前优先级为 0</span><br><span class="line">		int brackets = 0; 		// 记录括号，因为在括号中的运算符优先级最高，而我们的目的是找到最小优先级，故当存在括号时，当前操作符的优先级被设为最高 5</span><br><span class="line">		/* 以下考虑 ‘+ - * / ==’ */</span><br><span class="line">		</span><br><span class="line">		for (int i = p; i &lt;= q; ++i) &#123;</span><br><span class="line">			if (tokens[i].type == TK_MUL || tokens[i].type == TK_DIV) &#123;</span><br><span class="line">				if (brackets == 0) &#123; curPriority = 4; &#125;	// 乘除法的优先级为 4</span><br><span class="line">				else &#123; curPriority = 5; &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (tokens[i].type == TK_ADD || tokens[i].type == TK_SUB) &#123;</span><br><span class="line">				if (brackets == 0) &#123; curPriority = 3; &#125;	// 加减法优先级为 3</span><br><span class="line">				else &#123; curPriority = 5; &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (tokens[i].type == TK_EQ) &#123;</span><br><span class="line">				if (brackets == 0) &#123; curPriority = 2; &#125;	// 等号优先级为 2</span><br><span class="line">				else &#123; curPriority = 5; &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (tokens[i].type == TK_LB) &#123;</span><br><span class="line">				++brackets;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (tokens[i].type == TK_RB) &#123;</span><br><span class="line">				--brackets;</span><br><span class="line">				continue;</span><br><span class="line">			&#125; else &#123; continue; &#125;</span><br><span class="line">			/* 	如果当前操作符优先级 &lt;= 最小优先级(取等号的原因是最后被结合的运算符才是主运算符) </span><br><span class="line">			 *	则替换主操作符位置</span><br><span class="line">			*/</span><br><span class="line">			if(curPriority &lt;= minPriority) &#123;</span><br><span class="line">				minPriority = curPriority;</span><br><span class="line">				op = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		/* 找到主操作符后，分割并递归求值 */</span><br><span class="line">		uint32_t val1 = eval(p, op -1, flag);</span><br><span class="line">		uint32_t val2 = eval(op + 1, q, flag);</span><br><span class="line">		/* 执行操作后返回值 */</span><br><span class="line">		switch(tokens[op].type) &#123;</span><br><span class="line">			case TK_ADD: </span><br><span class="line">				return val1 + val2;</span><br><span class="line">			case TK_SUB: </span><br><span class="line">				return val1 - val2;</span><br><span class="line">			case TK_MUL:</span><br><span class="line">				return val1 * val2;</span><br><span class="line">			case TK_EQ:</span><br><span class="line">				return val1 == val2;</span><br><span class="line">			case TK_DIV:</span><br><span class="line">				return val1 / val2;</span><br><span class="line">			default:</span><br><span class="line">				printf(&quot;func eval switch bad type\n&quot;);</span><br><span class="line">				assert(0);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>​	接着完善<code>expr()</code>函数，该函数先识别字符串并存储到<code>tokens</code>数组中去，接着便利所有规则，对负数，接触引用等具有特殊含义的token进行重新标记，以便后续<code>eval()</code>函数识别并处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">word_t expr(char *e, bool *success) &#123;</span><br><span class="line">  // 如果不在给定的token之中，则返回0，并置为false</span><br><span class="line">  if (!make_token(e)) &#123;</span><br><span class="line">    *success = false;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  /* TODO: Insert codes to evaluate the expression. */</span><br><span class="line">  // TODO();</span><br><span class="line">  // 遍历所有规则</span><br><span class="line">  for(int i = 0; i &lt; nr_token; ++i) &#123;</span><br><span class="line">	  // if the type is &#x27;-&#x27; and it is the first symbol of the expr, it is a negtive flag</span><br><span class="line">	  if( tokens[i].type == TK_SUB) &#123;</span><br><span class="line">		  if (i == 0) &#123; tokens[i].type = TK_NEG; &#125;</span><br><span class="line">		  else if(tokens[i - 1].type == TK_ADD </span><br><span class="line">			|| tokens[i - 1].type == TK_SUB</span><br><span class="line">			|| tokens[i - 1].type == TK_MUL</span><br><span class="line">			|| tokens[i - 1].type == TK_DIV</span><br><span class="line">			|| tokens[i - 1].type == TK_LB</span><br><span class="line">			|| tokens[i - 1].type == TK_NEG</span><br><span class="line">			|| tokens[i - 1].type == TK_POINT) &#123;</span><br><span class="line">		 // in this condition, the - will be a negtive flag</span><br><span class="line">		 tokens[i].type = TK_NEG;</span><br><span class="line">	  	&#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	  else if(tokens[i].type == TK_MUL) &#123;</span><br><span class="line">		// in this condition, * will be a get value symbol</span><br><span class="line">	  	if (i == 0) &#123;</span><br><span class="line">			tokens[i].type = TK_POINT;</span><br><span class="line">		&#125; else if (i == nr_token - 1) &#123;</span><br><span class="line">			*success = false;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125; else if (tokens[i - 1].type == TK_ADD </span><br><span class="line">				|| tokens[i - 1].type == TK_SUB</span><br><span class="line">				|| tokens[i - 1].type == TK_MUL</span><br><span class="line">				|| tokens[i - 1].type == TK_DIV</span><br><span class="line">				|| tokens[i - 1].type == TK_LB</span><br><span class="line">				|| tokens[i - 1].type == TK_NEG</span><br><span class="line">				|| tokens[i - 1].type == TK_POINT) &#123;</span><br><span class="line">			tokens[i].type = TK_POINT;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *success = true;</span><br><span class="line">  return eval(0, nr_token - 1, success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	效果如下图所示：</p>
<p>​	<img src="/../images/PA1-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0%E7%9A%84%E7%AF%87%E7%AB%A0-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%88%AA%E5%B1%8F2023-10-11%2014.13.58-7004844.png" alt="截屏2023-10-11 14.13.58"></p>
<h3 id="任务-实现表达式生成器"><a href="#任务-实现表达式生成器" class="headerlink" title="任务  实现表达式生成器"></a>任务  实现表达式生成器</h3><blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gen_rand_expr</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (choose(<span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: gen_num(); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: gen(<span class="string">&#x27;(&#x27;</span>); gen_rand_expr(); gen(<span class="string">&#x27;)&#x27;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: gen_rand_expr(); gen_rand_op(); gen_rand_expr(); <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上文内容, 实现表达式生成器. 实现后, 就可以用来生成表达式求值的测试用例了.</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gen-expr 10000 &gt; input</span><br></pre></td></tr></table></figure>

<p>将会生成10000个测试用例到<code>input</code>文件中, 其中每行为一个测试用例, 其格式为</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果 表达式</span><br></pre></td></tr></table></figure>

<p>再稍微改造一下NEMU的<code>main()</code>函数, 让其读入<code>input</code>文件中的测试表达式后, 直接调用<code>expr()</code>, 并与结果进行比较. 为了容纳长表达式的求值, 你还需要对<code>tokens</code>数组的大小进行修改.</p>
<p>随着你的程序通过越来越多的测试, 你会对你的代码越来越有信心.</p>
</blockquote>
<p>​	这里就直接把代码贴出来了，生成的错误表达式将直接被程序抛弃，这个功能<code>NEMU</code>已经实现了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">int index_buf = 0;</span><br><span class="line"></span><br><span class="line">int choose(int n)&#123;</span><br><span class="line">    int flag = rand() % 3 ; // 0 1 2</span><br><span class="line">	printf(&quot;index = %d, flag = %d. \n&quot;,index_buf, flag);</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br><span class="line">void gen_num()&#123;</span><br><span class="line">    int num = rand()% 100;</span><br><span class="line">    int num_size = 0, num_tmp = num;</span><br><span class="line">    while(num_tmp)&#123;</span><br><span class="line">	num_tmp /= 10;</span><br><span class="line">	num_size ++;</span><br><span class="line">    &#125;</span><br><span class="line">    int x = 1;</span><br><span class="line">    while(num_size)</span><br><span class="line">    &#123;</span><br><span class="line">	x *= 10;</span><br><span class="line">	num_size -- ;</span><br><span class="line">    &#125;</span><br><span class="line">    x /= 10;</span><br><span class="line">    while(num)</span><br><span class="line">    &#123;</span><br><span class="line">	char c = num / x + &#x27;0&#x27;;</span><br><span class="line">	num %= x;</span><br><span class="line">	x /= 10;</span><br><span class="line">	buf[index_buf ++] = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void gen(char c)&#123;</span><br><span class="line">    buf[index_buf ++] = c;</span><br><span class="line">&#125;</span><br><span class="line">void gen_rand_op()&#123;</span><br><span class="line">    char op[4] = &#123;&#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27;, &#x27;/&#x27;&#125;;</span><br><span class="line">    int op_position = rand() % 4;</span><br><span class="line">    buf[index_buf ++] = op[op_position];</span><br><span class="line">&#125;</span><br><span class="line">static void gen_rand_expr() &#123;</span><br><span class="line">  //  buf[0] = &#x27;\0&#x27;;</span><br><span class="line">  /*</span><br><span class="line">   * switch (choose(3)) &#123;</span><br><span class="line">   *	case 0: gen_num(); break;</span><br><span class="line">   *	case 1: gen(&#x27;(&#x27;); gen_rand_expr(); gen(&#x27;)&#x27;); break;</span><br><span class="line">   *	default: gen_rand_expr(); gen_rand_op(); gen_rand_expr(); break;</span><br><span class="line">   * &#125;</span><br><span class="line">   * */</span><br><span class="line">	switch(choose(3)) &#123;</span><br><span class="line">		case 0: </span><br><span class="line">			gen_num();</span><br><span class="line">			break;</span><br><span class="line">		case 1: gen(&#x27;(&#x27;);</span><br><span class="line">			gen_rand_expr();</span><br><span class="line">			gen(&#x27;)&#x27;);</span><br><span class="line">			break;</span><br><span class="line">		default:</span><br><span class="line">			gen_rand_expr();</span><br><span class="line">			gen_rand_op();</span><br><span class="line">			gen_rand_expr();</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="theLonging"
      src="/images/touxiang.JPG">
  <p class="site-author-name" itemprop="name">theLonging</p>
  <div class="site-description" itemprop="description">不捨晝夜。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/chantchanH7" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chantchanH7" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/562879980@qq.com" title="E-Mail → 562879980@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-07 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">theLonging</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">362k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:29</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
