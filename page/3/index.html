<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="不捨晝夜。">
<meta property="og:type" content="website">
<meta property="og:title" content="talk is cheap, show me the code.">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="talk is cheap, show me the code.">
<meta property="og:description" content="不捨晝夜。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="theLonging">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>talk is cheap, show me the code.</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">talk is cheap, show me the code.</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/11/Lab-page-tables/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/11/Lab-page-tables/" class="post-title-link" itemprop="url">Lab: page tables</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-11 20:03:25" itemprop="dateCreated datePublished" datetime="2024-01-11T20:03:25+08:00">2024-01-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-28 13:40:02" itemprop="dateModified" datetime="2024-02-28T13:40:02+08:00">2024-02-28</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>33k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>30 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab-page-tables"><a href="#Lab-page-tables" class="headerlink" title="Lab: page tables"></a>Lab: page tables</h1><p>准备工作：</p>
<ol>
<li>阅读<code>book-riscv-rev1</code>第三章</li>
<li>阅读<code>memlayout.h</code></li>
<li>阅读<code>vm.c</code></li>
<li>阅读<code>riscv.h</code></li>
<li>阅读<code>kalloc.c</code></li>
<li>阅读<code>exec.c</code></li>
</ol>
<h2 id="从main-c开始："><a href="#从main-c开始：" class="headerlink" title="从main.c开始："></a>从<code>main.c</code>开始：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start() jumps here in supervisor mode on all CPUs.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">    kinit();         <span class="comment">// physical page allocator</span></span><br><span class="line">    kvminit();       <span class="comment">// create kernel page table</span></span><br><span class="line">    kvminithart();   <span class="comment">// turn on paging</span></span><br><span class="line">    procinit();      <span class="comment">// process table</span></span><br><span class="line">    trapinit();      <span class="comment">// trap vectors</span></span><br><span class="line">    trapinithart();  <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinit();      <span class="comment">// set up interrupt controller</span></span><br><span class="line">    plicinithart();  <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">    binit();         <span class="comment">// buffer cache</span></span><br><span class="line">    iinit();         <span class="comment">// inode table</span></span><br><span class="line">    fileinit();      <span class="comment">// file table</span></span><br><span class="line">    virtio_disk_init(); <span class="comment">// emulated hard disk</span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(started == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hart %d starting\n&quot;</span>, cpuid());</span><br><span class="line">    kvminithart();    <span class="comment">// turn on paging</span></span><br><span class="line">    trapinithart();   <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinithart();   <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">  &#125;</span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kinit-函数分配物理页面physical-page-allocator"><a href="#kinit-函数分配物理页面physical-page-allocator" class="headerlink" title="kinit()函数分配物理页面physical page allocator:"></a><code>kinit()</code>函数分配物理页面<code>physical page allocator:</code></h3><p>其中<code>end</code>指向内核代码后的第一个地址，也即<code>kernel data</code>结束的地方，现在我们知道，<code>freerange()</code>函数将图中<code>Free memory</code>的部分全部清空，并以页面对齐的形式存入<code>freelist</code>中。</p>
<p><img src="/../images/Lab-page-tables/%E6%88%AA%E5%B1%8F2024-01-16%2011.02.46.png" alt="截屏2024-01-16 11.02.46"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kinit</span><span class="params">()</span> &#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>); <span class="comment">// kinit 初始化保护 kmem 的自旋锁</span></span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP); <span class="comment">// freerange 对 end 到 PHYSTOP 之间的每一页调用 kfree 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="freerange-函数"><a href="#freerange-函数" class="headerlink" title="freerange()函数:"></a><code>freerange()</code>函数:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);	<span class="comment">// 将起始地址按页对齐</span></span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="kfree-函数"><a href="#kfree-函数" class="headerlink" title="kfree()函数:"></a><code>kfree()</code>函数:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free the page of physical memory pointed at by pa,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP) <span class="comment">// 判断物理地址是否规范</span></span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">  <span class="comment">// 将该页填充垃圾数据</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line">  acquire(&amp;kmem.lock);	<span class="comment">// 请求锁</span></span><br><span class="line">  r-&gt;next = kmem.freelist;	<span class="comment">// 头插法插入空闲页列表</span></span><br><span class="line">  kmem.freelist = r;	</span><br><span class="line">  release(&amp;kmem.lock);	<span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kvminit-函数创建内核页表："><a href="#kvminit-函数创建内核页表：" class="headerlink" title="kvminit()函数创建内核页表："></a><code>kvminit()</code>函数创建内核页表：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the one kernel_pagetable</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvminit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  kernel_pagetable = kvmmake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="kvmmake-为内核制作一个直接映射的页表："><a href="#kvmmake-为内核制作一个直接映射的页表：" class="headerlink" title="kvmmake()为内核制作一个直接映射的页表："></a><code>kvmmake()</code>为内核制作一个直接映射的页表：</h4><p>其中<code>etext</code>指向内核代码结束的地方，即<code>kernel text</code>结束的地方。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Make a direct-map page table for the kernel.</span></span><br><span class="line"><span class="type">pagetable_t</span> <span class="title function_">kvmmake</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">pagetable_t</span> kpgtbl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建内核页表</span></span><br><span class="line">  kpgtbl = (<span class="type">pagetable_t</span>) kalloc();	<span class="comment">// kalloc()函数从freelist中取出一页并返回</span></span><br><span class="line">  <span class="built_in">memset</span>(kpgtbl, <span class="number">0</span>, PGSIZE);	<span class="comment">// 将内核页表填充空</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W); <span class="comment">// 直接映射 uart 寄存器的 虚拟地址 到 物理地址</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W); <span class="comment">// 直接映射 virtio disk 接口的 虚拟地址 到 物理地址</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  kvmmap(kpgtbl, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W); <span class="comment">// 直接映射 PLIC 的 虚拟地址 到 物理地址，大小为 0x400000</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// kernel text 在 内核代码结束的地方往下增长一个 KERNBASE 大小</span></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将内核数据和物理内存映射</span></span><br><span class="line">  <span class="comment">// 接着上面映射，将kernel data 和 free memory 映射到 从 etext 到 PHYSTOP 的物理地址空间中</span></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 映射 负责 trap entry/exit 的 trampoline</span></span><br><span class="line">  <span class="comment">// trampoline 是在 内核虚拟地址的最高处</span></span><br><span class="line">  <span class="comment">// 即从最大的虚拟地址向下分配一页给 trampoline</span></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为每一个进程分配和映射 内核栈</span></span><br><span class="line">  <span class="comment">// allocate and map a kernel stack for each process.</span></span><br><span class="line">  proc_mapstacks(kpgtbl);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> kpgtbl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="proc-mapstacks-函数为进程分配一页内核栈："><a href="#proc-mapstacks-函数为进程分配一页内核栈：" class="headerlink" title="proc_mapstacks()函数为进程分配一页内核栈："></a><code>proc_mapstacks()</code>函数为进程分配一页内核栈：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map kernel stacks beneath the trampoline,</span></span><br><span class="line"><span class="comment">// each surrounded by invalid guard pages.</span></span><br><span class="line"><span class="comment">// 内核栈映射到 trampoline 的下方，每一个内核栈页紧跟一个保护页</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACK(p) (TRAMPOLINE - (p)*2*PGSIZE - 3*PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a page for each process&#x27;s kernel stack.</span></span><br><span class="line"><span class="comment">// Map it high in memory, followed by an invalid guard page.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">proc_mapstacks</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="comment">// 遍历所有进程，为每一个进程分配一页内核栈</span></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="type">char</span> *pa = kalloc();	<span class="comment">// 分配物理页面</span></span><br><span class="line">    <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">    uint64 va = KSTACK((<span class="type">int</span>) (p - proc));	<span class="comment">// 映射后返回虚拟地址</span></span><br><span class="line">    kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);	<span class="comment">// 将虚拟地址 映射到 物理地址上</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kvminithart-函数启用分页："><a href="#kvminithart-函数启用分页：" class="headerlink" title="kvminithart()函数启用分页："></a><code>kvminithart()</code>函数启用分页：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Switch h/w page table register to the kernel&#x27;s page table, and enable paging.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvminithart</span><span class="params">()</span>	<span class="comment">// 将硬件页表寄存器切换到内核的页表，并启用分页</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// wait for any previous writes to the page table memory to finish.</span></span><br><span class="line">  sfence_vma();</span><br><span class="line">  <span class="comment">// install the kernel page table</span></span><br><span class="line">  <span class="comment">// writes the physical page address of the root page-table page into the register satp</span></span><br><span class="line">  <span class="comment">// after this the CPU will translate addresses using the kernel page table</span></span><br><span class="line">  <span class="comment">// 加载内核页表</span></span><br><span class="line">  <span class="comment">// 将 根页表页的物理页地址写入 寄存器satp 中</span></span><br><span class="line">  <span class="comment">// 然后 cpu 可以通过 内核页表 翻译地址</span></span><br><span class="line">  w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line">  <span class="comment">// flush stale entries from the TLB.</span></span><br><span class="line">  sfence_vma();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use riscv&#x27;s sv39 page table scheme.</span></span><br><span class="line"><span class="comment">// 使用 riscv&#x27;s sv39 页表标准</span></span><br><span class="line"><span class="comment">// SV39是一种支持39位虚拟地址的页表模式。将8L左移60位，是为了将模式设置位放置在`satp`寄存器的最高位，因为在SV39模式中，`satp`寄存器的 [63:60] 位用于指定页表模式。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP_SV39 (8L &lt;&lt; 60)</span></span><br><span class="line"><span class="comment">// 右移12位是因为RISC-V中的页表基地址是按4KB对齐的，所以低12位应该是0。右移操作删除了这些对齐位。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAKE_SATP(pagetable) (SATP_SV39 | (((uint64)pagetable) &gt;&gt; 12))</span></span><br></pre></td></tr></table></figure>

<h3 id="procinit-初始化进程表："><a href="#procinit-初始化进程表：" class="headerlink" title="procinit()初始化进程表："></a><code>procinit()</code>初始化进程表：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize the proc table.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">procinit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  initlock(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);</span><br><span class="line">  initlock(&amp;wait_lock, <span class="string">&quot;wait_lock&quot;</span>);</span><br><span class="line">  <span class="comment">// 开始时 p = proc，p 的位置是数组 proc[NPROC] 的起始位置</span></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      initlock(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line">      p-&gt;state = UNUSED;</span><br><span class="line">      p-&gt;kstack = KSTACK((<span class="type">int</span>) (p - proc));</span><br><span class="line">      <span class="comment">// 指针相减就是地址相减，获取当前进程p和proc数组最开始位置的偏移量</span></span><br><span class="line">      <span class="comment">// 比如第一次 p - proc = 0，则p-&gt;kstack = TRAMPOLINE - 3 * PGSIZE</span></span><br><span class="line">      <span class="comment">// 3 个 pagesize 分别是</span></span><br><span class="line">      <span class="comment">// trampolie</span></span><br><span class="line">      <span class="comment">// guard page 占一个 pagesize</span></span><br><span class="line">      <span class="comment">// kstack0    占一个 pagesize</span></span><br><span class="line">      <span class="comment">// guard page 占一个 pagesize</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="memlayout-h头文件描述了物理内存的布局"><a href="#memlayout-h头文件描述了物理内存的布局" class="headerlink" title="memlayout.h头文件描述了物理内存的布局"></a><code>memlayout.h</code>头文件描述了物理内存的布局</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Physical memory layout</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu -machine virt is set up like this,</span></span><br><span class="line"><span class="comment">// based on qemu&#x27;s hw/riscv/virt.c:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 00001000 -- boot ROM, provided by qemu</span></span><br><span class="line"><span class="comment">// 02000000 -- CLINT</span></span><br><span class="line"><span class="comment">// 0C000000 -- PLIC</span></span><br><span class="line"><span class="comment">// 10000000 -- uart0 </span></span><br><span class="line"><span class="comment">// 10001000 -- virtio disk </span></span><br><span class="line"><span class="comment">// 80000000 -- boot ROM jumps here in machine mode</span></span><br><span class="line"><span class="comment">//             -kernel loads the kernel here</span></span><br><span class="line"><span class="comment">// unused RAM after 80000000.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the kernel uses physical memory thus:</span></span><br><span class="line"><span class="comment">// 80000000 -- entry.S, then kernel text and data</span></span><br><span class="line"><span class="comment">// end -- start of kernel page allocation area</span></span><br><span class="line"><span class="comment">// PHYSTOP -- end RAM used by the kernel</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu puts UART registers here in physical memory.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0 0x10000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0_IRQ 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// virtio mmio interface</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO0 0x10001000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO0_IRQ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_NET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_IRQ 33</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// core local interruptor (CLINT), which contains the timer.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT 0x2000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT_MTIMECMP(hartid) (CLINT + 0x4000 + 8*(hartid))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT_MTIME (CLINT + 0xBFF8) <span class="comment">// cycles since boot.</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu puts platform-level interrupt controller (PLIC) here.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC 0x0c000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_PRIORITY (PLIC + 0x0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_PENDING (PLIC + 0x1000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_MENABLE(hart) (PLIC + 0x2000 + (hart)*0x100)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SENABLE(hart) (PLIC + 0x2080 + (hart)*0x100)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_MPRIORITY(hart) (PLIC + 0x200000 + (hart)*0x2000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SPRIORITY(hart) (PLIC + 0x201000 + (hart)*0x2000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_MCLAIM(hart) (PLIC + 0x200004 + (hart)*0x2000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SCLAIM(hart) (PLIC + 0x201004 + (hart)*0x2000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the kernel expects there to be RAM</span></span><br><span class="line"><span class="comment">// for use by the kernel and user pages</span></span><br><span class="line"><span class="comment">// from physical address 0x80000000 to PHYSTOP.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNBASE 0x80000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHYSTOP (KERNBASE + 128*1024*1024)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map the trampoline page to the highest address,</span></span><br><span class="line"><span class="comment">// in both user and kernel space.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAMPOLINE (MAXVA - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map kernel stacks beneath the trampoline,</span></span><br><span class="line"><span class="comment">// each surrounded by invalid guard pages.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACK(p) (TRAMPOLINE - (p)*2*PGSIZE - 3*PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// User memory layout.</span></span><br><span class="line"><span class="comment">// Address zero first:</span></span><br><span class="line"><span class="comment">//   text</span></span><br><span class="line"><span class="comment">//   original data and bss</span></span><br><span class="line"><span class="comment">//   fixed-size stack</span></span><br><span class="line"><span class="comment">//   expandable heap</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   USYSCALL (shared with kernel)</span></span><br><span class="line"><span class="comment">//   TRAPFRAME (p-&gt;trapframe, used by the trampoline)</span></span><br><span class="line"><span class="comment">//   TRAMPOLINE (the same page as in the kernel)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE)  <span class="comment">// 将 USYSCALL 映射到 TRAPFRAME 地址空间后的一页</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> pid;  <span class="comment">// Process ID</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="vm-c描述了内核地址和用户地址的处理："><a href="#vm-c描述了内核地址和用户地址的处理：" class="headerlink" title="vm.c描述了内核地址和用户地址的处理："></a><code>vm.c</code>描述了内核地址和用户地址的处理：</h2><h3 id="pte-t-walk-pagetable-t-pagetable-uint64-va-int-alloc-函数返回虚拟地址va对应的页表项"><a href="#pte-t-walk-pagetable-t-pagetable-uint64-va-int-alloc-函数返回虚拟地址va对应的页表项" class="headerlink" title="pte_t *walk(pagetable_t pagetable, uint64 va, int alloc)函数返回虚拟地址va对应的页表项"></a><code>pte_t *walk(pagetable_t pagetable, uint64 va, int alloc)</code>函数返回虚拟地址va对应的页表项</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the address of the PTE in page table pagetable</span></span><br><span class="line"><span class="comment">// that corresponds to virtual address va. If alloc!=0,</span></span><br><span class="line"><span class="comment">// create any required page-table pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The risc-v Sv39 scheme has three levels of page-table</span></span><br><span class="line"><span class="comment">// pages. A page-table page contains 512 64-bit PTEs.</span></span><br><span class="line"><span class="comment">// A 64-bit virtual address is split into five fields:</span></span><br><span class="line"><span class="comment">//   39..63 -- must be zero.</span></span><br><span class="line"><span class="comment">//   30..38 -- 9 bits of level-2 index.</span></span><br><span class="line"><span class="comment">//   21..29 -- 9 bits of level-1 index.</span></span><br><span class="line"><span class="comment">//   12..20 -- 9 bits of level-0 index.</span></span><br><span class="line"><span class="comment">//    0..11 -- 12 bits of byte offset within the page.</span></span><br><span class="line"><span class="comment">// walk函数为给定va找到其对应的PTE</span></span><br><span class="line"><span class="type">pte_t</span> *<span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)   <span class="comment">// 给定va不能大于最大虚拟地址</span></span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">    <span class="comment">// 根据当前level，对va进行移位和掩码操作，得到当前level页表的中对应PTE</span></span><br><span class="line">    <span class="comment">// 当 level = 2 时，向右移出 12 + 2 * 9 = 30, 经掩码后得到9位level=2页表的PTE编号</span></span><br><span class="line">    <span class="comment">// 当 level = 1 时，向右移出 12 + 1 * 9 = 21, 经掩码后得到9位level=1页表的PTE编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;  <span class="comment">// 判断有效位</span></span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">      <span class="comment">// 提取物理地址，对应一个页的首地址</span></span><br><span class="line">      <span class="comment">// PTE2PA 函数将最右10位标志位移出，补充12位全0偏移位（12位对应offset），原44位 PPN 保留，得到指向下一层页表的物理地址</span></span><br><span class="line">      <span class="comment">// level = 2 时，pagetable 指向 level = 1 的页表</span></span><br><span class="line">      <span class="comment">// level = 1 时，pagetable 指向 level = 0 的页表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 对应PTE不存在，且alloc被置位，则为该PTE指向的下一层页表分配一页</span></span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 一切清0，新分配的下一级页表的所有PTE也是无效的</span></span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      <span class="comment">// 更新PTE，将56位物理地址右移12位去掉偏移位，移进10位标志位，同时将PTE_V置1</span></span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 跳出循环，此时 pagetable 指向level = 0 的页表</span></span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">  <span class="comment">// level=0，向右移出12位，经掩码后得到9位level=0页表的PTE编号</span></span><br><span class="line">  <span class="comment">// 返回va对应的level=0页表中的对应PTE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uint64-walkaddr-pagetable-t-pagetable-uint64-va-返回虚拟地址va对应的物理地址："><a href="#uint64-walkaddr-pagetable-t-pagetable-uint64-va-返回虚拟地址va对应的物理地址：" class="headerlink" title="uint64 walkaddr(pagetable_t pagetable, uint64 va)返回虚拟地址va对应的物理地址："></a><code>uint64 walkaddr(pagetable_t pagetable, uint64 va)</code>返回虚拟地址<code>va</code>对应的物理地址：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look up a virtual address, return the physical address,</span></span><br><span class="line"><span class="comment">// or 0 if not mapped.</span></span><br><span class="line"><span class="comment">// Can only be used to look up user pages.</span></span><br><span class="line">uint64 <span class="title function_">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> &#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  pa = PTE2PA(*pte);	<span class="comment">// 通过PTE寻找PA</span></span><br><span class="line">  <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kvmmap-为内核页表添加映射："><a href="#kvmmap-为内核页表添加映射：" class="headerlink" title="kvmmap()为内核页表添加映射："></a><code>kvmmap()</code>为内核页表添加映射：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a mapping to the kernel page table.</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvmmap</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kpgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-mappages-pagetable-t-pagetable-uint64-va-uint64-size-uint64-pa-int-perm"><a href="#int-mappages-pagetable-t-pagetable-uint64-va-uint64-size-uint64-pa-int-perm" class="headerlink" title="int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)"></a><code>int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)</code></h3><p>该函数为虚拟地址<code>va</code>设置到物理地址<code>pa</code>的页表项，<code>va</code>和<code>size</code>必须是按页对齐的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class="line"><span class="comment">// physical addresses starting at pa.</span></span><br><span class="line"><span class="comment">// va and size MUST be page-aligned.</span></span><br><span class="line"><span class="comment">// Returns 0 on success, -1 if walk() couldn&#x27;t</span></span><br><span class="line"><span class="comment">// allocate a needed page-table page.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span> &#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;   <span class="comment">// 指向将要分配的 page table entry</span></span><br><span class="line">  <span class="comment">// 判断是否按页对齐</span></span><br><span class="line">  <span class="keyword">if</span>((va % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: va not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((size % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: size not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: size&quot;</span>);</span><br><span class="line">  <span class="comment">// a 是 va的起始地址</span></span><br><span class="line">  a = va;</span><br><span class="line">  <span class="comment">// last 是 va 的终止地址，按页对齐</span></span><br><span class="line">  last = va + size - PGSIZE;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;mappages: remap&quot;</span>); <span class="comment">// 该 pte 已经被分配，其 PTE_V 位 有效</span></span><br><span class="line">    <span class="comment">// 将物理地址的 PPN 取出来，加上标志位信息 prem 和 有效位 PTE_V</span></span><br><span class="line">    <span class="comment">// 然后将该有效位 放入 pte 中</span></span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="keyword">if</span>(a == last)   <span class="comment">// 分配到了足够的页数就跳出循环</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">    <span class="comment">// 已经分配了一页，虚拟地址的起始位置和物理地址的起始位置都增加一页</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-uvmunmap"><a href="#void-uvmunmap" class="headerlink" title="void uvmunmap()"></a><code>void uvmunmap()</code></h3><p>从虚拟地址<code>va</code>开始，移除 <code>npages</code> 个映射。<code>va</code>必须是页对齐的。这些映射必须是存在的。且可选的释放物理内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remove npages of mappings starting from va. va must be</span></span><br><span class="line"><span class="comment">// page-aligned. The mappings must exist.</span></span><br><span class="line"><span class="comment">// Optionally free the physical memory.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  <span class="keyword">if</span>((va % PGSIZE) != <span class="number">0</span>)	<span class="comment">// 虚拟地址必须是页对齐的</span></span><br><span class="line">    panic(<span class="string">&quot;uvmunmap: not aligned&quot;</span>);</span><br><span class="line">  <span class="comment">/* 循环遍历从 va 开始的 n 个页 */</span></span><br><span class="line">  <span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)	<span class="comment">// walk函数找到a对应的PTE</span></span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: walk&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)	<span class="comment">// 检查该 PTE 是否有效</span></span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: not mapped&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(PTE_FLAGS(*pte) == PTE_V) <span class="comment">// 检查是否为叶子页表条目</span></span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(do_free)&#123;	<span class="comment">// do_free 为真时，释放内存</span></span><br><span class="line">      uint64 pa = PTE2PA(*pte);	<span class="comment">// 通过 PTE2PA 获取物理地址 </span></span><br><span class="line">      kfree((<span class="type">void</span>*)pa);	<span class="comment">// 释放物理内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pagetable-t-uvmcreate-创建一个空用户页表并返回"><a href="#pagetable-t-uvmcreate-创建一个空用户页表并返回" class="headerlink" title="pagetable_t uvmcreate()创建一个空用户页表并返回"></a><code>pagetable_t uvmcreate()</code>创建一个空用户页表并返回</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create an empty user page table.</span></span><br><span class="line"><span class="comment">// returns 0 if out of memory.</span></span><br><span class="line"><span class="type">pagetable_t</span> <span class="title function_">uvmcreate</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line">  pagetable = (<span class="type">pagetable_t</span>) kalloc();	<span class="comment">// 分配一页</span></span><br><span class="line">  <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uint64-uvmalloc-为进程分配PTE和物理内存，以便增加进程的内存大小"><a href="#uint64-uvmalloc-为进程分配PTE和物理内存，以便增加进程的内存大小" class="headerlink" title="uint64 uvmalloc()为进程分配PTE和物理内存，以便增加进程的内存大小"></a><code>uint64 uvmalloc()</code>为进程分配<code>PTE</code>和物理内存，以便增加进程的内存大小</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">uvmalloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz, <span class="type">int</span> xperm)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line">  uint64 a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(newsz &lt; oldsz)</span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line"></span><br><span class="line">  oldsz = PGROUNDUP(oldsz);	<span class="comment">// 将 oldsz 上调到最近的页大小倍数</span></span><br><span class="line">  <span class="comment">// 按页大小循环</span></span><br><span class="line">  <span class="keyword">for</span>(a = oldsz; a &lt; newsz; a += PGSIZE)&#123;</span><br><span class="line">    mem = kalloc();	<span class="comment">// 分配一页</span></span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="comment">// 将虚拟地址 a 以页大小映射到 新分配的物理地址 mem 中</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != <span class="number">0</span>)&#123;</span><br><span class="line">      kfree(mem);</span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newsz;	<span class="comment">// 返回新大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uint64-uvmdealloc-减少进程的内存大小，即释放一部分用户空间内存。"><a href="#uint64-uvmdealloc-减少进程的内存大小，即释放一部分用户空间内存。" class="headerlink" title="uint64 uvmdealloc()减少进程的内存大小，即释放一部分用户空间内存。"></a><code>uint64 uvmdealloc()</code>减少进程的内存大小，即释放一部分用户空间内存。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Deallocate user pages to bring the process size from oldsz to</span></span><br><span class="line"><span class="comment">// newsz.  oldsz and newsz need not be page-aligned, nor does newsz</span></span><br><span class="line"><span class="comment">// need to be less than oldsz.  oldsz can be larger than the actual</span></span><br><span class="line"><span class="comment">// process size.  Returns the new process size.</span></span><br><span class="line">uint64 <span class="title function_">uvmdealloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(newsz &gt;= oldsz)	<span class="comment">// 新的大小必须小于旧的大小</span></span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line">	<span class="comment">// 将 newsz, oldsz 上调到最近的页大小倍数</span></span><br><span class="line">  <span class="keyword">if</span>(PGROUNDUP(newsz) &lt; PGROUNDUP(oldsz))&#123;</span><br><span class="line">    <span class="comment">// 计算出新旧大小间的页面数量</span></span><br><span class="line">    <span class="type">int</span> npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;</span><br><span class="line">    uvmunmap(pagetable, PGROUNDUP(newsz), npages, <span class="number">1</span>);	<span class="comment">// 取消从新的大小开始，到旧的大小之间的 n 页映射</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="freewalk-pagetable-t-pagetable-递归释放页表中的页面，所有的叶子映射必须被移除"><a href="#freewalk-pagetable-t-pagetable-递归释放页表中的页面，所有的叶子映射必须被移除" class="headerlink" title="freewalk(pagetable_t pagetable)递归释放页表中的页面，所有的叶子映射必须被移除"></a><code>freewalk(pagetable_t pagetable)</code>递归释放页表中的页面，所有的叶子映射必须被移除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recursively free page-table pages.</span></span><br><span class="line"><span class="comment">// All leaf mappings must already have been removed.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freewalk</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123; <span class="comment">// 检查条目是否有效且非叶子（即指向另一个页表）</span></span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      freewalk((<span class="type">pagetable_t</span>)child);</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      panic(<span class="string">&quot;freewalk: leaf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*)pagetable);	<span class="comment">// 释放当前页表所占用的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-uvmfree-释放用户空间页，然后释放页表页面"><a href="#void-uvmfree-释放用户空间页，然后释放页表页面" class="headerlink" title="void uvmfree()释放用户空间页，然后释放页表页面"></a><code>void uvmfree()</code>释放用户空间页，然后释放页表页面</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free user memory pages,</span></span><br><span class="line"><span class="comment">// then free page-table pages.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uvmfree</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(sz &gt; <span class="number">0</span>)</span><br><span class="line">    uvmunmap(pagetable, <span class="number">0</span>, PGROUNDUP(sz)/PGSIZE, <span class="number">1</span>); <span class="comment">// 先取消映射</span></span><br><span class="line">  freewalk(pagetable);	<span class="comment">// 然后释放页表中的所有页</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h2><p>一些操作系统通过共享用户空间和内核之间的仅读区域的数据加速某些系统调用。这消除了在执行这些系统调用时对内核交叉的需求。为了帮助你学习如何向页表中插入映射，你的第一个任务是为<code>xv6</code>的<code>getpid()</code>系统调用实现这种优化。</p>
<blockquote>
<p>当进程被创建时，在<code>USYSCALL</code>（一个在<code>memlayout.h</code>定义的虚拟地址）映射一个只读页面。在这个页面的开始，存储了一个<code>struct usyscall</code>，用于保存当前进程的<code>PID</code>。这个实验中，<code>ugetpid()</code>在用户空间中被提供并将会自动的使用<code>USYSCALL</code>映射。</p>
</blockquote>
<p>提示：</p>
<ul>
<li>选择合适的允许位使用户空间访问只读页面。</li>
<li>在新页面的生命周期中需要完成一些事情。为了获得灵感，请了解内核<code>kernel/proc.c</code>中的陷阱框架处理。</li>
</ul>
<p>结构体<code>usyscall</code>用于保存进程<code>ID</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> pid;  <span class="comment">// Process ID</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>函数<code>ugetpid()</code>，其中<code>USYSCALL</code>是一个全局变量，指向用户空间的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ugetpid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> *<span class="title">u</span> =</span> (<span class="keyword">struct</span> usyscall *)USYSCALL;</span><br><span class="line">  <span class="keyword">return</span> u-&gt;pid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>看一看<code>kernel/proc.c</code>中如何描述一个<code>page table</code>的生命周期的？</p>
<blockquote>
<p><code>trampoline (跳板)</code>：通常指的是一种用于实现不同函数或程序段之间跳转的技术，特别是在操作系统内核中用于系统调用和中断处理的上下文切换。</p>
<p><code>trampoline</code>在操作系统内核中的应用</p>
<p>1.系统调用和中断处理：</p>
<ul>
<li>在操作系统中，当程序执行1系统调用或当发生中断时，需要从用户模式<code>(user mode)</code>切换到内核模式<code>(kernel mode)</code>。</li>
<li>这种模式切换涉及到处理器状态的大量改变，如切换栈，改变权限级别等。</li>
</ul>
<p>2.上下文切换：</p>
<ul>
<li><code>Trampoline</code>通常用于这种上下文切换的过程。它提供了一个固定的、已知的内核空间地址，用户模式代码可以跳转到这个地址以执行系统调用或响应中断。</li>
<li>这个跳板代码负责保存当前的执行上下文（如寄存器状态），设置适当的内核栈，然后跳转到实际的系统调用或中断处理函数。</li>
</ul>
<p><code>trapframe (陷阱帧)</code>通常指的是一种数据结构，它用于在发生异常或中断（统称为“陷阱”）时保存进程或线程的状态。当操作系统必须处理这样的事件时，它会保存当前执行环境的关键信息到<code>trapframe</code>中，以便之后可以恢复并继续执行。</p>
<ol>
<li>保存上下文：<ul>
<li>当系统调用、中断或其他异常发生时，当前进程的状态（如CPU寄存器的值）会被保存到<code>trapframe</code>中。</li>
<li>这包含程序计数器（PC）、堆栈指针（SP）、状态寄存器和其他重要的寄存器。</li>
</ul>
</li>
<li>上下文切换</li>
</ol>
<ul>
<li><code>Trapframe</code>使得操作系统能够在处理完中断或异常后，准确地恢复到发生中断前的状态，继续执行进程。</li>
<li>这是多任务操作系统实现时间共享的关键机制之一。</li>
</ul>
<ol start="3">
<li>系统调用：<ul>
<li>对于系统调用，<code>trapframe</code>可以用来传递调用参数和返回值。</li>
</ul>
</li>
</ol>
<p><code>Trapframe page:</code></p>
<ul>
<li>特定内存页：<ul>
<li>在某些操作系统实现中，每个进程或线程的<code>trapframe</code>可能被存储在一个特定的内存页中，这个页称为<code>trapframe page</code>。</li>
<li>这个页面通常位于进程的用户空间内存中的一个固定位置。</li>
</ul>
</li>
<li>访问和管理：<ul>
<li>操作系统内核负责管理这些页面，并在需要时读写<code>trapframe</code>的内容。</li>
<li>这种方法为每个进程提供了一个独立的空间来存放其中断或异常的状态信息。</li>
</ul>
</li>
</ul>
</blockquote>
<p>在<code>kernel/proc.c</code>中，观察<code>fork</code>函数是如何创建一个进程的。</p>
<p><code>fork()</code>函数通过调用<code>allocproc()</code>创建一个新的进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new process, copying the parent.</span></span><br><span class="line"><span class="comment">// Sets up child kernel stack to return as if from fork() system call.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们看看<code>allocproc()</code>做了什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look in the process table for an UNUSED proc.</span></span><br><span class="line"><span class="comment">// If found, initialize state required to run in the kernel,</span></span><br><span class="line"><span class="comment">// and return with p-&gt;lock held.</span></span><br><span class="line"><span class="comment">// If there are no free procs, or a memory allocation fails, return 0.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc* <span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="comment">/* 遍历线程池，寻找未使用的线程 */</span></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = allocpid();	<span class="comment">// 分配 pid</span></span><br><span class="line">  p-&gt;state = USED;	<span class="comment">// 标记当前线程为已使用</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page. 通过 kalloc() 为 trapframe 分配一页</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to user space.</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空闲用户页表通过函数<code>proc_pagetable()</code>分配，让我们看看函数<code>proc_pagetable</code>做了什么</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a user page table for a given process, with no user memory,</span></span><br><span class="line"><span class="comment">// but with trampoline and trapframe pages.</span></span><br><span class="line"><span class="type">pagetable_t</span> <span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty page table.</span></span><br><span class="line">  pagetable = uvmcreate();	<span class="comment">// 分配一个空闲的用户页表</span></span><br><span class="line">  <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline code (for system call return)</span></span><br><span class="line">  <span class="comment">// at the highest user virtual address.</span></span><br><span class="line">  <span class="comment">// only the supervisor uses it, on the way</span></span><br><span class="line">  <span class="comment">// to/from user space, so not PTE_U.</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在 pagetable 中，创建一个PTE，从 TRAMPOLINE 映射到 trampoline，大小为 PGSIZE</span></span><br><span class="line"><span class="comment">   * 权限为 可读，可执行</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,</span><br><span class="line">              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trapframe page just below the trampoline page, for</span></span><br><span class="line">  <span class="comment">// trampoline.S.</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在 pagetable 中，创建一个PTE，从 TRAPFRAME 映射到 p-&gt;trapframe，大小为 PGSIZE</span></span><br><span class="line"><span class="comment">   * 权限为可读，可写</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们看看释放进程时函数<code>freeproc()</code>做了什么：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free a proc structure and the data hanging from it,</span></span><br><span class="line"><span class="comment">// including user pages.</span></span><br><span class="line"><span class="comment">// p-&gt;lock must be held.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)	</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;trapframe);	<span class="comment">// 释放 trapframe</span></span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);	<span class="comment">// 释放进程页表，但proc_freepagetable 函数没有定义</span></span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回头再看实验，要加速系统调用<code>getpid()</code>，首先我们要知道<code>getpid()</code>中的<code>pid</code>存放在什么地方，观察代码后发现<code>pid</code>存放在内核代码段<code>struct proc</code>中，因此要访问<code>pid</code>必须要进行用户态和内核态之间的切换。有什么办法能避免用户态和内核态的切换？我们知道操作系统为每个进程在用户态维护一个页表，如果我们把<code>pid</code>存储到进程页表中，则省去了切换到内核态的开销。下面讲讲怎么做。</p>
<p>在<code>memlayout.h</code>中发现，用户页表中的布局为：</p>
<p>我们发现<code>USYSCALL</code>页表已经布局到用户页表中了，并且是与内核共享的一段页面（注意，这是一个虚拟地址）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User memory layout.</span></span><br><span class="line"><span class="comment">// Address zero first:</span></span><br><span class="line"><span class="comment">//   text</span></span><br><span class="line"><span class="comment">//   original data and bss</span></span><br><span class="line"><span class="comment">//   fixed-size stack</span></span><br><span class="line"><span class="comment">//   expandable heap</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   USYSCALL (shared with kernel)</span></span><br><span class="line"><span class="comment">//   TRAPFRAME (p-&gt;trapframe, used by the trampoline)</span></span><br><span class="line"><span class="comment">//   TRAMPOLINE (the same page as in the kernel)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> pid;  <span class="comment">// Process ID</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>为了在进程中访问这段页面，我们需要在<code>struct proc</code>中添加一个新的指针，指向该段页面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line"> 	...</span><br><span class="line">	...</span><br><span class="line">  <span class="comment">// used to speed up system call</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> * <span class="title">usyscall</span>;</span>   <span class="comment">// 加速系统调用，指向共享的页的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们在创建一个进程的时候，同样要为<code>USYSCALL</code>页面分配物理地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look in the process table for an UNUSED proc.</span></span><br><span class="line"><span class="comment">// If found, initialize state required to run in the kernel,</span></span><br><span class="line"><span class="comment">// and return with p-&gt;lock held.</span></span><br><span class="line"><span class="comment">// If there are no free procs, or a memory allocation fails, return 0.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = allocpid();</span><br><span class="line">  p-&gt;state = USED;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// allocate a usyscall page using kalloc()</span></span><br><span class="line">  <span class="comment">// 使用 kalloc() 函数为 usyscall 分配一页物理页面</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;usyscall = (<span class="keyword">struct</span> usyscall * )kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">      freeproc(p);</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	p-&gt;usyscall-&gt;pid = p-&gt;pid;	<span class="comment">// 让 p-&gt;usyscall-&gt;pid 为 p-&gt;pid</span></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to user space.</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，在<code>proc_pagetable</code>中，我们要添加虚拟地址到物理地址的映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a user page table for a given process, with no user memory,</span></span><br><span class="line"><span class="comment">// but with trampoline and trapframe pages.</span></span><br><span class="line"><span class="type">pagetable_t</span> <span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty page table.</span></span><br><span class="line">  pagetable = uvmcreate();</span><br><span class="line">  <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 注意到在allocproc()中我们已经为p-&gt;usyscall分配了一个物理页面并且 p-&gt;usyscall 指针指向该物理页面的</span></span><br><span class="line">  <span class="comment">// 首地址，现在我们通过 mappages 在 页表中将虚拟地址 USYSCALL 映射到 p-&gt;usyscall 中。</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p-&gt;usyscall), PTE_R | PTE_U | PTE_W) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline code (for system call return)</span></span><br><span class="line">  <span class="comment">// at the highest user virtual address.</span></span><br><span class="line">  <span class="comment">// only the supervisor uses it, on the way</span></span><br><span class="line">  <span class="comment">// to/from user space, so not PTE_U.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,</span><br><span class="line">              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trapframe page just below the trampoline page, for</span></span><br><span class="line">  <span class="comment">// trampoline.S.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在创建进程的操作就结束了，要注意到的是，我们在释放进程的时候，同时也要把该页表项及映射释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free a proc structure and the data hanging from it,</span></span><br><span class="line"><span class="comment">// including user pages.</span></span><br><span class="line"><span class="comment">// p-&gt;lock must be held.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 kfree 函数将 p-&gt;usyscall 指向的一页物理地址释放掉</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;usyscall)</span><br><span class="line">      kfree((<span class="type">void</span>*)p-&gt;usyscall);</span><br><span class="line">  p-&gt;usyscall = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅仅释放掉物理地址还不够，我们还需要调用函数<code>proc_freepagetable()</code>取消页表中相应页表项的映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free a process&#x27;s page table, and free the</span></span><br><span class="line"><span class="comment">// physical memory it refers to.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);	<span class="comment">// 取消 pagetable 中映射到 TRAMPOLINE 的页表项</span></span><br><span class="line">    uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);	<span class="comment">// 取消 pagetable 中映射到 TRAPFRAME 的页表项</span></span><br><span class="line">    uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);	<span class="comment">// 取消 pagetable 中映射到 USYSCALL 的页表项</span></span><br><span class="line">    uvmfree(pagetable, sz);	<span class="comment">// 调用 uvmfree 释放整个页表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试通过。</p>
<p><img src="/../images/Lab-page-tables/%E6%88%AA%E5%B1%8F2024-01-25%2020.54.17-6187266-6187267.png" alt="截屏2024-01-25 20.54.17"></p>
<h3 id="Question-Which-other-xv6-system-call-s-could-be-made-faster-using-this-shared-page-Explain-how"><a href="#Question-Which-other-xv6-system-call-s-could-be-made-faster-using-this-shared-page-Explain-how" class="headerlink" title="Question: Which other xv6 system call(s) could be made faster using this shared page? Explain how."></a>Question: Which other xv6 system call(s) could be made faster using this shared page? Explain how.</h3><p>通过共享页面能加速的系统调用，首先要求不能是对共享页中的数据进行写操作，因为对内核页面的写操作需要切换到内核态，这违背了加速系统调用的初衷。于是我们推测：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return how many clock tick interrupts have occurred since start.</span></span><br><span class="line">uint64 <span class="title function_">sys_uptime</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  uint xticks;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  xticks = ticks;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">  <span class="keyword">return</span> xticks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也是可以映射到共享页面上。</p>
<h2 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h2><p>为了帮助你可视化<code>RISC-V</code>页表，也可能为了帮助未来的调试工作，你的第二个任务是编写一个函数用来打印页表的内容。</p>
<blockquote>
<p>定义一个叫做<code>vmprint()</code>的函数。传入的参数类型为<code>pagetable_t</code>，打印页表格式如下。在<code>exec.c</code>中的<code>return argc</code>语句前加入<code>if(p-&gt;pid == 1) vmprint(p-&gt;pagetable)</code>，这样可以打印第一个进程的页表。如果你通过了 ‘make grade’ 中的 ‘pte printout’ 测试，那么你将获得这部分实验的全部学分。</p>
</blockquote>
<p>现在当你启动 xv6 时，它应该会打印类似于这样的输出，描述在刚刚完成执行 init 函数时第一个进程的页表情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">page table 0x0000000087f6b000</span><br><span class="line"> ..0: pte 0x0000000021fd9c01 pa 0x0000000087f67000</span><br><span class="line"> .. ..0: pte 0x0000000021fd9801 pa 0x0000000087f66000</span><br><span class="line"> .. .. ..0: pte 0x0000000021fda01b pa 0x0000000087f68000</span><br><span class="line"> .. .. ..1: pte 0x0000000021fd9417 pa 0x0000000087f65000</span><br><span class="line"> .. .. ..2: pte 0x0000000021fd9007 pa 0x0000000087f64000</span><br><span class="line"> .. .. ..3: pte 0x0000000021fd8c17 pa 0x0000000087f63000</span><br><span class="line"> ..255: pte 0x0000000021fda801 pa 0x0000000087f6a000</span><br><span class="line"> .. ..511: pte 0x0000000021fda401 pa 0x0000000087f69000</span><br><span class="line"> .. .. ..509: pte 0x0000000021fdcc13 pa 0x0000000087f73000</span><br><span class="line"> .. .. ..510: pte 0x0000000021fdd007 pa 0x0000000087f74000</span><br><span class="line"> .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000</span><br><span class="line">init: starting sh</span><br></pre></td></tr></table></figure>

<p>第一行显示了vmprint的参数。在此之后，每个PTE都会占据一行，包括那些引用到树更深层次的页表页的PTE。每个PTE行通过一些” ..”进行缩进，以表示其在树中的深度。每个PTE行展示了其在页表页中的PTE索引、pte位，以及从PTE中提取的物理地址。不打印那些无效的PTE。在上述例子中，顶层页表页对于条目0和255有映射。下一层的条目0只映射了索引0，而该索引0的底层映射了条目0、1和2。</p>
<p>你的代码可能会生成与上述不同的物理地址。条目数量和虚拟地址应当是相同的。</p>
<p>提示：</p>
<p>你可以在 <code>kernel/vm.c</code> 中放置 <code>vmprint()</code>。<br>使用 <code>kernel/riscv.h</code> 文件末尾的宏。<br>函数 <code>freewalk</code> 可能会提供一些灵感。<br>在 <code>kernel/defs.h</code> 中定义 <code>vmprint</code> 的原型，这样你就可以从 <code>exec.c</code> 调用它。<br>使用 <code>%p</code> 在你的 <code>printf</code> 调用中打印出如示例所示的完整的64位十六进制PTE和地址。</p>
<p>观察函数<code>freewalk()</code>，该函数递归的释放页表，我们可以发现<code>pte &amp; PTE_V</code>检测一个页表项是否合法，<code>pte &amp; (PTE_R | PTE_W | PTE_X)</code>检测一个页表项是否指向下一层页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recursively free page-table pages.</span></span><br><span class="line"><span class="comment">// All leaf mappings must already have been removed.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freewalk</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      freewalk((<span class="type">pagetable_t</span>)child);</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      panic(<span class="string">&quot;freewalk: leaf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是我们递归的打印页表项：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* lab page table: Print a page table */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> * indent[] = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;..&quot;</span>,</span><br><span class="line">        <span class="string">&quot;.. ..&quot;</span>,</span><br><span class="line">        <span class="string">&quot;.. .. ..&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recursive_print</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">    <span class="comment">// judge if depth is legal</span></span><br><span class="line">    <span class="keyword">if</span>(depth == <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(depth &lt; <span class="number">1</span> || depth &gt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Recursive print failed: depth must be 1, 2, or 3&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// there are 512 pte in each page table</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">        <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">        <span class="keyword">if</span>(pte &amp; PTE_V) &#123;</span><br><span class="line">            <span class="comment">// this is a valid PTE</span></span><br><span class="line">            <span class="comment">// print the current PTE</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s%d: pte %p pa %p\n&quot;</span>, indent[depth], i, pte, PTE2PA(pte));</span><br><span class="line">            <span class="keyword">if</span>((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">                uint64 child = PTE2PA(pte);</span><br><span class="line">                <span class="comment">// recursive print</span></span><br><span class="line">                recursive_print((<span class="type">pagetable_t</span>)child, depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">    recursive_print(pagetable, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过测试：</p>
<p><img src="/../images/Lab-page-tables/%E6%88%AA%E5%B1%8F2024-02-24%2016.07.33.png" alt="截屏2024-02-24 16.07.33"></p>
<h2 id="Detect-which-pages-have-been-accessed"><a href="#Detect-which-pages-have-been-accessed" class="headerlink" title="Detect which pages have been accessed"></a>Detect which pages have been accessed</h2><p>一些垃圾收集器（一种自动内存管理形式）可以从有关哪些页面已被访问（读或写）的信息中受益。在实验室的这一部分中，你将为xv6添加一个新功能，该功能通过检查RISC-V页表中的访问位来检测并向用户空间报告这一信息。RISC-V硬件页表遍历器在解决TLB缺失时会在PTE中标记这些位。</p>
<blockquote>
<p>你的任务是实现 <code>pgaccess()</code>，一个系统调用，用于报告哪些页面已被访问。这个系统调用接受三个参数。首先，它接受第一个用户页面的起始虚拟地址以供检查。其次，它接受要检查的页面数量。最后，它接受一个用户地址，指向一个缓冲区，以将结果存储到位掩码中（一种数据结构，每个页面使用一个位，其中第一个页面对应最不重要的位）。如果 <code>pgaccess</code> 测试用例在运行 <code>pgtbltest</code> 时通过，你将为这部分实验室获得全部学分。</p>
</blockquote>
<p>建议：</p>
<ul>
<li>阅读 <code>user/pgtbltest.c</code> 中的 <code>pgaccess_test()</code> 以了解 <code>pgaccess</code> 是如何被使用的。</li>
<li>首先在 <code>kernel/sysproc.c</code> 中实现 <code>sys_pgaccess()</code>。</li>
<li>你需要使用 <code>argaddr()</code> 和 <code>argint()</code> 解析参数。</li>
<li>对于输出位掩码，最简单的方法是在内核中存储一个临时缓冲区，并在填充了正确的位后通过 <code>copyout()</code> 将其复制到用户空间。</li>
<li>为可以扫描的页面数量设置一个上限是可以接受的。</li>
<li><code>kernel/vm.c</code> 中的 <code>walk()</code> 对于找到正确的PTE非常有用。</li>
<li>你需要在 <code>kernel/riscv.h</code> 中定义 <code>PTE_A</code>（访问位）。参考RISC-V特权架构手册来确定它的值。</li>
<li>确保在检查 <code>PTE_A</code> 是否设置后清除它。否则，将无法确定自上次调用 <code>pgaccess()</code> 以来页面是否被访问过（即，该位将永远被设置）。</li>
<li><code>vmprint()</code> 可能在调试页表时非常有用。</li>
</ul>
<p>首先我们找到<code>pgaccess_test()</code>，观察程序是如何测试<code>pgaccess</code>的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pgaccess_test</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> *buf;	<span class="comment">// 用户页面的起始虚拟地址</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> abits;	<span class="comment">// 掩码</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pgaccess_test starting\n&quot;</span>);</span><br><span class="line">  testname = <span class="string">&quot;pgaccess_test&quot;</span>;</span><br><span class="line">  buf = <span class="built_in">malloc</span>(<span class="number">32</span> * PGSIZE);	<span class="comment">// 分配32个页大小的空间</span></span><br><span class="line">  <span class="keyword">if</span> (pgaccess(buf, <span class="number">32</span>, &amp;abits) &lt; <span class="number">0</span>)	<span class="comment">// 调用 pgaccess() 函数</span></span><br><span class="line">    err(<span class="string">&quot;pgaccess failed&quot;</span>);</span><br><span class="line">  buf[PGSIZE * <span class="number">1</span>] += <span class="number">1</span>;	<span class="comment">// 访问第一页</span></span><br><span class="line">  buf[PGSIZE * <span class="number">2</span>] += <span class="number">1</span>; <span class="comment">// 访问第二页</span></span><br><span class="line">  buf[PGSIZE * <span class="number">30</span>] += <span class="number">1</span>; <span class="comment">// 访问第三页</span></span><br><span class="line">  <span class="keyword">if</span> (pgaccess(buf, <span class="number">32</span>, &amp;abits) &lt; <span class="number">0</span>)	<span class="comment">// 调用 pgaccess() 函数</span></span><br><span class="line">    err(<span class="string">&quot;pgaccess failed&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (abits != ((<span class="number">1</span> &lt;&lt; <span class="number">1</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">2</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">30</span>))) <span class="comment">// 检查位掩码的第1，2，30位</span></span><br><span class="line">    err(<span class="string">&quot;incorrect access bits set&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(buf);	<span class="comment">// 释放分配的地址</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pgaccess_test: OK\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们修改<code>sys_pgaccess()</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in riscv.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A (1L &lt;&lt; 6)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* in sysproc.c*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  uint64 va; <span class="comment">// 存储用户态传过来的用户页面起始虚拟地址</span></span><br><span class="line">  <span class="type">int</span> pgnum; <span class="comment">// 存储用户态传过来的页面数量</span></span><br><span class="line">  uint64 abitsaddr; <span class="comment">// 存储用户态传过来的位掩码</span></span><br><span class="line">  </span><br><span class="line">  argaddr(<span class="number">0</span>, &amp;va); <span class="comment">// 将a0寄存器的值，第一个参数，写入av</span></span><br><span class="line">  argint(<span class="number">1</span>, &amp;pgnum); <span class="comment">// 将a1寄存器的值，第二个参数，写入pgnum</span></span><br><span class="line">  argaddr(<span class="number">2</span>, &amp;abitsaddr); <span class="comment">// 将a2寄存器的值，第三个参数，写入abitsaddr</span></span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> * <span class="title">p</span> =</span> myproc(); <span class="comment">// 获取当前进程</span></span><br><span class="line">  uint64 bitmask = <span class="number">0</span>; <span class="comment">// 初始化掩码</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; pgnum; ++i) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = walk(p-&gt;pagetable, va + i * PGSIZE, <span class="number">0</span>); <span class="comment">// 获取每个虚拟地址的页表项</span></span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span>) &#123;</span><br><span class="line">      panic(<span class="string">&quot;invalid PTE\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断该页表项是否被访问</span></span><br><span class="line">    <span class="keyword">if</span>(PTE_FLAGS(*pte) &amp; PTE_A) &#123;</span><br><span class="line">      bitmask = bitmask | (<span class="number">1L</span> &lt;&lt; i); <span class="comment">// 如果该页表项对应的页表页被访问，则把对应的bitmask中的位设为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 然后将页表项中 access flag 设置为0</span></span><br><span class="line">  	*pte = ((*pte &amp; PTE_A) ^ *pte) ^ <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/27/confzns/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/27/confzns/" class="post-title-link" itemprop="url">confzns</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-27 14:08:58" itemprop="dateCreated datePublished" datetime="2023-12-27T14:08:58+08:00">2023-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-02 20:33:46" itemprop="dateModified" datetime="2024-01-02T20:33:46+08:00">2024-01-02</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ConfZNS学习记录"><a href="#ConfZNS学习记录" class="headerlink" title="ConfZNS学习记录"></a>ConfZNS学习记录</h1><h2 id="阅读confZNS论文"><a href="#阅读confZNS论文" class="headerlink" title="阅读confZNS论文"></a>阅读confZNS论文</h2><p><code>confzns</code>是一个基于<code>femu</code>的<code>zns ssd</code>模拟器。源码地址在 <a target="_blank" rel="noopener" href="https://github.com/DKU-StarLab/ConfZNS%E3%80%82">https://github.com/DKU-StarLab/ConfZNS。</a></p>
<p>论文地址在 <a target="_blank" rel="noopener" href="https://dl.acm.org/doi/abs/10.1145/3579370.3594772">https://dl.acm.org/doi/abs/10.1145/3579370.3594772</a></p>
<h3 id="解决的问题："><a href="#解决的问题：" class="headerlink" title="解决的问题："></a>解决的问题：</h3><p><code>ZNS SSD</code>的内部架构是如何影响使用这些设备的应用程序的并行性和隔离性的。</p>
<blockquote>
<p>例如，如果区域与多个通道和路径相关联，即使在与单个区域进行大请求大小交互时，应用程序也可以获得高内部并行性的好处。</p>
</blockquote>
<h3 id="ConfZNS的特性"><a href="#ConfZNS的特性" class="headerlink" title="ConfZNS的特性"></a><code>ConfZNS</code>的特性</h3><ol>
<li><code>ConfZNS</code>支持<code>zns ssd</code>多样化区域映射。</li>
<li><code>ConfZNS</code>模拟的时间是精确的。</li>
<li><code>ConfZNS</code>允许从内部设备结构到应用软件的全栈探索。</li>
</ol>
<h3 id="ConfZNS设计"><a href="#ConfZNS设计" class="headerlink" title="ConfZNS设计"></a><code>ConfZNS</code>设计</h3><ol>
<li><code>ZNS</code>架构</li>
<li>时间估算器</li>
<li>资源监视器</li>
<li><code>ZNS</code>配置器</li>
</ol>
<h3 id="ZNS架构"><a href="#ZNS架构" class="headerlink" title="ZNS架构"></a><code>ZNS</code>架构</h3><p>在<code>SSD</code>中，通道<code>(channels)</code>、路径<code>(ways)</code>、晶圆<code>(dies)</code>、平面<code>(planes)</code>等都可以称为并行单元。可以利用这样的并行单元来达到最大的吞吐量。</p>
<p>如图所示，同一区域可以分配给不同的并行单元。</p>
<p><img src="/../images/confzns/%E6%88%AA%E5%B1%8F2023-12-27%2016.11.11.png" alt="截屏2023-12-27 16.11.11"></p>
<h3 id="时间估算器"><a href="#时间估算器" class="headerlink" title="时间估算器"></a><code>时间估算器</code></h3><p>服务延迟和队列延迟是影响<code>SSD I/O</code>延迟的两个因素。</p>
<p>图3、图4展示了<code>confzns</code>如何估算读写请求的延迟。</p>
<p>其中<code>Logic Page Numbers</code>被暴露给主机，而<code>Physic Page Numbers</code>靠设备维护。</p>
<p>由于区域映射的方式不同，每个区域覆盖的<code>PPN</code>也不同。</p>
<p>通过使用两种时钟，全局时钟<code>gc</code>，本地时钟<code>lc</code>。</p>
<ul>
<li><p><code>gc</code>: 会在每一个<code>tick</code>是增加</p>
</li>
<li><p><code>lc</code>: 每个资源维护一个<code>lc</code>，<code>lc</code>表示该资源的下一次可用时间。</p>
<p><code>lc = max(gc, lc) + service_time</code>，表示该资源的下一次可用时间。</p>
</li>
<li><p>如果<code>local clock</code>小于或者等于<code>global clock</code>，这表示该<code>local clock</code>对应的资源当前是空闲的。</p>
</li>
</ul>
<p><img src="/../images/confzns/%E6%88%AA%E5%B1%8F2023-12-27%2016.49.23.png" alt="截屏2023-12-27 16.49.23"></p>
<p><img src="/../images/confzns/%E6%88%AA%E5%B1%8F2023-12-27%2016.49.37.png" alt="截屏2023-12-27 16.49.37"></p>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>**混合区域支持<code>Mixed zone support</code>**：<code>confzns</code>可以同时支持<code>Single Unit Zone</code>或者<code>Full Unit Zone</code>。这使得<code>ZNS SSD</code>的应用程序有两种控制方式。一种是传统的线程，通过创建不同数量的线程，它们可以控制并行性。第二个是不同的区域。通过分配不同的区域，它们可以控制SSD中可以使用多少并行单元。同时也支持每个鱼去使用不同类型的闪存。</p>
<p><strong>传统区域支持</strong>：<code>ConfZNS</code>同样支持传统区域。</p>
<p><strong>PCIe链接带宽延迟模型</strong>：在ConfZNS中，PCIe链接带宽和版本是可配置的。此外，ConfZNS可以调节I&#x2F;O请求以满足PCIe接口的最大带宽。带宽调节的时间模型是基于漏桶算法实现的。当PCIe链接带宽未饱和时，所有请求都可以无延迟转移，只有转移时间会应用于这些请求。然而，如果达到最大带宽（例如3.94GB&#x2F;s），剩余的请求必须等待直到它们可以被转移。随着带宽接近其极限，这个等待时间会增加，并且会应用于所有待处理的请求。</p>
<h2 id="运行ConfZNS："><a href="#运行ConfZNS：" class="headerlink" title="运行ConfZNS："></a>运行<code>ConfZNS</code>：</h2><p>拉取<code>ConfZNS</code>源码：<a target="_blank" rel="noopener" href="https://github.com/DKU-StarLab/ConfZNS">https://github.com/DKU-StarLab/ConfZNS</a></p>
<p>根据<code>README.md</code>运行</p>
<p>先安装必要的工具链</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Switch to the FEMU building directory</span></span><br><span class="line">cd build-femu</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">only Debian/Ubuntu based distribution supported</span></span><br><span class="line">sudo ./pkgdep.sh</span><br></pre></td></tr></table></figure>

<p>编译<code>FEMU</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./femu-compile.sh</span><br></pre></td></tr></table></figure>

<p>下载镜像，这里我们用到的是<code>FEMU</code>官网提供的镜像。填个问卷就可以获得了。</p>
<p>然后模拟运行<code>zns ssd</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run-zns.sh</span><br></pre></td></tr></table></figure>

<p>我在这里遇到了一些打印时结构体访问越界的错误问题，把那段代码注释后可以成功运行。</p>
<p>不过接着遇到的问题是<code>run-zns.sh</code>运行失败。这是因为在<code>confzns</code>的源码中<code>-device femu, devsz_mb = 4096, femu_mode = 1</code>，其中<code>femu_mode = 1</code>表示<code>ssd</code>类型为<code>black box</code>。修改后的<code>run-zns.sh</code>如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Huaicheng Li &lt;hcli@cmu.edu&gt;</span></span><br><span class="line"><span class="comment"># Run FEMU as Zoned-Namespace (ZNS) SSDs</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Image directory</span></span><br><span class="line">IMGDIR=/home/parallels/images</span><br><span class="line"><span class="comment"># Virtual machine disk image</span></span><br><span class="line">OSIMGF=<span class="variable">$IMGDIR</span>/u20s.qcow2</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ ! -e <span class="string">&quot;<span class="variable">$OSIMGF</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;VM disk image couldn&#x27;t be found ...&quot;</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Please prepare a usable VM image and place it as <span class="variable">$OSIMGF</span>&quot;</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Once VM disk image is ready, please rerun this script again&quot;</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">sudo x86_64-softmmu/qemu-system-x86_64 \</span><br><span class="line">    -name <span class="string">&quot;FEMU-ZNSSD-VM&quot;</span> \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -cpu host \</span><br><span class="line">    -smp $(<span class="built_in">nproc</span>) \ 虚拟机CPU数量等于宿主机的处理器数量</span><br><span class="line">    -m 4G \					为虚拟机分配4GB内存</span><br><span class="line">    -device virtio-scsi-pci,<span class="built_in">id</span>=scsi0 \	</span><br><span class="line">    -device scsi-hd,drive=hd0 \</span><br><span class="line">    -drive file=<span class="variable">$OSIMGF</span>,<span class="keyword">if</span>=none,aio=native,cache=none,format=qcow2,<span class="built_in">id</span>=hd0 \</span><br><span class="line">    -device femu,devsz_mb=4096,femu_mode=3 \	表示分配的FEMU设备的大小为4GB 模式为zns ssd</span><br><span class="line">    -net user,hostfwd=tcp::8080-:22 \	设置端口为 8080</span><br><span class="line">    -net nic,model=virtio \</span><br><span class="line">    -nographic \</span><br><span class="line">    -qmp unix:./qmp-sock,server,nowait 2&gt;&amp;1 | <span class="built_in">tee</span> <span class="built_in">log</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>ConfZNS</code>启动后，我们新建一个终端，通过命令<code>ssh -p 8080 femu@localhost</code>远程连接终端，输入密码后成功连接。</p>
<p>首先键入命令<code>nvme list</code>查看系统中所有的<code>NVMe</code>设备的概览。</p>
<ul>
<li><code>node</code>是设备节点。</li>
<li><code>SN</code>是设备序列号<code>serial number</code>的缩写，用于唯一标识硬件设备。</li>
<li><code>Model</code>: 这是NVMe设备的模型名称，由制造商指定。（比如这里是 FEMU模拟的ZNS SSD）</li>
<li><code>Namespace</code>这是NVMe设备上的命名空间编号，命名空间是NVMe存储的逻辑分区。</li>
<li><code>Usage</code>:显示当前命名空间已使用的存储空间以及总可用空间。</li>
<li><code>Format</code>：描述了该命名空间的数据格式，包括扇区大小。这里的<code>512B + 0B</code>表示扇区大小为<code>512</code>字节加上<code>0</code>字节的元数。</li>
<li><code>FW Rev</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ sudo nvme list</span><br><span class="line">Node          SN       Model                    Namespace   Usage              Format           FW Rev  </span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line">/dev/nvme0n1  vZNSSD0  FEMU ZNS-SSD Controller  1          4.29  GB / 4.29  GB  512   B +  0 B   1.0     </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输入命令<code>nvme zns help</code>查看命令的帮助。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ nvme zns help</span><br><span class="line">nvme-1.13.48.g33c6</span><br><span class="line">usage: nvme zns &lt;command&gt; [&lt;device&gt;] [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">The &#x27;&lt;device&gt;&#x27; may be either an NVMe character device (ex: /dev/nvme0) or an</span><br><span class="line">nvme block device (ex: /dev/nvme0n1).</span><br><span class="line"></span><br><span class="line">Zoned Namespace Command Set</span><br><span class="line"></span><br><span class="line">The following are all implemented sub-commands:</span><br><span class="line">  id-ctrl             Retrieve ZNS controller identification</span><br><span class="line">  id-ns               Retrieve ZNS namespace identification</span><br><span class="line">  zone-mgmt-recv      Sends the zone management receive command</span><br><span class="line">  zone-mgmt-send      Sends the zone management send command</span><br><span class="line">  report-zones        Retrieve the Report Zones report</span><br><span class="line">  close-zone          Closes one or more zones</span><br><span class="line">  finish-zone         Finishes one or more zones</span><br><span class="line">  open-zone           Opens one or more zones</span><br><span class="line">  reset-zone          Resets one or more zones</span><br><span class="line">  offline-zone        Offlines one or more zones</span><br><span class="line">  set-zone-desc       Attaches zone descriptor extension data</span><br><span class="line">  zone-append         Writes data and metadata (if applicable), appended to the end of the requested zone</span><br><span class="line">  changed-zone-list   Retrieves the changed zone list log</span><br><span class="line">  version             Shows the program version</span><br><span class="line">  help                Display this help</span><br><span class="line"></span><br><span class="line">See &#x27;nvme zns help &lt;command&gt;&#x27; for more information on a specific command</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>让我们一一解释这些命令的用法：</p>
<ul>
<li><p><code>nvme zns id-ctrl</code>: Send NVMe Zoned Command Set Identify Controller, return result and structure.下面给出一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ sudo nvme zns id-ctrl /dev/nvme0n1</span><br><span class="line">NVMe ZNS Identify Controller:</span><br><span class="line">zasl    : 5</span><br></pre></td></tr></table></figure>

<p><code>zone append size limit</code>是区域追加大小限制，这里指的区域追加大小限制应该是append命令的大小限制。</p>
<blockquote>
<p>分区命名空间命令集规范目前在命令集的识别控制器中只定义了一个字段：区域追加大小限制（ZASL）。区域追加大小限制（ZASL）编码了区域追加命令的最大命令大小。下面的例子返回的是‘5’，这对应于128千字节（在这个例子中可以追加的最大大小）。</p>
</blockquote>
</li>
<li><p><code>nvme zns id-ns</code> 获取 <code>ZNS namespace</code> 标识</p>
<p>人不可读的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ sudo nvme zns id-ns /dev/nvme0n1 </span><br><span class="line">ZNS Command Set Identify Namespace:</span><br><span class="line">zoc     : 0</span><br><span class="line">ozcs    : 1</span><br><span class="line">mar     : 0xffffffff</span><br><span class="line">mor     : 0xffffffff</span><br><span class="line">rrl     : 0</span><br><span class="line">frl     : 0</span><br><span class="line">lbafe  0: zsze:0x20000 zdes:0 (in use)</span><br><span class="line">lbafe  1: zsze:0x0 zdes:0</span><br><span class="line">lbafe  2: zsze:0x0 zdes:0</span><br><span class="line">lbafe  3: zsze:0x0 zdes:0</span><br><span class="line">lbafe  4: zsze:0x0 zdes:0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>人可读的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ sudo nvme zns id-ns /dev/nvme0n1 -H</span><br><span class="line">ZNS Command Set Identify Namespace:</span><br><span class="line">zoc     : 0	Zone Operation Characteristics</span><br><span class="line">  [1:1] : 0	  Zone Active Excursions: No</span><br><span class="line">  [0:0] : 0	  Variable Zone Capacity: No</span><br><span class="line"></span><br><span class="line">ozcs    : 1	Optional Zoned Command Support</span><br><span class="line">  [0:0] : 0x1	  Read Across Zone Boundaries: Yes</span><br><span class="line">mar     : No Active Resource Limit</span><br><span class="line">mor     : No Open Resource Limit</span><br><span class="line">rrl     : Not Reported</span><br><span class="line">frl     : Not Reported</span><br><span class="line">LBA Format Extension  0 : Zone Size: 0x20000 LBAs - Zone Descriptor Extension Size: 0 bytes (in use)</span><br><span class="line">LBA Format Extension  1 : Zone Size: 0x0 LBAs - Zone Descriptor Extension Size: 0 bytes</span><br><span class="line">LBA Format Extension  2 : Zone Size: 0x0 LBAs - Zone Descriptor Extension Size: 0 bytes</span><br><span class="line">LBA Format Extension  3 : Zone Size: 0x0 LBAs - Zone Descriptor Extension Size: 0 bytes</span><br><span class="line">LBA Format Extension  4 : Zone Size: 0x0 LBAs - Zone Descriptor Extension Size: 0 bytes</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>zoc</code>：区域活动波动<code>Zone Active Excursions</code>和可变区域容量<code>Variable Zone Capability</code>的特性都不支持。</li>
<li><code>Optional Zoned Command Support</code>：表示支持的可选分区命令。<code>1</code>表示跨区域边界读取是支持的。</li>
<li><code>mar</code> <code>Max Active Resources</code>：表示没有限制可以活动的资源数量。</li>
<li><code>mor</code> <code>Maximum Open Resources</code>：表示没有开放资源的限制。</li>
<li><code>rrl</code> <code>Read Recovery Levels</code>：未报告，意味着没有读取恢复级别的信息。</li>
<li><code>frl</code> <code>Finish Recovery Levels</code>：未报告，意味着没有提供关于完成恢复级别的信息。</li>
<li><code>LBA Format Extension</code>：这些是逻辑块地址格式扩展条目，描述了不同区域的大小和描述符扩展大小。‘<ul>
<li><code>Zone Size</code>的大小为：<code>0x20000</code>的逻辑块地址，区域描述符扩展大小为0字节，表示这个区域格式当前正在使用中。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>zone-mgmt-recv      Sends the zone management receive command</code> 不太明白咋用，一用内核就挂了。</strong></p>
</li>
<li><p><strong><code>zone-mgmt-send      Sends the zone management send command</code> 同上。</strong></p>
</li>
<li><p><code>report-zones</code>：获取分区的报告，以下是一部分输出。</p>
<ul>
<li><code>nr_zones</code>表示一共有64个分区。</li>
<li><code>SLBA</code>表示每个分区的起始逻辑块地址。</li>
<li><code>WP</code>表示每个分区的写指针指向的逻辑块地址。<ul>
<li><code>Cap</code>表示每个分区的<code>Zone capability</code>，大小为<code>0x20000</code>。</li>
<li><code>State</code>表示每个分区的类型，这里的类型是<code>EMPTY</code>。</li>
<li><code>Type</code>类型为<code>Unknown</code>或者<code>SEQWRITE_REQ</code>顺序写规定。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ sudo nvme zns report-zones /dev/nvme0n1 </span><br><span class="line">nr_zones: 64</span><br><span class="line">SLBA: 0x380000   WP: 0x380000   Cap: 0x20000    State: EMPTY        Type: Unknown        Attrs: 0x0</span><br><span class="line">SLBA: 0x3a0000   WP: 0x3a0000   Cap: 0x20000    State: EMPTY        Type: Unknown        Attrs: 0x0</span><br><span class="line">SLBA: 0x3c0000   WP: 0x3c0000   Cap: 0x20000    State: EMPTY        Type: Unknown        Attrs: 0x0</span><br><span class="line">SLBA: 0x3e0000   WP: 0x3e0000   Cap: 0x20000    State: EMPTY        Type: Unknown        Attrs: 0x0</span><br><span class="line">SLBA: 0x400000   WP: 0x400000   Cap: 0x20000    State: EMPTY        Type: SEQWRITE_REQ   Attrs: 0x0</span><br><span class="line">SLBA: 0x420000   WP: 0x420000   Cap: 0x20000    State: EMPTY        Type: SEQWRITE_REQ   Attrs: 0x0</span><br><span class="line">SLBA: 0x440000   WP: 0x440000   Cap: 0x20000    State: EMPTY        Type: SEQWRITE_REQ   Attrs: 0x0</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>open-zone</code>: 显示打开区域，<code>action:3</code>表示执行的具体操作；<code>zone:0</code>表示操作的是第0个区域；<code>nsid:1</code>表示操作的区域的命名空间标识符是1。<strong>区域需要先打开才能关闭，否则会出现错误。</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ sudo nvme zns open-zone /dev/nvme0n1</span><br><span class="line">zns-open-zone: Success, action:3 zone:0 nsid:1</span><br></pre></td></tr></table></figure>

<p>执行命令<code>sudo nvme zns report-zones /dev/nvme0n1</code>查看区域状态。我们可以发现区域的状态为<code>EXP_OPENED</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nr_zones: 64</span><br><span class="line">SLBA: 0x0        WP: 0x0        Cap: 0x20000    State: EXP_OPENED   Type: Unknown        Attrs: 0x0</span><br><span class="line">SLBA: 0x20000    WP: 0x20000    Cap: 0x20000    State: EMPTY        Type: Unknown        Attrs: 0x0</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>close-zone</code>关闭区域，关闭后再通过<code>report-zones</code>命令得到区域的报告。状态为关闭。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ sudo nvme zns close-zone /dev/nvme0n1</span><br><span class="line">zns-close-zone: Success, action:1 zone:0 nsid:1</span><br><span class="line">femu@fvm:~$ sudo nvme zns report-zones /dev/nvme0n1</span><br><span class="line">nr_zones: 64</span><br><span class="line">SLBA: 0x0        WP: 0x0        Cap: 0x20000    State: CLOSED       Type: Unknown        Attrs: 0x0</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>finish-zone</code>完成区域，即将该区域设置为满。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ sudo nvme zns finish-zone /dev/nvme0n1 </span><br><span class="line">zns-finish-zone: Success, action:2 zone:0 nsid:1</span><br><span class="line">femu@fvm:~$ sudo nvme zns report-zones /dev/nvme0n1 </span><br><span class="line">nr_zones: 64</span><br><span class="line">SLBA: 0x0        WP: 0xffffffffffffffff Cap: 0x20000    State: FULL         Type: Unknown        Attrs: 0x0</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>offline-zone</code>：将一个区域设置为离线会使该区域变得无法访问。在离线区域上的数据将无法访问，且在区域被重置之前，无法向该区域写入数据。运行此命令来将第一个区域设置为离线。</p>
<p><strong>对状态为空的区域关闭不行，对状态为显示打开的区域关闭也不行，对状态为满的区域关闭也不行。</strong></p>
</li>
<li><p><code>zone-append</code>和<code>read</code>命令，这里 <code>-z 512</code>代表追加操作追加的数据大小为<code>512B</code>。通过区域报告，我们可以知道每个逻辑块的大小为<code>512B</code>（因为我们发现读指针增加了1）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ echo &quot;Hello World&quot; | sudo nvme zns zone-append /dev/nvme0n1 -z 512</span><br><span class="line">Success appended data to LBA 0</span><br><span class="line">femu@fvm:~$ sudo nvme read /dev/nvme0n1 -z 512</span><br><span class="line">Hello World</span><br><span class="line">read: Success</span><br><span class="line">femu@fvm:~$ sudo nvme zns report-zones /dev/nvme0n1</span><br><span class="line">nr_zones: 64</span><br><span class="line">SLBA: 0x0        WP: 0x1        Cap: 0x20000    State: EXP_OPENED   Type: Unknown        Attrs: 0x0</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ echo &quot;Goodbye World&quot; | sudo nvme zns zone-append /dev/nvme0n1 -z 512</span><br><span class="line">Success appended data to LBA 1</span><br><span class="line">femu@fvm:~$ sudo nvme read /dev/nvme0n1 -z 512</span><br><span class="line">Hello World</span><br><span class="line">read: Success</span><br><span class="line">femu@fvm:~$ sudo nvme read /dev/nvme0n1 -z 1024</span><br><span class="line">Hello World</span><br><span class="line">read: Success</span><br><span class="line">femu@fvm:~$ sudo nvme read /dev/nvme0n1 -z 512 -s 1</span><br><span class="line">Goodbye World</span><br><span class="line">read: Success</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​	当我们再次使用<code>zone-append</code>命令写入数据时，我们无须指定逻辑块地址。但在读取数据的时候，我们需要通过<code>-s</code>选项指定逻辑块地址以实现随机读。</p>
<ul>
<li>为什么使用nvme-cli write 命令也可以？</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/16/Lab-system-calls-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/16/Lab-system-calls-1/" class="post-title-link" itemprop="url">Lab: system calls</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-16 11:16:19" itemprop="dateCreated datePublished" datetime="2023-12-16T11:16:19+08:00">2023-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-26 08:59:15" itemprop="dateModified" datetime="2023-12-26T08:59:15+08:00">2023-12-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab-system-calls"><a href="#Lab-system-calls" class="headerlink" title="Lab: system calls"></a>Lab: system calls</h1><p>决定重新开始捡起<code>xv6</code>的实验。</p>
<h2 id="1-Using-gdb"><a href="#1-Using-gdb" class="headerlink" title="1.Using gdb:"></a>1.Using gdb:</h2><p>这个就跟着教程一步一步来。简单说一下在<code>mac os</code>下如何使用<code>gdb</code>，打开两个终端窗口：</p>
<ul>
<li><p>在第一个窗口下：</p>
<ol>
<li><p>执行<code>cd xv6-labs-2023</code>，进入目标文件。</p>
</li>
<li><p>运行<code>make qemu-gdb</code>。</p>
</li>
<li><p>终端会输出当前窗口的tcp，例如<code>tcp::26000</code>。</p>
<blockquote>
<p>以远程调试模式连接到本地主机上的端口<code>26000</code></p>
</blockquote>
</li>
</ol>
<p>	</p>
</li>
<li><p>在第二个窗口下：</p>
<ol>
<li><p>执行<code>cd xv6-labs-2023</code>，进入目标文件。</p>
</li>
<li><p>执行<code>riscv64-unknown-elf-gdb</code>，运行<code>gdb</code>。</p>
</li>
<li><p>在<code>gdb</code>中执行<code>target remote localhost:26000</code>，链接第一个窗口。</p>
</li>
<li><p>然后在<code>gdb</code>窗口中执行<code>file kernel/kernel</code>，加载可执行文件<code>kernel</code>到调试器<code>gdb</code>中。</p>
<blockquote>
<p>这一步只是加载可执行文件，并没有运行该文件。</p>
</blockquote>
</li>
<li><p>在<code>gdb</code>窗口中，执行<code>b syscall</code>，这一步是在<code>syscall</code>函数处打断点。</p>
</li>
<li><p>在<code>gdb</code>窗口中，执行<code>c</code>，运行上文加载的<code>kernel/kernel</code>可执行文件，可执行文件会在第一个调用<code>syscall</code>处暂停。</p>
</li>
<li><p>通过在<code>gdb</code>窗口中执行<code>layout src</code>命令启动和显示源代码布局。</p>
</li>
<li><p>然后调用执行<code>backtrace</code>，用于显示当前线程的调用堆栈。</p>
</li>
</ol>
</li>
</ul>
<p>效果如图所示：</p>
<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-16%2014.12.00-2707131.png" alt="截屏2023-12-16 14.12.00"></p>
<h3 id="Question-Looking-at-the-backtrace-output-which-function-called-syscall"><a href="#Question-Looking-at-the-backtrace-output-which-function-called-syscall" class="headerlink" title="Question: Looking at the backtrace output, which function called syscall?"></a>Question: Looking at the backtrace output, which function called <code>syscall</code>?</h3><p>如图所示，我们发现是在<code>kernel/trap.c:67</code>行，即函数<code>usertrap()</code>中调用了<code>syscall()</code>。检查源码确实如此。</p>
<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-16%2014.16.15.png" alt="截屏2023-12-16 14.16.15"></p>
<p>键入<code>n</code>命令让程序执行过<code>struct proc *p = myproc();</code>，然后键入<code>p /x *p</code>，打印指针<code>p</code>指向的<code>struct pro</code>结构体内容。</p>
<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-16%2014.28.45.png" alt="截屏2023-12-16 14.28.45"></p>
<p>上图中显示了结构体<code>struct proc</code>中的大部分内容。</p>
<h3 id="Question-What-is-the-value-of-p-gt-trapframe-gt-a7-and-what-does-that-value-represent-Hint-look-user-initcode-S-the-first-user-program-xv6-starts"><a href="#Question-What-is-the-value-of-p-gt-trapframe-gt-a7-and-what-does-that-value-represent-Hint-look-user-initcode-S-the-first-user-program-xv6-starts" class="headerlink" title="Question: What is the value of p-&gt;trapframe-&gt;a7 and what does that value represent? (Hint: look user/initcode.S, the first user program xv6 starts.)"></a>Question: What is the value of <code>p-&gt;trapframe-&gt;a7</code> and what does that value represent? (Hint: look <code>user/initcode.S</code>, the first user program xv6 starts.)</h3><p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-16%2014.32.49.png" alt="截屏2023-12-16 14.32.49"></p>
<p>接着我们打印<code>p-&gt;trapframe-&gt;a7</code>，发现值为7。问题的提示让我们去看<code>user/initcode.S</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Initial process that execs /init.</span><br><span class="line"># This code runs in user space.</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line"># exec(init, argv)</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        la a0, init</span><br><span class="line">        la a1, argv</span><br><span class="line">        li a7, SYS_exec</span><br><span class="line">        ecall</span><br><span class="line"></span><br><span class="line"># for(;;) exit();</span><br><span class="line">exit:</span><br><span class="line">        li a7, SYS_exit</span><br><span class="line">        ecall</span><br><span class="line">        jal exit</span><br><span class="line"></span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">  .string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">  .long init</span><br><span class="line">  .long 0</span><br></pre></td></tr></table></figure>

<p>我们发现这段代码把<code>SYS_exec</code>的值加载到寄存器<code>a7</code>中，然后通过<code>ecall</code>执行<code>a7</code>中的系统调用。</p>
<p>处理器当前在内核模式下运行，我们可以打印特权寄存器<code>(privileged registers)</code>，例如<code>sstatus (supervisor Status Register)</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p /x $sstatus</span><br><span class="line">$3 = 0x200000022</span><br></pre></td></tr></table></figure>

<p>图4.1和图4.2展示了64位机器和32位机器下的<code>sstatus</code>每一位的含义。</p>
<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-17%2010.18.16.png" alt="截屏2023-12-17 10.18.16"></p>
<h3 id="Question-What-was-the-previous-mode-that-the-CPU-was-in"><a href="#Question-What-was-the-previous-mode-that-the-CPU-was-in" class="headerlink" title="Question: What was the previous mode that the CPU was in?"></a>Question: What was the previous mode that the CPU was in?</h3><p>如图所示，<code>SSP</code>在64位机器上的<code>sstatus</code>的第八位，得到值为<code>0</code>。现在我们知道，当<code>trap</code>发生前，硬件线程<code>hart</code>处于用户态<code>user mode</code>。</p>
<p>在接下来的实验中，一些编程错误会导致<code>xv6</code>内核崩溃。例如，替换<code>num = p-&gt;trapframe-&gt;a7</code>为<code>num = *(int *)0;</code>，然后执行<code>make qemu</code>，会看见：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 1 starting</span><br><span class="line">hart 2 starting</span><br><span class="line">scause 0x000000000000000d</span><br><span class="line">sepc=0x0000000080002054 stval=0x0000000000000000</span><br><span class="line">panic: kerneltrap</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sepc: When a trap occurs, RISC-V saves the program counter here (since the pc is then overwritten with the value in stvec). The sret (return from trap) instruction copies sepc to the pc. The kernel can write sepc to control where sret goes.</p>
</blockquote>
<p><code>sepc</code>中存储的值是发生<code>trap</code>时，程序计数器中存储的处理器即将执行的下一条指令在内存中的地址。</p>
<h3 id="Question-Write-down-the-assembly-instruction-the-kernel-is-panicing-at-Which-register-corresponds-to-the-variable-num"><a href="#Question-Write-down-the-assembly-instruction-the-kernel-is-panicing-at-Which-register-corresponds-to-the-variable-num" class="headerlink" title="Question: Write down the assembly instruction the kernel is panicing at. Which register corresponds to the variable num?"></a>Question: Write down the assembly instruction the kernel is panicing at. Which register corresponds to the variable <code>num</code>?</h3><p><code>kernel/kernel.asm</code>是通过编译器将<code>c语言</code>编译成的内核汇编语言源文件，包含了原代码的汇编语言表示。</p>
<p>我们在<code>kernel/kernel.asm</code>中找到<code>sepc=0x0000000080002054</code>地址对应的汇编指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = *(int*)0;</span><br><span class="line">80002054:	00002683          	lw	a3,0(zero) # 0 &lt;_entry-0x80000000&gt;</span><br></pre></td></tr></table></figure>

<p>该指令尝试从零地址加载一个字<code>load word</code>到<code>a3</code>寄存器中。这会产生错误：因为地址0在大多数操作系统中是不可访问的，在<code>xv6</code>系统中<code>0x0-0x80000000</code>地址用于<code>I/O</code>设备。并且我们发现，<code>num</code>的值存储在<code>a3</code>寄存器中。</p>
<blockquote>
<p>The loader loads the xv6 kernel into memory at physical address <code>0x80000000</code>. The reason it places the kernel at <code>0x80000000</code> rather than <code>0x0</code> is because the address range <code>0x0:0x80000000</code> contains I&#x2F;O devices.</p>
</blockquote>
<p>要在故障指令处检查处理器和内核的状态，请启动gdb，并在故障epc上设置断点，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x0000000080002054</span><br><span class="line">Breakpoint 1 at 0x80002054: file kernel/syscall.c, line 138</span><br><span class="line">(gdb) layout asm</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[Switching to Thread 1.2]</span><br><span class="line"></span><br><span class="line">Thread 2 hit Breakpoint 1, syscall () at kernel/syscall.c:138</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-17%2011.40.13.png" alt="截屏2023-12-17 11.40.13"></p>
<p><code>gdb</code>展示的结果和<code>sepc</code>的结果相同。</p>
<h3 id="Question-Why-does-the-kernel-crash-Hint-look-at-figure-3-3-in-the-text-is-address-0-mapped-in-the-kernel-address-space-Is-that-confirmed-by-the-value-in-scause-above-See-description-of-scause-in-RISC-V-privileged-instructions"><a href="#Question-Why-does-the-kernel-crash-Hint-look-at-figure-3-3-in-the-text-is-address-0-mapped-in-the-kernel-address-space-Is-that-confirmed-by-the-value-in-scause-above-See-description-of-scause-in-RISC-V-privileged-instructions" class="headerlink" title="Question: Why does the kernel crash? Hint: look at figure 3-3 in the text; is address 0 mapped in the kernel address space? Is that confirmed by the value in scause above? (See description of scause in RISC-V privileged instructions)"></a>Question: Why does the kernel crash? Hint: look at figure 3-3 in the text; is address 0 mapped in the kernel address space? Is that confirmed by the value in <code>scause</code> above? (See description of <code>scause</code> in <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2023/labs/n//github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">RISC-V privileged instructions</a>)</h3><p>首先我们要清楚，在<code>kernel/kernel.asm</code>中的地址为虚拟地址。然后找到图3.3。如图，我们可以发现，虚拟地址0并没有映射到任何一个物理地址上。检查<code>scause</code>寄存器的值<code>scause = 0x000000000000000d</code>，通过图4.2可知，<code>0xd=13</code>对应<code>Load Page Fault</code>。</p>
<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-17%2020.08.43.png" alt="截屏2023-12-17 20.08.43"></p>
<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-18%2018.53.43.png" alt="截屏2023-12-18 18.53.43"></p>
<p><code>scause</code>是被上面的<code>kernel panic</code>打印出来的，但是你通常需要额外的信息来追踪导致崩溃的问题。例如，找到崩溃时是哪个用户进程正在运行，可以通过<code>p p-&gt;name</code>命令打印进程的名字。</p>
<p><code>process name is &quot;initcode\000\000\000\000\000\000\000&quot;</code>，进程的<code>pid</code>是<code>1</code>。</p>
<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-18%2019.12.14.png" alt="截屏2023-12-18 19.12.14"></p>
<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-18%2019.16.08.png" alt="截屏2023-12-18 19.16.08"></p>
<h2 id="2-System-call-tracing"><a href="#2-System-call-tracing" class="headerlink" title="2. System call tracing"></a>2. System call tracing</h2><h3 id="In-this-assignment-you-will-add-a-system-call-tracing-feature-that-may-help-you-when-debugging-later-labs-You’ll-create-a-new-trace-system-call-that-will-control-tracing-It-should-take-one-argument-an-integer-“mask”-whose-bits-specify-which-system-calls-to-trace-For-example-to-trace-the-fork-system-call-a-program-calls-trace-1-lt-lt-SYS-fork-where-SYS-fork-is-a-syscall-number-from-kernel-syscall-h-You-have-to-modify-the-xv6-kernel-to-print-out-a-line-when-each-system-call-is-about-to-return-if-the-system-call’s-number-is-set-in-the-mask-The-line-should-contain-the-process-id-the-name-of-the-system-call-and-the-return-value-you-don’t-need-to-print-the-system-call-arguments-The-trace-system-call-should-enable-tracing-for-the-process-that-calls-it-and-any-children-that-it-subsequently-forks-but-should-not-affect-other-processes"><a href="#In-this-assignment-you-will-add-a-system-call-tracing-feature-that-may-help-you-when-debugging-later-labs-You’ll-create-a-new-trace-system-call-that-will-control-tracing-It-should-take-one-argument-an-integer-“mask”-whose-bits-specify-which-system-calls-to-trace-For-example-to-trace-the-fork-system-call-a-program-calls-trace-1-lt-lt-SYS-fork-where-SYS-fork-is-a-syscall-number-from-kernel-syscall-h-You-have-to-modify-the-xv6-kernel-to-print-out-a-line-when-each-system-call-is-about-to-return-if-the-system-call’s-number-is-set-in-the-mask-The-line-should-contain-the-process-id-the-name-of-the-system-call-and-the-return-value-you-don’t-need-to-print-the-system-call-arguments-The-trace-system-call-should-enable-tracing-for-the-process-that-calls-it-and-any-children-that-it-subsequently-forks-but-should-not-affect-other-processes" class="headerlink" title="In this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new trace system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls trace(1 &lt;&lt; SYS_fork), where SYS_fork is a syscall number from kernel/syscall.h. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The trace system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes."></a>In this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new <code>trace</code> system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls <code>trace(1 &lt;&lt; SYS_fork)</code>, where <code>SYS_fork</code> is a syscall number from <code>kernel/syscall.h</code>. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The <code>trace</code> system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</h3><blockquote>
<p>这个实验做着比较奇怪，感觉只是做出来了，但为啥是这样的？</p>
</blockquote>
<p>我们先跟着<code>hints</code>走一遍流程：</p>
<ul>
<li><p><strong>Add <code>$U/_trace</code> to UPROGS in Makefile</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in Makefile</span><br><span class="line">UPROGS=\</span><br><span class="line">		...</span><br><span class="line">		$U/_trace</span><br></pre></td></tr></table></figure>
</li>
<li><p>Run make qemu and you will see that the compiler cannot compile <code>user/trace.c</code>, because the user-space stubs for the system call don’t exist yet: add a prototype for the system call to <code>user/user.h</code>, a stub to <code>user/usys.pl</code>, and a syscall number to <code>kernel/syscall.h</code>. The Makefile invokes the perl script <code>user/usys.pl</code>, which produces <code>user/usys.S</code>, the actual system call stubs, which use the RISC-V <code>ecall</code> instruction to transition to the kernel. Once you fix the compilation issues, run trace 32 grep hello README; it will fail because you haven’t implemented the system call in the kernel yet.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*In user/user.h*/</span></span><br><span class="line"><span class="comment">// system calls</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In user/usys.pl</span></span><br><span class="line">entry(<span class="string">&quot;trace&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Add a <code>sys_trace()</code> function in <code>kernel/sysproc.c</code> that implements the new system call by remembering its argument in a new variable in the <code>proc</code> structure (see <code>kernel/proc.h</code>). The functions to retrieve system call arguments from user space are in <code>kernel/syscall.c</code>, and you can see examples of their use in <code>kernel/sysproc.c</code>.</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in the proc structure of kernel/pro.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="type">int</span> tracemask;            <span class="comment">// Used to store trace mask number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> maskval;</span><br><span class="line">    argint(<span class="number">0</span>, &amp;maskval);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * when we run trace 32 grep hello README</span></span><br><span class="line"><span class="comment">     * terminal outputs p-&gt;trapframe-&gt;a0 32</span></span><br><span class="line"><span class="comment">     * thus we know the first argument is stored on register a0</span></span><br><span class="line"><span class="comment">     * now we store the trace mask into the structure proc-&gt;tracemask</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">cp</span> =</span> myproc();</span><br><span class="line">    cp-&gt;tracemask = maskval;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Modify <code>fork()</code> (see <code>kernel/proc.c</code>) to copy the trace mask from the parent to the child process.</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* function fork() in kernel/proc.c */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  	...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   	* modified by theFutile</span></span><br><span class="line"><span class="comment">   	* copy trace mask from parent to child</span></span><br><span class="line"><span class="comment">   	*/</span></span><br><span class="line">  	np-&gt;tracemask = p-&gt;tracemask;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Modify the <code>syscall()</code> function in <code>kernel/syscall.c</code> to print the trace output. You will need to add an array of syscall names to index into.</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in kernel/syscall.c */</span></span><br><span class="line"><span class="comment">/* add a new array stored syscall name*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span>* syscallsInfo[<span class="number">23</span>] = &#123;</span><br><span class="line">  			<span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;fork&quot;</span>,</span><br><span class="line">  			...</span><br><span class="line">        <span class="string">&quot;trace&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* modified the syscall function */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">syscall(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    <span class="comment">// Use num to lookup the system call function for num, call it,</span></span><br><span class="line">    <span class="comment">// and store its return value in p-&gt;trapframe-&gt;a0</span></span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * judge the trace mask bit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;tracemask &amp; (<span class="number">1ULL</span> &lt;&lt; num)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscallsInfo[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意，在上述操作结束后，<code>trace</code>命令在不传入<code>mask</code>时仍会打印信息，这是因为在创建进程的时候并没有初始化<code>tracemask</code>的值。所以，我们要在初始化进程的时候将<code>tracemask</code>赋值为<code>0</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* function freeproc() in kernel/proc.c */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">  	...</span><br><span class="line">		<span class="comment">/* free trace mask bits */</span></span><br><span class="line">  	p-&gt;tracemask = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阅读<code>syscall()</code>函数我们知道，系统调用的返回值被存储在<code>p-&gt;trapframe-&gt;a0</code>寄存器中，</p>
<p>在操作系统内核中，我们可以定义一个函数指针数组来映射系统调用编号到它们的处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">    [SYS_fork] = sys_fork,</span><br><span class="line">    [SYS_exit] = sys_exit,</span><br><span class="line">    [SYS_read] = sys_read,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-Sysinfo"><a href="#3-Sysinfo" class="headerlink" title="3. Sysinfo"></a>3. Sysinfo</h2><h3 id="In-this-assignment-you-will-add-a-system-call-sysinfo-that-collects-information-about-the-running-system-The-system-call-takes-one-argument-a-pointer-to-a-struct-sysinfo-see-kernel-sysinfo-h-The-kernel-should-fill-out-the-fields-of-this-struct-the-freemem-field-should-be-set-to-the-number-of-bytes-of-free-memory-and-the-nproc-field-should-be-set-to-the-number-of-processes-whose-state-is-not-UNUSED-We-provide-a-test-program-sysinfotest-you-pass-this-assignment-if-it-prints-“sysinfotest-OK”"><a href="#In-this-assignment-you-will-add-a-system-call-sysinfo-that-collects-information-about-the-running-system-The-system-call-takes-one-argument-a-pointer-to-a-struct-sysinfo-see-kernel-sysinfo-h-The-kernel-should-fill-out-the-fields-of-this-struct-the-freemem-field-should-be-set-to-the-number-of-bytes-of-free-memory-and-the-nproc-field-should-be-set-to-the-number-of-processes-whose-state-is-not-UNUSED-We-provide-a-test-program-sysinfotest-you-pass-this-assignment-if-it-prints-“sysinfotest-OK”" class="headerlink" title="In this assignment you will add a system call, sysinfo, that collects information about the running system. The system call takes one argument: a pointer to a struct sysinfo (see kernel/sysinfo.h). The kernel should fill out the fields of this struct: the freemem field should be set to the number of bytes of free memory, and the nproc field should be set to the number of processes whose state is not UNUSED. We provide a test program sysinfotest; you pass this assignment if it prints “sysinfotest: OK”."></a>In this assignment you will add a system call, <code>sysinfo</code>, that collects information about the running system. The system call takes one argument: a pointer to a <code>struct sysinfo</code> (see <code>kernel/sysinfo.h</code>). The kernel should fill out the fields of this struct: the <code>freemem</code> field should be set to the number of bytes of free memory, and the <code>nproc</code> field should be set to the number of processes whose <code>state</code> is not <code>UNUSED</code>. We provide a test program <code>sysinfotest</code>; you pass this assignment if it prints “sysinfotest: OK”.</h3><p>还是跟着<code>hints</code>走一遍流程：</p>
<ul>
<li><p><strong>Add <code>$U/_sysinfotest</code> to UPROGS in Makefile</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in Makefile</span><br><span class="line">UPROGS=\</span><br><span class="line">		...</span><br><span class="line">		$U/_trace</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Run make qemu; <code>user/sysinfotest.c</code> will fail to compile. Add the system call sysinfo, following the same steps as in the previous assignment. To declare the prototype for sysinfo() <code>in user/user.h</code> you need predeclare the existence of <code>struct sysinfo</code></strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*In user/user.h*/</span></span><br><span class="line"><span class="comment">// declare prototype</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span>;</span></span><br><span class="line"><span class="comment">// system calls</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo*)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In user/usys.pl</span></span><br><span class="line">entry(<span class="string">&quot;sysinfo&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>sysinfo needs to copy a <code>struct sysinfo</code> back to user space; see <code>sys_fstat()</code> (<code>kernel/sysfile.c</code>) and <code>filestat()</code> (<code>kernel/file.c</code>) for examples of how to do that using <code>copyout()</code>.</strong></p>
<p>我们知道，<code>sys_sysinfo()</code>函数是在内核代码部分声明的，但我们观察到用于测试<code>sysinfo()</code>的代码是在用户态中运行的。所以在用户态中运行的代码需要和在内核态中运行的代码进行交互。观察<code>sys_fstat()</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_fstat</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  uint64 st; <span class="comment">// user pointer to struct stat</span></span><br><span class="line">  argaddr(<span class="number">1</span>, &amp;st); <span class="comment">// store p-&gt;trapframe-&gt;a1 into st</span></span><br><span class="line">  <span class="keyword">if</span>(argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> filestat(f, st);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数将进程<code>p</code>中<code>trapframe-&gt;a1</code>中存储的地址赋值给<code>st</code>，该地址是从用户态中的代码传到内核空间中的。然后函数进一步将该地址传递到函数<code>filestat()</code>中，现在我们观察<code>filestat()</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get metadata about file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address, pointing to a struct stat.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">filestat</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_INODE || f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    stati(f-&gt;ip, &amp;st);</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">    <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;st, <span class="keyword">sizeof</span>(st)) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，该函数声明一个<code>struct stat</code>，然后将数据存储到当前的<code>stat</code>中，再调用<code>copyout()</code>函数，观察<code>copyout()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy from kernel to user.</span></span><br><span class="line"><span class="comment">// Copy len bytes from src to virtual address dstva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    <span class="keyword">if</span>(va0 &gt;= MAXVA)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    pte = walk(pagetable, va0, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span> || (*pte &amp; PTE_U) == <span class="number">0</span> ||</span><br><span class="line">       (*pte &amp; PTE_W) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    pa0 = PTE2PA(*pte);</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过注释，我们知道该函数从内核中拷贝数据到用户态中，其中，<code>pagetable</code>是<code>dstva</code>所在的页表中。该函数将内核空间中指针<code>src</code>指向的地址，拷贝<code>len</code>个字节，到虚拟地址<code>dstva</code>中，这个虚拟地址也即用户态空间中的位置。现在我们大致明白数据是如何从内核空间拷贝到用户空间。</p>
</li>
<li><p><strong>To collect the amount of free memory, add a function to <code>kernel/kalloc.c</code></strong></p>
<p>在结构体<code>struct sysinfo</code>中，我们要填写两个成员，<code>freemem</code>和<code>nproc</code>。其中<code>freemem</code>是存储空闲内存的数量的。观察<code>kernel/kalloc.c</code>代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>

<p>两个结构体<code>kmem</code>表示内核中的内存空间，其中 <code>lock</code>是一个自旋锁，在分配空间时需要加锁，<code>freelist</code>是一个指向空闲空间的链表，换句话说，空闲空间通过链表的形式存储。观察函数<code>kalloc()</code>的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现在分配物理空间的时候，首先通过<code>acquire(&amp;kmem.lock)</code>请求锁，然后获取当前内存的<code>freelist</code>，如果有空闲的内存，我们将内存取出并释放锁，然后将指针指向的空闲内存填充一些垃圾并返回该指针。并且，我们可以从上述代码中知道，每个<code>struct run</code>只想一个大小为<code>PGSIZE</code>的空间，也即<code>4096</code>比特。</p>
<p>现在我们尝试实现<code>collect_free_memory</code>。该函数首先获取<code>kmem</code>的空闲链表，然后请求锁，这保证了在计算空闲空间的时候内存不会被改变。然后每有一个空闲节点，<code>mem_byte</code>增加一个<code>PAGESIZE = 4096</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">count_free_mem</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> * <span class="title">r</span> =</span> kmem.freelist;</span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    uint64 mem_byte = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r) &#123;</span><br><span class="line">        mem_byte += PGSIZE;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">    <span class="keyword">return</span> mem_byte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>To collect the number of processes, add a function to <code>kernel/proc.c</code></strong></p>
<p>我们需要统计当前系统中状态不为<code>UNUSED</code>的进程数量，然后存储到<code>nproc</code>中，观察<code>kernel/proc.c</code>中函数<code>wakeup()</code>的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wake up all processes sleeping on chan.</span></span><br><span class="line"><span class="comment">// Must be called without any p-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p != myproc())&#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">        p-&gt;state = RUNNABLE;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道了内核代码遍历所有进程的方法，进程是在进程池中的，<code>NPROC</code>表示了进程的数量，于是我们实现<code>collect the number of processes</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">collect_process_num</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; ++p) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;state != UNUSED) &#123;</span><br><span class="line">            ++num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意，我们需要在<code>kernel/defs.h</code>中声明这些函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in kernel/defs.h */</span></span><br><span class="line"><span class="comment">// kalloc.c</span></span><br><span class="line">uint64          <span class="title function_">count_free_mem</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// proc.c</span></span><br><span class="line"><span class="type">int</span> 						<span class="title function_">collect_process_num</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>同时，要在<code>kernel/sysproc.c</code>中添加头文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/sysinfo.h&quot;</span></span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/05/ZNSLiterature02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/05/ZNSLiterature02/" class="post-title-link" itemprop="url">ZNSLiterature02</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-05 08:50:51" itemprop="dateCreated datePublished" datetime="2023-12-05T08:50:51+08:00">2023-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-12 15:52:33" itemprop="dateModified" datetime="2023-12-12T15:52:33+08:00">2023-12-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是第三周2023.12.4-2023.12.10的论文阅读笔记</p>
<h1 id="Performance-Characterization-of-NVMe-Flash-Devices-with-Zoned-Namespaces-ZNS"><a href="#Performance-Characterization-of-NVMe-Flash-Devices-with-Zoned-Namespaces-ZNS" class="headerlink" title="Performance Characterization of NVMe Flash Devices with Zoned Namespaces (ZNS)"></a>Performance Characterization of NVMe Flash Devices with Zoned Namespaces (ZNS)</h1><p>这篇文章大概讲了具有分区命名空间的闪存的性能分析。</p>
<p>本文的贡献:</p>
<ul>
<li><p>系统地描述了一款商业可用的 NVMe ZNS 设备的性能特性（即延迟、带宽和并行管理），包括其追加、读取、写入和区域管理操作（即完成和重置）。</p>
</li>
<li><p>我们分析了 ZNS 独特的重置和追加操作对读取、写入和追加 I&#x2F;O 性能的干扰影响。</p>
</li>
<li><p>我们揭示了最新 ZNS 模拟器性能模型的局限性，并讨论了解决这些问题的建议。</p>
</li>
<li><p>我们根据我们的特性分析，为 ZNS 应用开发者分享了关键建议。</p>
</li>
<li><p>我们在 <a target="_blank" rel="noopener" href="https://github.com/stonet-research/NVMeBenchmarks">https://github.com/stonet-research/NVMeBenchmarks</a> 上发布了我们的基准测试软件和数据集，以鼓励可复现的研究。</p>
</li>
</ul>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem:"></a>Problem:</h2><p>​	缺乏对 ZNS SSD（带有分区命名空间的固态硬盘）的广泛特性分析严重限制了在大数据工作负载中使用和应用 ZNS 设备的能力。这篇文章通过展示一款商业可用的 NVMe ZNS 设备的性能特性来弥补这一差距。</p>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background:"></a>Background:</h2><p>本文中提到的关于闪存的一些背景又和之前了解的概念有些偏差，在此记录下来：</p>
<ul>
<li><p>页<code>(page)</code>需要被顺序写入块中<code>(block)</code>，因此不允许数据随机写入。</p>
</li>
<li><p><code>It is also prone to read-write disturbs that occur when many reads are issued to the same blocks—they cause data loss. </code> </p>
<blockquote>
<p>读写干扰<code>(read-write distrubs)</code>是由于NAND闪存在频繁读取过程中对特定块施加重复电压引起的，这可能导致存储在邻近页中的数据不稳定，进而引发数据丢失或损坏。</p>
</blockquote>
<p>这也是为什么<code>ZNS SSD</code>中同时活跃的区域的数量有限制的原因<code>active zone limits</code>。</p>
<p>同样导致活跃区域的数量限制的原因还有：</p>
<blockquote>
<p>Since each zone operation (e.g., read, write, and append) consumes SSD resources (e.g., internal buffers), there are limits on the number of zones that can be concurrently opened and used.</p>
<p>由于每个区域操作（例如读取、写入和附加）都会消耗SSD资源（例如内部缓冲区），因此可以同时打开和使用的区域数量受到限制。</p>
</blockquote>
</li>
<li><p>追加操作<code>append</code>，类似于<code>nameless write</code>。</p>
<blockquote>
<p>这里追加操作没有固定写入的地址，而是在设备完成写入后返回给主机写入的地址。</p>
<p>即，不像写指令<code>write</code>，接收一个目标块地址。</p>
<p>追加指令<code>append</code>接收一个区域起始逻辑块地址<code>zone starting LBA (ZSLBA)</code>，当<code>append</code>完成后，逻辑块地址<code>LBA</code>返回给应用程序。这使得程序可以对同一个区域发送多个<code>append</code>命令。</p>
</blockquote>
</li>
<li><p>重置操作，显示通知设备某个区域中的数据可以被回收，但不一定是实时的。重置操作可以限制为 FTL（闪存翻译层）元数据映射操作，这会向设备指示该块稍后可以被擦除。</p>
</li>
</ul>
<h2 id="EXPERIMENTS"><a href="#EXPERIMENTS" class="headerlink" title="EXPERIMENTS:"></a>EXPERIMENTS:</h2><h3 id="Benchmarking-setup"><a href="#Benchmarking-setup" class="headerlink" title="Benchmarking setup:"></a><em>Benchmarking setup:</em></h3><ul>
<li><p><code>fio</code>，用来生成工作负载和基准测试。</p>
<blockquote>
<p><code>fio</code> 是一个流行的、灵活的开源工具，全称为 Flexible I&#x2F;O Tester。它被广泛用于执行和分析存储系统的性能和基准测试。<code>fio</code> 可以产生一定的I&#x2F;O负载，并以一种可控制和可预测的方式执行这些负载，使其成为评估和测试存储设备（如硬盘驱动器、固态硬盘、存储区域网络）性能的理想工具。</p>
</blockquote>
</li>
<li><p><code>SPDK</code>，（Storage Performance Development Kit）是一个高性能、用户态的存储开发工具包。它是由英特尔开发的开源项目，旨在提高存储设备，尤其是固态硬盘在数据中心中的性能和效率。SPDK 实现了一系列优化，使得存储操作可以绕过传统的内核栈，直接在用户空间运行，从而显著降低延迟并提高吞吐量。</p>
<blockquote>
<p>The <em>SPDK</em> stack, in contrast, is a bare-bones storage stack without any I&#x2F;O scheduler.</p>
</blockquote>
</li>
<li><p><code>mq-deadline</code> 是一种 I&#x2F;O 调度器，用于管理 Linux 操作系统中的块设备（如硬盘驱动器和固态硬盘）的请求队列。<code>mq-deadline</code> 是对原有 <code>deadline</code> 调度器的改进，专门为支持多队列 (Multi-Queue) 存储接口设计。这种调度器旨在平衡 I&#x2F;O 请求的延迟和吞吐量，特别是在高负载情况下。</p>
<blockquote>
<p>The Linux block layer ships with the <em>mq-deadline</em> scheduler, which buffers multiple write operations to a single zone, merges writes to contiguous LBAs into one or multiple (larger) writes, and sequentially issues the merged requests. Applications can, hence, issue multiple write operations to a single zone.</p>
</blockquote>
</li>
<li><p><code>io_uring</code> 是 Linux 内核中的一个比较新的异步I&#x2F;O接口。它为用户空间程序提供了一种高效的方式来提交和完成I&#x2F;O操作，尤其是在处理大量I&#x2F;O请求时。</p>
</li>
</ul>
<h3 id="Performance-metrics"><a href="#Performance-metrics" class="headerlink" title="Performance metrics:"></a><em>Performance metrics:</em></h3><ul>
<li><code>throughput</code>吞吐量</li>
<li><code>latency</code>延时</li>
</ul>
<h2 id="Observation"><a href="#Observation" class="headerlink" title="Observation:"></a>Observation:</h2><ol>
<li><p><em>The LBA format can have significant impact on both</em> write <em>and</em> append <em>latencies.</em></p>
<blockquote>
<p>导致这一现象的原因主要是硬件可能没有对于小的<code>IO</code>请求进行优化。</p>
</blockquote>
</li>
<li><p><em>Using the SPDK storage stack results in the lowest latencies.</em></p>
<blockquote>
<p>这是因为<code>SPDK</code>绕过内核直接与<code>SSD</code>设备交互。</p>
</blockquote>
</li>
<li><p>Write <em>and</em> append <em>throughput depends on the request size.</em></p>
<blockquote>
<ol>
<li><strong>请求大小与吞吐量的关系</strong>：<ul>
<li>实验显示，写入操作在 4 KiB 和 8 KiB 的请求大小时，IOPS（每秒输入&#x2F;输出操作数）吞吐量最高，达到约 85K IOPS。</li>
<li>而追加操作的性能随着请求大小的增加略有提升，从 66K IOPS 增至 69K IOPS。</li>
</ul>
</li>
<li><strong>字节吞吐量</strong>：<ul>
<li>以字节&#x2F;秒计算的吞吐量在大型请求（例如大于或等于 32 KiB）时最高，这是通过请求大小乘以 IOPS 计算得出的。（虽然每秒的<code>I\O</code>操作的次数减少了，但是每次<code>I\O</code>处理的字节数量提高了）。</li>
</ul>
</li>
<li><strong>请求方式的影响</strong>：<ul>
<li>由于请求是同步发出的，因此吞吐量是请求延迟的倒数。这意味着请求大小对性能的影响因写入和追加操作而异。</li>
</ul>
</li>
<li><strong>追加与写入性能差异</strong>：<ul>
<li>追加操作的吞吐量低于写入操作，并非 ZNS 设计固有的，而是取决于固件。预计新型 ZNS 设备的追加吞吐量会有所提高。</li>
</ul>
</li>
<li><strong>区域并行性的影响</strong>：<ul>
<li>请求大小的影响可能是由于区域并行性（即区域映射到多个闪存通道）造成的，类似于在文献 [44] 中观察到的情况。</li>
</ul>
</li>
<li><strong>最大吞吐量的建议</strong>：<ul>
<li>为了获得最大吞吐量，建议发出大型请求；在评估中使用的 ZNS 设备上，写入和追加操作分别在 4 KiB 和 8 KiB 请求大小时观察到最大的 IOPS 吞吐量，而对于大于 32 KiB 的请求观察到最大的字节吞吐量。</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li><p>write <em>operations have lower I&#x2F;O latencies than</em> append <em>operations.</em></p>
</li>
<li><p>对比了区域内并行<code>(intra-zone)</code>和区域间<code>(inter-zone)</code>并行</p>
<ol>
<li><p>在测试<code>write</code>和<code>read</code>操作时我们发现，区域内并行对比区域间并行，能达到更高的<code>IOPS</code>。</p>
<blockquote>
<p>如果程序需要比同时可打开区域数量更高的可扩展性，更推荐使用区域内并行。</p>
</blockquote>
</li>
<li><p>然而对于<code>append</code>操作来说，区域内和区域间请求并不敏感。</p>
<blockquote>
<p>推测这是由于<code>ZNS</code>设备的限制，而非<code>ZNS</code>设备设计的原因。</p>
</blockquote>
</li>
<li><p>对于大型（即 &gt;&#x3D;8KiB）I&#x2F;O请求，区域内追加和区域间写入操作的性能达到设备极限，并且在不同并发级别下以类似的方式扩展。</p>
</li>
</ol>
</li>
<li><p>区域状态机的转移开销</p>
<ol>
<li>区域的利用率对<code>reset</code>和<code>finish</code>操作有重要的影响。</li>
</ol>
</li>
<li><p><code>I/O</code>干扰：<code>write</code>，<code>append</code>和<code>read</code>的干扰</p>
<ol>
<li>ZNS设备在并发写入触发垃圾收集的情况下提供比普通<code>NVMe device</code>更稳定的读写性能。</li>
<li></li>
</ol>
</li>
</ol>
<h2 id="Recommendation"><a href="#Recommendation" class="headerlink" title="Recommendation:"></a>Recommendation:</h2><ol>
<li>对于低<code>I/O</code>延迟，使用<code>write</code>而不是<code>append</code>操作，并且使用<code>SPDK</code>存储堆栈，因为<code>SPDK</code>提供最低的<code>I/O</code>延迟。</li>
<li>相比于区域间并行性，更推荐使用区域内并行性；前者适用于追加和读取操作，而后者更适合写入操作。使用大型请求尺寸（即 &gt;&#x3D;8KiB，接近内部块大小）发起I&#x2F;O，因为更大的请求在更高并发级别下扩展性更好。</li>
<li>避免使用<code>finish</code>，特别是对于部分写入的区域。最小化需要<code>finish</code>的区域数量，</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/22/ZNSLiterature01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/22/ZNSLiterature01/" class="post-title-link" itemprop="url">ZNSLiterature01</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-22 15:56:24" itemprop="dateCreated datePublished" datetime="2023-11-22T15:56:24+08:00">2023-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-26 11:22:52" itemprop="dateModified" datetime="2023-11-26T11:22:52+08:00">2023-11-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是第二周2023.11.20-2023.11.26的论文阅读笔记</p>
<h1 id="ZNS-Avoiding-the-Block-Interface-Tax-for-Flash-based-SSDs"><a href="#ZNS-Avoiding-the-Block-Interface-Tax-for-Flash-based-SSDs" class="headerlink" title="ZNS: Avoiding the Block Interface Tax for Flash-based SSDs"></a>ZNS: Avoiding the Block Interface Tax for Flash-based SSDs</h1><p><a target="_blank" rel="noopener" href="https://www.usenix.org/conference/atc21/presentation/bjorling">https://www.usenix.org/conference/atc21/presentation/bjorling</a></p>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem:"></a>Problem:</h2><p>传统的<code>SSD</code>的问题：</p>
<ul>
<li><p>额外配置<code>(over-provision)</code>：这是为了在物理地址之间移动数据。</p>
</li>
<li><p>额外的<code>DRAM</code>：为了维护逻辑地址和物理地址之间的不稳定映射，这两个问题被称为<code>Block Interface Tax</code>。</p>
<blockquote>
<p>指使用块接口存储设备时所面临的性能和操作成本的问题。</p>
</blockquote>
</li>
</ul>
<h2 id="Previous-approach"><a href="#Previous-approach" class="headerlink" title="Previous approach:"></a>Previous approach:</h2><ul>
<li><p><code>Stream SSD</code>：主机会在写命令上添加标记<code>hint</code>。<code>Stream SSD</code>会通过这些标记将不同的数据放入不同的擦除块中。</p>
<blockquote>
<p>存在的问题：</p>
<ul>
<li>如果主机不添加标记，则和传统的<code>SSD</code> <code>(black box ssd)</code>没有区别。</li>
<li><code>SSD</code>仍然需要维护资源来管理这些标记的数据，所以不会降低额外配置<code>over provision</code>和额外<code>DRAM</code></li>
</ul>
</blockquote>
</li>
<li><p><code>open channel SSD</code>：主机和<code>SSD</code>共同管理一组连续的逻辑块簇<code>a set of contiguous LBA chunks</code>。这些连续的块簇<code>chunks</code>和物理擦除块<code>physical erased blocks</code>对齐。这样的对齐消除了设备垃圾回收开销<code>GC</code>，额外配置和<code>DRAM</code>。</p>
<blockquote>
<p>存在的问题：</p>
<ul>
<li>增加了主机的工作负担。</li>
<li>需要主机来管理不同<code>SSD</code>实现间的差异性。</li>
<li>需要持续的软件维护来保证其功能。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="Approach"><a href="#Approach" class="headerlink" title="Approach:"></a>Approach:</h2><p>提出了<code>ZNS</code>接口 <code>(Zone Namespace interface)</code>：</p>
<ul>
<li>兼容性：<code>ZNS</code>利用并兼容<code>ZAC/ZBC (Zoned ATA Command / Zoned Block Command)</code>规范中定义的分区存储模型。</li>
<li>增加了可以充分利用闪存特性的功能。</li>
<li>消除了<code>SSD</code>介质和设备接口之间的不匹配。</li>
<li>提供了一个不直接管理特定介质特性的下一代存储接口，这避免了像<code>OCSSD</code>那样直接处理介质特有特性的需要。</li>
</ul>
<p>一种<code>Tax-free Storage with zones</code>：</p>
<ul>
<li><code>zone state</code></li>
<li><code>zone write pointer</code></li>
</ul>
<p>提出上述的两个<code>ZNS</code>的特性，消除了主机软件需要跟踪每个区域最后写入的<code>LBA</code>的需求，简化了在例如不当关机后的恢复过程。</p>
<p><code>ZNS</code>接口在遵循区域存储规范的同时，也给出了两个对应闪存特性的新概念：</p>
<ul>
<li><p><code>writeable zone capability</code>：允许将区域内的<code>LBA</code>分为可写和不可写两部分，允许区域有比区域大小<code>zone size</code>更小的<code>writeable capability</code>。</p>
<blockquote>
<p>目的：使得<code>ZNS SSD</code>的区域大小可以与<code>SMR HDD</code>引入的2的幂次方大小行业标准对齐。</p>
</blockquote>
</li>
<li><p><code>active zone limit</code>：对处于打开或者关闭的区域的数量进行限制了限制。</p>
<blockquote>
<p>原因：基于闪存的介质<code>flash-based media</code>对这一数量有限制。</p>
<p>程序干扰（Program Disturb）是闪存（特别是NAND型闪存）中的一个现象，它对ZNS（区域命名空间）固态硬盘（SSD）的活动区域数量产生限制的方式是比较复杂的。我将为您详细解释这个过程。</p>
<h3 id="程序干扰（Program-Disturb）"><a href="#程序干扰（Program-Disturb）" class="headerlink" title="程序干扰（Program Disturb）"></a>程序干扰（Program Disturb）</h3><ol>
<li><strong>定义与影响</strong>：<ul>
<li>程序干扰是指在对NAND闪存的某个区域进行写操作（编程）时，可能无意中影响到相邻单元的现象。</li>
<li>这种干扰可能导致数据损坏或存储单元性能下降。</li>
</ul>
</li>
<li><strong>发生原因</strong>：<ul>
<li>NAND闪存中的存储单元（单元格）非常紧密排列。</li>
<li>当对一个单元进行写操作（注入电荷）时，相邻单元可能会因电场干扰而受到影响，尤其是在重复写入的情况下。</li>
</ul>
</li>
</ol>
<h3 id="对ZNS-SSD的影响"><a href="#对ZNS-SSD的影响" class="headerlink" title="对ZNS SSD的影响"></a>对ZNS SSD的影响</h3><ol>
<li><strong>ZNS SSD结构</strong>：<ul>
<li>ZNS SSD通过将存储空间划分为多个区域（zones）来优化数据管理和写入效率。</li>
<li>这些区域可独立管理，减少了写入放大（Write Amplification）和垃圾收集（Garbage Collection）的需要。</li>
</ul>
</li>
<li><strong>活动区域限制的必要性</strong>：<ul>
<li>由于程序干扰的存在，如果太多区域同时保持在可写状态（尤其是在高密度存储条件下），可能会增加数据损坏的风险。</li>
<li>限制同时处于打开或关闭状态的活动区域数量，可以减少相邻区域间的干扰，从而降低数据损坏的风险。</li>
</ul>
</li>
<li><strong>管理策略</strong>：<ul>
<li>ZNS SSDs通过限制同时可写的区域数量，从而降低程序干扰的风险。</li>
<li>这种限制有助于提高数据的可靠性和存储介质的寿命。</li>
</ul>
</li>
</ol>
<p>总的来说，程序干扰是一个物理现象，它限制了ZNS SSD中可以同时处于活动（即可写）状态的区域数量，这是为了减少数据损坏的风险并提高整体存储系统的稳定性和可靠性。</p>
<p><em>*<em>更深入的解释参考：Yu Cai, Onur Mutlu, Erich F Haratsch, and Ken Mai. Program Interference in MLC NAND Flash Memory: Characterization, Modeling, and Mitigation. In <em>2013 IEEE 31st International Conference on Computer De- sign (ICCD)</em>, pages 123–130. IEEE, 2013.</em>*</em></p>
</blockquote>
</li>
</ul>
<p>尽管ZNS接口增加了主机软件的责任，我们仍然使用一些方法减轻主机的这种负担。</p>
<h3 id="Evoloving-towards-ZNS"><a href="#Evoloving-towards-ZNS" class="headerlink" title="Evoloving towards ZNS:"></a>Evoloving towards ZNS:</h3><h4 id="对硬件的影响："><a href="#对硬件的影响：" class="headerlink" title="对硬件的影响："></a>对硬件的影响：</h4><p><code>ZNS</code>接口可以将区域的顺序写入转换到不同的擦除块中，从而消灭了接口和媒介之间的不匹配。</p>
<ul>
<li>数据放置在区域的粒度上被管理，这意味着负责在擦除块之间移动有效数据（以释放可写容量）的SSD垃圾收集例程将成为主机的责任。</li>
<li>这意味着设备上的写放大现象被消除，从而消除了对容量过剩配置的需求，同时也提升了介质的整体性能和使用寿命。</li>
</ul>
<blockquote>
<h3 id="ZNS-SSD的核心设计"><a href="#ZNS-SSD的核心设计" class="headerlink" title="ZNS SSD的核心设计"></a>ZNS SSD的核心设计</h3><ol>
<li><strong>顺序区域写入</strong>:<ul>
<li>ZNS SSD将存储空间分割成多个区域（zones），每个区域在一次写入操作中只允许顺序写入。</li>
<li>这种方式与传统的随机写入相比，更加适合NAND闪存的物理特性。</li>
</ul>
</li>
<li><strong>区域与擦除块的对应关系</strong>:<ul>
<li>在ZNS SSD中，顺序写入的区域直接对应于闪存的擦除块。</li>
<li>这样，每个区域的写入操作都直接映射到一个特定的擦除块上，减少了因随机写入造成的额外擦写循环。</li>
</ul>
</li>
</ol>
<h3 id="消除接口-介质不匹配"><a href="#消除接口-介质不匹配" class="headerlink" title="消除接口-介质不匹配"></a>消除接口-介质不匹配</h3><ol>
<li><strong>简化的闪存翻译层（FTL）</strong>:<ul>
<li>传统SSD中的FTL负责管理随机写入和数据在擦除块间的移动。</li>
<li>在ZNS SSD中，由于不支持随机写入，FTL的复杂性大大降低，这意味着更少的数据移动和管理开销。</li>
</ul>
</li>
<li><strong>由主机管理数据放置</strong>:<ul>
<li>在ZNS SSD中，数据的放置和擦除块的重置由主机（而非设备）显式管理。</li>
<li>这种设计使得数据存储更加高效，减少了写放大（Write Amplification）现象。</li>
</ul>
</li>
</ol>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><ul>
<li>减少写放大：由于写操作更加高效，ZNS SSD减少了写放大现象，这直接影响到设备的性能和寿命。</li>
<li>无需容量过剩配备：减少写放大也意味着不再需要为了补偿性能损耗而过度配备存储容量。</li>
<li>提升性能和寿命：整体上，ZNS SSD通过这种设计，提高了性能，并延长了存储介质的使用寿命。</li>
</ul>
<p>总之，ZNS SSD通过其对区域的顺序写入方式和简化的数据管理，有效地消除了传统接口与NAND闪存介质之间的不匹配问题，从而提高了存储效率和设备的整体性能。</p>
</blockquote>
<p><strong>Zone Sizing</strong>：区域写容量<code>zone write capability</code>和<code>SSD</code>的擦除块大小有直接的联系。</p>
<ul>
<li><p>在以块为接口的<code>SSD</code>中，擦除块中的数据是跨越了多个闪存晶圆<code>(flash dies)</code>的。 </p>
<blockquote>
<p>既为了获得更高的读写性能，也为了通过每条带（stripe）的奇偶校验来防止芯片级别和其他介质故障。</p>
</blockquote>
</li>
</ul>
<p><strong>Mapping Table</strong>：传统的<code>SSD</code>中，<code>FTL</code>维护了一个逻辑块到物理块的映射表，这样的映射表在提高垃圾回收效率的同时也占用了很大的空间。</p>
<p>而<code>ZNS SSD</code>的顺序写限制，可以使这种全相连的映射在擦除块级别或者以某种混合方式维护的粗粒度映射。这样做可以显著减少甚至完全消除<code>DRAM</code>（映射表需要提前存放在<code>SSD</code>的<code>DRAM</code>中）。</p>
<p><strong>Device Resources</strong>：部分写入的擦除块会关联一组资源。</p>
<blockquote>
<p>这一套装备包括硬件资源，如异或（XOR）引擎，内存资源，如静态随机存取内存（SRAM）或动态随机存取内存（DRAM），以及用于在断电后保持奇偶校验数据的电源电容器。</p>
</blockquote>
<p>数据和奇偶校验的大小可以从数百千字节到数兆字节不等，例如，这可能是由于两步编程所致。</p>
<blockquote>
<p>在NAND闪存技术中，”Two-Step Programming”（两步编程）是一种数据写入方法。这种方法在写入数据到NAND闪存单元时分为两个阶段进行，以提高数据的可靠性和减少错误。以下是两步编程的主要步骤和特点：</p>
<h3 id="第一步：初步写入"><a href="#第一步：初步写入" class="headerlink" title="第一步：初步写入"></a>第一步：初步写入</h3><ul>
<li>在这一步中，数据首先被写入到闪存单元，但并不是以最终的形态。这个阶段的目的是将数据大致定位到所需的状态。</li>
</ul>
<h3 id="第二步：精细调整"><a href="#第二步：精细调整" class="headerlink" title="第二步：精细调整"></a>第二步：精细调整</h3><ul>
<li>第二步涉及对之前写入的数据进行精细调整。这个阶段确保数据准确地达到其目标状态，从而减少写入错误。</li>
<li>这种方法特别适用于多级单元（MLC）和三级单元（TLC）NAND闪存，其中每个单元存储多个位的数据。</li>
</ul>
<h3 id="为什么使用两步编程"><a href="#为什么使用两步编程" class="headerlink" title="为什么使用两步编程"></a>为什么使用两步编程</h3><ol>
<li><p><strong>提高精确度</strong>：</p>
<ul>
<li>由于NAND闪存单元在存储多个数据位时容易受到干扰，两步编程通过分阶段精细调整来提高写入数据的准确度。</li>
</ul>
</li>
<li><p><strong>减少错误</strong>：</p>
<ul>
<li>分步骤写入减少了数据写入错误的可能性，特别是在高密度存储技术（如MLC和TLC）中。</li>
</ul>
</li>
<li><p><strong>提升可靠性</strong>：</p>
<ul>
<li>通过减少写入错误，两步编程提高了存储的可靠性，这对于保持数据完整性和延长设备寿命非常重要。</li>
</ul>
</li>
</ol>
<p>总体来说，两步编程是NAND闪存中一种重要的数据写入方法，特别是在那些要求高数据密度和可靠性的应用中。通过这种方法，可以有效地减少写入错误，提高整体存储介质的性能和可靠性。</p>
</blockquote>
<p>由于这些要求和相关成本，预计ZNS固态硬盘将拥有8到32个活动区域。尽管通过增加额外的电源电容器、使用动态随机存取内存（DRAM）进行数据移动、减少奇偶校验要求，或部署一种写回缓存的形式，可以进一步增加活动区域的数量。 </p>
<h4 id="Host-Software-Adoption-主机软件的采用情况"><a href="#Host-Software-Adoption-主机软件的采用情况" class="headerlink" title="Host Software Adoption 主机软件的采用情况"></a>Host Software Adoption 主机软件的采用情况</h4><p>三种让主机软件适配<code>ZNS</code>接口的方式。</p>
<p>采用顺序写特性的软件能更好的适配<code>ZNS</code>接口，比如<code>Log Structure Merge (LSM) tree-based database</code>。主要执行原地更新<code>in-place update</code>的应用程序在不对核心数据结构进行根本性修改的情况下，更难以支持。</p>
<ul>
<li><code>Host-side FTL (HFTL)</code>：一种在<code>ZNS SSD</code>写语法和使用随机写和就地更新的程序之间的媒介，类似于<code>SSD</code>的<code>FTL</code>层。</li>
</ul>
<p>  但只负责<code>translation mapping</code>和<code>Garbage collection</code></p>
<blockquote>
<p><strong>缺点：</strong><code>HFTL</code>需要占用<code>CPU</code>和<code>DRAM</code>。</p>
<p><strong>优点：</strong>使集成主机端的信息更加简单，增加了对数据放置和垃圾回收的控制，同时将<code>ZNS SSD</code>当作<code>conventional SSD</code>暴露给应用程序。</p>
</blockquote>
<ul>
<li><p><code>FTL System</code>：更高层次的存储接口允许多个应用程序通过常见的文件语法访问存储系统。</p>
<p>即：将区域与存储堆栈的更高层次集成，以确保顺序写入。</p>
</li>
<li><p><code>End-to-end Data placement</code>端到端数据放置：理想情况下，区域写语法讲与应用程序的现有数据结构保持一致。这将通过允许应用程序管理数据放置来提供最高程度的自由度，同时消除了来自文件系统和翻译层的间接开销。</p>
<blockquote>
<p>虽然端到端的数据放置使应用程序与ZNS固态硬盘之间的协作成为可能，并有潜力实现最佳的写放大、吞吐量和延迟改进，但它就像与原始块设备交互一样令人生畏。</p>
</blockquote>
</li>
</ul>
<h3 id="Implementation-我们已经向四个主要软件项目增加了支持，以评估ZNS的好处。"><a href="#Implementation-我们已经向四个主要软件项目增加了支持，以评估ZNS的好处。" class="headerlink" title="Implementation: 我们已经向四个主要软件项目增加了支持，以评估ZNS的好处。"></a>Implementation: 我们已经向四个主要软件项目增加了支持，以评估ZNS的好处。</h3><ul>
<li>更改<code>Linux</code>内核以支持<code>ZNS SSD</code></li>
<li>更改<code>f2fs file system</code></li>
<li>更改<code>fio benchmark</code>：这是为了测试和评估支持<code>ZNS</code>的存储设备性能</li>
<li>提出<code>ZenFS</code>：一个针对<code>RockDB</code>的新型存储后端，它通过分区来控制设备用以评估端到端集成对分区存储的好处</li>
</ul>
<h4 id="General-Linux-support"><a href="#General-Linux-support" class="headerlink" title="General Linux support"></a>General Linux support</h4><p><strong>Zone Capability:</strong></p>
<p><code>fio</code>和<code>f2fs</code>支持<code>Zone capability</code>，<code>fio</code>只保证不超过<code>zone capability</code>，<code>f2fs</code>管理段，段大小为<code>2MB</code>，多个段位一个区<code>section</code>，一个区<code>section</code>的大小和一个域<code>zone</code>的大小相同。</p>
<p><strong>limiting active zones 打开区域数量限制:</strong></p>
<p><code>fio</code>要求用户遵守打开区域数量这一限制。</p>
<p>对于<code>f2fs</code>来说，这种限制体现在打开的段的数量上。</p>
<h4 id="RocksDB-Zone-Support"><a href="#RocksDB-Zone-Support" class="headerlink" title="RocksDB Zone Support:"></a>RocksDB Zone Support:</h4><p>调整键值数据库<code>RocksBD</code>，使其能够通过使用<code>ZenFS</code>存储后端，将数据端到端地放置到分区存储设备上。<code>ZenFS</code>利用了<code>RocksDB</code>的日志结构合并<code>(LSM)</code>数数据结构，这是<code>RocksDB</code>用来存储和维护其数据的，并且还利用了其相关的不可变的仅限顺序的压缩过程。</p>
<p><code>LSM tree</code>：</p>
<p>最上层的数据是热数据，冷数据会被一直下放到最底层。</p>
<p><img src="/../images/ZNSLiterature01/%E6%88%AA%E5%B1%8F2023-11-25%2018.16.52.png" alt="截屏2023-11-25 18.16.52"></p>
<p><strong>ZenFS Architecture</strong>：</p>
<p><code>ZenFS</code>存储后端实现了一种最小的磁盘上文件系统，并使用<code>RocksDB</code>的文件包装<code>API</code>对其进行集成。</p>
<p><img src="/../images/ZNSLiterature01/%E6%88%AA%E5%B1%8F2023-11-25%2018.35.12.png" alt="截屏2023-11-25 18.35.12"></p>
<p><strong>Journaling and data</strong>：</p>
<ul>
<li>journal：日志区域用于恢复文件系统的状态，维护超级块数据结构，并将写前日志（WAL）和数据文件映射到区域。</li>
<li>data：数据区域存储文件内容。</li>
</ul>
<p><strong>Extents</strong>：</p>
<ul>
<li><code>RocksDB</code>的数据文件被映射并存储到一系列内容<code>a set of content</code>中。</li>
<li><code>content</code>是大小可变，块对齐的。</li>
<li><code>Extents</code>按顺序写入一个数据区域。</li>
<li>包含与特定标识符相关联的数据。</li>
</ul>
<p>每个区域包含很多<code>extents</code>，但是<code>extents</code>不能扩大<code>zone</code>的大小。</p>
<blockquote>
<p>区段的分配和释放事件被记录在内存数据结构中，并在关闭文件或通过<code>fsync</code>调用要求<code>RocksDB</code>持久化数据时写入日志。内存数据结构跟踪区段到区域的映射，一旦一个区域中分配了区段的所有文件都被删除，该区域就可以被重置并重用。</p>
</blockquote>
<p><strong>superblock 超级块</strong>：</p>
<p><strong>Journal 日志</strong>：</p>
<p><strong>Writeable Capacity in Data Zones 数据区域的可写容量</strong>：</p>
<p><strong>Data Zone Selection</strong>：ZenFS采用了一种尽最大努力的算法来选择最佳区域存储RocksDB数据文件。</p>
<blockquote>
<p> A match is only valid if the lifetime of the file is less than the oldest data stored in the zone to avoid prolonging the life of the data in the zone.</p>
<p>目的是为了确保不因为新添加的文件而不必要地延长存储区域中旧数据的存储时间，从而有效管理数据的生命周期和存储区域的使用效率。</p>
</blockquote>
<p><strong>Active Zone limit</strong></p>
<blockquote>
<p>活动区域限制。ZenFS必须遵守分区块设备指定的活动区域限制。要运行ZenFS，至少需要三个活动区域，它们分别被分配给日志、写前日志（WAL）和压缩过程。为了提高性能，用户可以控制并发压缩的数量。我们的实验表明，通过限制并发压缩的数量，RocksDB可以在写性能受限的情况下，只使用最少6个活动区域工作，而超过12个活动区域并不会带来任何显著的性能好处。</p>
</blockquote>
<p><strong>Direct I&#x2F;O and Buffered Writes</strong></p>
<blockquote>
<p>直接I&#x2F;O和缓冲写入。ZenFS利用了写入SST文件是顺序的和不可变的这一事实，并对SST文件执行直接I&#x2F;O写入，绕过了内核页面缓存。对于其他文件，如写前日志（WAL），ZenFS在内存中缓冲写入，并在缓冲区满、文件关闭或RocksDB请求刷新时刷新缓冲区。如果请求了刷新，缓冲区将被填充到下一个块边界，并且一个带有有效字节数的区段将被存储在日志中。这种填充导致了少量的写入放大，但这并非ZenFS独有，传统文件系统中也有类似的做法。</p>
</blockquote>
<h2 id="Regular-data-write-vs-zone-append-data-write"><a href="#Regular-data-write-vs-zone-append-data-write" class="headerlink" title="Regular data write .vs zone append data write"></a>Regular data write .vs zone append data write</h2><h3 id="zone-append-data-write-的优点"><a href="#zone-append-data-write-的优点" class="headerlink" title="zone append data write 的优点"></a>zone append data write 的优点</h3><ol>
<li><strong>锁定和资源分配</strong>：<ul>
<li>在Zone Append Write中，不需要在提交写操作之前分配存储空间（即延迟分配），也不需要锁定块组。这简化了I&#x2F;O提交过程，减少了延迟和开销，因为不需要等待资源的分配和锁定。</li>
<li>相反，Regular Write需要在写操作之前分配和锁定相应的块组，这会增加写操作的复杂性和时间成本。</li>
</ul>
</li>
<li><strong>写入操作的顺序</strong>：<ul>
<li>Zone Append Write不关心BIO（Block I&#x2F;O）的顺序，因为所有写入都是追加到区域末尾的。这允许利用异步校验和，而且无需等待特定的写入顺序，提高了效率。</li>
<li>Regular Write则需要保持写入顺序，因为块的位置是预先确定的。这可能需要对写入操作进行排序和同步，从而增加了复杂性和可能的延迟。</li>
</ul>
</li>
<li><strong>并行性和性能</strong>：<ul>
<li>Zone Append Write由于其简单性，允许更高的并行操作，可以在不同的队列中异步处理校验和计算。</li>
<li>而Regular Write的并行性受到锁定机制和同步需求的限制，对于每个文件范围，必须保持写操作的原子性，这可能限制了性能。</li>
</ul>
</li>
<li><strong>系统复杂性和可靠性</strong>：<ul>
<li>Zone Append Write简化了I&#x2F;O路径，减少了需要管理的元数据数量。在写入完成后，使用的块可以直接从end_bio()回调中检索，简化了块分配元数据的更新。</li>
<li>Regular Write通常涉及更多的系统调用和层次，每个步骤都增加了出错的可能性，也增加了系统资源的使用。</li>
</ul>
</li>
</ol>
<p>总结来说，Zone Append Write的设计减少了I&#x2F;O操作的复杂性，通过简化写入过程、减少锁定和资源分配的需求，以及提高写入操作的并行性来提高效率。这使得Zone Append Write特别适合于现代存储系统，这些系统通常优化了顺序写入操作并能够从这种简化的I&#x2F;O提交过程中受益。</p>
<h3 id="zone-append-data-write-的缺点"><a href="#zone-append-data-write-的缺点" class="headerlink" title="zone append data write 的缺点"></a>zone append data write 的缺点</h3><ol>
<li><p><strong>不支持RAID级别</strong>：</p>
<ul>
<li>Zone Append Writes 是为单个区域化设备设计的，这意味着它们在设计上用于向单个存储区域追加数据。当涉及到RAID（独立磁盘冗余阵列）时，数据通常跨越多个磁盘分布以提供冗余和性能提升。Zone Append Write无法处理发送到不同区域&#x2F;设备的两个写入操作，因为在RAID配置中，这可能导致不一致的逻辑块地址（LBA）位置返回，从而破坏数据的连续性和完整性。</li>
</ul>
</li>
<li><p><strong>仍然使用专用写入路径</strong>：</p>
<ul>
<li>该系统仍然需要专用的写入路径来处理全部延迟分配范围的写入。这是因为正常写入路径可能会跳过某些数据的写入，例如在<code>fdatasync()</code>调用范围之外的数据，导致数据丢失或不完整。在使用正常写入路径时，需要在提交写操作（bio）之前拆分现有的文件范围，这增加了处理复杂性。</li>
</ul>
</li>
<li><p><strong>文件范围的碎片化</strong>：</p>
<ul>
<li>每个I&#x2F;O操作限制在<code>zone_append_max_bytes</code>（例如512KB）这样的最大字节大小，意味着如果文件范围超过这个限制，它需要被拆分成多个I&#x2F;O操作。这导致同一文件的多个范围被创建，增加了文件系统的碎片化。因此，与常规的文件系统（如btrfs）相比，文件范围数量增多，可能导致性能下降和管理上的复杂性。</li>
</ul>
</li>
</ol>
<p>总的来说，虽然Zone Append Write在顺序数据写入方面具有效率优势，但它在一些特定的系统配置和操作上存在限制。这些限制主要是由于Zone Append Write设计的固有特性，它们在多设备（如RAID配置）、需要维护数据完整性和减少碎片化的环境中可能不是最佳选择。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/13/ZNSSSDliterature/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/13/ZNSSSDliterature/" class="post-title-link" itemprop="url">ZNSSSDliterature</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-13 19:38:51" itemprop="dateCreated datePublished" datetime="2023-11-13T19:38:51+08:00">2023-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-21 14:38:20" itemprop="dateModified" datetime="2023-11-21T14:38:20+08:00">2023-11-21</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Critical-Thinking-Reading"><a href="#Critical-Thinking-Reading" class="headerlink" title="Critical Thinking - Reading"></a>Critical Thinking - Reading</h1><h2 id="Read-a-paper-and-consider"><a href="#Read-a-paper-and-consider" class="headerlink" title="Read a paper and consider:"></a>Read a paper and consider:</h2><h3 id="Do-I-like-it-Hate-it-opinion"><a href="#Do-I-like-it-Hate-it-opinion" class="headerlink" title="Do I like it? Hate it? (opinion)"></a>Do I like it? Hate it? (opinion)</h3><h3 id="What-problem-is-it-trying-to-solve"><a href="#What-problem-is-it-trying-to-solve" class="headerlink" title="What problem is it trying to solve"></a>What problem is it trying to solve</h3><h3 id="How-does-their-approach-differ-from-previous-ones"><a href="#How-does-their-approach-differ-from-previous-ones" class="headerlink" title="How does their approach differ from previous ones"></a>How does their approach differ from previous ones</h3><h3 id="how-much-previous-work-do-I-know-about-read-it-reference-chaining"><a href="#how-much-previous-work-do-I-know-about-read-it-reference-chaining" class="headerlink" title="(how much previous work do I know about - read it! (reference chaining))"></a>(how much previous work do I know about - read it! (reference chaining))</h3><h3 id="Does-it-work"><a href="#Does-it-work" class="headerlink" title="Does it work?"></a>Does it work?</h3><h3 id="What-could-be-improved"><a href="#What-could-be-improved" class="headerlink" title="What could be improved"></a>What could be improved</h3><h1 id="Optimizing-Data-Migration-for-Garbage-Collection-in-ZNS-SSDs"><a href="#Optimizing-Data-Migration-for-Garbage-Collection-in-ZNS-SSDs" class="headerlink" title="Optimizing Data Migration for Garbage Collection in ZNS SSDs"></a>Optimizing Data Migration for Garbage Collection in ZNS SSDs</h1><h2 id="Problem-to-be-solved"><a href="#Problem-to-be-solved" class="headerlink" title="Problem to be solved"></a>Problem to be solved</h2><p>在<code>zns ssd</code>中，程序被允许以一种高效的数据放置方法连续的写入不同的区域<code>zone</code>中。然而，在一个区域<code>zone</code>中的<strong>无效数据<code>invalid data</code>只有在整个区域的数据被擦除时才能被释放</strong>，这导致了空间低利用率。</p>
<p>现阶段的研究集中在降低数据迁移的次数，但是他们的数据迁移方式并不高效。</p>
<p>一方面，<code>ZNS SSD</code>中的数据迁移会导致不必要的端到端开销。</p>
<blockquote>
<p>这是因为在<code>ZNS SSD</code>的数据迁移由<code>host</code>管理，迁移时要先将数据读取到内存中，再由主机指定写入对应的区域<code>zone</code>中去。</p>
</blockquote>
<p>另一方面，两个区域<code>zone</code>之间，进行块到块<code>block-to-block</code>的数据迁移的开销也很大，会导致巨大的重写开销。</p>
<p><strong>一种理想的方法是</strong>，将受害区域<code>victim zone</code>中的包含有效数据的块<code>blocks with valid data</code>重新映射到目标区域中<code>target zone</code>（通过这种映射，我们只需要擦除受害区域<code>victim zone</code>中的<code>blocks with invalid data </code>擦除，然后在目标区域<code>target zone</code>中开辟新的<code>block</code>并写入<code>blocks with invalid data</code>块中的有效数据即可）。</p>
<p>仍然，<code>ZNS SSD</code>中的区域和块之间的映射基于芯片间的并行提前被定义好了。</p>
<h2 id="Approaches"><a href="#Approaches" class="headerlink" title="Approaches"></a>Approaches</h2><p>提出一种新的<code>ZNS SSD</code>垃圾回收方式，<code>IS_AR</code>：</p>
<ul>
<li><h3 id="Zone-MD：提出的新ZNS命令，用于实现存储内部数据迁移in-storage-data-migration，以避免端到端的传输开销。"><a href="#Zone-MD：提出的新ZNS命令，用于实现存储内部数据迁移in-storage-data-migration，以避免端到端的传输开销。" class="headerlink" title="Zone_MD：提出的新ZNS命令，用于实现存储内部数据迁移in-storage data migration，以避免端到端的传输开销。"></a><code>Zone_MD</code>：提出的新<code>ZNS</code>命令，用于实现存储内部数据迁移<code>in-storage data migration</code>，以避免端到端的传输开销。</h3><p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-13%2020.27.34.png" alt="截屏2023-11-13 20.27.34"></p>
<p>如图所示，函数<code>Zone_MD(Src, Dst, Size)</code>接收三个参数：</p>
<ul>
<li><code>Src</code>：表示受害区域<code>victim zone</code>中的有效数据<code>valid data</code>的逻辑起始地址<code>starting logic address</code>。</li>
<li><code>Dst</code>：表示目标区域<code>target zone</code>的写指针<code>write pointer</code>地址。</li>
<li><code>Size</code>：表示要迁移的连续有效数据<code>continuous valid data</code>的大小。</li>
</ul>
<p>整个存储内数据迁移<code>in-storage data migration</code>在存储的内部通道<code>internal channel</code>的帮助下完成，避免了端到端传输。</p>
<blockquote>
<p><code>internal channel</code>是指固态硬盘（SSD）内部用于数据传输的通道。这个通道在硬盘的控制器内部进行操作，而不是通过主机的数据总线。这意味着数据迁移是在SSD设备内部完成的，而不需要数据经过主机（即计算机的CPU和主内存）。</p>
<p>这种内部数据迁移通道通常由SSD的固件和控制器逻辑来管理。它能够直接访问闪存存储单元，执行读取、传输和写入操作。使用这样的通道，可以有效地将数据从一个区域（源区域，Src）移动到另一个区域（目标区域，Dst），而不必通过外部接口传输数据，这样可以极大地减少数据迁移的延迟和带宽消耗。</p>
</blockquote>
</li>
<li><h3 id="AR：一种重映射策略remapping-strategy，该策略基于并行物理块，以减少block-to-block重写的开销。"><a href="#AR：一种重映射策略remapping-strategy，该策略基于并行物理块，以减少block-to-block重写的开销。" class="headerlink" title="AR：一种重映射策略remapping strategy，该策略基于并行物理块，以减少block-to-block重写的开销。"></a><code>AR</code>：一种重映射策略<code>remapping strategy</code>，该策略基于并行物理块，以减少<code>block-to-block</code>重写的开销。</h3></li>
</ul>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-13%2020.39.07.png" alt="截屏2023-11-13 20.39.07"></p>
<p>为保证对一个区域<code>zone</code>的并行写操作<code>parallelism of writing</code>，提出了一种基于并行块组<code>parallel block groups (PBGs)</code>动态的区域映射方法。</p>
<blockquote>
<p>上文中的每个block不是指NAND闪存内部的物理块，而是一个逻辑上的映射单元，它可能跨越多个芯片（chip）。</p>
</blockquote>
<ul>
<li>首先将<code>SSD</code>中的芯片分组，形成多个并行芯片组<code>mutiple parallel chip groups (PCG)</code>。通过<code>PCG</code>，读写操作可以并行的执行。</li>
<li>在每个并行芯片组<code>PCG</code>中，拥有相同偏移量<code>offset</code>的块被分到相同的并行块组中<code>PBG</code>，同样并行块组中的读写操作也能被并行的执行。</li>
<li>我们把并行块组<code>(PBG)</code>作为最小的重映射单位，并保证了区域内的并行性。</li>
<li>当一个区域被分配时，我们动态的将<code>PBGs</code>映射到区域上。</li>
</ul>
<p>现在我们讨论重映射策略。</p>
<p>在受害区域<code>victim zone</code>中，有两种<code>PBG</code>区域需要被迁移：</p>
<ul>
<li><code>V1</code>：整个并行块组<code>PBG</code>都是合法数据。</li>
<li><code>V2</code>：并行块组<code>PBG</code>的一部分是合法数据。</li>
</ul>
<p>在目标区域<code>target zone</code>，并行块组也分为两类：</p>
<ul>
<li><code>T1</code>：并行块组的所有部分均会被写入。</li>
<li><code>T2</code>：并行块组只有一部分会被写入。</li>
</ul>
<p>两辆组合，产生四种重映射方法：</p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-14%2008.44.24.png" alt="截屏2023-11-14 08.44.24"></p>
<ul>
<li><p><code>Fig.3.(1),(2)</code>：<code>V1</code>被重映射到包含<code>T1</code>或<code>T2</code>的区域<code>zone</code>。</p>
<ul>
<li><p><code>V1-&gt;T1</code>：<code>V1</code>的逻辑地址和物理地址直接重映射（这里的关键是没有提到数据从物理上的一个位置被复制到另一个位置，而是提到了逻辑空间（LS）到物理空间（PS）的映射直接重映射到目标区域，这通常涉及更新映射表（MT）而不是实际的数据移动。）到目标区域。同时，<code>Write Point</code>移动到<code>WP* = (WP + V1_Size)</code>，并在映射表<code>Mapping Table</code>上更新物理地址和逻辑地址。</p>
</li>
<li><p><code>V1-&gt;T2</code>：为了提高<code>T2</code>的空间利用率，<code>P1-P2</code>这段未被使用的空间的物理地址将被重映射到逻辑地址中去，其位置会在写指针<code>WP*</code>后面的<code>CW</code>处，长度不变。</p>
<blockquote>
<p><code>RT (Remapping Table)</code>：为了保持正确的索引关系，添加了一个新的重新映射表（RT），以记录逻辑地址与范围内的物理地址的偏移量（即具有相同偏移量相同的LS的连续段）粒度。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>Fig.3.(3),(4)</code>：<code>V2</code>被重映射到包含<code>T1</code>或<code>T2</code>的区域<code>zone</code>。</p>
<ul>
<li><p><code>V2</code>的整个物理地址直接被重映射到目标区域的物理地址中。然而，只有<code>V2</code>中的有效数据的逻辑地址被重映射到目标区域，因为目标区域只需要有效数据。</p>
<blockquote>
<p>V2中的无效数据空间被保留，直到目标区域重置（即部分无效空间被目标区域暂时占据）。</p>
</blockquote>
<p>因此，我们使用<code>ZNS SSD</code>的当前空间占用率<code>current space utilization (su)</code>作为基准<code>benchmark</code>。</p>
<p>如果<code>V2</code>中的有效数据的百分占比大于<code>su</code>，我们执行重映射。</p>
<p>否则我们直接重写<code>V2</code>中的所有有效数据。</p>
</li>
</ul>
</li>
</ul>
<p>​	通过上述方法，我们平衡了空间利用率和性能。</p>
<h2 id="Does-it-work-1"><a href="#Does-it-work-1" class="headerlink" title="Does it work?"></a>Does it work?</h2><p>将<code>IS-AR</code>和传统的数据迁移策略<code>Trad-DM</code>（没有实现数据内迁移和重映射）进行比较。具体的实验参数如下：</p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-14%2010.00.17.png" alt="截屏2023-11-14 10.00.17"></p>
<p>表格上看，数据迁移的延迟确实降低了，而且提高了<code>ZNS SSD</code>的寿命。</p>
<h2 id="What-could-be-improved？"><a href="#What-could-be-improved？" class="headerlink" title="What could be improved？"></a>What could be improved？</h2><p>论文中提到的<code>current space utilization</code>是如何选择的。</p>
<h1 id="A-New-LSM-style-Garbage-Collection-Scheme-for-ZNS-SSDs"><a href="#A-New-LSM-style-Garbage-Collection-Scheme-for-ZNS-SSDs" class="headerlink" title="A New LSM-style Garbage Collection Scheme for ZNS SSDs"></a>A New LSM-style Garbage Collection Scheme for ZNS SSDs</h1><h2 id="Problem-to-be-solved-1"><a href="#Problem-to-be-solved-1" class="headerlink" title="Problem to be solved"></a>Problem to be solved</h2><p><code>ZNS SSD</code>的两面性：</p>
<ul>
<li>Pro：通过将不同的工作负载分类到不同的区域中减少写放大<code>WAF</code></li>
<li>Cons：主机需要直接管理ZNS SSD，例如区域重置，并且它们具有顺序写入约束。</li>
</ul>
<p>简单的垃圾回收策略：</p>
<ul>
<li><code>LFS (log-structured File System)</code>：日志结构文件系统使用的段清理。</li>
<li><code>FTL (Flash Transition Layer)</code>：闪存层使用的垃圾回收策略</li>
</ul>
<p>上述策略的区别是将垃圾回收应用在区域<code>zone</code>还是段<code>segment</code>中。然而，这种简单的垃圾回收策略会因为区域的大小而导致更长的延迟，相比段大小而言。</p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><ul>
<li>如下图所示，要解决的问题还是：区域间的垃圾回收策略导致的时间开销过大。并且，最好选择利用利用率低的区域作为垃圾回收的区域。</li>
</ul>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-14%2015.11.12.png" alt="截屏2023-11-14 15.11.12"></p>
<ul>
<li><p>另一个观察是，在读取一个区域时，对块进行单独读取的耗时比对块进行组读取的模式的耗时更高。</p>
<blockquote>
<p>结果显示，以组的方式访问比单独访问要快得多。这是因为它不仅可以减少请求的数量，而且还可以利用ZNS固态硬盘内部的并行性。一般来说，ZNS固态硬盘中的一个区域会分布在多个通道上，这使得可以并行处理连续块的请求，就像开放通道固态硬盘（OCSSDs）那样。这一观察激励我们设计我们的LSM风格垃圾收集方案。</p>
</blockquote>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-14%2015.20.00.png" alt="截屏2023-11-14 15.20.00"></p>
</li>
</ul>
<h2 id="Approaches-1"><a href="#Approaches-1" class="headerlink" title="Approaches"></a>Approaches</h2><p>为了应对上文中提到的问题，提出了一个新的垃圾回收策略<code>LSM_ZGC</code>：</p>
<ul>
<li><code>LSM_ZGC</code>将区域分割为多个段，并分别管理这些段的信息。</li>
<li>以<code>LSM</code>的风格进行垃圾回收，读取候选区域的所有数据，识别冷数据，将它们合并到一个区域，同时将剩余数据合并到另一个区域。</li>
</ul>
<p>以下是<code>LSM_ZGC</code>的优点：</p>
<ul>
<li>采用基于段<code>segment</code>（而不是基于区域<code>zone</code>）的方式，有利于冷热数据分割，并可以用流水线的方式实现策略。</li>
<li>读取段中所有有效和无效的数据，可以通过利用区域中的内部并行性来减少垃圾收集开销。</li>
<li>将冷热数据放入不同的区域，可以增加找到利用率较低的区域的机会。</li>
</ul>
<p>在<code>ZNS SSD</code>的垃圾回收策略中，最简单的方式<code>Basic_ZGC</code>是：</p>
<ul>
<li>选择一个利用率最低的区域。</li>
<li>读取该区域中有效数据块并将它们写入新的区域中去。</li>
<li>最后通过<code>reset command</code>重置选择的块。</li>
</ul>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-14%2015.26.30.png" alt="截屏2023-11-14 15.26.30"></p>
<p>而<code>LSM_ZGC</code>的策略有三个不同之处：</p>
<ul>
<li><p>对于一个区域<code>zone</code>的垃圾回收会在段<code>segment</code>上实现。此外，它允许使用细粒度段单元执行区域垃圾收集，其中可以以管道方式读取、合并和写入段。</p>
</li>
<li><p>在垃圾回收阶段，它以<code>128KB</code>大小<code>IO</code>，不仅读取有效块，也读取无效块，而<code>Basic_ZGC</code>只读取有效块。</p>
<blockquote>
<p>读取所有快的原因是，我们在Figure 2中观察到，<code>in group manner</code>利用芯片的并行性提高读取速度。</p>
<p>因此当块数量大于16时，我们采取全部读取的方式。（由于16个128KB大小的请求可以覆盖整个2MB的段数据，它会读取所有块。）</p>
</blockquote>
</li>
<li><p><code>LSM_ZGC</code>通过鉴别冷数据<code>cold data</code>，并将冷数据合并到一个单独的区域中。</p>
<p>为了到达这个目的，我们定义四种区域的状态：</p>
<ul>
<li><p><code>C0_zone</code></p>
</li>
<li><p><code>C1C_zone</code>：</p>
<blockquote>
<p>我们将利用率高于阈值的段（称为门槛冷）定义为冷。这一决定基于我们的观察，即具有相似寿命的数据显示出强大的空间局部性。<br>可能的原因：段中大部分空间被占用通常意味着其中的数据已经稳定下来，且变动不大。</p>
</blockquote>
</li>
<li><p><code>C1H_zone</code></p>
</li>
<li><p><code>C2_zone</code></p>
</li>
</ul>
<p>新到达的数据按顺序写入状态为<code>C0</code>区域的区域，删除的数据将离开图中所示的状态。</p>
<ul>
<li><p>将冷数据写入<code>C1C_zone</code>。</p>
</li>
<li><p>将其他数据写入<code>C1H_zone</code>中。</p>
</li>
</ul>
<p>而当要回收的区域状态是<code>C1C_zone</code>或者<code>C1H_zone</code>时，<code>LSM_ZGC</code>将读取所有段，并把所有有效块看作冷数据。这是因为这些有效块在连续两次垃圾回收操作后都被保留了。最后这些块中的数据会被写入<code>C2_zone</code>中。</p>
<p>我们预计这种机制能够将冷数据与其他数据隔离开来，从而增加在垃圾收集期间找到利用率较低的候选区的机会。</p>
</li>
</ul>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-14%2015.42.42.png" alt="截屏2023-11-14 15.42.42"></p>
<h1 id="InDeF-An-Advanced-Defragmenter-Supporting-Migration-Offloading-on-ZNS-SSD"><a href="#InDeF-An-Advanced-Defragmenter-Supporting-Migration-Offloading-on-ZNS-SSD" class="headerlink" title="InDeF: An Advanced Defragmenter Supporting Migration Offloading on ZNS SSD"></a>InDeF: An Advanced Defragmenter Supporting Migration Offloading on ZNS SSD</h1><h2 id="Problem-to-be-solved-2"><a href="#Problem-to-be-solved-2" class="headerlink" title="Problem to be solved"></a>Problem to be solved</h2><p><code>ZNS SSD</code>由于其不恰当的更新和应用程序的多线程写作行为，它脆弱地能够碎片化。</p>
<blockquote>
<p>碎片化是指<code>SSD</code>中的数据不是连续存储在<code>SSD</code>上的，而是分散到不同的区域。</p>
</blockquote>
<p>由于碎片化，<code>I/O</code>请求会被分割（要读取不同的区域，所以将一个<code>I/O</code>分割成多个的<code>I/O</code>）。</p>
<blockquote>
<p>为什么说<code>ZNS SSD</code>更容易碎片化？</p>
<p>由于<code>ZNS SSD</code>的顺序写特性，访存需要使用一种<code>log-structured file system (LFS)</code>，如<code>F2FS</code>。</p>
</blockquote>
<p>传统的<code>Defragmentation tool</code>有如下缺点：</p>
<ul>
<li><p>由于大多数<code>Defragmentation tool</code>是为传统<code>SSD</code>设计的，它们无法处理物理碎片（这是因为传统SSD不会将物理地址暴露给主机）。而<code>ZNS SSD</code>将逻辑地址组织成一个个区域，且区域与物理介质的边界对齐。因此，我们可以通过这种特性在主机端判断物理碎片化。</p>
</li>
<li><p>传统的碎片整理工具<code>defragmentation tool</code>，如<code>defrag.f2fs</code>，在整理碎片时的开销很大。</p>
<blockquote>
<p>这是因为<code>defrag.f2fs</code>会把底层设备的所有内容读入主机内存中去，然后再将数据写入设备中的连续空间。这会导致大量的<code>I/O</code>开销。</p>
</blockquote>
</li>
<li><p>并且对于不熟悉系统编程的用户来说，使用这样的工具<code>defrag.f2fs</code>是困难的。</p>
</li>
<li><p>闪存设备的擦除次数有限，过多的数据迁移会降低<code>ZNS SSD</code>的寿命。</p>
</li>
<li><p>碎片整理会消耗大量的时间，且会降低前端应用的性能（由于额外的<code>I/O</code>操作）</p>
</li>
</ul>
<h2 id="How-to-find-these-problems"><a href="#How-to-find-these-problems" class="headerlink" title="How to find these problems?"></a>How to find these problems?</h2><ul>
<li><p><strong>在多线程模式的工作负荷下，数据读取的吞吐量显著降低，如图1所示：</strong></p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2010.19.07.png" alt="截屏2023-11-15 10.19.07"></p>
<ul>
<li><p><strong>I&#x2F;O请求碎片化的定义:</strong><br>由于文件系统的碎片化和闪存<code>SSD</code>的内部操作，一部分访存数据的分布变得更加随机，导致内部资源的冲突。</p>
<p>我们定义<code>I/O</code>请求的逻辑碎片<code>logical fragmentation</code>和物理碎片<code>physical fragmentation</code>，如图2所示：</p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2010.27.43.png" alt="截屏2023-11-15 10.27.43"></p>
</li>
</ul>
</li>
<li><p>**<code>Request splitting</code>**：由于碎片数据的逻辑地址不连续，向碎片数据发出的大型顺序I&#x2F;O被拆分为多个小型随机I&#x2F;O。</p>
</li>
<li><p>**<code>DoLF</code>**：<code>degree of logical fragmentation</code>，一个<code>I/O</code>范围中的逻辑碎片的数量。</p>
</li>
<li><p>**<code>DoPF</code>**：<code>degree of physical fragmentation</code>， 我们通过I&#x2F;O范围内的数据在闪存并行单元之间的均匀分布来衡量I&#x2F;O请求的物理碎片程度。</p>
<blockquote>
<p>这是因为在<code>SSD</code>中，物理碎片的定义和在磁盘上的不同（物理地址上连续），这是因为<code>SSD</code>上的芯片可以被并行的访问。如图2所示，我们把具有相同偏移量（即只能被同一芯片顺序访问的地址定义为物理碎片）。</p>
</blockquote>
<p>$$<br>DoPF &#x3D; \frac{\sum_{i&#x3D;1}^{L} \left(N_i - \frac{M}{L}\right)^2}{L}<br>$$</p>
<ul>
<li><code>M</code>：<code>I/O</code>请求访问的数据块的数量</li>
<li><code>L</code>：闪存的并行芯片数量</li>
<li><code>N_i</code>：<code>N</code>表示位于<code>i</code>平行单元（平行芯片）的数据块数量</li>
</ul>
<p>综上，较大的<code>DoPF</code>表明物理碎片程度较高，<code>I/O</code>并行程度较低。</p>
</li>
<li><p><strong>物理碎片和逻辑碎片对<code>I/O</code>性能的影响</strong></p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2011.03.09.png" alt="截屏2023-11-15 11.03.09"></p>
</li>
</ul>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2011.03.57.png" alt="截屏2023-11-15 11.03.57"></p>
<blockquote>
<p><strong>当芯片数量少于6个时，I&#x2F;O并行性对I&#x2F;O性能有显著影响，DoPF值显著增加，而I&#x2F;O性能大幅下降。然而，当DoPF值较小时，例如小于40，物理碎片化对I&#x2F;O性能的影响可以忽略不计。这是因为当I&#x2F;O的物理并行度超过一定程度时，软件开销主导了总的I&#x2F;O延迟。</strong></p>
</blockquote>
<ul>
<li><strong>如何寻找合适的碎片进行处理？</strong></li>
</ul>
<blockquote>
<p>碎片化程度低或很少访问的冷数据碎片整理数据几乎没有性能提升。</p>
</blockquote>
<p>​	<code>IODP</code>，<code>I/O data defragmentation priority</code>:<br>$$<br>IODP &#x3D; (\alpha \cdot DoLF + \beta \cdot DoPF) \times \text{readcount}<br>$$</p>
<ul>
<li><p><strong>传统固态硬盘碎片处理时的开销</strong></p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2011.20.51.png" alt="截屏2023-11-15 11.20.51"></p>
<ul>
<li><p>内存页面分配</p>
</li>
<li><p>读数据</p>
<blockquote>
<p>对内存的大量读取可能会导致主机内存使用量显著增加，并调用页面帧回收</p>
</blockquote>
</li>
<li><p>分配连续空间</p>
</li>
<li><p>写数据</p>
<blockquote>
<p>其次，在将所有目标数据读入页面缓存之前，defrag.f2fs分配一个连续的可用空间，并按顺序将所有数据写入SSD，从而导致SSD中的芯片空闲间隔很大。</p>
</blockquote>
</li>
<li><p>元数据<code>metadata</code>更新</p>
</li>
</ul>
</li>
</ul>
<h2 id="Approaches-2"><a href="#Approaches-2" class="headerlink" title="Approaches"></a>Approaches</h2><p><code>InDeF</code>的两个目标：</p>
<ul>
<li><p>一个是尽量减少用于碎片整理的迁移数据量，以减少底层设备的写入流量。</p>
</li>
<li><p>另一个是利用ZENS SSD的内部并行性来减少碎片整理的时间。</p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2011.34.18.png" alt="截屏2023-11-15 11.34.18"></p>
<ul>
<li><p><em>Fagmentation Information Management Module</em>：</p>
<ul>
<li><p>I&#x2F;O Monitor. 通过<code>I/O</code>访问的文件的<code>inode</code>确定文件块的范围</p>
</li>
<li><p>I&#x2F;O Information Management：</p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2017.08.59.png" alt="截屏2023-11-15 17.08.59"></p>
</li>
<li><p>Fagmentation Information Management.</p>
</li>
</ul>
</li>
<li><p><em>Fragmentation Calculation Module</em></p>
<ul>
<li><p>Zone Mapping in ZNS SSD</p>
<p><code>F2FS</code>通常使用<code>2MB</code>大小的段管理逻辑地址空间，图八中是区域映射到闪存块的例子：</p>
<p>图中<code>ZNS SSD</code>有四个并行芯片，一个逻辑块对应一个物理闪存页。</p>
<p>一个区域对应<code>F2FS</code>的两个连续的段。</p>
<p>根据区域大小，物理区域由一组分布在并行芯片中的块组成。</p>
<p>物理区域中的页面以交错的方式放置在不同的芯片中。</p>
<p>这样的方式能完全利用闪存操作的并行性。</p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2017.15.40.png" alt="截屏2023-11-15 17.15.40"></p>
</li>
<li><p>Calculating the degree of Fragmentation</p>
<p>首先将<code>I/O</code>范围内的文件块索引转换为文件的物理块地址。</p>
<p><code>DoLF</code>由逻辑块碎片计算。</p>
<p><code>DoPF</code>由物理块碎片计算。</p>
<p>图9是计算碎片化程度的一个例子</p>
<p>通过文件到存储的映射表，将文件<code>inode</code>中的索引号转换为文件系统的逻辑块地址。</p>
<ul>
<li><code>(32, 48, 3)</code>分别表示起始索引，结束索引，和读计数<code>read count</code></li>
<li><code>Inode# = 7</code>表示文件7</li>
</ul>
<p>索引对应了16个文件系统块。</p>
<p>我们会发现有在<code>File-system Block</code>，也就是所谓的逻辑块中，有6组碎片。所以<code>DoLF = 6</code></p>
<p>对于物理碎片，我们首先需要通过段号和段内偏移量获取闪存设备中每个逻辑块的位置。</p>
<p>例如，对于逻辑块<code>801</code>我们首先计算<code>In-segment offset = 801 - 800 = 1</code></p>
<p><code>1 mode 4 = 1</code>，现在我们知道逻辑块<code>801</code>会在芯片1上被处理。</p>
<p>最终，我们通过计算可以得到<code>DoPF</code>的值为2.5。</p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2018.52.28.png" alt="截屏2023-11-15 18.52.28"></p>
</li>
</ul>
</li>
<li><p>Defragmentation Module</p>
<p>选择需要迁移的数据过滤掉对<code>I/O</code>性能影响不大的碎片。</p>
<p>其次，毗连空间分配从该区域分配毗连的自由空间。</p>
<p>第三，主机的数据迁移任务被卸载到SSD。</p>
<p>最后，文件系统会保留迁移数据的元数据块。</p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2019.15.20.png" alt="截屏2023-11-15 19.15.20"></p>
<ul>
<li><p>Fragments filter.</p>
</li>
<li><p>Migration offloading.</p>
<ul>
<li><p>Command generating</p>
<p>InDeF将源数据分为两组，其中一组需要从主机内存传输到设备，另一组通过迁移卸载进行处理。</p>
<blockquote>
<p>这是因为：对于I&#x2F;O范围内的每个块，首先要检查它是否缓存在页面缓存中。如果它已经被缓存并且页面很脏，则需要将该块排除在迁移卸载之外，并从内存写入设备。如果缓存的页面干净或未缓存，则可以通过迁移卸载在内部复制。</p>
</blockquote>
</li>
<li><p>Command sending:</p>
<p> <code>In_Device_Defragment</code> 命令实现存储内数据迁移</p>
<blockquote>
<p>它包含一组源LBA和一组目标LBA。该命令非常高效，因为每个4KB逻辑块被两个4字节块地址替换。</p>
</blockquote>
</li>
<li><p>Command processing:</p>
<p>SSD内部控制器根据区域的写入策略处理迁移卸载和主机请求。</p>
<ul>
<li><p>如果源块和目标块属于同一芯片，则使用<code>copyback</code>命令在芯片内进行传输。</p>
</li>
<li><p>否则，先将数据块读入<code>SSD</code>中的<code>DRAM</code>，再写到目标位置。</p>
<blockquote>
<p>即使是对迁移卸载数据的读取请求，它们也可以通过SSD上的DRAM或闪存芯片正常处理。由于异地更新策略，对迁移卸载数据的写入请求不受影响。最后，文件系统会保留迁移到设备的数据的元数据块。F2FS实施检查点以提供一致的恢复点。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Slides"><a href="#Slides" class="headerlink" title="Slides:"></a>Slides:</h1><iframe src="../../../../pdf_file/ZNS00/ZNS_11.18.pdf" style="width:100%; height:800px;" frameborder="0"></iframe>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/11/ZNSLinuxKernelSupport/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/11/ZNSLinuxKernelSupport/" class="post-title-link" itemprop="url">ZNSLinuxKernelSupport</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-11 12:01:17" itemprop="dateCreated datePublished" datetime="2023-11-11T12:01:17+08:00">2023-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-16 13:16:53" itemprop="dateModified" datetime="2023-11-16T13:16:53+08:00">2023-11-16</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux-Zoned-Storage-Support-Overview"><a href="#Linux-Zoned-Storage-Support-Overview" class="headerlink" title="Linux Zoned Storage Support Overview"></a>Linux Zoned Storage Support Overview</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>​	应用程序开发者可以通过多种 I&#x2F;O 路径使用分区块设备，可以用不同的编程接口来控制它们，并且可以以不同的方式暴露分区块设备。下面的图表简单表示了各种访问路径。</p>
<blockquote>
<ul>
<li><code>POSIX</code>：<code>Portable Operating System Interface</code>，它是一系列 IEEE 标准，旨在确保不同操作系统之间的兼容性。</li>
</ul>
</blockquote>
<p><img src="/../images/ZNSLinuxKernelSupport/%E6%88%AA%E5%B1%8F2023-11-11%2013.15.44.png" alt="截屏2023-11-11 13.15.44"></p>
<ul>
<li><code>File Access Interface</code>：文件访问接口。上图中<code>Legacy Application</code>有两种文件访问方式：<ul>
<li><code>ZBD Compliant File System</code>：文件系统被修改，可以将随机写转换为适合<code>Zoned Block Devices</code>的顺序写。例如，<code>F2FS</code>。</li>
<li><code>Legacy File System</code>：文件系统未经修改，设备的顺序写入限制由一个设备映射器目标处理器<code>dm-zoned</code>处理。</li>
</ul>
</li>
<li><code>Raw Block Access Interface</code>：应用程序直接访问设备上的数据，该接口类似于<code>legacy File System</code>，使用<code>dm-zoned</code>设备映射器目标驱动实现的，以便对应用程序隐藏顺序写入的限制。</li>
</ul>
<p>​	为遵守分区块设备的顺序写入约束而编写或修改的应用程序可以使用三个额外的接口。这些接口直接将设备约束暴露给应用程序，这些应用程序必须确保数据使用从区域的写入指针位置开始的顺序流进行写入。</p>
<ul>
<li><code>File Access Interface</code>：该接口专门适配<a target="_blank" rel="noopener" href="https://zonedstorage.io/docs/linux/fs#zonefs"><code>zonefs</code></a>文件系统。该文件系统将<code>zoned block device</code>的每一个<code>zone</code>作为一个文件。但有所不同的是，设备中的顺序写不由<code>zonefs</code>管理，区域的顺序写应交给上层的应用程序负责。</li>
<li><code>Zoned Raw Block Access Interface</code>：该接口没有任何中间驱动来处理设备限制。应用程序可以直接打开分区块设备的设备文件来使用这个接口，以获取对区块信息和块层提供的管理操作的访问。</li>
<li><code>Passthrough Device Access Interface</code>：该接口由<code>SCSI</code>通用驱动<code>SG</code>和<code>NVMe</code>驱动提供，它允许应用程序直接向设备发送<code>SCSI</code>和<code>NVMe</code>命令。在这个接口中，内核对应用程序发送的命令干预非常小，这导致需要应用程序自己处理所有的设备限制（例如，逻辑和物理扇区大小，区域边界，命令超时，命令重试次数等）。如<code>libzbc</code>和<code>libnvme</code>这样的用户级库可以大大简化使用这个接口的应用程序的实现。</li>
</ul>
<h2 id="Kernel-Versions"><a href="#Kernel-Versions" class="headerlink" title="Kernel Versions"></a>Kernel Versions</h2><p><img src="/../images/ZNSLinuxKernelSupport/%E6%88%AA%E5%B1%8F2023-11-11%2014.07.43.png" alt="截屏2023-11-11 14.07.43"></p>
<ul>
<li><code>Passthrough Access Support (SG Access)</code>：内核支持通过<code>SCSI</code>通用<code>(SG)</code>接口访问主机管理的<code>ZBC/ZAC</code>硬盘。对于符合条件的 SCSI 硬盘或连接到兼容 SAS HBA 的 SATA 硬盘，用户可以通过 SG 驱动创建的节点文件来访问这些主机管理的磁盘。这允许用户通过 SG 接口与这些磁盘交互。</li>
<li><code>Zoned Block Device Access and F2FS Support</code>：4.10以后的内核支持主机以管理常规磁盘的方式将ZBC&#x2F;ZAC<code>磁盘当作block device files</code>管理。</li>
<li><code>Device Mapper and dm-zoned Support</code>：在内核4.13.0中，对分区块设备的支持被添加到了设备映射器基础架构中。这项支持允许在分区块设备之上使用 dm-linear 和 dm-flakey 设备映射器目标。此外，还添加了 dm-zoned 设备映射器目标驱动程序。</li>
<li><code>Block multi-queue and SCSI multi-queue Support</code>：支持块多队列和SCSI多队列。</li>
<li><code>zonefs</code>：支持<code>zonefs file system</code>，将分区块设备的区域作为常规文件暴露出来，支持所有类型的分区块设备。</li>
<li><code>Zone Append Operation Support</code>：追加写操作。</li>
<li><code>NVM Express Zoned Namespaces</code>：支持<code>NVMe ZNS</code>命令集。</li>
</ul>
<h1 id="Kernel-Configuration"><a href="#Kernel-Configuration" class="headerlink" title="Kernel Configuration"></a>Kernel Configuration</h1><p>内核中一些关于zoned block device 的配置</p>
<h2 id="Block-Layer"><a href="#Block-Layer" class="headerlink" title="Block Layer"></a>Block Layer</h2><h3 id="Zoned-Block-Devices-Core-Support"><a href="#Zoned-Block-Devices-Core-Support" class="headerlink" title="Zoned Block Devices Core Support"></a>Zoned Block Devices Core Support</h3><p>通过make menuconfig 打开Linux配置菜单，选择 <code>Zoned block device support</code>。</p>
<h3 id="Write-Ordering-Control"><a href="#Write-Ordering-Control" class="headerlink" title="Write Ordering Control"></a>Write Ordering Control</h3><p>​	写入顺序控制通过<code>deadline</code>（遗留的单队列块I&#x2F;O路径）和mq-deadkine（多队列块I&#x2F;O路径）块 I&#x2F;O 调度器实现的（见写入顺序控制）。如果设置了 CONFIG_BLK_DEV_ZONED 配置选项，则自动启用 deadline 和 mq-deadline 分区块设备支持。</p>
<p>​	对于分区块设备，启用这个调度器是必须的。配置选项 CONFIG_MQ_IOSCHED_DEADLINE 启用 mq-deadline 调度器。配置选项 CONFIG_IOSCHED_DEADLINE 启用 deadline 调度器。这两个选项都可以从 IO 调度器顶级菜单中选择。</p>
<p>​	不过在后续的版本中，<code>CONFIG_MQ_IOSCHED_DEADLINE</code>会随着<code>CONFIG_BLK_DEV_ZONED</code>配置而配置。</p>
<h2 id="Device-Drivers-Configuration"><a href="#Device-Drivers-Configuration" class="headerlink" title="Device Drivers Configuration"></a>Device Drivers Configuration</h2><ul>
<li><code>null_blk</code> Logic Device</li>
<li><code>ZBC</code> and &#96;ZAC Hard-Disks Support</li>
<li><code>NVMe Zoned Namespace Solid State Disks Support</code></li>
</ul>
<h2 id="Device-Mapper"><a href="#Device-Mapper" class="headerlink" title="Device Mapper"></a>Device Mapper</h2><p>设置了 CONFIG_BLK_DEV_ZONED 选项时，设备映射器子系统对分区块设备的支持会自动启用。这使得 dm-linear 和 dm-flakey 目标得到支持。请注意，必须启用 dm-zoned 设备映射器目标才能使用。</p>
<p>通过在菜单“设备驱动程序 –&gt; 多设备驱动支持（RAID 和 LVM）–&gt; 设备映射器支持 –&gt; 驱动管理的分区块设备目标支持”中选择 CONFIG_DM_ZONED 选项来启用 dm-zoned 目标。</p>
<h2 id="File-Systems"><a href="#File-Systems" class="headerlink" title="File Systems"></a>File Systems</h2><h3 id="F2fs"><a href="#F2fs" class="headerlink" title="F2fs"></a>F2fs</h3><p>当<code>CONFIG_BLK_DEV_ZONED</code>配置时，<code>f2fs file system</code>也自动被配置。</p>
<h3 id="zonefs"><a href="#zonefs" class="headerlink" title="zonefs"></a>zonefs</h3><p>这个要在 <code>menu File system -&gt; zonefs</code>中手动配置</p>
<h3 id="Kernel-Installation"><a href="#Kernel-Installation" class="headerlink" title="Kernel Installation"></a>Kernel Installation</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo make modules_install install</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo make headers_install</span><br></pre></td></tr></table></figure>

<h1 id="Zoned-Block-Device-user-Interface"><a href="#Zoned-Block-Device-user-Interface" class="headerlink" title="Zoned Block Device user Interface"></a>Zoned Block Device user Interface</h1><p>用户程序可以通过两种接口访问<code>zone information</code>和管理<code>zoned block device</code>中的<code>zones</code></p>
<ol>
<li><code>sysfs attribute files</code>：可以直接作为常规文件由应用程序访问，或者通过脚本语言访问。</li>
<li><code>ioctl() system call</code>：适用于从 C 程序或其他具有等效系统调用绑定的编程语言中使用。</li>
</ol>
<h2 id="Sysfs-Interface"><a href="#Sysfs-Interface" class="headerlink" title="Sysfs Interface"></a>Sysfs Interface</h2><table>
<thead>
<tr>
<th align="center">File</th>
<th>Kernel version</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x2F;sys&#x2F;block&#x2F;<em>dev name</em>&#x2F;queue&#x2F;zoned</td>
<td>4.10.0</td>
<td>Device zoned model</td>
</tr>
<tr>
<td align="center">&#x2F;sys&#x2F;block&#x2F;<em>dev name</em>&#x2F;queue&#x2F;chunk_sectors</td>
<td>4.10.0</td>
<td>Device zone size</td>
</tr>
<tr>
<td align="center">&#x2F;sys&#x2F;block&#x2F;<em>dev name</em>&#x2F;queue&#x2F;nr_zones</td>
<td>4.20.0</td>
<td>Total number of zones</td>
</tr>
<tr>
<td align="center">&#x2F;sys&#x2F;block&#x2F;<em>dev name</em>&#x2F;queue&#x2F;zone_append_max_bytes</td>
<td>5.8.0</td>
<td>Maximum size in bytes of a zone append write operation</td>
</tr>
<tr>
<td align="center">&#x2F;sys&#x2F;block&#x2F;<em>dev name</em>&#x2F;queue&#x2F;max_open_zones</td>
<td>5.9.0</td>
<td>Maximum number of open zones</td>
</tr>
<tr>
<td align="center">&#x2F;sys&#x2F;block&#x2F;<em>dev name</em>&#x2F;queue&#x2F;max_active_zones</td>
<td>5.9.0</td>
<td>Maximum number of active zones</td>
</tr>
</tbody></table>
<h3 id="Device-Zoned-Model"><a href="#Device-Zoned-Model" class="headerlink" title="Device Zoned Model"></a>Device Zoned Model</h3><p><code>zone model</code>（<code>host-managed</code>和<code>host-awared</code>）可以通过<code>zoned</code>设备队列 查看，例如，如果一个<code>zoned block device</code>叫做<code>sdb</code>，则通过命令查看模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /sys/block/sdb/queue/zoned</span></span><br><span class="line">host-managed</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>Regular block device, including drive-managed SMR disks</td>
</tr>
<tr>
<td>host-aware</td>
<td>Host-aware device model</td>
</tr>
<tr>
<td>host-managed</td>
<td>Host-managed device model</td>
</tr>
</tbody></table>
<h3 id="Zone-Size"><a href="#Zone-Size" class="headerlink" title="Zone Size"></a>Zone Size</h3><p>设备的区域大小<code>zone size</code>可以从<code>sysfs</code>队列属性文件读取，命令如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /sys/block/sdb/queue/chunk_sectors</span></span><br><span class="line">524288</span><br></pre></td></tr></table></figure>

<p>该值以512字节扇区的数量显示，不论设备的实际逻辑和物理大小如何。在上文中，设备分区的大小为<code>524288 * 512 = 256 MB</code></p>
<h3 id="Number-of-Zones"><a href="#Number-of-Zones" class="headerlink" title="Number of Zones"></a>Number of Zones</h3><p>同样，<code>zoned device</code>的<code>zones</code>的数量可以通过如下命令获取</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /sys/block/sdb/queue/nr_zones</span></span><br><span class="line">55880</span><br></pre></td></tr></table></figure>

<p>对于普通块设备，这个参数为0。</p>
<h3 id="Zone-Resources"><a href="#Zone-Resources" class="headerlink" title="Zone Resources"></a>Zone Resources</h3><p>设备区域资源可以从<code>sysfs queue</code>参数文件中读取，分别是<code>max_open_zones</code>和<code>max_active_zones</code>。</p>
<p>命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /sys/block/sdb/queue/max_open_zones</span></span><br><span class="line">128</span><br></pre></td></tr></table></figure>

<p>该命令给出了能被显示或者隐示打开的<code>zones</code>的数量为<code>128</code>。如果为0，则表示设备没有限制最大zones的打开数量。</p>
<p>接下来的命令给出了<code>zones</code>是<code>active</code>状态<code>(open or closed state)</code>的最大数量，同上，0表示没有限制：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /sys/block/sdb/queue/max_active_zones</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>当我们通过<code>null_blk</code>,<code>QEMU</code>,或者<code>tcmu-runner</code>模拟一个<code>zoned device</code>，以上参数是可以被人工设置的。</p>
<h2 id="ioctl-Application-Programming-Interface"><a href="#ioctl-Application-Programming-Interface" class="headerlink" title="ioctl() Application Programming Interface"></a><em>ioctl()</em> Application Programming Interface</h2><p>用户可以通过头文件<del>&#x2F;usr&#x2F;include&#x2F;linux&#x2F;blkzoned.h</del>，在kernel 5.10中，头文件在<code>include/uapi/linux/blkzone.h</code>，中定义的宏和数据结构获取<code>zoned block device</code>的信息并管理他们。</p>
<h3 id="Zone-Information-Data-Structures"><a href="#Zone-Information-Data-Structures" class="headerlink" title="Zone Information Data Structures"></a>Zone Information Data Structures</h3><p><code>struct blk_zone</code>定义了一个<code>zone-descriptor</code>结构，该结构包含了zone的所有描述。</p>
<ul>
<li><code>zone&#39;s location on device</code></li>
<li><code>zone type</code></li>
<li><code>zone state</code></li>
<li><code>position of zone write pointer</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct blk_zone - Zone descriptor for BLKREPORTZONE ioctl.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @start: Zone start in 512 B sector units </span></span><br><span class="line"><span class="comment"> * @len: Zone length in 512 B sector units</span></span><br><span class="line"><span class="comment"> * @wp: Zone write pointer location in 512 B sector units</span></span><br><span class="line"><span class="comment"> * @type: see enum blk_zone_type for possible values</span></span><br><span class="line"><span class="comment"> * @cond: see enum blk_zone_cond for possible values</span></span><br><span class="line"><span class="comment"> * @non_seq: Flag indicating that the zone is using non-sequential resources</span></span><br><span class="line"><span class="comment"> *           (for host-aware zoned block devices only).</span></span><br><span class="line"><span class="comment"> * @reset: Flag indicating that a zone reset is recommended.</span></span><br><span class="line"><span class="comment"> * @resv: Padding for 8B alignment.</span></span><br><span class="line"><span class="comment"> * @capacity: Zone usable capacity in 512 B sector units</span></span><br><span class="line"><span class="comment"> * @reserved: Padding to 64 B to match the ZBC, ZAC and ZNS defined zone</span></span><br><span class="line"><span class="comment"> *            descriptor size.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * start, len, capacity and wp use the regular 512 B sector unit, regardless</span></span><br><span class="line"><span class="comment"> * of the device logical block size. The overall structure size is 64 B to</span></span><br><span class="line"><span class="comment"> * match the ZBC, ZAC and ZNS defined zone descriptor and allow support for</span></span><br><span class="line"><span class="comment"> * future additional zone information.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_zone</span> &#123;</span></span><br><span class="line">	__u64	start;		<span class="comment">/* 分区的起始扇区。这是一个64位无符号整数，表示分区在存储设备上的起始位置，以512字节的扇区为单位计量。 */</span></span><br><span class="line">	__u64	len;		<span class="comment">/* 分区的长度，用扇区的数量表示。这同样是一个64位无符号整数，指示该分区包含多少个512字节的扇区。 */</span></span><br><span class="line">	__u64	wp;		<span class="comment">/* 分区的写入指针位置。这个值指示当前可写入数据的位置，在存储设备中也是以512字节扇区为单位表示。 */</span></span><br><span class="line">	__u8	type;		<span class="comment">/* 分区的类型。这是一个8位无符号整数，其值根据 enum blk_zone_type 中定义的类型来确定，比如常规分区、顺序写入分区等。 */</span></span><br><span class="line">	__u8	cond;		<span class="comment">/* 分区的状态。这个字段根据 enum blk_zone_cond 定义的值来确定分区的当前状态，例如空闲、满、只读等。*/</span></span><br><span class="line">	__u8	non_seq;	<span class="comment">/* 非顺序写入资源的标志。这是一个8位的标志位，用于指示该分区是否使用了非顺序写入资源，这通常仅适用于主动感知分区的块设备。 */</span></span><br><span class="line">	__u8	reset;		<span class="comment">/* 重置写入指针的推荐标志。这个字段表示是否推荐对该分区执行写入指针重置操作。 */</span></span><br><span class="line">	__u8	resv[<span class="number">4</span>];	<span class="comment">/*	 为了实现8字节对齐而设置的保留字段。	*/</span></span><br><span class="line">	__u64	capacity;	<span class="comment">/* 分区的可用容量，以512字节扇区为单位计量。*/</span></span><br><span class="line">	__u8	reserved[<span class="number">24</span>]; <span class="comment">/* 额外的保留字段，用来填充结构体大小，以确保整个结构体与 ZBC（Zoned Block Commands）、ZAC（Zoned ATA Commands）和 ZNS（Zoned Namespace）定义的分区描述符大小相匹配，即64字节。	*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	正如这个数据结构定义中的注释所指出的，用来表示（1）分区的起始位置、（2）分区的大小和（3）写入指针位置的单位是‘512字节的扇区大小’。这一点不受设备实际逻辑块大小的影响。即使是具有4KB逻辑扇区的设备，上述分区描述符字段也使用512字节扇区大小单位。”</p>
<h3 id="Zone-Type"><a href="#Zone-Type" class="headerlink" title="Zone Type"></a>Zone Type</h3><p>一个zone的discriptor只有一种类别：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * enum blk_zone_type - Types of zones allowed in a zoned device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_TYPE_CONVENTIONAL: The zone has no write pointer and can be writen</span></span><br><span class="line"><span class="comment"> *                              randomly. Zone reset has no effect on the zone.</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_TYPE_SEQWRITE_REQ: The zone must be written sequentially</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_TYPE_SEQWRITE_PREF: The zone can be written non-sequentially</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Any other value not defined is reserved and must be considered as invalid.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">blk_zone_type</span> &#123;</span></span><br><span class="line">	BLK_ZONE_TYPE_CONVENTIONAL	= <span class="number">0x1</span>,</span><br><span class="line">	BLK_ZONE_TYPE_SEQWRITE_REQ	= <span class="number">0x2</span>,</span><br><span class="line">	BLK_ZONE_TYPE_SEQWRITE_PREF	= <span class="number">0x3</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Zone-Condition"><a href="#Zone-Condition" class="headerlink" title="Zone Condition"></a>Zone Condition</h3><p>每个zone也只有一种状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * enum blk_zone_cond - Condition [state] of a zone in a zoned device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_COND_NOT_WP: The zone has no write pointer, it is conventional.</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_COND_EMPTY: The zone is empty.</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_COND_IMP_OPEN: The zone is open, but not explicitly opened.</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_COND_EXP_OPEN: The zones was explicitly opened by an</span></span><br><span class="line"><span class="comment"> *                          OPEN ZONE command.</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_COND_CLOSED: The zone was [explicitly] closed after writing.</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_COND_FULL: The zone is marked as full, possibly by a zone</span></span><br><span class="line"><span class="comment"> *                      FINISH ZONE command.</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_COND_READONLY: The zone is read-only.</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_COND_OFFLINE: The zone is offline (sectors cannot be read/written).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The Zone Condition state machine in the ZBC/ZAC standards maps the above</span></span><br><span class="line"><span class="comment"> * deinitions as:</span></span><br><span class="line"><span class="comment"> *   - ZC1: Empty         | BLK_ZONE_COND_EMPTY</span></span><br><span class="line"><span class="comment"> *   - ZC2: Implicit Open | BLK_ZONE_COND_IMP_OPEN</span></span><br><span class="line"><span class="comment"> *   - ZC3: Explicit Open | BLK_ZONE_COND_EXP_OPEN</span></span><br><span class="line"><span class="comment"> *   - ZC4: Closed        | BLK_ZONE_COND_CLOSED</span></span><br><span class="line"><span class="comment"> *   - ZC5: Full          | BLK_ZONE_COND_FULL</span></span><br><span class="line"><span class="comment"> *   - ZC6: Read Only     | BLK_ZONE_COND_READONLY</span></span><br><span class="line"><span class="comment"> *   - ZC7: Offline       | BLK_ZONE_COND_OFFLINE</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Conditions 0x5 to 0xC are reserved by the current ZBC/ZAC spec and should</span></span><br><span class="line"><span class="comment"> * be considered invalid.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">blk_zone_cond</span> &#123;</span></span><br><span class="line">	BLK_ZONE_COND_NOT_WP	= <span class="number">0x0</span>,</span><br><span class="line">	BLK_ZONE_COND_EMPTY	= <span class="number">0x1</span>,</span><br><span class="line">	BLK_ZONE_COND_IMP_OPEN	= <span class="number">0x2</span>,</span><br><span class="line">	BLK_ZONE_COND_EXP_OPEN	= <span class="number">0x3</span>,</span><br><span class="line">	BLK_ZONE_COND_CLOSED	= <span class="number">0x4</span>,</span><br><span class="line">	BLK_ZONE_COND_READONLY	= <span class="number">0xD</span>,</span><br><span class="line">	BLK_ZONE_COND_FULL	= <span class="number">0xE</span>,</span><br><span class="line">	BLK_ZONE_COND_OFFLINE	= <span class="number">0xF</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，<code>BLK_ZONE_COND_OFFLINE</code>和<code>BLK_ZONE_COND_READONLY</code>只能被设备本身设置，用来指示因硬件缺陷而能力受限的分区。</p>
<p>用户操作可能导致状态的转变。使用内核<code>ioctl()</code>接口的应用程序可以发出分区管理命令。</p>
<blockquote>
<p>The SCSI Zoned Block Command specification (ZBC), the ATA Zoned Device ATA Command Set specification (ZAC) and the NVM Express Zoned Namespace Command Set specification (ZNS) define a zone condition state machine that governs the possible transitions of a zone from one condition to another depending on the commands executed.</p>
</blockquote>
<h3 id="ioctl-Commands"><a href="#ioctl-Commands" class="headerlink" title="ioctl() Commands"></a>ioctl() Commands</h3><p>下面是 ioctl()命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Zoned block device ioctl&#x27;s:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @BLKREPORTZONE: Get zone information. Takes a zone report as argument.</span></span><br><span class="line"><span class="comment"> *                 The zone report will start from the zone containing the</span></span><br><span class="line"><span class="comment"> *                 sector specified in the report request structure.</span></span><br><span class="line"><span class="comment"> * @BLKRESETZONE: Reset the write pointer of the zones in the specified</span></span><br><span class="line"><span class="comment"> *                sector range. The sector range must be zone aligned.</span></span><br><span class="line"><span class="comment"> * @BLKGETZONESZ: Get the device zone size in number of 512 B sectors.</span></span><br><span class="line"><span class="comment"> * @BLKGETNRZONES: Get the total number of zones of the device.</span></span><br><span class="line"><span class="comment"> * @BLKOPENZONE: Open the zones in the specified sector range.</span></span><br><span class="line"><span class="comment"> *               The 512 B sector range must be zone aligned.</span></span><br><span class="line"><span class="comment"> * @BLKCLOSEZONE: Close the zones in the specified sector range.</span></span><br><span class="line"><span class="comment"> *                The 512 B sector range must be zone aligned.</span></span><br><span class="line"><span class="comment"> * @BLKFINISHZONE: Mark the zones as full in the specified sector range.</span></span><br><span class="line"><span class="comment"> *                 The 512 B sector range must be zone aligned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLKREPORTZONE	_IOWR(0x12, 130, struct blk_zone_report)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLKRESETZONE	_IOW(0x12, 131, struct blk_zone_range)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLKGETZONESZ	_IOR(0x12, 132, __u32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLKGETNRZONES	_IOR(0x12, 133, __u32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLKOPENZONE	_IOW(0x12, 134, struct blk_zone_range)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLKCLOSEZONE	_IOW(0x12, 135, struct blk_zone_range)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLKFINISHZONE	_IOW(0x12, 136, struct blk_zone_range)</span></span><br></pre></td></tr></table></figure>

<p>以下是内核支持的命令：</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Kernel version</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>BLKREPORTZONE</td>
<td>4.10.0</td>
<td>Get zone information</td>
</tr>
<tr>
<td>BLKRESETZONE</td>
<td>4.10.0</td>
<td>Reset a zone write pointer</td>
</tr>
<tr>
<td>BLKGETZONESZ</td>
<td>4.20.0</td>
<td>Get a device zone size</td>
</tr>
<tr>
<td>BLKGETNRZONES</td>
<td>4.20.0</td>
<td>Get the total number of zones of a device</td>
</tr>
<tr>
<td>BLKOPENZONE</td>
<td>5.5.0</td>
<td>Explicitly open a zone</td>
</tr>
<tr>
<td>BLKCLOSEZONE</td>
<td>5.5.0</td>
<td>Close a zone</td>
</tr>
<tr>
<td>BLKFINISHZONE</td>
<td>5.5.0</td>
<td>Finish a zone</td>
</tr>
</tbody></table>
<h3 id="Obtaining-Zone-Information"><a href="#Obtaining-Zone-Information" class="headerlink" title="Obtaining Zone Information"></a>Obtaining Zone Information</h3><p><code>BLKREPORTZONE</code>命令允许应用以分区描述符数组的形式获取设备的分区消息，<code>struct blk_zone_report</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct blk_zone_report - BLKREPORTZONE ioctl request/reply</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @sector: starting sector of report</span></span><br><span class="line"><span class="comment"> * @nr_zones: IN maximum / OUT actual</span></span><br><span class="line"><span class="comment"> * @flags: one or more flags as defined by enum blk_zone_report_flags.</span></span><br><span class="line"><span class="comment"> * @zones: Space to hold @nr_zones @zones entries on reply.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The array of at most @nr_zones must follow this structure in memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_zone_report</span> &#123;</span></span><br><span class="line">	__u64		sector;</span><br><span class="line">	__u32		nr_zones;</span><br><span class="line">	__u8    reserved[<span class="number">4</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blk_zone</span> <span class="title">zones</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sector</code>：代表报告的起始扇区。指定分区报告应该从哪个扇区开始。</li>
<li><code>nr_zones</code>：作为输入，指定调用者希望检索信息的最大分区数。作为输出，表示设备响应<code>BLKREPORTZONE</code>命令后报告的实际分区数。</li>
<li><code>zones[0]</code>：这是一个灵活数组成员（由<code>[0]</code>表示），用于存储分区描述符。此数组中的元素数量由<code>nr_zones</code>指定。这个数组将包含设备返回的实际分区信息。数组中的每个元素都是<code>struct blk_zone</code>类型，其中包含了关于单个分区的详细信息。</li>
</ul>
<p>下面是一个简单的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/blkzoned.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> start_sector = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_zone_report</span> *<span class="title">hdr</span>;</span></span><br><span class="line"><span class="type">size_t</span> hdr_len;</span><br><span class="line"><span class="type">int</span> nr_zones = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 	文件头的长度 	*/</span></span><br><span class="line">hdr_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> blk_zone_report) + nr_zones * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> blkzone);</span><br><span class="line"><span class="comment">/* 	为文件头分配空间	 */</span></span><br><span class="line">hdr = <span class="built_in">malloc</span>(hdr_len);</span><br><span class="line"><span class="comment">/*	检查是否分配成功	*/</span></span><br><span class="line"><span class="keyword">if</span> (!hdr)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">/*	文件头的起始扇区	*/</span></span><br><span class="line">    hdr-&gt;sector = start_sector;</span><br><span class="line">    <span class="comment">/*	最大分区数	*/</span></span><br><span class="line">    hdr-&gt;nr_zones = nr_zones;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*	通过`ioctl`调用，使用BLKREPORTZONE命令获取分区信息	*/</span></span><br><span class="line">    ret = ioctl(fd, BLKREPORTZONE, hdr);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*	如果没有报告任何分区，结束	*/</span></span><br><span class="line">    <span class="keyword">if</span> (!hdr-&gt;nr_zones) &#123;</span><br><span class="line">        <span class="comment">/* Done */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got %u zone descriptors\n&quot;</span>, hdr-&gt;nr_zones);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The next report must start after the last zone reported */</span></span><br><span class="line">    <span class="comment">/*	更新 start_sector 以便下一次报告从上一次报告的最后一个分区之后的扇区开始	*/</span></span><br><span class="line">    start_sector = hdr-&gt;zones[hdr-&gt;nr_zones - <span class="number">1</span>].start +</span><br><span class="line">               hdr-&gt;zones[hdr-&gt;nr_zones - <span class="number">1</span>].len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>zone</code>描述符的数量存储在结构体<code>blk_zone_report</code>中的<code>nr_zones</code>并返回。 </p>
<p>在5.9内核中，定义有所不同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * enum blk_zone_report_flags - Feature flags of reported zone descriptors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_REP_CAPACITY: Zone descriptor has capacity field.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">blk_zone_report_flags</span> &#123;</span></span><br><span class="line">	BLK_ZONE_REP_CAPACITY	= (<span class="number">1</span> &lt;&lt; <span class="number">0</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct blk_zone_report - BLKREPORTZONE ioctl request/reply</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @sector: starting sector of report</span></span><br><span class="line"><span class="comment"> * @nr_zones: IN maximum / OUT actual</span></span><br><span class="line"><span class="comment"> * @flags: one or more flags as defined by enum blk_zone_report_flags.</span></span><br><span class="line"><span class="comment"> * @zones: Space to hold @nr_zones @zones entries on reply.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The array of at most @nr_zones must follow this structure in memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_zone_report</span> &#123;</span></span><br><span class="line">    __u64       sector;</span><br><span class="line">    __u32       nr_zones;</span><br><span class="line">    __u32       flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_zone</span> <span class="title">zones</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>flags</code>：包含一个或者多个<code>blk_zone_report_flags</code>的枚举类，枚举量为<code>BLK_ZONE_REP_CAPACITY</code>，</p>
<p>如果该值为1，则<code>zone</code>描述符结构<code>blk_zone</code>体会设置<code>capacity</code>域可用。否则忽略该成员。</p>
<p>下面的代码实例展示应用程序如何通过<code>autotool</code>构建环境中检查特定头文件和结构体成员的存在：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># less configure.ac</span><br><span class="line">...</span><br><span class="line">AC_CHECK_HEADER(linux/blkzoned.h, [],</span><br><span class="line">                [AC_MSG_ERROR([Couldn&#x27;t find linux/blkzoned.h. Kernel too old ?])],</span><br><span class="line">                [[#include &lt;linux/blkzoned.h&gt;]])</span><br><span class="line"></span><br><span class="line">AC_CHECK_MEMBER([struct blk_zone.capacity],</span><br><span class="line">                [AC_DEFINE(HAVE_BLK_ZONE_REP_V2, [1], [report zones includes zone capacity])],</span><br><span class="line">                [], [[#include &lt;linux/blkzoned.h&gt;]])</span><br></pre></td></tr></table></figure>

<p>在一些较新的Linux内核版本中，特别是从5.9版本开始，增加了对分区容量信息的支持。这意味着内核可以提供每个分区的容量信息。对于这些内核，宏<code>HAVE_BLK_ZONE_REP_V2</code>被定义，它的应用如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Handle kernel zone capacity support</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HAVE_BLK_ZONE_REP_V2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLK_ZONE_REP_CAPACITY   (1 &lt;&lt; 0)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_zone_v2</span> &#123;</span></span><br><span class="line">        __u64   start;          <span class="comment">/* Zone start sector */</span></span><br><span class="line">        __u64   len;            <span class="comment">/* Zone length in number of sectors */</span></span><br><span class="line">        __u64   wp;             <span class="comment">/* Zone write pointer position */</span></span><br><span class="line">        __u8    type;           <span class="comment">/* Zone type */</span></span><br><span class="line">        __u8    cond;           <span class="comment">/* Zone condition */</span></span><br><span class="line">        __u8    non_seq;        <span class="comment">/* Non-sequential write resources active */</span></span><br><span class="line">        __u8    reset;          <span class="comment">/* Reset write pointer recommended */</span></span><br><span class="line">        __u8    resv[<span class="number">4</span>];</span><br><span class="line">        __u64   capacity;       <span class="comment">/* Zone capacity in number of sectors */</span></span><br><span class="line">        __u8    reserved[<span class="number">24</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> blk_zone blk_zone_v2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_zone_report_v2</span> &#123;</span></span><br><span class="line">        __u64   sector;</span><br><span class="line">        __u32   nr_zones;</span><br><span class="line">        __u32   flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_zone</span> <span class="title">zones</span>[0];</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> blk_zone_report blk_zone_report_v2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* HAVE_BLK_ZONE_REP_V2 */</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>对于不支持报告分区容量的内核，通过上述代码重新定义<code>blk_zone</code>。</p>
<p>再次以libzbd库的源代码为例，分区报告回复的分区描述符可以按照以下方式处理。我们在上文中提到，结构体<code>struct blk_zone</code>内的成员的长度，都是以<code>512B</code>扇区计数的。而在函数<code>zbd_parse_zone</code>中，我们通过将<code>blk_zone</code>内的成员左移9位（即乘以512）得到对应的字节数量，并存储到对应的<code>struct zbd_zone * zone</code>中。</p>
<p>这是因为，在内核层面，分区的起始位置、长度、容量和写入指针通常以扇区为单位进行存储和报告，而在许多高级应用和系统调用中，使用字节作为更通用和精确的度量单位更为常见。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * zbd_parse_zone - Fill a zone descriptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*	</span></span><br><span class="line"><span class="comment"> 	*	zbd_zone 	用于存储解析后的分区信息</span></span><br><span class="line"><span class="comment"> 	*	blk_zone	指向原始从内核获取的分区信息</span></span><br><span class="line"><span class="comment"> 	*	blk_zone_report 指向分区报告的结构体指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">zbd_parse_zone</span><span class="params">(<span class="keyword">struct</span> zbd_zone *zone, <span class="keyword">struct</span> blk_zone *blkz,</span></span><br><span class="line"><span class="params">                                  <span class="keyword">struct</span> blk_zone_report *rep)</span></span><br><span class="line">&#123;</span><br><span class="line">				<span class="comment">/*	将分区的起始扇区转换为字节单位存储在 zbd_zone	中	*/</span></span><br><span class="line">        zone-&gt;start = blkz-&gt;start &lt;&lt; SECTOR_SHIFT;</span><br><span class="line">        <span class="comment">/*	将分区的长度(以扇区为单位)转换为以字节为单位	SECTOR_SHIFT = 9，扇区大小为512B	*/</span></span><br><span class="line">        zone-&gt;len = blkz-&gt;len &lt;&lt; SECTOR_SHIFT;</span><br><span class="line">        <span class="comment">/*	判断capacity	*/</span></span><br><span class="line">        <span class="keyword">if</span> (rep-&gt;flags &amp; BLK_ZONE_REP_CAPACITY)</span><br><span class="line">                zone-&gt;capacity = blkz-&gt;capacity &lt;&lt; SECTOR_SHIFT;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                zone-&gt;capacity = zone-&gt;len;</span><br><span class="line">        </span><br><span class="line">        zone-&gt;wp = blkz-&gt;wp &lt;&lt; SECTOR_SHIFT;</span><br><span class="line"></span><br><span class="line">        zone-&gt;type = blkz-&gt;type;</span><br><span class="line">        zone-&gt;cond = blkz-&gt;cond;</span><br><span class="line">        zone-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (blkz-&gt;reset)</span><br><span class="line">                zone-&gt;flags |= ZBD_ZONE_RWP_RECOMMENDED;</span><br><span class="line">        <span class="keyword">if</span> (blkz-&gt;non_seq)</span><br><span class="line">                zone-&gt;flags |= ZBD_ZONE_NON_SEQ_RESOURCES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命令行工具blkzone，作为util-linux项目的一部分，使用BLKREPORTZONE命令来实现其报告功能。其代码类似于上述方法进行了修改，以确保无论使用的是哪个版本的内核，都能正确编译和执行。</p>
<h3 id="Resetting-a-Zone-Write-Pointer"><a href="#Resetting-a-Zone-Write-Pointer" class="headerlink" title="Resetting a Zone Write Pointer"></a>Resetting a Zone Write Pointer</h3><p>一个或多个连续写区域的写指针可以通过命令<code>BLKRESETZONE</code>重置，在重置一个写指针的时候，区域的状态同样会被更改为<code>BLK_ZONE_COND_EMPTY</code>。</p>
<p>当多个区域需要被重置时，使用结构体<code>blk_zone_range</code>追踪这些区域，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct blk_zone_range - BLKRESETZONE/BLKOPENZONE/</span></span><br><span class="line"><span class="comment"> *                         BLKCLOSEZONE/BLKFINISHZONE ioctl</span></span><br><span class="line"><span class="comment"> *                         requests</span></span><br><span class="line"><span class="comment"> * @sector: Starting sector of the first zone to operate on.</span></span><br><span class="line"><span class="comment"> * @nr_sectors: Total number of sectors of all zones to operate on.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_zone_range</span> &#123;</span></span><br><span class="line">	__u64		sector;</span><br><span class="line">	__u64		nr_sectors;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同样，该结构体也可以在，打开区域<code>BLKOPENZONE</code>，关闭区域<code>BLKCLOSEZONE</code>，完成区域<code>BLKFINISHZONE</code> <code>ioctl</code>中使用。</p>
<p>下面是一个简单的例子，该例子重置一个区域起始在274726912位置，该区域大小为256MiB(524288 sectors of 512B)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/blkzoned.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_zone_range</span> <span class="title">zrange</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">zrange.sector = <span class="number">274726912</span>;</span><br><span class="line">zrange.nr_sectors = <span class="number">524288</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*	调用BLKRESETZONE	*/</span></span><br><span class="line">ret = ioctl(fd, BLKRESETZONE, &amp;zrange);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>其中，<code>fd</code>为设备描述符，必须保证该设备是打开的。</p>
<p>命令行工具blkzone使用BLKRESETZONE命令来实现其重置功能。</p>
<h3 id="Opening-Closing-and-Finishing-Zones"><a href="#Opening-Closing-and-Finishing-Zones" class="headerlink" title="Opening. Closing and Finishing Zones"></a>Opening. Closing and Finishing Zones</h3><ul>
<li><code>BLKOPENZONE</code>命令的参数和<code>BLKRESETZONE</code>的命令一样。</li>
<li><code>BLKCLOSEZONE</code>命令关闭一个区域；<code>BLKFINISHZONE</code>会结束一个区域，这意味着将该区域的状态设置为满<code>BLK_ZONE_COND_FULL</code>。以上两个命令均需要指向<code>blk_zone_range</code>的指针，用来表明操作的区域范围。</li>
</ul>
<h3 id="Zone-Size-and-Number-of-Zones"><a href="#Zone-Size-and-Number-of-Zones" class="headerlink" title="Zone Size and Number of Zones"></a>Zone Size and Number of Zones</h3><ul>
<li><code>BLKGETZONESZ</code>：获取分区设备的分区大小<code>zoned device&#39;s zone size</code>。</li>
<li><code>BLKGETNRZONES</code>：获取设备的总分区数。</li>
</ul>
<p>以上两个命令均接受一个指向32位无符号整型的指针， 并返回对应的数量。下面给出例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/blkzoned.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> nr_zones, zone_size;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = ioctl(fd, ,BLKGETZONESZ, &amp;zone_size);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">ret = ioctl(fd, ,BLKGETNRZONES, &amp;nr_zones);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Device has %u zones of %u 512-Bytes sectors\n&quot;</span>,</span><br><span class="line">       nr_zones, zone_size);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们发现，在调用<code>BLKGETNRZONES</code>等函数时，需要通过<code>ioctl</code>。</p>
<p><code>BLKGETNRZONES</code>命令特别适用于分配足够大的分区描述符数组，以便对设备上所有分区进行分区报告</p>
<h1 id="Write-Ordering-Control-1"><a href="#Write-Ordering-Control-1" class="headerlink" title="Write Ordering Control"></a>Write Ordering Control</h1><p>以前，Linux内核块<code>I/O</code>堆栈<code>Linux kernel block I/O stack</code>（例如，块层和<code>SCSI</code>层），并不会保证块<code>I/O</code>请求的执行顺序。不能保证块<code>I/O</code>请求的执行顺序的原因是因为块I&#x2F;O请求内核中执行的异步性质和设备请求队列需要细粒度锁模型的必要性。（当多个上下文同时向块设备发出I&#x2F;O请求时，最大限度地减少锁定竞争开销）。</p>
<p>这种设计直接导致的结果是，<code>well-behaving ZBD-compliant application</code>在沿着<code>LBA</code>顺序进行的写命令无法保证齐顺序性。</p>
<p>为了解决这个问题，内核<code>ZBD</code>支持添加区域写锁<code>zone write locking</code>以保证写请求在每一个区域中的执行顺序。</p>
<h2 id="Zone-Write-Locking"><a href="#Zone-Write-Locking" class="headerlink" title="Zone Write Locking"></a>Zone Write Locking</h2><p>区域写入锁<code>Zone write locking</code>实现了对于每个区域的写锁定，以顺序执行每一个对相同区域的写请求。此功能不保证写入命令始终在区域写入指针的位置发出：这是写<code>I/O</code>发出者的责任。区域写入锁定只保证应用程序，文件系统，设备映射器目标发出的写命令的顺序将被块<code>I/O</code>堆栈所遵守。因此，优秀的区域块设备用户将避免为对齐的写入命令失败。</p>
<p>区域写入锁定不会影响读命令。因为读命令不是顺序的。</p>
<h2 id="Initial-Implementation"><a href="#Initial-Implementation" class="headerlink" title="Initial Implementation"></a>Initial Implementation</h2><p>区域写锁定的第一次实现在内核版本为4.10的<code>SCSI</code>硬盘驱动上（在块层之下），对块<code>I/O</code>调度器已传递给设备调度队列的请求进行操作。</p>
<p>这种早期实现依赖于SCSI层可能会延迟向设备发出任何请求的事实。</p>
<p>通过维护每个区域一个位的位图，SCSI磁盘驱动程序每当看到写入命令时都会将区域标记为锁定。此算法在此更详细地介绍：</p>
<ol>
<li>如果下一个派遣给设备的命令不是写命令，则该命令会被直接派遣。</li>
<li>如果下一个派遣给设备的命令是写命令，则写命令的目标区域的区域写入锁定位<code>zone write lock bit</code>会被检查。<ol>
<li>如果写命令的目标区域未被写锁定（即<code>zone write lock bit is not set</code>），则锁定区域并将写命令发送给设备。写锁定操作和命令发送操作都是在设备请求队列旋转锁下原子执行的。</li>
<li>如果区域已被锁定（即<code>zone write lock bit is set</code>），则<code>SCSI</code>磁盘驱动会延迟发送该命令直到区域写入锁被释放。</li>
<li>当写命令完成时，区域写入锁被释放，调度过程会恢复。意味着如果派遣队列中的头命令（第一个命令）如果指向同一个区域（上述区域写入锁定被释放的区域），该命令会被发出。</li>
</ol>
</li>
</ol>
<p>尽管这种实现为遗留的单对列块<code>I/O</code>路径提供了写顺序的保障，并且不依赖于任何特定的HBA，它仍有一些缺点。</p>
<blockquote>
<p>“HBA” 指的是 “Host Bus Adapter”。HBA 是一种硬件设备，通常以插卡的形式存在，用于连接计算机主机（如服务器或工作站）与外部存储设备，比如硬盘阵列、磁带库或SAN（存储区域网络）设备。HBA 卡负责处理输入&#x2F;输出 (I&#x2F;O) 请求和数据传输，从而将主机与存储设备之间的通信和数据交换工作负载从 CPU 上卸载出来。</p>
<p>在许多高性能计算和数据密集型环境中，HBA 卡是至关重要的组件，因为它们可以提高数据传输速率，减少主机 CPU 的负担，并提高整体系统的 I&#x2F;O 性能。在上下文中提到的“write-ordering guarantees for the legacy single-queue block I&#x2F;O path”与 HBA 的独立性表明，该实现不依赖于特定的 HBA 硬件，从而具有更广泛的兼容性。</p>
</blockquote>
<ul>
<li><p>潜在的性能退化：任何写入任何区域的命令都会导致命令调度处理停止。这阻止了所有其他命令被发送，包括读取命令。这可能会限制在高队列深度操作设备时可以通过设备级命令重新排序获得的性能优势。极端情况是应用程序向具有异步I&#x2F;O系统调用的区域发出写流（例如io_submit()）。在这种情况下，顺序写入命令将在设备调度队列中按顺序排队，导致驱动器在一次一个写入命令的队列深度运行。</p>
</li>
<li><p>不支持块多队列<code>I/O</code>路径：不像遗留的单对列块<code>I/O</code>接口，多队列块<code>I/O</code>的实现并不过多的依赖于设备队列自旋锁来处理磁盘用户（应用程序或者内核组件）发出的多队列块<code>I/O</code>请求。这导致在请求传递到设备调度队列之前发生潜在的块I&#x2F;O请求重新排序，并且区域写入锁定无效。</p>
<blockquote>
<ol>
<li><strong>I&#x2F;O 请求重排序</strong>：由于不是所有的 I&#x2F;O 请求都通过单一的、受自旋锁保护的队列来处理，因此不同队列中的请求可能会出现重排序现象。这意味着即使应用程序或内核组件按照特定的顺序发出 I&#x2F;O 请求，这些请求到达设备调度队列时的顺序可能已经改变。</li>
<li><strong>区域写锁定的无效性</strong>：在支持区域块设备（ZBD）的环境中，维持写操作的顺序是非常重要的，特别是对于顺序写入区域。由于多队列实现可能导致 I&#x2F;O 请求的重排序，区域写锁定机制（旨在保证写操作顺序）可能无法有效地工作。在多队列环境中，即使应用程序尝试按照正确的顺序发出写命令，由于请求在到达设备之前可能被重排序，因此无法保证这些写操作遵循 ZBD 的顺序写入约束。</li>
</ol>
</blockquote>
</li>
</ul>
<p>这些限制导致使用块层I&#x2F;O调度器在I&#x2F;O堆栈中更高级别开发区域写入锁定的新实现。</p>
<h2 id="Improved-Implementation-Block-I-x2F-O-Scheduler"><a href="#Improved-Implementation-Block-I-x2F-O-Scheduler" class="headerlink" title="Improved Implementation: Block I&#x2F;O Scheduler"></a>Improved Implementation: Block I&#x2F;O Scheduler</h2><p>于是我们将区域写入锁定的实现移动到<code>I/O</code>堆栈的更高层级，块多队列（以及 SCSI 多队列）基础设施也得到了支持。这一改进在内核版本 4.16 中被添加，同时移除了 SCSI 层的区域写锁定实现。</p>
<p>这一新的区域写入锁定的实现依赖于块层的<code>deadline</code>和<code>mq-deadline</code> <code>I/O</code>调度器，并解决了之前的实现的缺点。</p>
<p>这种新的算法细节如下：</p>
<ol>
<li>如果调度器正在处理读命令：<ul>
<li>读取命令列表中排队的第一个命令允许继续并提交给设备调度队列。</li>
<li>如果没有可用的读命令，则激活写命令。</li>
<li>如果读命令的处理时间达到限制，切换处理写命令，以避免写命令饥饿。</li>
<li>如果读命令可用，则继续步骤1</li>
</ul>
</li>
<li>在处理写命令时，按从LBA有序列表头部的命令或到达时间有序列表中的第一个命令开始扫描调度器中排队的写命令列表（当存在饥饿命令的风险时）。<ul>
<li>如果第一个写命令的目标区域没有被写锁定，该区域被锁定，然后把写命令发送到设备中。这两个操作都是在调度器维护的自旋锁下原子执行的。</li>
<li>如果目标区域已被锁定（位设置），则跳过该命令，并在LBA有序的写入命令列表中搜索针对不同区域的第一个写入命令。如果找到这样的命令，则再次执行步骤2。</li>
<li>如果所有排队的写入命令都针对锁定区域，则调度器操作模式（批处理模式）将切换到<em>读取</em>并调用步骤1。</li>
</ul>
</li>
<li>当写命令完成后，命令目标区域的区域写锁将被释放，调度程序将被激活。根据当前的批处理模式，在第1或2步恢复操作。</li>
</ol>
<p>从这个算法中，很明显，该设备现在可以在更高的队列深度下操作，只有顺序写入目标同一区域才会受到限制。所有读取命令都可以继续，并编写针对不同区域不会相互影响的命令。</p>
<blockquote>
<p>该实现并不保障所有的命令都是有序的。它只保障对于同一区域的写命令是顺序执行的。调度器可能会更改针对不同区域的写入命令的调度顺序。对于任何单个顺序区域，在任何时候，总是最多执行一个写入命令。当有读取访问和同时写入多个区域时，可以在高队列深度进行整体磁盘操作。</p>
</blockquote>
<h2 id="Block-I-x2F-O-Scheduler-Configuration"><a href="#Block-I-x2F-O-Scheduler-Configuration" class="headerlink" title="Block I&#x2F;O Scheduler Configuration"></a>Block I&#x2F;O Scheduler Configuration</h2><h3 id="null-blk-Logical-Device"><a href="#null-blk-Logical-Device" class="headerlink" title="null_blk Logical Device"></a><code>null_blk</code> Logical Device</h3><p><code>CONFIG_BLK_DEV_ZONED</code>配置选项会自动支持使用<code>null_blk</code>设备驱动程序的区域块设备仿真。</p>
<h3 id="ZBC-and-ZAC-Hard-Disks-Support"><a href="#ZBC-and-ZAC-Hard-Disks-Support" class="headerlink" title="ZBC and ZAC Hard-Disks Support"></a>ZBC and ZAC Hard-Disks Support</h3><p>使用CONFIG_BLK_DEV_ZONED配置选项自动启用对ZBC和ZAC SMR磁盘的SCSI子系统支持。</p>
<h3 id="NVMe-Zoned-Namespace-Solid-State-Disks-Support"><a href="#NVMe-Zoned-Namespace-Solid-State-Disks-Support" class="headerlink" title="NVMe Zoned Namespace Solid State Disks Support"></a>NVMe Zoned Namespace Solid State Disks Support</h3><p>NVM Express分区命名空间命令集依赖于CONFIG_BLK_DEV_ZONED和CONFIG_NVME_CORE。如果启用这两个配置选项，它会自动构建。</p>
<p>此驱动程序要求设备支持Zone Append命令才能成功绑定到分区命名空间。它不支持区域游览。有关这些功能的更多详细信息，请参阅Zoned Namespace（ZNS）SSD。</p>
<h2 id="Device-Mapper-1"><a href="#Device-Mapper-1" class="headerlink" title="Device Mapper"></a>Device Mapper</h2><p>当<code>CONFIG_BLK_DEV_ZONED </code>选项被设置，设备映射器子系统也会自动的启用。这支持dm线性和dmflakey目标。请注意，必须启用dm分区的设备映射器目标才能使用。</p>
<p>通过从菜单设备驱动程序中选择CONFIG_DM_ZONED选项来启用dm分区目标–&gt;多个设备驱动程序支持（RAID和LVM）–&gt;设备映射器支持–&gt;驱动器管理的分区块设备目标支持。</p>
<h2 id="File-Systems-1"><a href="#File-Systems-1" class="headerlink" title="File Systems"></a>File Systems</h2><h3 id="f2fs"><a href="#f2fs" class="headerlink" title="f2fs"></a>f2fs</h3><p>使用CONFIG_BLK_DEV_ZONED配置选项自动启用对f2fs文件系统中分区块设备的支持。</p>
<h3 id="zonefs-1"><a href="#zonefs-1" class="headerlink" title="zonefs"></a>zonefs</h3><p>通过从菜单文件系统-&gt;zonefs文件系统支持中选择CONFIG_ZONEFS_FS选项来启用zonefs文件系统的编译。仅当CONFIG_BLK_DEV_ZONED选项设置为启用分区块设备支持时，此选项才可用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/10/kernelInside/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/10/kernelInside/" class="post-title-link" itemprop="url">kernelInside</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-10 18:35:09" itemprop="dateCreated datePublished" datetime="2023-11-10T18:35:09+08:00">2023-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-15 20:34:32" itemprop="dateModified" datetime="2023-11-15T20:34:32+08:00">2023-11-15</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>35k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>32 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Kernel-Inside"><a href="#Kernel-Inside" class="headerlink" title="Kernel Inside!"></a>Kernel Inside!</h1><p>说是要做<code>zns ssd</code>存储开发，但是好像离不开<code>linux</code>内核，既然如此，那就开始<del>愉快的</del>Linux内核之旅吧！</p>
<p>用到的参考资料包括（其实就是kernel inside 的学习笔记）：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://0xax.gitbooks.io/linux-insides/content/">Kernel Inside</a> </li>
<li>深入理解Linux内核</li>
</ul>
<h1 id="Booting"><a href="#Booting" class="headerlink" title="Booting"></a>Booting</h1><p>启动！</p>
<h1 id="Kernel-booting-process-Part-1"><a href="#Kernel-booting-process-Part-1" class="headerlink" title="Kernel booting process. Part 1."></a>Kernel booting process. Part 1.</h1><h2 id="From-the-boot-loader-to-the-kernel"><a href="#From-the-boot-loader-to-the-kernel" class="headerlink" title="From the boot loader to the kernel"></a>From the boot loader to the kernel</h2><h3 id="The-Magical-Power-Button-What-happens-next"><a href="#The-Magical-Power-Button-What-happens-next" class="headerlink" title="The Magical Power Button, What happens next?"></a>The Magical Power Button, What happens next?</h3><p>​	当按下开机键后，计算机首先会唤醒<code>cpu</code>，<code>80386</code>及之后的<code>cpu</code>会在其寄存器中定义如下数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP						0xfff0</span><br><span class="line">CS selector		0xf000</span><br><span class="line">CS base				0xffff0000</span><br></pre></td></tr></table></figure>

<p>​	处理器会在实模式<code>(real mode)</code>下运行</p>
<blockquote>
<ul>
<li><code>real mode</code>：所有的<code>x86</code>机器支持实模式，<code>8086</code>处理器的总线地址有20位，能处理<code>0 - 0xfffff</code>地址空间，但是该处理器的寄存器只有<code>16 bit</code>，只能处理<code>0-0xffff</code>位。</li>
<li><code>Memory segmentation</code>：使得所有地址空间都可以被访问，内存被分为小的，固定的<code>65536 bytes (64KB) segments</code>。但由于我们无法通过<code>16-bit</code>寻址<code>64KB</code>地址，下面会给出一个解决方法。</li>
<li><code>IP</code>： instruction pointer</li>
<li><code>CS selector</code>：Code Segment Selector</li>
<li><code>CS Base</code>：Code Segment Base Address</li>
</ul>
</blockquote>
<p>因此，一个<code>address</code>包括：<code>a segment selector</code>，<code>offset</code>；物理地址的计算公式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhysicalAddress = Segment Selector * 16 + Offset</span><br></pre></td></tr></table></figure>

<p>但如果<code>segment selector</code>和<code>offset</code>太大了，就会发生溢出，如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hex((0xffff &lt;&lt; 4) + 0xffff) = 0x10ffef</span><br></pre></td></tr></table></figure>

<p>由于实模式下只有20位地址位，所以<code>0x10ffef</code>会变成<code>0x00ffef</code>，这叫作<code>A20 line disabled</code>。</p>
<p>回到开机后的寄存器值：</p>
<p><code>CS register</code>包含：</p>
<ul>
<li><code>the visible segment selector</code></li>
<li><code>the hidden base address</code></li>
</ul>
<p>结合之前定义的<code>CS</code>基址和<code>IP</code>值，<code>CS:IP</code>是<code>0xf000:0xfff0</code>，经过物理地址公式的计算得到<code>0xfff0</code>.</p>
<p>该物理地址加上基址我们最终得到·存储在 <code>EIP register</code>中的值：<code>0xfffffff0</code>。</p>
<blockquote>
<ul>
<li><code>Extended Instruction Pointer</code>：该寄存器的作用是存储CPU当前正在执行的指令的地址。当CPU执行程序时，EIP寄存器会连续更新，以指向下一条要执行的指令。这对于程序的流程控制至关重要。</li>
</ul>
</blockquote>
<p>得到的值<code>0xfffffff0</code>被叫做复位向量<code>reset vector</code>，该内存地址是CPU在重置后希望找到第一个指令的地方。该内存地址包含一个<code>jump</code>指令，该指令通常指向<code>BIOS(Basic Input/ Output System)</code>入口。看看源代码，我们这里看的是 <a target="_blank" rel="noopener" href="https://www.coreboot.org`src/cpu/x86/16bit/reset16.inc%60%EF%BC%9A">https://www.coreboot.org`src/cpu/x86/16bit/reset16.inc`：</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> .section &quot;.reset&quot;, &quot;ax&quot;, %progbits</span><br><span class="line">    .code16</span><br><span class="line">.globl    _start</span><br><span class="line">_start:</span><br><span class="line">    .byte  0xe9</span><br><span class="line">    .int   _start16bit - ( . + 2 )</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p><code>0xe9</code>是<code>jump</code>指令的<code>opcode</code>，目的地址是<code>_start16bit - ( . + 2 )</code>。</p>
<p>同样，我们能找到之前说的其实地址是如何计算的<code>0xfffffff0 (src/cpu/x86/16bit/reset16.ld):</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    /* Trigger an error if I have an unuseable start address */</span><br><span class="line">    _bogus = ASSERT(_start16bit &gt;= 0xffff0000, &quot;_start16bit too low. Please report.&quot;);</span><br><span class="line">    _ROMTOP = 0xfffffff0;</span><br><span class="line">    . = _ROMTOP;</span><br><span class="line">    .reset . : &#123;</span><br><span class="line">        *(.reset);</span><br><span class="line">        . = 15;</span><br><span class="line">        BYTE(0x00);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<code>BIOS</code>启动，在检查完硬件后，<code>BIOS</code>需要找到一个可启动的设备，启动顺序是设定在<code>BIOS</code>中的，当尝试从硬盘中启动时，<code>BIOS</code>需要找到一个启动扇区<code>boot sector</code>。在硬盘上有一个分区叫作主引导记录<code>Main Boot Record</code>，<code>boot sector</code>在该分区的前<code>446</code>个字节，每个扇区有<code>512 bytes</code>，第一个扇区的最后两个字节为<code>0x55, 0xaa</code>，向<code>BIOS</code>说明该设备是可启动的。</p>
<p>​	下表给出实模式下的内存映射：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0x00000000 - 0x000003FF - Real Mode Interrupt Vector Table</span><br><span class="line">0x00000400 - 0x000004FF - BIOS Data Area</span><br><span class="line">0x00000500 - 0x00007BFF - Unused</span><br><span class="line">0x00007C00 - 0x00007DFF - Our Bootloader</span><br><span class="line">0x00007E00 - 0x0009FFFF - Unused</span><br><span class="line">0x000A0000 - 0x000BFFFF - Video RAM (VRAM) Memory</span><br><span class="line">0x000B0000 - 0x000B7777 - Monochrome Video Memory</span><br><span class="line">0x000B8000 - 0x000BFFFF - Color Video Memory</span><br><span class="line">0x000C0000 - 0x000C7FFF - Video ROM BIOS</span><br><span class="line">0x000C8000 - 0x000EFFFF - BIOS Shadow Area</span><br><span class="line">0x000F0000 - 0x000FFFFF - System BIOS</span><br></pre></td></tr></table></figure>

<p>​	之前我们说<code>CPU</code>尝试执行的第一个指令是存储在地址<code>0xffff fff0</code>中的，这比上表的地址大的多。<code>CPU</code>如何访问改地址？在<a target="_blank" rel="noopener" href="https://www.coreboot.org/Developer_Manual/Memory_map">coreboot</a>文档中给出了答案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xFFFE_0000 - 0xFFFF_FFFF: 128 kilobyte ROM mapped into address space</span><br></pre></td></tr></table></figure>

<p>​	现在我们知道，<code>BIOS</code>程序是存储在<code>ROM</code>中的。</p>
<h3 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h3><blockquote>
<p>​	现在 BIOS 已经选择了一个启动设备，并且将控制权转移给了启动扇区中的代码，在我们的例子中，启动扇区代码是 <a target="_blank" rel="noopener" href="http://git.savannah.gnu.org/gitweb/?p=grub.git;a=blob;f=grub-core/boot/i386/pc/boot.S;hb=HEAD">boot.img</a>。因为这段代码只能占用一个扇区，因此非常简单，只做一些必要的初始化，然后就跳转到 GRUB 2’s core image 去执行。 Core image 的代码请参考 <a target="_blank" rel="noopener" href="http://git.savannah.gnu.org/gitweb/?p=grub.git;a=blob;f=grub-core/boot/i386/pc/diskboot.S;hb=HEAD">diskboot.img</a>，一般来说 core image 在磁盘上存储在启动扇区之后到第一个可用分区之前。core image 的初始化代码会把整个 core image （包括 GRUB 2的内核代码和文件系统驱动） 引导到内存中。 引导完成之后，<a target="_blank" rel="noopener" href="http://git.savannah.gnu.org/gitweb/?p=grub.git;a=blob;f=grub-core/kern/main.c">grub_main</a>将被调用。</p>
<p>​	<code>grub_main</code> 初始化控制台，计算模块基地址，设置 root 设备，读取 grub 配置文件，加载模块。最后，将 GRUB 置于 normal 模式，在这个模式中，<code>grub_normal_execute</code>(from <code>grub-core/normal/main.c</code>) 将被调用以完成最后的准备工作，然后显示一个菜单列出所用可用的操作系统。当某个操作系统被选择之后，<code>grub_menu_execute_entry</code> 开始执行，它将调用 GRUB 的 <code>boot</code> 命令，来引导被选中的操作系统。</p>
<p>​	就像 kernel boot protocol 所描述的，引导程序必须填充 kernel setup header （位于 kernel setup code 偏移 <code>0x01f1</code> 处） 的必要字段。kernel setup header的定义开始于<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S">arch&#x2F;x86&#x2F;boot&#x2F;header.S</a>：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	.globl	hdr</span><br><span class="line">hdr:</span><br><span class="line">setup_sects:	.byte 0			/* Filled in by build.c */</span><br><span class="line">root_flags:	.word ROOT_RDONLY</span><br><span class="line">syssize:	.long 0			/* Filled in by build.c */</span><br><span class="line">ram_size:	.word 0			/* Obsolete */</span><br><span class="line">vid_mode:	.word SVGA_MODE</span><br><span class="line">root_dev:	.word 0			/* Filled in by build.c */</span><br><span class="line">boot_flag:	.word 0xAA55</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>.globl hdr</code>: <code>hdr</code>是一个全局符号，全局符号对程序的所有部分都是可见的，同时它也是一个标签，标记当前位置。</li>
<li>在后续的数据中遵循：<code>varible: .type value</code>，即<code>变量：类型 值</code>的形式。<ul>
<li><code>boot_flag:	.word 0xAA55</code>：<code>0xAA55</code>是可启动标志。</li>
</ul>
</li>
</ul>
</blockquote>
<p>​	我们将在<code>kernel boot protocol</code>中看到，内存在加载内核后是如何映射的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">         | Protected-mode kernel  |</span><br><span class="line">100000   +------------------------+</span><br><span class="line">         | I/O memory hole        |</span><br><span class="line">0A0000   +------------------------+</span><br><span class="line">         | Reserved for BIOS      | Leave as much as possible unused</span><br><span class="line">         ~                        ~</span><br><span class="line">         | Command line           | (Can also be below the X+10000 mark)</span><br><span class="line">X+10000  +------------------------+</span><br><span class="line">         | Stack/heap             | For use by the kernel real-mode code.</span><br><span class="line">X+08000  +------------------------+</span><br><span class="line">         | Kernel setup           | The kernel real-mode code.</span><br><span class="line">         | Kernel boot sector     | The kernel legacy boot sector.</span><br><span class="line">       X +------------------------+</span><br><span class="line">         | Boot loader            | &lt;- Boot sector entry point 0x7C00</span><br><span class="line">001000   +------------------------+</span><br><span class="line">         | Reserved for MBR/BIOS  |</span><br><span class="line">000800   +------------------------+</span><br><span class="line">         | Typically used by MBR  |</span><br><span class="line">000600   +------------------------+</span><br><span class="line">         | BIOS use only          |</span><br><span class="line">000000   +------------------------+</span><br></pre></td></tr></table></figure>

<p>当启动程序把控制权交给内核后，内核将从:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X + sizeof(KernelBootSector) + 1</span><br></pre></td></tr></table></figure>

<p><code>X</code>是内核启动扇区被加载的地址。启动程序现在加载<code>Linux</code>内核到内存中去，填充好头文件，然后跳转到相应的内存地址中去，我们去看内核建立程序。</p>
<h3 id="The-Beginning-of-the-Kernel-Setup-Stage"><a href="#The-Beginning-of-the-Kernel-Setup-Stage" class="headerlink" title="The Beginning of the Kernel Setup Stage"></a>The Beginning of the Kernel Setup Stage</h3><p>​	首先内核需要建立，这包括一些配置，如解压器和一些内存管理相关的东西，仅举几例。完成所有这些事情之后，内核设置部分将解压实际的内核并跳转到它。在代码<code>arch/x86/boot/header.S</code>的 <code>__start</code>标签是<code>setup part</code>。</p>
<pre><code> 为了能够作为`bootloader`来使用，`header.S`在开始处定义了 `MZ`，并且定义了`PE`头文件。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_EFI_STUB</span><br><span class="line">	# &quot;MZ&quot;, MS-DOS header</span><br><span class="line">	.word	MZ_MAGIC</span><br><span class="line">#endif</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">#ifdef CONFIG_EFI_STUB</span><br><span class="line">pe_header:</span><br><span class="line">	.long	PE_MAGIC</span><br></pre></td></tr></table></figure>

<p> 之所以代码需要这样写，这个是因为遵从 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">UEFI</a> 的硬件需要这样的结构才能正常引导操作系统。</p>
<p>除开这些作为<code>bootloader</code>的代码，真正的内核建立从下面开始：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// header.S line 299</span><br><span class="line">_start:</span><br><span class="line">		# Explicitly enter this as bytes, or the assembler</span><br><span class="line">		# tries to generate a 3-byte jump here, which causes</span><br><span class="line">		# everything else to push off to the wrong offset.</span><br><span class="line">		.byte	0xeb		# short (2-byte) jump</span><br><span class="line">		.byte	start_of_setup-1f</span><br></pre></td></tr></table></figure>

<p>bootloader 知道这个开始点，并且直接跳转到该点， 因此， bootloader将不会再从<code>.bstext section</code>开始。因为我们会在<code>arch/x86/boot/setup.ld</code>中看见：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// arch/x86/boot/setup.ld</span><br><span class="line">//</span><br><span class="line">. = 0;                    // current position</span><br><span class="line">.bstext : &#123; *(.bstext) &#125;  // put .bstext section to position 0</span><br><span class="line">.bsdata : &#123; *(.bsdata) &#125;</span><br></pre></td></tr></table></figure>

<p>​	这段代码是一个连接器脚本的一部分，用于指定程序编译后在内存中的布局。</p>
<blockquote>
<ul>
<li>设置当前位置：<code>. = 0;</code>设置连接器的当前位置指针为0。意味着紧接着的定义段将从内存地址0开始放置。</li>
<li>定义了<code>.bstext</code>段：<code>.bstext : &#123; *(.bstext) &#125;</code>，这行代码定义了一个名为 <code>.bstext</code> 的段。<code>&#123; *(.bstext) &#125;</code> 的意思是将所有标记为 <code>.bstext</code> 的部分（即汇编代码中用 <code>.section &quot;.bstext&quot;</code> 定义的部分）集中到这个段里。由于当前位置已经设置为0，所以这个段的内容将被放置在内存的开始位置。</li>
<li>定义了<code>.bsdata</code>段：<code>.bsdata : &#123; *(.bsdata) &#125;</code>：这行代码定义了一个名为 <code>.bsdata</code> 的段，并将所有标记为 <code>.bsdata</code> 的部分集中到这个段里。这允许链接器将这些数据放置在内存中的特定位置。</li>
</ul>
</blockquote>
<p>接着我们来看看内核设置的进入点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	# offset 512, entry point</span><br><span class="line"></span><br><span class="line">	.globl	_start</span><br><span class="line">_start:</span><br><span class="line">		# Explicitly enter this as bytes, or the assembler</span><br><span class="line">		# tries to generate a 3-byte jump here, which causes</span><br><span class="line">		# everything else to push off to the wrong offset.</span><br><span class="line">		.byte	0xeb		# short (2-byte) jump</span><br><span class="line">		.byte	start_of_setup-1f</span><br><span class="line">1:</span><br><span class="line"></span><br><span class="line">	# Part 2 of the header, from the old setup.S</span><br><span class="line"></span><br><span class="line">		.ascii	&quot;HdrS&quot;		# header signature</span><br><span class="line">		.word	0x020f		# header version number (&gt;= 0x0105)</span><br></pre></td></tr></table></figure>

<p>上述代码中， <code>0xeb</code>是<code>jmp</code>指令的<code>opcode</code>，表示将要跳转到<code>start_of_setup - 1f</code>。</p>
<p><code>Nf</code>声明：<code>2f</code>表示<code>local label 2</code>。在上述代码中，<code>1f</code>就是后面的<code>1:</code>，这部分代码包含了剩余的<code>setup header</code>，当<code>setup header</code>结束后，我们会看见<code>.entrytext</code>代码段，在<code>start_of_setup</code>标签处开始。	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># End of setup header #####################################################</span><br><span class="line">	.section &quot;.entrytext&quot;, &quot;ax&quot;</span><br><span class="line">start_of_setup:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这是第一段实际运行的代码。当内核配置<code>kernel setup</code>部分收到来自启动程序<code>bootloader</code>，第一个<code>jump</code>指令跳转到离内核起始点<code>(kernel real mode)``0x200 offset</code>。</p>
<p>终于，代码跳转到了<code>start_of_setup</code>，接着内核会做如下几件事：</p>
<ul>
<li><p>保证所有的段寄存器<code>segment register</code>值是相等的。</p>
</li>
<li><p>如果需要的话，建配置一个正确的栈。</p>
</li>
<li><p>配置bss</p>
<blockquote>
<p>BSS（Block Started by Symbol）是一个用来描述可执行文件或内存中的一部分的术语，它代表了一个程序中未初始化的全局变量和静态变量的集合。在程序的二进制文件中，BSS段通常不占用实际的磁盘空间，因为它只是一系列的零值。然而，在程序加载到内存时，操作系统为BSS段分配内存，并将其全部初始化为零。</p>
<p>BSS段的主要特点和作用包括：</p>
<ol>
<li><strong>未初始化的变量</strong>：BSS段用于存储程序中未显式初始化为特定值的全局变量和静态变量。这些变量在程序启动时默认被初始化为零。</li>
<li><strong>节省空间</strong>：由于BSS段中的数据默认为零，因此在程序的磁盘文件中不需要为它们分配空间。这有助于减少程序的文件大小。</li>
<li><strong>内存中的初始化</strong>：虽然在磁盘上不占用空间，但在程序加载到内存时，操作系统会为BSS段中的变量分配内存，并将它们初始化为零。</li>
<li><strong>与数据段的区别</strong>：BSS段通常与数据段（用于存储已初始化的全局变量和静态变量）相区分。数据段中的变量在程序的二进制文件中会占用相应的存储空间，以保持它们的初始值。</li>
</ol>
</blockquote>
</li>
<li><p>调转到c代码<code>arch/x86/boot/main.c</code></p>
</li>
</ul>
<h3 id="Aligning-the-Segment-Registers"><a href="#Aligning-the-Segment-Registers" class="headerlink" title="Aligning the Segment Registers"></a>Aligning the Segment Registers</h3><p>首先，内核保证，<code>ds</code>和<code>es</code>段寄存器指向同一个地址。接着使用<code>cld</code>指令，清除方向标志<code>direction flag</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Force %es = %ds</span><br><span class="line">	movw	%ds, %ax</span><br><span class="line">	movw	%ax, %es</span><br><span class="line">	cld</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>Direction Flag：在x86架构的CPU中，direction flag是标志寄存器（Flags Register）的一部分，用于控制字符串操作指令（如 <code>movsb</code>, <code>movsw</code>, <code>movsd</code>, <code>stosb</code>, <code>stosw</code>, <code>stosd</code>, <code>lodsb</code>, <code>lodsw</code>, <code>lodsd</code>, <code>scasb</code>, <code>scasw</code>, <code>scasd</code> 等）的处理方向。</p>
<p><code>direction flag = 1</code>时，这些操作指令处理字符串时会从高地址向底地址移动。为0时则相反。</p>
</li>
<li><p><code>cld</code>指令：<code>clear Direction Flag</code>，会将<code>Direction Flag</code>置为0。</p>
</li>
<li><p><code>es</code>：附加段寄存器</p>
</li>
<li><p><code>ds</code>：数据段寄存器</p>
</li>
<li><p><code>cs</code>：代码段寄存器</p>
</li>
<li><p><code>ss</code>：段寄存器</p>
</li>
<li><p><code>sp</code>：堆栈指针寄存器</p>
</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">segment = grub_linux_real_target &gt;&gt; 4;</span><br><span class="line">state.gs = state.fs = state.es = state.ds = state.ss = segment;</span><br><span class="line">state.cs = segment + 0x20; // cs = 0x1000 + 0x20 = 0x1020</span><br></pre></td></tr></table></figure>

<p><code>grub2</code>默认将<code>kernel setup</code>代码，加载到地址<code>0x10000</code>处，而<code>cs</code>是在<code>0x1020</code>处，这是因为代码的执行不会在文件的起始位置开始，而是跳转到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br><span class="line">    .byte 0xeb</span><br><span class="line">    .byte start_of_setup-1f</span><br></pre></td></tr></table></figure>

<p>这段代码是位于 <code>4d 5a</code>的<code>512 bytes</code>偏移处。之后开始配置栈。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> We will have entered with %cs = %ds+0x20, normalize %cs so</span><br><span class="line"># it is on par with the other segments.</span><br><span class="line">	pushw	%ds</span><br><span class="line">	pushw	$6f</span><br><span class="line">	lretw</span><br></pre></td></tr></table></figure>

<p>这段代码将 <code>ds</code>的值推入栈，紧跟着的是标签<code>6</code>的地址也推入栈，然后执行<code>lretw</code>。当执行<code>lretw</code>时，它将标签<code>6</code>的地址加载到<code>instruction pointer register</code>中，将<code>ds</code>的值加载到<code>cs</code>中。最终，<code>cs</code>和<code>ds</code>的值会保持一致。</p>
<blockquote>
<p><code>lretw</code>：这是一个远返回指令，用于从子程序返回。<code>lretw</code> 会从堆栈中弹出返回地址，并将其加载到指令指针寄存器（%ip）中。同时，它还会从堆栈中弹出一个值加载到代码段寄存器（%cs）中，这是远调用和远返回的特性。</p>
</blockquote>
<h3 id="Stack-Setup"><a href="#Stack-Setup" class="headerlink" title="Stack Setup"></a>Stack Setup</h3><p>​	几乎所有的配置代码是为了准备实模式下的<code>c</code>语言环境。下一个步骤是判断并纠正<code>ss</code>寄存器的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Force %es = %ds</span><br><span class="line">	movw	%ds, %ax</span><br><span class="line">	movw	%ax, %es</span><br><span class="line">	cld</span><br><span class="line"></span><br><span class="line"># Apparently some ancient versions of LILO invoked the kernel with %ss != %ds,</span><br><span class="line"># which happened to work by accident for the old code.  Recalculate the stack</span><br><span class="line"># pointer if %ss is invalid.  Otherwise leave it alone, LOADLIN sets up the</span><br><span class="line"># stack behind its own code, so we can&#x27;t blindly put it directly past the heap.</span><br><span class="line"></span><br><span class="line">	movw	%ss, %dx</span><br><span class="line">	cmpw	%ax, %dx	# %ds == %ss?</span><br><span class="line">	movw	%sp, %dx 	# move %sp to %dx</span><br></pre></td></tr></table></figure>

<p>我们首先要保证<code>%ss == %ds</code>，会出现三种情况：</p>
<p><code>ss</code>值合法</p>
<p><code>ss</code>值不合法且<code>CAN_USE_HEAP</code>被设置。</p>
<p><code>ss</code>值不合法且<code>CAN_USE_HEAP</code>未被设置。</p>
<ul>
<li>当<code>ss</code>值<code>(0x1000)</code>合法时，程序跳转到标签2：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2:	# Now %dx should point to the end of our stack space</span><br><span class="line">	andw	$~3, %dx	# dword align (might as well...)</span><br><span class="line">	jnz	3f					# jump if not zero</span><br><span class="line">	movw	$0xfffc, %dx	# Make sure we&#x27;re not zero</span><br><span class="line">3:	movw	%ax, %ss</span><br><span class="line">	movzwl	%dx, %esp	# Clear upper half of %esp</span><br><span class="line">	sti			# Now we should have a working stack</span><br></pre></td></tr></table></figure>

<p>​	首先将3取反得到<code>1111 1111 1111 1111 1111 1111 1111 1100</code> 之后和<code>%dx</code>做与运算，这将使 <code>%dx</code>的最后两位为0，以达到<code>dword align</code>双字对齐。即如果一个地址是4的倍数，我们就可以说它是双字对齐的。接着判断<code>andw</code>操作后的结果是否为0。如果为0，我们要将<code>%dx</code>的值设置为<code>0xfffc</code>（这是在 <code>64KB segment</code> 下的最大按四字对齐的地址）以保证<code>%dx</code>不为0。反之直接跳转到标签3。</p>
<p>​	标签3将<code>%ax</code>的值赋值给<code>%ss</code>。得到一个正确的栈：</p>
<p>​	<img src="/../images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-11%2010.58.21.png" alt="截屏2023-11-11 10.58.21"></p>
<ul>
<li>当<code>ss</code>值不合法且<code>CAN_USE_HEAP</code>被设置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Invalid %ss, make up a new stack</span><br><span class="line">	movw	$_end, %dx</span><br><span class="line">	testb	$CAN_USE_HEAP, loadflags</span><br><span class="line">	jz	1f</span><br><span class="line">	movw	heap_end_ptr, %dx</span><br><span class="line">1:	addw	$STACK_SIZE, %dx</span><br><span class="line">jnc	2f</span><br><span class="line">xorw	%dx, %dx	# Prevent wraparound</span><br></pre></td></tr></table></figure>

<p>我们首先将<code>$_end</code>赋值给 <code>%dx</code>，然后检查 <code>loadflag</code>中的 <code> $CAN_USE_HEAP</code>位。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S#L320">loadflags</a> is a bitmask header defined as:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOADED_HIGH     (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUIET_FLAG      (1&lt;&lt;5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEEP_SEGMENTS   (1&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_USE_HEAP    (1&lt;&lt;7)</span></span><br></pre></td></tr></table></figure>

<p>我们在<code>boot protocol</code>中了解到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Field name: loadflags</span><br><span class="line"></span><br><span class="line">  This field is a bitmask.</span><br><span class="line"></span><br><span class="line">  Bit 7 (write): CAN_USE_HEAP</span><br><span class="line">    Set this bit to 1 to indicate that the value entered in the</span><br><span class="line">    heap_end_ptr is valid.  If this field is clear, some setup code</span><br><span class="line">    functionality will be disabled.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>因此，如果<code>CAN_USE_HEAP</code>为1时 ，代表<code>heap_end_ptr</code>是合法的（指向栈底：<code>_end</code>）。然后将<code>%dx</code>加上一个<code>$STACK_SIZE</code>（这可能使得<code>%dx</code>指向栈顶）。如果没有溢出，则跳转到标签2，继续配置一个正确的栈。</p>
<p><img src="/../images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-11%2011.14.17.png" alt="截屏2023-11-11 11.14.17"></p>
<ul>
<li>当<code>ss</code>值不合法且<code>CAN_USE_HEAP</code>未被设置。那就只能用一个最小的栈，大小为from <code>_end</code> to <code>_end + STACK_SIZE</code></li>
</ul>
<p><img src="/../images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-11%2011.16.57.png" alt="截屏2023-11-11 11.16.57"></p>
<h3 id="BSS-Setup"><a href="#BSS-Setup" class="headerlink" title="BSS Setup"></a>BSS Setup</h3><p>在我们能跳向<code>main C code</code>之前，还有两个步骤需要配置，一个是配置<code>BSS</code>，第二个是检查<code>magic</code>签名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Check signature at end of setup</span><br><span class="line">	cmpl	$0x5a5aaa55, setup_sig</span><br><span class="line">	jne	setup_bad</span><br></pre></td></tr></table></figure>

<p>检查签名，如果不对，会报告一个<code>fatal error</code>。</p>
<p>签名匹配后，我们拥有了正确的段寄存器和栈，现在只需要配置正确的<code>BSS</code>段就可以跳转到<code>C</code>代码了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Zero the bss</span><br><span class="line">	movw	$__bss_start, %di</span><br><span class="line">	movw	$_end+3, %cx</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	subw	%di, %cx</span><br><span class="line">	shrw	$2, %cx</span><br><span class="line">	rep; stosl</span><br></pre></td></tr></table></figure>

<p><code>__bss_start</code>的地址赋值给<code>%di</code>，接着<code>__end + 3</code>的结果赋值给<code>%cx</code>。通过异或操作清空<code>%eax</code>的值。计算<code>cx -di</code>得到<code>bss section</code>的大小并存储到<code>cx</code>中。 <code>cx</code>除以4（右移2位）并重复执行<code>stosl</code>，该命令将持续把<code>eax</code>中的值（这里是0）存到<code>di</code>指向的地址中去，并将<code>di</code>的值增加4（这也是为什么<code>cx</code>要除以4的原因）。直到<code>cx</code>的值递减到0。以上的操作将<code>BSS section</code>的所有内存赋值为0：</p>
<p><img src="/../images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-11%2011.32.50.png" alt="截屏2023-11-11 11.32.50"></p>
<h3 id="Jump-to-main"><a href="#Jump-to-main" class="headerlink" title="Jump to main"></a>Jump to main</h3><p>现在我们跳转到主函数，<code>arch/x86/boot/main.c</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Jump to C code (should not return)</span><br><span class="line">	calll	main</span><br></pre></td></tr></table></figure>

<h1 id="Kernel-booting-process-Part-2"><a href="#Kernel-booting-process-Part-2" class="headerlink" title="Kernel booting process. Part 2."></a>Kernel booting process. Part 2.</h1><h2 id="First-steps-in-the-kernel-setup"><a href="#First-steps-in-the-kernel-setup" class="headerlink" title="First steps in the kernel setup"></a>First steps in the kernel setup</h2><p>现在我们将继续阅读<code>arch/x86/boot/main.c</code>，将学习如下内容：</p>
<ul>
<li>保护模式<code>protected mode</code>是什么。</li>
<li>计算机是怎样进入保护模式。</li>
<li>堆<code>heap</code>和控制台<code>console</code>的初始化。</li>
<li>内存检测，CPU确认，键盘初始化。</li>
<li><code>and much much more</code>。</li>
</ul>
<p>So, let‘s go ahead!</p>
<h2 id="Protected-mode"><a href="#Protected-mode" class="headerlink" title="Protected mode"></a>Protected mode</h2><p>在我们在进入<code>intel Long Mode</code>之前，内核需要将<code>CPU</code>转换到保护模式。</p>
<blockquote>
<ul>
<li><p>在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/X86-64">x86-64</a>处理器架构中，当处于<strong>长模式</strong>（Long mode）时，64位应用程序（或者是操作系统）可以使用64位指令和寄存器，而32位程序将以一种兼容子模式运行。<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC86%E6%A8%A1%E5%BC%8F">虚拟86模式</a>在长模式下不可用，也就是说，长模式不兼容16位程序。</p>
</li>
<li><p>不在长模式下运行时，处理器支持<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AE%9E%E6%A8%A1%E5%BC%8F">实模式</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BF%9D%E8%AD%B7%E6%A8%A1%E5%BC%8F">保护模式</a>两个子模式，在这两个模式下的x86-64处理器与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/X86-32">x86-32</a>处理器运行方式完全相同。</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CPUID">CPUID</a>扩展属性域中的一个位可以令运行在实模式或者保护模式的程序得知处理器能否转换到长模式，这使得程序能够检测是否使用了x86-64处理器。这类似于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Intel">Intel</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IA-64">IA-64</a>处理器使用CPUID中的一个属性位来让程序检测自己是否运行在IA-32仿真模式下。</p>
</li>
<li><p>保护模式在1982年第一次加入到<code>x86</code>架构，并在<code>intel 64</code>和长模式出现之前，一直是<code>intel</code>处理器的主模式。</p>
</li>
</ul>
</blockquote>
<p>从实模式<code>Real Mode</code>跳转出来的原因主要是实模式只提供非常有限的<code>RAM</code>访问。在前一章我们提到实模式只支持<code>1MB</code>，有时甚至只支持<code>640KB</code>的<code>RAM</code>。</p>
<p>保护模式带来了很多改变，其中最重要的是内存管理。实模式中20位地址总线被32位地址总线所替代。因此，它允许访问<code>4GB</code>的内存。同样，分页技术在保护模式中也可用。</p>
<p>实模式中的内存管理被分为两个部分：</p>
<ul>
<li>分段<code>Segmentation</code></li>
<li>分页<code>Paging</code></li>
</ul>
<p>在本节先讨论分段<code>segmentation</code>。在下一章我们会讨论分页<code>Paging</code>。</p>
<p>在之前我们介绍了实模式下的地址包含如下两部分：</p>
<ul>
<li>段基址<code>Base address of the segment</code></li>
<li>从段基址的偏移量<code>Offset from the segment base</code></li>
</ul>
<p>我们可以通过上述两部分获得物理地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhysicalAddress = Segment_Base * <span class="number">16</span> + Offset</span><br></pre></td></tr></table></figure>

<p>在保护模式，内存分段的方式则完全不同。不同于实模式下的固定<code>64KB</code>分段，保护模式中的段大小和位置被一个特殊的数据结构<code>Segment Descriptor</code>描述。这些段描述符<code>Segment Descriptor</code>存储在<code>Global Descriptor Table (GDT)</code>中。</p>
<p><code>GDT</code>常驻于内存中，但它在内存中没有固定的位置，因此它的地址存储在一个叫<code>GDTR</code>的寄存器中。</p>
<p>接着，我们介绍<code>GDT</code>是如何被加载到Linux内核代码中的。会有一个将它从内存中加载的操作，就像下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lgdt gdt	#	load global descriptor table 	</span><br></pre></td></tr></table></figure>

<p><code>lgdt</code>命令加载<code>GDT(global descriptor table)</code>的基址和大小加载到<code>GDTR</code>寄存器中，<code>GDTR</code>寄存器占48位：</p>
<ul>
<li><code>16</code>位表示<code>global descriptor table</code>的大小。</li>
<li><code>32</code>位表示<code>global descriptor table</code>的地址。</li>
</ul>
<p>之前提到，<code>GDT</code>包含<code>segment descriptors</code>，这是内存段的描述符。每个描述符占<code>64</code>位。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 63         56         51   48    45           39        32 </span><br><span class="line">------------------------------------------------------------</span><br><span class="line">|             | |B| |A|       | |   | |0|E|W|A|            |</span><br><span class="line">| BASE 31:24  |G|/|L|V| LIMIT |P|DPL|S|  TYPE | BASE 23:16 |</span><br><span class="line">|             | |D| |L| 19:16 | |   | |1|C|R|A|            |</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"> 31                         16 15                         0 </span><br><span class="line">------------------------------------------------------------</span><br><span class="line">|                             |                            |</span><br><span class="line">|        BASE 15:0            |       LIMIT 15:0           |</span><br><span class="line">|                             |                            |</span><br><span class="line">------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>51:48</code>和<code>15:0</code>表示段大小<code>length_of_segment - 1</code>，总共<code>20</code>位，同时段大小还取决于第<code>55</code>位<code>G (Granularity)</code>。</p>
<ul>
<li>当<code>G = 0</code>且<code>(segment) Limit = 0</code>时，段大小为<code>1 B</code>。</li>
<li>当<code>G = 1</code>且<code>(segment) Limit = 1</code>时，段大小为<code>4096 B</code>。</li>
<li>当<code>G = 0</code>且<code>(segment) Limit = 0xfffff</code>时，段大小为<code>1 MB。</code></li>
<li>当<code>G = 1</code>且<code>(segment) Limit = 0xfffff</code>时，段大小为<code>4 GB</code>。</li>
</ul>
<p>从上面的例子可以知道：</p>
<ul>
<li><code>G = 0</code>时，<code>Limit</code>被解释为<code>1 B</code>。</li>
<li><code>G = 1</code>时，<code>Limit</code>被解释为<code>4096 B = 4 KB = 1 页(page)</code>。</li>
</ul>
</li>
<li><p><code>Base</code>是<code>32位</code>，占<code>63:56</code>，<code>39:32</code>和<code>31:16</code>。表示段的起始物理地址。</p>
</li>
<li><p><code>Type/Attribute</code>为<code>5位</code>，占<code>44:40</code>，确定的段的属性。</p>
<ul>
<li><code>44位</code>的<code>S = 0</code>时，表示该段为系统段；<code>S = 1</code>时代表该段为数据段（栈段也属于数据段，且支持读和写）。</li>
<li><code>43位</code>的<code>Ex</code>规定该段是数据段还是代码段，<code>Ex = 0</code>表示数据段，反之为代码段。</li>
</ul>
</li>
</ul>
<p>下面列出所有类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">|           Type Field        | Descriptor Type | Description                        |</span><br><span class="line">|-----------------------------|-----------------|------------------------------------|</span><br><span class="line">| Decimal                     |                 |                                    |</span><br><span class="line">|             0    E    W   A |                 |                                    |</span><br><span class="line">| 0           0    0    0   0 | Data            | Read-Only                          |</span><br><span class="line">| 1           0    0    0   1 | Data            | Read-Only, accessed                |</span><br><span class="line">| 2           0    0    1   0 | Data            | Read/Write                         |</span><br><span class="line">| 3           0    0    1   1 | Data            | Read/Write, accessed               |</span><br><span class="line">| 4           0    1    0   0 | Data            | Read-Only, expand-down             |</span><br><span class="line">| 5           0    1    0   1 | Data            | Read-Only, expand-down, accessed   |</span><br><span class="line">| 6           0    1    1   0 | Data            | Read/Write, expand-down            |</span><br><span class="line">| 7           0    1    1   1 | Data            | Read/Write, expand-down, accessed  |</span><br><span class="line">|                  C    R   A |                 |                                    |</span><br><span class="line">| 8           1    0    0   0 | Code            | Execute-Only                       |</span><br><span class="line">| 9           1    0    0   1 | Code            | Execute-Only, accessed             |</span><br><span class="line">| 10          1    0    1   0 | Code            | Execute/Read                       |</span><br><span class="line">| 11          1    0    1   1 | Code            | Execute/Read, accessed             |</span><br><span class="line">| 12          1    1    0   0 | Code            | Execute-Only, conforming           |</span><br><span class="line">| 14          1    1    0   1 | Code            | Execute-Only, conforming, accessed |</span><br><span class="line">| 13          1    1    1   0 | Code            | Execute/Read, conforming           |</span><br><span class="line">| 15          1    1    1   1 | Code            | Execute/Read, conforming, accessed |</span><br><span class="line">--------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p><code>40, 41, 42</code>位表示<code>EXW</code>：<code>(Expansion, Writable, Accessiable)</code>或<code>CRA</code>：<code>(Conforming Readable Accesible)</code>。</p>
<ul>
<li><p><code>E = 0</code>，表示<code>expand up</code>，反之表示<code>expand down</code></p>
<blockquote>
<ul>
<li><strong>Expand Up</strong> 当一个内存段被定义为 “expand up” 时，这意味着段的大小可以向上扩展，也就是说，段的起始地址保持不变，而它的结束地址可以增大。在段描述符中，如果一个段是 “expand up” 类型的，当执行如堆（heap）内存分配这样的操作时，可以不断地向高地址扩展，增加段的大小。</li>
<li><strong>Expand Down</strong> 相反，”expand down” 段是指其结束地址固定，而起始地址可以减小（即向更低的内存地址扩展）。这通常用于如栈（stack）这样的数据结构，它们在增长时是向低地址扩展的。例如，在x86架构中，栈是向下增长的，这意味着如果栈需要更多空间，它的起始地址会向内存地址更低的方向移动。</li>
<li>在保护模式下的段描述符中，可以通过设置特定的标志位来定义段是 “expand up” 还是 “expand down”。这些标志位告诉处理器段的界限是如何随着数据的增长而变化的。</li>
</ul>
</blockquote>
</li>
<li><p><code>W = 1</code>，表示该段是写允许的；反之，该段为只读。</p>
</li>
<li><p><code>A = 1</code>，表示该段可被处理器访问。</p>
</li>
<li><p><code>C = 1</code>，该位仅在<code>43</code>位为1时有效，表示段代码可以被更低优先级的状态（例如用户态）执行。</p>
</li>
<li><p><code>R = 1</code>，表示可以从该段读取数据。</p>
</li>
</ul>
<ol>
<li><p><code>DPL[2 bits], (Descriptor privilege Level)</code>，占<code>46:45</code>两位。表示段的优先级，其中0为最高优先级。</p>
</li>
<li><p><code>47</code>位的<code>P</code>标志，表示该段是否存在内存中。<code>p = 0</code>表示该段不在内存中，如果处理器尝试访问一个不在内存中的段，会产生一个段不存在的异常。</p>
</li>
<li><p><code>52</code>位的<code>AVL</code>：保留位。</p>
</li>
<li><p><code>53</code>位的<code>L</code>表示该代码段是否包含<code>native 64-bit code</code>，如果包含，该代码段会在<code>64 bit</code>模式下执行。</p>
<blockquote>
<p>“Native 64-bit code”指的是为64位处理器架构专门编写和编译的程序代码。这些代码直接利用64位处理器能提供的特性，如更广泛的寄存器集合、更大的地址空间以及64位数据宽度，从而可以更高效地执行指令和处理数据。</p>
<p>当段描述符中的L标志（位53）被设置时，它表明该代码段包含的是原生的64位代码，且将在64位模式下执行。这与32位代码不同，后者即使在64位处理器上运行，也仅能使用32位架构的特性。</p>
</blockquote>
</li>
<li><p><code>54</code>位的<code>D/B</code>标志<code>(Default/Big flag)</code>表示操作数大小<code>32/16</code>位。</p>
<blockquote>
<p>操作数大小（Operand Size）是指在计算机架构中，CPU执行指令时所能处理的数据的位宽。这涉及到CPU指令能直接操作的数据单元的大小，例如，16位、32位或64位整数。</p>
<p>例如，在x86架构中：</p>
<ul>
<li>如果操作数大小是16位，那么CPU指令将会操作16位的数据单元，即它可以一次性读取、写入或处理16位（2字节）的数据。</li>
<li>如果操作数大小是32位，那么CPU指令将操作32位的数据单元，即它可以一次性读取、写入或处理32位（4字节）的数据。</li>
</ul>
</blockquote>
</li>
</ol>
<p>在实模式<code>real mode</code>下，段寄存器包<code>segment register</code>含了段选择器<code>segment selector</code>。然而在保护模式<code>protected mode</code>下，段选择器有所不同。每个段描述符拥有一个<code>16</code>位的段选择器<code>segment selector</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 15             3 2  1     0</span><br><span class="line">-----------------------------</span><br><span class="line">|      Index     | TI | RPL |</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Index</code>：存储描述符在<code>Gobal Descriptor Table</code>中的索引。</li>
<li><code>TI (Table Indicator)</code>：表示在什么地方寻找描述符。当<code>TI = 0</code>时，在<code>GDT</code>中寻找<code>Descriptor</code>。否则，在<code>Local Descriptor Table (LDT)</code>中寻找。</li>
<li><code>RPL</code>：存储请求者的优先级。</li>
</ul>
<p>每个段寄存器都有可见<code>visible</code>的和不可见<code>hidden</code>的部分：</p>
<ul>
<li><code>Visible</code>：存储段选择器。</li>
<li><code>Hidden</code>：存储段描述符（base, limit, attributes &amp; flags）</li>
</ul>
<p>在保护模式下，获取物理地址的步骤是：</p>
<ol>
<li><p>将段选择器<code>segment selector</code>加载到任意一个段寄存器<code>segment register</code>中。</p>
</li>
<li><p><code>CPU</code>从选择器<code>selector</code>中通过偏移<code>GDT address + Index</code>找到段描述符。然后将描述符加载到寄存器的不可见<code>hidden</code>部分。</p>
</li>
<li><p>如果不允许分页<code>paging disabled</code>，段的物理地址的计算公式如下：<br>$$<br>BaseAddress(found In The Descriptor Obtained In The Previous Step) + Offset<br>$$</p>
</li>
<li></li>
</ol>
<p>如下图所示：</p>
<p><img src="/../images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-13%2011.10.19.png" alt="截屏2023-11-13 11.10.19"></p>
<p>从实模式跳转到保护模式的流程如下：</p>
<ul>
<li>禁止中断</li>
<li>通过<code>lgdt</code>命令描述并加载<code>GDT</code></li>
<li>在<code>CR0 (Control Register 0)</code>中配置<code>PE (Protection Enable)</code></li>
<li>跳转到保护模式的代码</li>
</ul>
<p>在跳转到保护模式前，我们需要做一些准备。</p>
<p>阅读<code>arch/x86/boot/main.c</code>，我们会看见一些实现，键盘初始化，堆初始化等等，的函数。</p>
<p>查看<code>main.c</code>中的<code>main</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* First, copy the boot header into the &quot;zeropage&quot; */</span></span><br><span class="line">	copy_boot_params();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize the early-boot console */</span></span><br><span class="line">	console_init();</span><br><span class="line">	<span class="keyword">if</span> (cmdline_find_option_bool(<span class="string">&quot;debug&quot;</span>))</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;early console in setup code\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* End of heap check */</span></span><br><span class="line">	init_heap();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure we have all the proper CPU support */</span></span><br><span class="line">	<span class="keyword">if</span> (validate_cpu()) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Unable to boot - please use a kernel appropriate &quot;</span></span><br><span class="line">		     <span class="string">&quot;for your CPU.\n&quot;</span>);</span><br><span class="line">		die();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Tell the BIOS what CPU mode we intend to run in. */</span></span><br><span class="line">	set_bios_mode();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Detect memory layout */</span></span><br><span class="line">	detect_memory();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set keyboard repeat rate (why?) and query the lock flags */</span></span><br><span class="line">	keyboard_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Query Intel SpeedStep (IST) information */</span></span><br><span class="line">	query_ist();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Query APM information */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_APM) || defined(CONFIG_APM_MODULE)</span></span><br><span class="line">	query_apm_bios();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Query EDD information */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_EDD) || defined(CONFIG_EDD_MODULE)</span></span><br><span class="line">	query_edd();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set the video mode */</span></span><br><span class="line">	set_video();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Do the last things and invoke protected mode */</span></span><br><span class="line">	go_to_protected_mode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Copyinh-boot-parameters-into-the-“zeropage”"><a href="#Copyinh-boot-parameters-into-the-“zeropage”" class="headerlink" title="Copyinh boot parameters into the “zeropage”"></a>Copyinh boot parameters into the “zeropage”</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* First, copy the boot header into the &quot;zeropage&quot; */</span></span><br><span class="line">	copy_boot_params();</span><br></pre></td></tr></table></figure>

<p>该函数将内核配置头拷贝到对应的结构体<code>boot_params</code>（也叫<code>zeropage</code>，定义在<code>arch/x86/include/uapi/asm/bootparam.h</code>）对应的成员<code>setup_header</code>中。</p>
<blockquote>
<p>在Linux内核启动过程中，“kernel setup header”通常指的是一个特定的数据结构，它包含了启动时内核所需的各种参数和信息。这个数据结构在启动早期由引导程序填充，然后由启动加载器（比如GRUB）传递给内核。</p>
<p>“kernel setup header”结构定义了内核如何被加载，包含了以下信息：</p>
<ul>
<li>内核的加载模式（实模式或保护模式）</li>
<li>启动设备</li>
<li>内存布局信息</li>
<li>初始化RAM盘的位置和大小</li>
<li>视频模式选择</li>
<li>其他硬件参数</li>
</ul>
<p>这个头部信息是由启动代码中的一部分，比如Linux的bootsect.S（启动扇区）和setup.S（设置代码）所使用。这些信息对于内核来说非常关键，因为它们告诉内核它被加载到内存中的哪个位置，以及硬件的配置如何。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">struct setup_header &#123;</span><br><span class="line">	__u8	setup_sects;	// 	引导扇区的大小。</span><br><span class="line">	__u16	root_flags;		// 	根文件系统的挂载标志。</span><br><span class="line">	__u32	syssize;			// 	内核映像的大小（单位为16字节段）。</span><br><span class="line">	__u16	ram_size;			//	旧式的RAM大小指示，现在不常用。</span><br><span class="line">	__u16	vid_mode;			//	视频模式标识。</span><br><span class="line">	__u16	root_dev;			//	根设备的编号。</span><br><span class="line">	__u16	boot_flag;		//	引导标志，用来指示有效的引导扇区。</span><br><span class="line">	__u16	jump;					//	引导代码中跳转指令的起始位置。</span><br><span class="line">	__u32	header;				//	Magic Number，用来识别这个结构体。</span><br><span class="line">	__u16	version;			//	结构体的版本号。</span><br><span class="line">	__u32	realmode_swtch;		</span><br><span class="line">	__u16	start_sys_seg;</span><br><span class="line">	__u16	kernel_version;</span><br><span class="line">	__u8	type_of_loader;</span><br><span class="line">	__u8	loadflags;</span><br><span class="line">	__u16	setup_move_size;</span><br><span class="line">	__u32	code32_start;</span><br><span class="line">	__u32	ramdisk_image;</span><br><span class="line">	__u32	ramdisk_size;</span><br><span class="line">	__u32	bootsect_kludge;</span><br><span class="line">	__u16	heap_end_ptr;</span><br><span class="line">	__u8	ext_loader_ver;</span><br><span class="line">	__u8	ext_loader_type;</span><br><span class="line">	__u32	cmd_line_ptr;</span><br><span class="line">	__u32	initrd_addr_max;</span><br><span class="line">	__u32	kernel_alignment;</span><br><span class="line">	__u8	relocatable_kernel;</span><br><span class="line">	__u8	min_alignment;</span><br><span class="line">	__u16	xloadflags;</span><br><span class="line">	__u32	cmdline_size;</span><br><span class="line">	__u32	hardware_subarch;</span><br><span class="line">	__u64	hardware_subarch_data;</span><br><span class="line">	__u32	payload_offset;</span><br><span class="line">	__u32	payload_length;</span><br><span class="line">	__u64	setup_data;</span><br><span class="line">	__u64	pref_address;</span><br><span class="line">	__u32	init_size;</span><br><span class="line">	__u32	handover_offset;</span><br><span class="line">	__u32	kernel_info_offset;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>boot_params</code>结构体包含 <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/x86/boot.txt">linux boot protocol</a>定义的域，这些域会在启动器启动电脑、内核编译时填充。<code>copy_boot_protocal</code>做了以下两件事：</p>
<ol>
<li>将汇编代码<code>header.S</code>中的<code>hdr</code>标签复制到结构体<code>boot_params</code>中的<code>setup_header</code>成员。</li>
<li>如果加载内核时用了旧的命令行工具，它负责跟新指针指向新的内核命令行工具。</li>
</ol>
<p>顺便看一看实现复制<code>hdr</code>功能的<code>memcpy</code>在<code>arch/x86/boot/copy.S</code>中是如何实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Memory copy routines</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">	.code16</span><br><span class="line">	.text</span><br><span class="line"></span><br><span class="line">SYM_FUNC_START_NOALIGN(memcpy)</span><br><span class="line">	pushw	%si						# si 是源索引寄存器</span><br><span class="line">	pushw	%di						#	di 是目标寄存器</span><br><span class="line">	movw	%ax, %di			# ax 通常存放目的地址</span><br><span class="line">	movw	%dx, %si			# dx 通常存放源地址</span><br><span class="line">	pushw	%cx						# cx 计数寄存器</span><br><span class="line">	shrw	$2, %cx</span><br><span class="line">	rep; movsl					# rep 重复执行标志；movsl：move string long。这条指令用于从源地址复制一个双字（32位，或者说4个字节）到目标地址。</span><br><span class="line">	popw	%cx</span><br><span class="line">	andw	$3, %cx</span><br><span class="line">	rep; movsb</span><br><span class="line">	popw	%di</span><br><span class="line">	popw	%si</span><br><span class="line">	retl</span><br><span class="line">SYM_FUNC_END(memcpy)</span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>SYM_FUNC_START_NOALIGN</code>定义在<code>include/linux/linkage.h</code>中，表示这是一个全局函数。其中 <code>w/o</code>表示 <code>without alignment</code>，即无对齐。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SYM_FUNC_START_NOALIGN -- use for global functions, w/o alignment */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SYM_FUNC_START_NOALIGN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYM_FUNC_START_NOALIGN(name)			\</span></span><br><span class="line"><span class="meta">	SYM_START(name, SYM_L_GLOBAL, SYM_A_NONE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>memcpy</code>的汇编代码很简单。</p>
<ul>
<li>首先将<code>%si</code>和<code>%di</code>寄存器中的值压入栈中以保留它们的值，这是因为接下来的操作会改变它们的值。</li>
<li>然后将<code>%ax</code>和<code>%dx</code>的值存储到<code>%di</code>和<code>%si</code>中。</li>
<li>将<code>%cx</code>的值保存在栈中，然后对<code>%cx</code>的值右移2位（除以4）。</li>
<li>循环复制（一次复制4字节）源寄存器<code>si</code>指向的地址中的值，到目的寄存器<code>di</code>指向的地址空间中，直到计数寄存器<code>cx</code>减小为0。</li>
</ul>
<p>因为上面的操作都是4个字节4个字节的复制，而在实际使用<code>memcpy</code>时肯定会出现复制的字节不是4的倍数的情况。</p>
<ul>
<li>这种情况下，我们取出在栈中保存的<code>%cx</code>值，然后重复使用<code>movsb</code>命令（b代表每次复制一个字节）复制剩下的字节。</li>
<li>最后取出保存在<code>%di</code>和<code>%si</code>中的值并返回。</li>
</ul>
<p>在<code>arch/x86/Makefile</code>中的<code>REALMODE_CFLAGS</code>中可以看到，构建内核时通过<code>-mregparm = 3</code>的<code>GCC</code>选项。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How to compile the 16-bit code.  Note we always compile for -march=i386;</span></span><br><span class="line"><span class="comment"># that way we can complain to the user if the CPU is insufficient.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The -m16 option is supported by GCC &gt;= 4.9 and clang &gt;= 3.5. For</span></span><br><span class="line"><span class="comment"># older versions of GCC, include an *assembly* header to make sure that</span></span><br><span class="line"><span class="comment"># gcc doesn&#x27;t play any games behind our back.</span></span><br><span class="line">CODE16GCC_CFLAGS := -m32 -Wa,<span class="variable">$(srctree)</span>/arch/x86/boot/code16gcc.h</span><br><span class="line">M16_CFLAGS	 := <span class="variable">$(<span class="built_in">call</span> cc-option, -m16, <span class="variable">$(CODE16GCC_CFLAGS)</span>)</span></span><br><span class="line"></span><br><span class="line">REALMODE_CFLAGS	:= <span class="variable">$(M16_CFLAGS)</span> -g -Os -DDISABLE_BRANCH_PROFILING -D__DISABLE_EXPORTS \</span><br><span class="line">		   -Wall -Wstrict-prototypes -march=i386 -mregparm=3 \</span><br><span class="line">		   -fno-strict-aliasing -fomit-frame-pointer -fno-pic \</span><br><span class="line">		   -mno-mmx -mno-sse <span class="variable">$(<span class="built_in">call</span> cc-option,-fcf-protection=none)</span></span><br></pre></td></tr></table></figure>

<p>现在我们知道，函数<code>memcpy</code>的三个参数分别存储在<code>ax</code>,<code>dx</code>和<code>cx</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(&amp;boot_params.hdr, &amp;hdr, <span class="keyword">sizeof</span> hdr);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ax</code> 存储<code>boot_params.hdr</code>的地址</li>
<li><code>dx</code> 存储 <code>hdr</code>的地址</li>
<li><code>cx</code> 存储 <code>hdr</code> 的大小</li>
</ul>
<h2 id="Console-initialization"><a href="#Console-initialization" class="headerlink" title="Console initialization"></a>Console initialization</h2><p>使用函数<code>console_init</code>初始化控制台，该函数定义在<code>arch/x86/boot/early_serial_console.c</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">console_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	parse_earlyprintk();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!early_serial_base)</span><br><span class="line">		parse_console_uart8250();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数在启动参数中寻找<code>earlyprintk</code>选项，如果成功找到，则解析端口地址和端口的波特率并初始化端口。<code>earlyprintk</code>命令行的参数是其中的下一个：</p>
<ul>
<li><code>serial, 0x3f8, 115200</code></li>
<li><code>serial, ttyS0, 115200</code></li>
<li><code>ttyS0, 115200</code></li>
</ul>
<p>串行端口初始化成功后，我们会看见第一个输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cmdline_find_option_bool(<span class="string">&quot;debug&quot;</span>))</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;early console in setup code\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>函数<code>puts</code>定义在：<code>arch/x86/boot/tty.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __section(<span class="string">&quot;.inittext&quot;</span>) <span class="built_in">putchar</span>(<span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (ch == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;\r&#x27;</span>);	<span class="comment">/* \n -&gt; \r\n */</span></span><br><span class="line"></span><br><span class="line">	bios_putchar(ch);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (early_serial_base != <span class="number">0</span>)</span><br><span class="line">		serial_putchar(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __section(<span class="string">&quot;.inittext&quot;</span>) <span class="built_in">puts</span>(<span class="type">const</span> <span class="type">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (*str)</span><br><span class="line">		<span class="built_in">putchar</span>(*str++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在c语言中，<code>__section</code>属性告诉编译器将特定的函数或者变量放置在指定的段<code>(section)</code>中。<code>&quot;.inittext&quot;</code>是一个段名，用于指定内核初始化代码的位置。</p>
<p>即，指示连接器将<code>putchar</code>函数放置在<code>ELF</code>二进制文件的<code>.inittext</code>段中。这个段专门用于内核启动时需要执行，但是一旦完成初始化过程后就不再需要的代码。内核通常在启动完成后会释放这些初始化代码占用的内存，因为这段时间内核已经开始运行正常的运行时代码了。</p>
<p>使用这个属性可以帮助减少内核的运行时内存占用，因为初始化代码在它不再需要之后不会占用宝贵的内存资源。这在嵌入式系统中尤其有用，其中内存资源可能非常有限。</p>
</blockquote>
<p>我们在链接文件<code>arch/x86/boot/setup.ld</code>可以看到上述代码的<code>.inittext</code>段的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> */</span><br><span class="line">OUTPUT_FORMAT(&quot;elf32-i386&quot;)</span><br><span class="line">OUTPUT_ARCH(i386)</span><br><span class="line">ENTRY(_start)</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">	. = 0;</span><br><span class="line">	.bstext		: &#123; *(.bstext) &#125;</span><br><span class="line">	.bsdata		: &#123; *(.bsdata) &#125;</span><br><span class="line"></span><br><span class="line">	. = 495;</span><br><span class="line">	.header		: &#123; *(.header) &#125;</span><br><span class="line">	.entrytext	: &#123; *(.entrytext) &#125;</span><br><span class="line">	.inittext	: &#123; *(.inittext) &#125;</span><br><span class="line">	.initdata	: &#123; *(.initdata) &#125;</span><br><span class="line">	__end_init = .;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们回到函数<code>putchar</code>，该函数在将<code>\n</code>转换为<code>\r</code>后。调用<code>bios_putchar</code>，通过<code>0x10</code>中断，在<code>VGA screen</code>上输出。</p>
<blockquote>
<ul>
<li>在计算机术语中，“VGA screen”指的是通过视频图形阵列（Video Graphics Array，VGA）接口显示的屏幕。</li>
<li>BIOS（基本输入输出系统）提供了一系列的中断调用，用于低级别的硬件交互，其中<code>0x10</code>是视频服务的中断号。软件可以通过设置相应的寄存器，然后触发这个中断来执行特定的视频操作，如在屏幕上显示字符。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __section(<span class="string">&quot;.inittext&quot;</span>) bios_putchar(<span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">biosregs</span> <span class="title">ireg</span>;</span></span><br><span class="line"></span><br><span class="line">	initregs(&amp;ireg);</span><br><span class="line">	ireg.bx = <span class="number">0x0007</span>;</span><br><span class="line">	ireg.cx = <span class="number">0x0001</span>;</span><br><span class="line">	ireg.ah = <span class="number">0x0e</span>;</span><br><span class="line">	ireg.al = ch;</span><br><span class="line">	intcall(<span class="number">0x10</span>, &amp;ireg, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>initregs</code>调用<code>memset</code>函数将<code>biosregs ireg</code>置为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initregs</span><span class="params">(<span class="keyword">struct</span> biosregs *reg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(reg, <span class="number">0</span>, <span class="keyword">sizeof</span>(*reg));</span><br><span class="line">	reg-&gt;eflags |= X86_EFLAGS_CF;</span><br><span class="line">	reg-&gt;ds = ds();</span><br><span class="line">	reg-&gt;es = ds();</span><br><span class="line">	reg-&gt;fs = fs();</span><br><span class="line">	reg-&gt;gs = gs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阅读<code>memset</code>的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SYM_FUNC_START_NOALIGN(memset)</span><br><span class="line">	pushw	%di</span><br><span class="line">	movw	%ax, %di</span><br><span class="line">	movzbl	%dl, %eax		# move with Zero-Extend from Byte to Longword	</span><br><span class="line">	imull	$0x01010101,%eax</span><br><span class="line">	pushw	%cx</span><br><span class="line">	shrw	$2, %cx</span><br><span class="line">	rep; stosl</span><br><span class="line">	popw	%cx</span><br><span class="line">	andw	$3, %cx</span><br><span class="line">	rep; stosb</span><br><span class="line">	popw	%di</span><br><span class="line">	retl</span><br><span class="line">SYM_FUNC_END(memset)</span><br></pre></td></tr></table></figure>

<ul>
<li>同样接受三个参数，存放在<code>ax dx cx</code>中。</li>
<li>将8位<code>%dl</code>零扩展到32位并移动到<code>%eax</code>中。</li>
<li>然后通过<code>imull $0x01010101, %eax</code>将高<code>24</code>位全复制为低<code>8</code>位的值。</li>
<li><code>stosl</code>：<code>Store String long</code>（存储字符串长字）。该指令将累加器（<code>AL</code>、<code>AX</code>或<code>EAX</code>）中的数据复制到目标索引寄存器（<code>DI</code>或<code>EDI</code>）指向的内存地址，并根据当前设置的方向标志（Direction Flag）在标志寄存器中自动增加或减少<code>DI</code>&#x2F;<code>EDI</code>的值。直到计数寄存器<code>cx</code>归<code>0</code>。</li>
</ul>
<h2 id="Heap-initialization"><a href="#Heap-initialization" class="headerlink" title="Heap initialization"></a>Heap initialization</h2><p>在<code>header.S</code>中，我们初始化了栈<code>stack</code>和<code>bss</code>段。现在内核需要使用<code>init_heap</code>初始化堆<code>heap</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_heap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *stack_end;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (boot_params.hdr.loadflags &amp; CAN_USE_HEAP) &#123;</span><br><span class="line">		<span class="keyword">asm</span>(<span class="string">&quot;leal %P1(%%esp),%0&quot;</span></span><br><span class="line">		    : <span class="string">&quot;=r&quot;</span> (stack_end) : <span class="string">&quot;i&quot;</span> (-STACK_SIZE));</span><br><span class="line"></span><br><span class="line">		heap_end = (<span class="type">char</span> *)</span><br><span class="line">			((<span class="type">size_t</span>)boot_params.hdr.heap_end_ptr + <span class="number">0x200</span>);</span><br><span class="line">		<span class="keyword">if</span> (heap_end &gt; stack_end)</span><br><span class="line">			heap_end = stack_end;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Boot protocol 2.00 only, no heap available */</span></span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;WARNING: Ancient bootloader, some functionality &quot;</span></span><br><span class="line">		     <span class="string">&quot;may be limited!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先检查启动文件头的<code>loadflag</code>中是否配置了<code>CAN_USE_HEAP</code>，如果配置了<code>CAN_USE_HEAP</code>，使用内链汇编代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;leal %P1(%%esp),%0&quot;</span></span><br><span class="line">		    : <span class="string">&quot;=r&quot;</span> (stack_end) : <span class="string">&quot;i&quot;</span> (-STACK_SIZE));</span><br></pre></td></tr></table></figure>

<p>计算栈的结束位置。也即：<code>stack_end = esp - STACK_SIZE</code></p>
<p>接着是计算堆结束位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap_end = (<span class="type">char</span> *)((<span class="type">size_t</span>)boot_params.hdr.heap_end_ptr + <span class="number">0x200</span>);</span><br></pre></td></tr></table></figure>

<p>最后检查堆结束地址<code>heap_end</code>是否大于栈结束地址<code>stack_end</code>，如果是，则要保持<code>heap_end = stack_end</code>。</p>
<p>堆初始化之后，我们可以使用<code>GET_HEAP</code>方法，在下一章我们会介绍它。</p>
<h2 id="CPU确认"><a href="#CPU确认" class="headerlink" title="CPU确认"></a>CPU确认</h2><p>下一步是确认<code>CPU，函数</code>validate_cpu<code>定义在</code><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/cpu.c"><code>arch/x86/boot/cpu.c</code></a>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">validate_cpu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 *err_flags;</span><br><span class="line">	<span class="type">int</span> cpu_level, req_level;</span><br><span class="line"></span><br><span class="line">	check_cpu(&amp;cpu_level, &amp;req_level, &amp;err_flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cpu_level &lt; req_level) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;This kernel requires an %s CPU, &quot;</span>,</span><br><span class="line">		       cpu_name(req_level));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;but only detected an %s CPU.\n&quot;</span>,</span><br><span class="line">		       cpu_name(cpu_level));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err_flags) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;This kernel requires the following features &quot;</span></span><br><span class="line">		     <span class="string">&quot;not present on the CPU:\n&quot;</span>);</span><br><span class="line">		show_cap_strs(err_flags);</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (check_knl_erratum()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数<code>check_cpu</code>判断当前CPU等级<code>cpu_level</code>和需要的CPU等级<code>req_level</code>是否一致。该函数还检查CPU标志，对于x86_64（64位）CPU，它会检查长模式（long mode）是否存在，检查处理器的供应商，并为特定供应商做准备，比如如果AMD缺失SSE+SSE2，就关闭它们等等。</p>
<p>当cpu被确认后，调用<code>set_bios_mode</code>，该函数告诉<code>BIOS</code>我们会在哪种<code>CPU</code>模式下运行。该函数只在<code>x86_64</code>模式下运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Tell the BIOS what CPU mode we intend to run in.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_bios_mode</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">biosregs</span> <span class="title">ireg</span>;</span></span><br><span class="line"></span><br><span class="line">	initregs(&amp;ireg);</span><br><span class="line">	ireg.ax = <span class="number">0xec00</span>;</span><br><span class="line">	ireg.bx = <span class="number">2</span>;</span><br><span class="line">	intcall(<span class="number">0x15</span>, &amp;ireg, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数通过<code>0x15 BIOS</code>中断告诉<code>BIOS</code>使用长模式<code>long mode</code>。</p>
<blockquote>
<p>在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/X86-64">x86-64</a>处理器架构中，当处于<strong>长模式</strong>（Long mode）时，64位应用程序（或者是操作系统）可以使用64位指令和寄存器，而32位程序将以一种兼容子模式运行。</p>
</blockquote>
<h2 id="Memory-detection"><a href="#Memory-detection" class="headerlink" title="Memory detection"></a>Memory detection</h2><p>接着主函数会调用<code>detect_memory</code>检测内存，该函数为<code>CPU</code>提供了基础的<code>RAM</code>映射表。使用了不同的编程接口<code>0xe820 0xe801</code>和<code>0x88</code>用于内存检测。以<code>0xE820</code>为例，<code>detect_memory_e820</code>定义在<code>arch/x86/boot/memory.c</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">detect_memory_e820</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">biosregs</span> <span class="title">ireg</span>, <span class="title">oreg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">boot_e820_entry</span> *<span class="title">desc</span> =</span> boot_params.e820_table;</span><br><span class="line">	<span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">boot_e820_entry</span> <span class="title">buf</span>;</span> <span class="comment">/* static so it is zeroed */</span></span><br><span class="line"></span><br><span class="line">	initregs(&amp;ireg);</span><br><span class="line">	ireg.ax  = <span class="number">0xe820</span>;</span><br><span class="line">	ireg.cx  = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">	ireg.edx = SMAP;</span><br><span class="line">	ireg.di  = (<span class="type">size_t</span>)&amp;buf;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Note: at least one BIOS is known which assumes that the</span></span><br><span class="line"><span class="comment">	 * buffer pointed to by one e820 call is the same one as</span></span><br><span class="line"><span class="comment">	 * the previous call, and only changes modified fields.  Therefore,</span></span><br><span class="line"><span class="comment">	 * we use a temporary buffer and copy the results entry by entry.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This routine deliberately does not try to account for</span></span><br><span class="line"><span class="comment">	 * ACPI 3+ extended attributes.  This is because there are</span></span><br><span class="line"><span class="comment">	 * BIOSes in the field which report zero for the valid bit for</span></span><br><span class="line"><span class="comment">	 * all ranges, and we don&#x27;t currently make any use of the</span></span><br><span class="line"><span class="comment">	 * other attribute bits.  Revisit this if we see the extended</span></span><br><span class="line"><span class="comment">	 * attribute bits deployed in a meaningful way in the future.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		intcall(<span class="number">0x15</span>, &amp;ireg, &amp;oreg);</span><br><span class="line">		ireg.ebx = oreg.ebx; <span class="comment">/* for next iteration... */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* BIOSes which terminate the chain with CF = 1 as opposed</span></span><br><span class="line"><span class="comment">		   to %ebx = 0 don&#x27;t always report the SMAP signature on</span></span><br><span class="line"><span class="comment">		   the final, failing, probe. */</span></span><br><span class="line">		<span class="keyword">if</span> (oreg.eflags &amp; X86_EFLAGS_CF)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Some BIOSes stop returning SMAP in the middle of</span></span><br><span class="line"><span class="comment">		   the search loop.  We don&#x27;t know exactly how the BIOS</span></span><br><span class="line"><span class="comment">		   screwed up the map at that point, we might have a</span></span><br><span class="line"><span class="comment">		   partial map, the full map, or complete garbage, so</span></span><br><span class="line"><span class="comment">		   just return failure. */</span></span><br><span class="line">		<span class="keyword">if</span> (oreg.eax != SMAP) &#123;</span><br><span class="line">			count = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		*desc++ = buf;</span><br><span class="line">		count++;</span><br><span class="line">	&#125; <span class="keyword">while</span> (ireg.ebx &amp;&amp; count &lt; ARRAY_SIZE(boot_params.e820_table));</span><br><span class="line"></span><br><span class="line">	boot_params.e820_entries = count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数首先为寄存器填充调用<code>0xe820</code>所需的特定值。</p>
<ul>
<li><code>ax</code>：包含了函数的名字。</li>
<li><code>cx</code>：缓存的大小，该缓存将用于存储内存中的数据。</li>
<li><code>edx</code>：包含了<code>SMAP magic number</code>。</li>
<li><code>es:di</code>：指向上面提到的缓存的地址（cx中）。</li>
<li><code>ebx</code>：必须为0.</li>
</ul>
<p>然后是一个循环，该循环收集内存中的数据。首先调用<code>0x15</code>的<code>BIOS</code>中断，该中断从地址分配表中写入一行。为了获取下一行，我们需要再次调用该中断。在下一次调用之前，ebx必须包含之前返回的值。</p>
<p>最终，该函数从地址分配表收集数据，并将这些数据写入e820_entry数组：</p>
<ul>
<li>内存段的起点</li>
<li>内存段的大小</li>
<li>内存段的类型（可用或者保留）</li>
</ul>
<p><code>dmesg</code>的输出是像下面给出的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[    0.000000] e820: BIOS-provided physical RAM map:</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x0000000000000000-0x000000000009fbff] usable</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x000000000009fc00-0x000000000009ffff] reserved</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x00000000000f0000-0x00000000000fffff] reserved</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x0000000000100000-0x000000003ffdffff] usable</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x000000003ffe0000-0x000000003fffffff] reserved</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x00000000fffc0000-0x00000000ffffffff] reserved</span><br></pre></td></tr></table></figure>

<h2 id="Keyboard-initialization"><a href="#Keyboard-initialization" class="headerlink" title="Keyboard initialization"></a>Keyboard initialization</h2><p>接着调用函数<code>keyboard_init</code>初始化键盘，同样通过函数<code>initregs</code>初始化寄存器。然后调用<code>0x16</code>中断查询键盘状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">keyboard_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">biosregs</span> <span class="title">ireg</span>, <span class="title">oreg</span>;</span></span><br><span class="line">	initregs(&amp;ireg);</span><br><span class="line"></span><br><span class="line">	ireg.ah = <span class="number">0x02</span>;		<span class="comment">/* Get keyboard status */</span></span><br><span class="line">	intcall(<span class="number">0x16</span>, &amp;ireg, &amp;oreg);</span><br><span class="line">	boot_params.kbd_status = oreg.al;</span><br><span class="line"></span><br><span class="line">	ireg.ax = <span class="number">0x0305</span>;	<span class="comment">/* Set keyboard repeat rate */</span></span><br><span class="line">	intcall(<span class="number">0x16</span>, &amp;ireg, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此之后，它再次调用0x16来设置重复率和延迟。</p>
<h2 id="Querying"><a href="#Querying" class="headerlink" title="Querying"></a>Querying</h2><p>接下来的几个步骤是对不同参数的查询。我们不会深入研究这些查询的细节，但稍后会回复它们。让我们简要看看这些功能：</p>
<ul>
<li><p><code>query_ist</code>：获取<code>Intel SpeedStep</code>信息。检查<code>CPU</code>的等级，如果正确，调用<code>0x15</code>中断获取信息并存储到<code>boot_params</code>中</p>
<blockquote>
<p>ST（Intel SpeedStep Technology）是英特尔开发的一种处理器技术，旨在优化处理器的性能和电源使用效率。它通过根据当前计算机负载动态调整处理器的频率和电压来实现这一目标。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get Intel SpeedStep (IST) information.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">query_ist</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">biosregs</span> <span class="title">ireg</span>, <span class="title">oreg</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Some older BIOSes apparently crash on this call, so filter</span></span><br><span class="line"><span class="comment">	   it from machines too old to have SpeedStep at all. */</span></span><br><span class="line">	<span class="keyword">if</span> (cpu.level &lt; <span class="number">6</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	initregs(&amp;ireg);</span><br><span class="line">	ireg.ax  = <span class="number">0xe980</span>;	 <span class="comment">/* IST Support */</span></span><br><span class="line">	ireg.edx = <span class="number">0x47534943</span>;	 <span class="comment">/* Request value */</span></span><br><span class="line">	intcall(<span class="number">0x15</span>, &amp;ireg, &amp;oreg);</span><br><span class="line"></span><br><span class="line">	boot_params.ist_info.signature  = oreg.eax;</span><br><span class="line">	boot_params.ist_info.command    = oreg.ebx;</span><br><span class="line">	boot_params.ist_info.event      = oreg.ecx;</span><br><span class="line">	boot_params.ist_info.perf_level = oreg.edx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>query_apm_bios</code>：从<code>BIOS</code>中获取<code>Advanced Power Management</code>信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Query_apm_bios也调用0x15 BIOS中断，但用ah = 0x53检查APM安装。0x15完成执行后，query_apm_bios函数检查PM签名（必须是0x504d）、携带标志（如果支持APM，则必须是0）和cx寄存器的值（如果是0x02，则支持受保护模式接口）。</span><br><span class="line"></span><br><span class="line">接下来，它再次调用0x15，但使用ax = 0x5304断开APM接口并连接32位保护模式接口。最后，它用从BIOS获得的值填充boot_params.apm_bios_info。</span><br><span class="line"></span><br><span class="line">请注意，只有在配置文件中设置了CONFIG_APM或CONFIG_APM_MODULE编译时间标志时，query_apm_bios才会执行：</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>query_edd</code>：查询<code>Enhanced Disk Drive</code>信息。</p>
<p>函数首先从内核命令行中读取<code>edd</code>设置，如果没有该选择则直接退出函数。</p>
<p>如果启用EDD，query_edd会检查BIOS支持的硬盘，并在循环中查询EDD信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">query_edd</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> eddarg[<span class="number">8</span>];</span><br><span class="line">	<span class="type">int</span> do_mbr = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EDD_OFF</span></span><br><span class="line">	<span class="type">int</span> do_edd = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">int</span> do_edd = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span> be_quiet;</span><br><span class="line">	<span class="type">int</span> devno;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">edd_info</span> <span class="title">ei</span>, *<span class="title">edp</span>;</span></span><br><span class="line">	u32 *mbrptr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cmdline_find_option(<span class="string">&quot;edd&quot;</span>, eddarg, <span class="keyword">sizeof</span>(eddarg)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(eddarg, <span class="string">&quot;skipmbr&quot;</span>) || !<span class="built_in">strcmp</span>(eddarg, <span class="string">&quot;skip&quot;</span>)) &#123;</span><br><span class="line">			do_edd = <span class="number">1</span>;</span><br><span class="line">			do_mbr = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(eddarg, <span class="string">&quot;off&quot;</span>))</span><br><span class="line">			do_edd = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(eddarg, <span class="string">&quot;on&quot;</span>))</span><br><span class="line">			do_edd = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	be_quiet = cmdline_find_option_bool(<span class="string">&quot;quiet&quot;</span>);</span><br><span class="line"></span><br><span class="line">	edp    = boot_params.eddbuf;</span><br><span class="line">	mbrptr = boot_params.edd_mbr_sig_buffer;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!do_edd)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Bugs in OnBoard or AddOnCards Bios may hang the EDD probe,</span></span><br><span class="line"><span class="comment">	 * so give a hint if this happens.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!be_quiet)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Probing EDD (edd=off to disable)... &quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (devno = <span class="number">0x80</span>; devno &lt; <span class="number">0x80</span>+EDD_MBR_SIG_MAX; devno++) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Scan the BIOS-supported hard disks and query EDD</span></span><br><span class="line"><span class="comment">		 * information...</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!get_edd_info(devno, &amp;ei)</span><br><span class="line">		    &amp;&amp; boot_params.eddbuf_entries &lt; EDDMAXNR) &#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(edp, &amp;ei, <span class="keyword">sizeof</span>(ei));</span><br><span class="line">			edp++;</span><br><span class="line">			boot_params.eddbuf_entries++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (do_mbr &amp;&amp; !read_mbr_sig(devno, &amp;ei, mbrptr++))</span><br><span class="line">			boot_params.edd_mbr_sig_buf_entries = devno<span class="number">-0x80</span>+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!be_quiet)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ok\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中0x80是第一个硬盘驱动器，EDD_MBR_SIG_MAX宏的值为16。它收集数据到<code>edd_info</code>结构数组中。</p>
<p><code>get_edd_info</code>通过调用0x13中断和<code>ah = 0x41</code>来检查EDD是否存在，如果EDD存在，get_edd_info再次调用0x13中断，但<code>ah=0x48</code>和<code>si</code>包含存储EDD信息的缓冲区地址。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/24/framewave-study/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/24/framewave-study/" class="post-title-link" itemprop="url">framewave_study</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-24 19:49:26" itemprop="dateCreated datePublished" datetime="2023-10-24T19:49:26+08:00">2023-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-25 19:00:37" itemprop="dateModified" datetime="2023-10-25T19:00:37+08:00">2023-10-25</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Framewave-tutorial"><a href="#Framewave-tutorial" class="headerlink" title="Framewave tutorial"></a>Framewave tutorial</h1><h2 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h2><p>​	去官网下载压缩包，解压后打开<code>readme</code>按照readme里面的步骤来就好了。</p>
<ul>
<li>提示：<code>readme</code>里面的<code>ExampleDir</code>直接换成绝对路径。</li>
<li>提示：后面那个<code>export</code>操作笔者没做出来，不过大概意思是把这个链接放到全局链接里去</li>
</ul>
<h2 id="Framewave-FW-是做什么的："><a href="#Framewave-FW-是做什么的：" class="headerlink" title="Framewave(FW)是做什么的："></a>Framewave(FW)是做什么的：</h2><p>​	Framewave (FW) is a collection of libraries that contain highly-optimized functions for use in a variety of programming domains. All implementations of the libraries provide C and C++ programmers ANSI C style interfaces.</p>
<p>​	Framewave consists of the following libraries:</p>
<ul>
<li>The <a target="_blank" rel="noopener" href="https://framewave.sourceforge.net/Manual/fw_section_010.html#fw_section_010">Base Library</a> functions are essential for primary tasks such as memory allocation and functions that manage the performance of other library functions.</li>
<li>The <a target="_blank" rel="noopener" href="https://framewave.sourceforge.net/Manual/fw_section_020.html#fw_section_020">Image Processing Library</a> functions perform a variety of tasks related to image processing.</li>
<li>The <a target="_blank" rel="noopener" href="https://framewave.sourceforge.net/Manual/fw_section_030.html#fw_section_030">JPEG Library</a> functions perform a variety of tasks related to Joint Photographic Experts Group image manipulation.</li>
<li>The <a target="_blank" rel="noopener" href="https://framewave.sourceforge.net/Manual/fw_section_040.html#fw_section_040">Signal Processing Library</a> functions perform a variety of tasks related to signal processing.</li>
<li>The <a target="_blank" rel="noopener" href="https://framewave.sourceforge.net/Manual/fw_section_050.html#fw_section_050">Video Library</a> functions perform video manipulation, encoding and decoding.</li>
</ul>
<h1 id="RTFM！！！！！"><a href="#RTFM！！！！！" class="headerlink" title="RTFM！！！！！"></a>RTFM！！！！！</h1><p>​	现在的任务就是读手册，手册里写的很清楚了！！！</p>
<p>​	</p>
<h2 id="Base-Library："><a href="#Base-Library：" class="headerlink" title="Base Library："></a>Base Library：</h2><p>​	This chapter provides an overview of the information contained in the functional descriptions. Base library functional descriptions include the following types of information.</p>
<h3 id="Data-Structures"><a href="#Data-Structures" class="headerlink" title="Data Structures"></a>Data Structures</h3><ul>
<li><strong>FwLibraryVersion</strong> Library version information.</li>
<li><strong>FwRoundMode</strong> Rounding mode used in data type conversion.</li>
<li><strong>FwWinType</strong> Type of window used to generate FIR filter coefficients.</li>
</ul>
<h3 id="Enumerator"><a href="#Enumerator" class="headerlink" title="Enumerator"></a>Enumerator</h3><ul>
<li><strong>FwBool</strong> Type of Boolean values.</li>
<li><strong>FwCmpOp</strong> Type of comparison operation.</li>
<li><strong>FwCpuType</strong> Type of CPU with presence of streaming SIMD extensions.</li>
<li><strong>FwHintAlgorithm</strong> Hint to favor speed or accuracy.</li>
</ul>
<h3 id="Parameter-Glossary"><a href="#Parameter-Glossary" class="headerlink" title="Parameter Glossary"></a>Parameter Glossary</h3><ul>
<li><em>StsCode</em> Specifies the status code used by the FwStatus function</li>
<li><em>alignBytes</em> Specifies the number of bytes for alignment, must be a power of 2. NULL is returned if the value is less than 2.</li>
<li><em>cpu</em> Specifies a CPU type.</li>
<li><em>length</em> Specifies a number of bytes to be allocated.</li>
<li><em>numThr</em>  Specifies the maximum number of threads that can be used by any Framewave function.</li>
<li><em>param</em> Specifies some parameter.</li>
<li><em>ptr</em>  Pointer to a memory buffer.</li>
<li><em>workFn</em> Specifies work function.</li>
</ul>
<h3 id="Core-Function"><a href="#Core-Function" class="headerlink" title="Core Function:"></a>Core Function:</h3><p>​	好像被标上<code>This function is reserved for FW internal use.</code>（此功能保留给FW内部使用）和程序员的关系不大。</p>
<ul>
<li><h4 id="GetStatusString"><a href="#GetStatusString" class="headerlink" title="GetStatusString"></a>GetStatusString</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> *	获取状态信息字符串</span><br><span class="line"> *  StsCode 指定FwStatus函数使用的状态代码。</span><br><span class="line"> *	返回一个字符串，该字符串描述了任何FwStatus枚举整数的含义。</span><br><span class="line"> */</span><br><span class="line">const char * fwGetStatusString ( FwStatus StsCode );</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="GetCpuType"><a href="#GetCpuType" class="headerlink" title="GetCpuType"></a>GetCpuType</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	获取 CPU 类型</span><br><span class="line"> *	返回存在的SSE支持级别。</span><br><span class="line"> *  它可用于识别CPU类型。</span><br><span class="line">*/</span><br><span class="line">FwCpuType fwGetCpuType();</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="GetCpuClocks"><a href="#GetCpuClocks" class="headerlink" title="GetCpuClocks"></a>GetCpuClocks</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 获取 CPU 时钟周期</span><br><span class="line"> * Fw64u 表示 64位 unsigned int 类型</span><br><span class="line"> * 此功能返回自CPU开机以来经过的CPU时钟周期数。</span><br><span class="line"> * 可以通过在两个不同点调用函数，然后从第二个返回值中减去第一个返回值来计时代码段。</span><br><span class="line">*/</span><br><span class="line">Fw64u fwGetCpuClocks();</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="StaticInit"><a href="#StaticInit" class="headerlink" title="StaticInit"></a>StaticInit</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 初始化为适当的CPU类型</span><br><span class="line"> * 此功能初始化FW内部调度器，</span><br><span class="line"> * 以使用最合适的CPU类型。</span><br><span class="line">*/</span><br><span class="line">FwStatus fwStaticInit();</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="StaticInitCpu"><a href="#StaticInitCpu" class="headerlink" title="StaticInitCpu"></a>StaticInitCpu</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	初始化为指定的CPU类型</span><br><span class="line"> *  参数cpu： 初始化为指定的CPU类型</span><br><span class="line"> *	此函数初始化FW内部调度器以使用指定的CPU类型。</span><br><span class="line">*/</span><br><span class="line">FwStatus	 	fwStaticInitCpu	(	FwCpuType cpu );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="SetNumThreads"><a href="#SetNumThreads" class="headerlink" title="SetNumThreads"></a>SetNumThreads</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *  设置线程数</span><br><span class="line"> *  参数numThr：指定任何Framewave函数可以使用的最大线程数。</span><br><span class="line"> *  此函数定义了任何FW函数可以使用的最大线程数。将numThr设置为1以关闭线程。</span><br><span class="line">*/</span><br><span class="line">FwStatus	 	fwSetNumThreads	(	unsigned int numThr );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="GetNumThreads"><a href="#GetNumThreads" class="headerlink" title="GetNumThreads"></a>GetNumThreads</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	获取线程数</span><br><span class="line"> *	此函数返回任何FW函数可以使用的最大线程数。</span><br><span class="line">*/</span><br><span class="line">Fw32u	 	fwGetNumThreads	(	  );</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="Allocate-memory"><a href="#Allocate-memory" class="headerlink" title="Allocate memory"></a>Allocate memory</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	分配空间</span><br><span class="line"> *	参数length:	指定分配的字节数量</span><br><span class="line"> *	此函数分配一个长度字节的内存缓冲区，并返回一个指针。</span><br><span class="line">*/</span><br><span class="line">void *	 	fwMalloc	(	int length );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="Free"><a href="#Free" class="headerlink" title="Free"></a>Free</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	释放空间</span><br><span class="line"> *	ptr	 	Pointer to a memory buffer.</span><br><span class="line"> *	此函数释放ptr指向的内存缓冲区。</span><br><span class="line">*/</span><br><span class="line">void	 	fwFree	(	void * ptr );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="AlignPtr"><a href="#AlignPtr" class="headerlink" title="AlignPtr"></a>AlignPtr</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	对齐缓冲区</span><br><span class="line"> *	alignBytes	指定对齐的字节数，必须是2的幂。如果值小于2，则返回NULL。 </span><br><span class="line"> *  ptr	指向内存缓冲区的指针。</span><br><span class="line"> *	此函数将ptr指向的缓冲区对齐到指定的对齐边界。</span><br><span class="line"> */</span><br><span class="line"> void *	 	fwAlignPtr	(	void * ptr, int alignBytes );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="SetNumThreads-local"><a href="#SetNumThreads-local" class="headerlink" title="SetNumThreads_local"></a>SetNumThreads_local</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	设置局部的线程数量</span><br><span class="line"> *	numThr	指定任何Framewave函数可以使用的最大线程数。</span><br><span class="line"> *	此功能保留给FW内部使用。</span><br><span class="line">*/</span><br><span class="line">FwStatus	 	fwSetNumThreads_local	(	unsigned int numThr );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	运行？</span><br><span class="line"> *	param	 	Specifies some parameter.</span><br><span class="line"> *	workFn	 	Specifies work function.</span><br><span class="line"> * 	此功能保留给FW内部使用。</span><br><span class="line">*/</span><br><span class="line">void	 	fwRun	(	WorkFn workFn, void* param );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	等待</span><br><span class="line"> *  此功能保留给FW内部使用。</span><br><span class="line">*/</span><br><span class="line">void	 	fwWait	(	  );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="GetInitType"><a href="#GetInitType" class="headerlink" title="GetInitType"></a>GetInitType</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	GetInitType</span><br><span class="line"> *	此功能保留给FW内部使用</span><br><span class="line">*/</span><br><span class="line">int	 	fwGetInitType	(	  );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="BaseData"><a href="#BaseData" class="headerlink" title="BaseData"></a>BaseData</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	BaseData</span><br><span class="line"> *	This function is reserved for FW internal use.</span><br><span class="line">*/</span><br><span class="line">void *	 	fwBaseData	(	  );</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Signal-Processing-Library"><a href="#Signal-Processing-Library" class="headerlink" title="Signal Processing Library:"></a>Signal Processing Library:</h2><p>​	这个库里面的函数大概就是本次作业的重点了，大部分是关于向量加减乘除法的，现在我们看着lab1的代码，直接在手册中找到对应的代码进行替换就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fwsCosh_64f_A53					  MT</span><br><span class="line">fwsAddC_64f_I							MT</span><br><span class="line">fwsMalloc_64f					not	MT</span><br><span class="line">fwsAdd_64f								MT</span><br><span class="line">fwsMulC_64f_I							MT</span><br><span class="line">fwsSqrt_64f								MT</span><br><span class="line">fwsFree								not	MT</span><br><span class="line">fwsThreshold_LT_64f				MT</span><br><span class="line">fwSetNumThreads				not	MT</span><br><span class="line">fwsDivC_64f_I							MT</span><br><span class="line">fwsCopy_64fc							MT</span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/20/parallelComputingLab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/20/parallelComputingLab/" class="post-title-link" itemprop="url">parallelComputingLab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-20 15:35:46" itemprop="dateCreated datePublished" datetime="2023-10-20T15:35:46+08:00">2023-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-21 14:39:53" itemprop="dateModified" datetime="2023-11-21T14:39:53+08:00">2023-11-21</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>48</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Parallel-Computing-Lab-1"><a href="#Parallel-Computing-Lab-1" class="headerlink" title="Parallel Computing Lab_1"></a>Parallel Computing Lab_1</h2><iframe src="../../../../pdf_file/parallelComputingLab/Lab1_report.pdf" style="width:100%; height:800px;" frameborder="0"></iframe>

<h2 id="Parallel-Computing-Lab-2"><a href="#Parallel-Computing-Lab-2" class="headerlink" title="Parallel Computing Lab_2"></a>Parallel Computing Lab_2</h2><iframe src="../../../../pdf_file/parallelComputingLab/Lab2_report.pdf" style="width:100%; height:800px;" frameborder="0"></iframe>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="theLonging"
      src="/images/touxiang.JPG">
  <p class="site-author-name" itemprop="name">theLonging</p>
  <div class="site-description" itemprop="description">不捨晝夜。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/chantchanH7" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chantchanH7" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/562879980@qq.com" title="E-Mail → 562879980@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-07 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">theLonging</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">453k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:52</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
