<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="不捨晝夜。">
<meta property="og:type" content="website">
<meta property="og:title" content="talk is cheap, show me the code.">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="talk is cheap, show me the code.">
<meta property="og:description" content="不捨晝夜。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="theLonging">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>talk is cheap, show me the code.</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="talk is cheap, show me the code." type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">talk is cheap, show me the code.</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/16/Lab-networking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/16/Lab-networking/" class="post-title-link" itemprop="url">Lab: networking</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-16 09:34:05" itemprop="dateCreated datePublished" datetime="2024-03-16T09:34:05+08:00">2024-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-17 12:58:11" itemprop="dateModified" datetime="2024-03-17T12:58:11+08:00">2024-03-17</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab-networking"><a href="#Lab-networking" class="headerlink" title="Lab: networking"></a>Lab: networking</h1><p>这个实验需要写一个<code>xv6</code>网络接口卡的设备驱动器。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>你需要使用E1000网络设备处理网络通信。对于xv6来说，E1000看起来就像是连接到真实以太网据局域网（LAN）的真实硬件。实际上，你的驱动程序将于之通信的E1000是由qemu提供的仿真，连接到的也是一个由qemu提供的仿真局域网。在这个仿真局域网上，xv6（作为客户机）的ip地址为10.0.2.15。qemu还安排运行qemu的计算机出现在局域网上，IP地址为10.0.2.2。当xv6使用E1000向10.0.2.2发送数据包时，qemu会将数据包递送到运行qemu的（真实）计算机上的适当应用程序（“宿主机”）。</p>
<p>你将使用qemu的用户模式网络栈。Qemu的文档有更多关于user-mode stack的信息。Makefile已经更新并支持QEMU的用户模式网络栈和E1000网卡。</p>
<p>Makefile 配置了 QEMU，以便将所有进出的数据包记录到实验目录中的 packets.pcap 文件。查看这些记录文件可能有助于确认 xv6 是否发送和接收了你期望的数据包。要显示记录的数据包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -XXnr packets.pcap</span><br></pre></td></tr></table></figure>

<p>为了这个实验，我们在 xv6 仓库中添加了一些文件。文件 <code>kernel/e1000.c</code> 包含了 E1000 的初始化代码，以及用于发送和接收数据包的空函数，你将填充这些函数。<code>kernel/e1000_dev.h</code> 包含由 E1000 定义的寄存器和标志位的定义，这些定义在 Intel E1000 软件开发者手册中有描述。<code>kernel/net.c</code> 和 <code>kernel/net.h</code> 包含了一个简单的网络栈，实现了 IP、UDP 和 ARP 协议。这些文件还包含了一种用于存放数据包的灵活数据结构的代码，称为 mbuf。最后，<code>kernel/pci.c</code> 包含了在 xv6 启动时搜索 PCI 总线上的 E1000 卡的代码。</p>
<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>你的任务是完成 <code>kernel/e1000.c</code> 中的 <code>e1000_transmit()</code> 和 <code>e1000_recv()</code> 函数，使得驱动程序能够发送和接收数据包。当 <code>make grade</code> 显示你的解决方案通过了所有测试时，说明你已经完成了任务。</p>
<blockquote>
<p>在编写代码时，你会发现自己需要参考 E1000 软件开发者手册。以下几个部分可能特别有帮助：</p>
<ul>
<li>第2节是必不可少的，提供了整个设备的概览。</li>
<li>第3.2节提供了数据包接收的概览。</li>
<li>第3.3节和第3.4节一起提供了数据包传输的概览。</li>
<li>第13节提供了 E1000 使用的寄存器的概览。</li>
<li>第14节可能会帮助你理解我们提供的初始化代码。</li>
</ul>
</blockquote>
<p>浏览 E1000 软件开发者手册。这份手册涵盖了几个密切相关的以太网控制器。QEMU 模拟的是 82540EM。现在先浏览第2章，以对设备有一个基本了解。为了编写你的驱动程序，你需要熟悉第3章和第14章，以及第4.1章（但不包括4.1章的小节）。你还需要将第13章作为参考。其他章节主要涵盖了你的驱动程序不需要交互的 E1000 的组件。首先不用担心细节；只需了解文档的结构，以便稍后可以找到所需的信息。E1000 有许多高级功能，其中大部分你可以忽略。只需要一小部分基本功能就可以完成这个实验。</p>
<p>我们在 <code>e1000.c</code> 中提供给你的 <code>e1000_init()</code> 函数配置了 E1000 从 RAM 读取要传输的数据包，并将接收到的数据包写入 RAM。这种技术称为 DMA，即直接内存访问，指的是 E1000 硬件直接向 RAM 读写数据包的事实。</p>
<p>由于数据包的突发可能比驱动程序能够处理的更快地到达，<code>e1000_init()</code> 为 E1000 提供了多个缓冲区，E1000 可以将数据包写入这些缓冲区。E1000 要求这些缓冲区通过 RAM 中的一个“描述符”数组来描述；每个描述符包含一个 RAM 中的地址，E1000 可以将接收到的数据包写入该地址。<code>struct rx_desc</code> 描述了描述符的格式。描述符数组被称为接收环或接收队列。从环形的角度来说，当卡或驱动到达数组的末尾时，它会回到开始的位置。<code>e1000_init()</code> 使用 <code>mbufalloc()</code> 为 E1000 分配 <code>mbuf</code> 数据包缓冲区以便 DMA 使用。还有一个发送环，驱动程序应将其希望 E1000 发送的数据包放置在其中。<code>e1000_init()</code> 配置这两个环的大小为 <code>RX_RING_SIZE</code> 和 <code>TX_RING_SIZE</code>。</p>
<p>当 <code>net.c</code> 中的网络栈需要发送数据包时，它会调用 <code>e1000_transmit()</code> 函数，并传入一个包含待发送数据包的 <code>mbuf</code>。你的传输代码必须将指向数据包数据的指针放置在 TX（发送）环的一个描述符中。<code>struct tx_desc</code> 描述了描述符的格式。你需要确保每个 <code>mbuf</code> 最终都被释放，但只有在 E1000 完成数据包传输后才能这么做（E1000 通过在描述符中设置 <code>E1000_TXD_STAT_DD</code> 位来指示这一点）。</p>
<p>当 E1000 从以太网接收到每个数据包时，它会通过直接内存访问（DMA）将数据包传输到 RX（接收）环描述符中的下一个 <code>addr</code> 指向的内存。如果 E1000 中断尚未挂起，E1000 会请求 PLIC 在启用中断后尽快交付一个中断。你的 <code>e1000_recv()</code> 代码必须扫描 RX 环，并通过调用 <code>net_rx()</code> 将每个新数据包的 <code>mbuf</code> 交给 <code>net.c</code> 中的网络栈。然后，你需要分配一个新的 <code>mbuf</code> 并将其放入描述符中，以便当 E1000 再次到达 RX 环的那一点时，它找到一个新的缓冲区，可以将新数据包通过 DMA 传输进去。</p>
<p>除了在 RAM 中读写描述符环，你的驱动程序还需要通过内存映射的控制寄存器与 E1000 交互，以检测何时有接收到的数据包可用，并通知 E1000 驱动程序已经填充了一些 TX 描述符，准备发送数据包。全局变量 <code>regs</code> 保存了一个指向 E1000 第一个控制寄存器的指针；你的驱动程序可以通过将 <code>regs</code> 作为数组进行索引来访问其他寄存器。你特别需要使用索引 <code>E1000_RDT</code> 和 <code>E1000_TDT</code>。</p>
<p>为了测试你的驱动程序，在一个窗口中运行 <code>make server</code>，在另一个窗口运行 <code>make qemu</code>，然后在 xv6 中运行 <code>nettests</code>。<code>nettests</code> 中的第一个测试尝试向宿主操作系统发送一个 UDP 数据包，地址指向 <code>make server</code> 运行的程序。如果你还没有完成实验，E1000 驱动程序实际上不会发送数据包，因此几乎没有什么会发生。</p>
<p>完成实验后，E1000 驱动程序将发送数据包，qemu 将把它传送到你的宿主计算机，<code>make server</code> 将看到它，它将发送一个响应数据包，然后 E1000 驱动程序和 <code>nettests</code> 将看到响应数据包。然而，在宿主发送回复之前，它会向 xv6 发送一个“ARP”请求数据包，以找出其 48 位以太网地址，并期望 xv6 用 ARP 回复进行响应。一旦你完成了 E1000 驱动程序的工作，<code>kernel/net.c</code> 将处理这个问题。如果一切顺利，<code>nettests</code> 将打印 <code>testing ping: OK</code>，而 <code>make server</code> 将打印一条来自 xv6 的消息！</p>
<p>tcpdump -XXnr packets.pcap should produce output that starts like this:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">reading from file packets.pcap, link-type EN10MB (Ethernet)</span><br><span class="line">15:27:40.861988 IP 10.0.2.15.2000 &gt; 10.0.2.2.25603: UDP, length 19</span><br><span class="line">        0x0000:  ffff ffff ffff 5254 0012 3456 0800 4500  ......RT..4V..E.</span><br><span class="line">        0x0010:  002f 0000 0000 6411 3eae 0a00 020f 0a00  ./....d.&gt;.......</span><br><span class="line">        0x0020:  0202 07d0 6403 001b 0000 6120 6d65 7373  ....d.....a.mess</span><br><span class="line">        0x0030:  6167 6520 6672 6f6d 2078 7636 21         age.from.xv6!</span><br><span class="line">15:27:40.862370 ARP, Request who-has 10.0.2.15 tell 10.0.2.2, length 28</span><br><span class="line">        0x0000:  ffff ffff ffff 5255 0a00 0202 0806 0001  ......RU........</span><br><span class="line">        0x0010:  0800 0604 0001 5255 0a00 0202 0a00 0202  ......RU........</span><br><span class="line">        0x0020:  0000 0000 0000 0a00 020f                 ..........</span><br><span class="line">15:27:40.862844 ARP, Reply 10.0.2.15 is-at 52:54:00:12:34:56, length 28</span><br><span class="line">        0x0000:  ffff ffff ffff 5254 0012 3456 0806 0001  ......RT..4V....</span><br><span class="line">        0x0010:  0800 0604 0002 5254 0012 3456 0a00 020f  ......RT..4V....</span><br><span class="line">        0x0020:  5255 0a00 0202 0a00 0202                 RU........</span><br><span class="line">15:27:40.863036 IP 10.0.2.2.25603 &gt; 10.0.2.15.2000: UDP, length 17</span><br><span class="line">        0x0000:  5254 0012 3456 5255 0a00 0202 0800 4500  RT..4VRU......E.</span><br><span class="line">        0x0010:  002d 0000 0000 4011 62b0 0a00 0202 0a00  .-....@.b.......</span><br><span class="line">        0x0020:  020f 6403 07d0 0019 3406 7468 6973 2069  ..d.....4.this.i</span><br><span class="line">        0x0030:  7320 7468 6520 686f 7374 21              s.the.host!</span><br></pre></td></tr></table></figure>

<p>你的输出会有些不同，但它应该包含字符串 “ARP, Request”（ARP 请求），”ARP, Reply”（ARP 回复），”UDP”，”a.message.from.xv6” 和 “this.is.the.host”。</p>
<p><code>nettests</code> 还执行了一些其他测试，最终通过（真实的）互联网向谷歌的某个域名服务器发送了一个 DNS 请求。你应该确保你的代码通过了所有这些测试，之后你应该会看到以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ nettests</span><br><span class="line">nettests running on port 25603</span><br><span class="line">testing ping: OK</span><br><span class="line">testing single-process pings: OK</span><br><span class="line">testing multi-process pings: OK</span><br><span class="line">testing DNS</span><br><span class="line">DNS arecord for pdos.csail.mit.edu. is 128.52.129.126</span><br><span class="line">DNS OK</span><br><span class="line">all tests passed.</span><br></pre></td></tr></table></figure>

<p>你应该确保让分数同意你的解决方案通过。</p>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>首先，在 <code>e1000_transmit()</code> 和 <code>e1000_recv()</code> 中添加打印语句，然后运行 <code>make server</code> 和（在 xv6 中）<code>nettests</code>。你应该从打印语句中看到 <code>nettests</code> 生成了对 <code>e1000_transmit</code> 的调用。实现 <code>e1000_transmit</code> 的一些提示：</p>
<ol>
<li>首先询问 E1000 下一个期望的数据包将放在 TX 环的哪个索引位置，通过读取 <code>E1000_TDT</code> 控制寄存器来实现。</li>
<li>然后检查环是否溢出。如果 <code>E1000_TDT</code> 索引的描述符中没有设置 <code>E1000_TXD_STAT_DD</code>，则 E1000 尚未完成相应的之前的传输请求，因此返回一个错误。</li>
<li>否则，使用 <code>mbuffree()</code> 释放从该描述符传输的最后一个 <code>mbuf</code>（如果有的话）。</li>
<li>然后填写描述符。<code>m-&gt;head</code> 指向内存中数据包的内容，<code>m-&gt;len</code> 是数据包长度。设置必要的 cmd 标志（查看 E1000 手册的第 3.3 节）并保存一个指向 <code>mbuf</code> 的指针以便以后释放。</li>
<li>最后，通过向 <code>E1000_TDT</code> 加一模 <code>TX_RING_SIZE</code> 来更新环位置。</li>
<li>如果 <code>e1000_transmit()</code> 成功将 <code>mbuf</code> 添加到环中，则返回 0。如果失败（例如，没有可用的描述符来传输 <code>mbuf</code>），则返回 -1，以便调用者知道要释放 <code>mbuf</code>。</li>
</ol>
<p>实现 <code>e1000_recv</code> 的一些提示：</p>
<ol>
<li>首先通过获取 <code>E1000_RDT</code> 控制寄存器并加一模 <code>RX_RING_SIZE</code> 来询问 E1000 下一个等待接收的数据包（如果有的话）位于环的哪个索引位置。</li>
<li>然后通过检查描述符的状态部分中的 <code>E1000_RXD_STAT_DD</code> 位来检查是否有新数据包可用。如果没有，停止。</li>
<li>否则，将 <code>mbuf</code> 的 <code>m-&gt;len</code> 更新为描述符报告的长度。使用 <code>net_rx()</code> 将 <code>mbuf</code> 交给网络栈。</li>
<li>然后使用 <code>mbufalloc()</code> 分配一个新的 <code>mbuf</code> 来替换刚刚给 <code>net_rx()</code> 的那个。将其数据指针（<code>m-&gt;head</code>）编程到描述符中。将描述符的状态位清零。</li>
<li>最后，将 <code>E1000_RDT</code> 寄存器更新为最后处理的环描述符的索引。</li>
</ol>
<p><code>e1000_init()</code> 使用 <code>mbufs</code> 初始化 RX 环，你将需要查看它是如何做到的，并可能借用代码。在某个时刻，到达的数据包总数将超过环的大小（16）；确保你的代码能够处理这个情况。你将需要锁来应对 xv6 可能从多个进程使用 E1000，或者在中断到达时在内核线程中使用 E1000 的可能性。</p>
<h2 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h2><p>跟着提示一步一步的走就好</p>
<h3 id="E1000-transmit"><a href="#E1000-transmit" class="headerlink" title="E1000_transmit"></a>E1000_transmit</h3><h4 id="1-首先询问-E1000-下一个期望的数据包将放在-TX-环的哪个索引位置，通过读取-E1000-TDT-控制寄存器来实现。"><a href="#1-首先询问-E1000-下一个期望的数据包将放在-TX-环的哪个索引位置，通过读取-E1000-TDT-控制寄存器来实现。" class="headerlink" title="1.首先询问 E1000 下一个期望的数据包将放在 TX 环的哪个索引位置，通过读取 E1000_TDT 控制寄存器来实现。"></a>1.首先询问 E1000 下一个期望的数据包将放在 TX 环的哪个索引位置，通过读取 <code>E1000_TDT</code> 控制寄存器来实现。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acquire(&amp;e1000_lock); <span class="comment">// 请求锁</span></span><br><span class="line"><span class="type">int</span> index = regs[E1000_TDT]; <span class="comment">// 寄存器 E1000_TDT 中存储了第一个软件可以写入的描述符的位置</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span> * <span class="title">tail_desc</span> =</span> &amp; tx_ring[index]; <span class="comment">// 拿到可用的文件描述符</span></span><br></pre></td></tr></table></figure>

<h4 id="2-然后检查环是否溢出。如果-E1000-TDT-索引的描述符中没有设置-E1000-TXD-STAT-DD，则-E1000-尚未完成相应的之前的传输请求，因此返回一个错误。"><a href="#2-然后检查环是否溢出。如果-E1000-TDT-索引的描述符中没有设置-E1000-TXD-STAT-DD，则-E1000-尚未完成相应的之前的传输请求，因此返回一个错误。" class="headerlink" title="2.然后检查环是否溢出。如果 E1000_TDT 索引的描述符中没有设置 E1000_TXD_STAT_DD，则 E1000 尚未完成相应的之前的传输请求，因此返回一个错误。"></a>2.然后检查环是否溢出。如果 <code>E1000_TDT</code> 索引的描述符中没有设置 <code>E1000_TXD_STAT_DD</code>，则 E1000 尚未完成相应的之前的传输请求，因此返回一个错误。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((tail_desc-&gt;status &amp; E1000_TXD_STAT_DD) == <span class="number">0</span>) &#123; </span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-否则，使用-mbuffree-释放从该描述符传输的最后一个-mbuf（如果有的话）。"><a href="#3-否则，使用-mbuffree-释放从该描述符传输的最后一个-mbuf（如果有的话）。" class="headerlink" title="3.否则，使用 mbuffree() 释放从该描述符传输的最后一个 mbuf（如果有的话）。"></a>3.否则，使用 <code>mbuffree()</code> 释放从该描述符传输的最后一个 <code>mbuf</code>（如果有的话）。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tx_mbufs[index]) &#123;</span><br><span class="line">  mbuffree(tx_mbufs[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-然后填写描述符。m-gt-head-指向内存中数据包的内容，m-gt-len-是数据包长度。设置必要的-cmd-标志（查看-E1000-手册的第-3-3-节）并保存一个指向-mbuf-的指针以便以后释放。"><a href="#4-然后填写描述符。m-gt-head-指向内存中数据包的内容，m-gt-len-是数据包长度。设置必要的-cmd-标志（查看-E1000-手册的第-3-3-节）并保存一个指向-mbuf-的指针以便以后释放。" class="headerlink" title="4.然后填写描述符。m-&gt;head 指向内存中数据包的内容，m-&gt;len 是数据包长度。设置必要的 cmd 标志（查看 E1000 手册的第 3.3 节）并保存一个指向 mbuf 的指针以便以后释放。"></a>4.然后填写描述符。<code>m-&gt;head</code> 指向内存中数据包的内容，<code>m-&gt;len</code> 是数据包长度。设置必要的 cmd 标志（查看 E1000 手册的第 3.3 节）并保存一个指向 <code>mbuf</code> 的指针以便以后释放。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail_desc-&gt;length = m-&gt;len; <span class="comment">// 数据包的长度</span></span><br><span class="line">tail_desc-&gt;addr = (uint64)m-&gt;head; <span class="comment">// 数据包在缓存中的起始位置</span></span><br><span class="line">tail_desc-&gt;cmd |= E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS; <span class="comment">// cmd位，end of packet, report status</span></span><br></pre></td></tr></table></figure>

<h4 id="5-最后，将-E1000-RDT-寄存器更新为最后处理的环描述符的索引。"><a href="#5-最后，将-E1000-RDT-寄存器更新为最后处理的环描述符的索引。" class="headerlink" title="5.最后，将 E1000_RDT 寄存器更新为最后处理的环描述符的索引。"></a>5.最后，将 <code>E1000_RDT</code> 寄存器更新为最后处理的环描述符的索引。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">regs[E1000_RDT] = (index + <span class="number">1</span>) % tx_ring; <span class="comment">// 更新index</span></span><br><span class="line">release(&amp;e1000_lock); <span class="comment">// 释放锁</span></span><br></pre></td></tr></table></figure>

<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">e1000_transmit</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// the mbuf contains an ethernet frame; program it into</span></span><br><span class="line">  <span class="comment">// the TX descriptor ring so that the e1000 sends it. Stash</span></span><br><span class="line">  <span class="comment">// a pointer so that it can be freed after sending.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  acquire(&amp;e1000_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * todo: ask the E1000 for the TX ring index at which it&#x27;s expecting the next packet</span></span><br><span class="line"><span class="comment">   * E1000_TDT 指向 tx_ring 中下一个可以被分配的 descriptor 的索引</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> index = regs[E1000_TDT];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span>* <span class="title">tail_desc</span> =</span> &amp;tx_ring[index];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * todo: check if the ring is overflow</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">  <span class="keyword">if</span>((tail_desc-&gt;status &amp; E1000_TXD_STAT_DD) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//      printf(&quot;tx_ring buffer is overflow\n&quot;);</span></span><br><span class="line">      release(&amp;e1000_lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * todo: use mbuffree() to free the last mbuf that was transmitted from that descriptor</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">  <span class="keyword">if</span>(tx_mbufs[index]) &#123;</span><br><span class="line">      mbuffree(tx_mbufs[index]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// todo: m-&gt;head points to the packet&#x27;s content in memory,</span></span><br><span class="line">  tail_desc-&gt;addr = (uint64)(m-&gt;head);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// todo: m-&gt;len is the packet length</span></span><br><span class="line">  tail_desc-&gt;length = m-&gt;len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// todo: set the necessary cmd flag (look at Section 3.3 in the E1000 manual)</span></span><br><span class="line">  tail_desc-&gt;cmd |= E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// todo: stash away a pointer to the mbuf for later freeing.</span></span><br><span class="line">  tx_mbufs[index] = m;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// todo: update the E1000_TDT</span></span><br><span class="line">  regs[E1000_TDT] = (index + <span class="number">1</span>) % TX_RING_SIZE;</span><br><span class="line">  <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="E1000-recv"><a href="#E1000-recv" class="headerlink" title="E1000_recv"></a>E1000_recv</h3><p>我们要注意的是，在接收数据包时，不是一个一个接收的，所以我们要不断更新index，需要接收的包都接收完毕为止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"> ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-首先通过获取-E1000-RDT-控制寄存器并加一模-RX-RING-SIZE-来询问-E1000-下一个等待接收的数据包（如果有的话）位于环的哪个索引位置。"><a href="#1-首先通过获取-E1000-RDT-控制寄存器并加一模-RX-RING-SIZE-来询问-E1000-下一个等待接收的数据包（如果有的话）位于环的哪个索引位置。" class="headerlink" title="1.首先通过获取 E1000_RDT 控制寄存器并加一模 RX_RING_SIZE 来询问 E1000 下一个等待接收的数据包（如果有的话）位于环的哪个索引位置。"></a>1.首先通过获取 <code>E1000_RDT</code> 控制寄存器并加一模 <code>RX_RING_SIZE</code> 来询问 E1000 下一个等待接收的数据包（如果有的话）位于环的哪个索引位置。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint32 index = (regs[E1000_RDT] + <span class="number">1</span>) % RX_RING_SIZE; <span class="comment">// fetch the index</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rx_desc</span> *<span class="title">des</span> =</span> &amp;rx_ring[index]; <span class="comment">// fetch the desc</span></span><br></pre></td></tr></table></figure>

<h4 id="2-然后通过检查描述符的状态部分中的-E1000-RXD-STAT-DD-位来检查是否有新数据包可用。如果没有，停止。"><a href="#2-然后通过检查描述符的状态部分中的-E1000-RXD-STAT-DD-位来检查是否有新数据包可用。如果没有，停止。" class="headerlink" title="2.然后通过检查描述符的状态部分中的 E1000_RXD_STAT_DD 位来检查是否有新数据包可用。如果没有，停止。"></a>2.然后通过检查描述符的状态部分中的 <code>E1000_RXD_STAT_DD</code> 位来检查是否有新数据包可用。如果没有，停止。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(des-&gt;status &amp; E1000_RXD_STAT_DD)) &#123; <span class="comment">// 如果当前描述符的状态为不可用，则停止</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-否则，将-mbuf-的-m-gt-len-更新为描述符报告的长度。使用-net-rx-将-mbuf-交给网络栈。"><a href="#3-否则，将-mbuf-的-m-gt-len-更新为描述符报告的长度。使用-net-rx-将-mbuf-交给网络栈。" class="headerlink" title="3.否则，将 mbuf 的 m-&gt;len 更新为描述符报告的长度。使用 net_rx() 将 mbuf 交给网络栈。"></a>3.否则，将 <code>mbuf</code> 的 <code>m-&gt;len</code> 更新为描述符报告的长度。使用 <code>net_rx()</code> 将 <code>mbuf</code> 交给网络栈。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">buf</span> =</span> rx_mbufs[index];</span><br><span class="line">buf-&gt;len = des-&gt;length;</span><br><span class="line">net_rx(buf);</span><br></pre></td></tr></table></figure>

<h4 id="4-然后使用-mbufalloc-分配一个新的-mbuf-来替换刚刚给-net-rx-的那个。将其数据指针（m-gt-head）编程到描述符中。将描述符的状态位清零。"><a href="#4-然后使用-mbufalloc-分配一个新的-mbuf-来替换刚刚给-net-rx-的那个。将其数据指针（m-gt-head）编程到描述符中。将描述符的状态位清零。" class="headerlink" title="4.然后使用 mbufalloc() 分配一个新的 mbuf 来替换刚刚给 net_rx() 的那个。将其数据指针（m-&gt;head）编程到描述符中。将描述符的状态位清零。"></a>4.然后使用 <code>mbufalloc()</code> 分配一个新的 <code>mbuf</code> 来替换刚刚给 <code>net_rx()</code> 的那个。将其数据指针（<code>m-&gt;head</code>）编程到描述符中。将描述符的状态位清零。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">new_buf</span> =</span> mbufalloc(<span class="number">0</span>);</span><br><span class="line">rx_mbufs[index] = new_buf;</span><br><span class="line">des-&gt;addr = (uint64)new_buf-&gt;head;</span><br><span class="line">des-&gt;status = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="5-最后，将-E1000-RDT-寄存器更新为最后处理的环描述符的索引。-1"><a href="#5-最后，将-E1000-RDT-寄存器更新为最后处理的环描述符的索引。-1" class="headerlink" title="5.最后，将 E1000_RDT 寄存器更新为最后处理的环描述符的索引。"></a>5.最后，将 <code>E1000_RDT</code> 寄存器更新为最后处理的环描述符的索引。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regs[E1000_RDT] = index;</span><br></pre></td></tr></table></figure>

<h4 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">e1000_recv</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Check for packets that have arrived from the e1000</span></span><br><span class="line">  <span class="comment">// Create and deliver an mbuf for each packet (using net_rx()).</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// todo: First ask the E1000 for the ring index at which the next waiting received packet (if any) is located,</span></span><br><span class="line">      <span class="comment">// todo: by fetching the E1000_RDT control register and adding one modulo RX_RING_SIZE.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">// todo: check if a new packet is available by checking for the E1000_RXD_STAT_DD bit in the status portion of the descriptor.</span></span><br><span class="line">      uint32 index = (regs[E1000_RDT] + <span class="number">1</span>) % RX_RING_SIZE; <span class="comment">// fetch the index</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">rx_desc</span> *<span class="title">des</span> =</span> &amp;rx_ring[index];</span><br><span class="line">      <span class="keyword">if</span>(!(des-&gt;status &amp; E1000_RXD_STAT_DD)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// todo: update the mbuf&#x27;s m-&gt;len to the length reported in the descriptor. Deliver the mbuf to the network stack using net_rx().</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">buf</span> =</span> rx_mbufs[index];</span><br><span class="line">      buf-&gt;len = des-&gt;length;</span><br><span class="line">      net_rx(buf);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// todo: Then allocate a new mbuf using mbufalloc() to replace the one just given to net_rx().</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">new_buf</span> =</span> mbufalloc(<span class="number">0</span>);</span><br><span class="line">      rx_mbufs[index] = new_buf;</span><br><span class="line">      <span class="comment">// todo: Program its data pointer (m-&gt;head) into the descriptor. Clear the descriptor&#x27;s status bits to zero.</span></span><br><span class="line">      des-&gt;addr = (uint64)new_buf-&gt;head;</span><br><span class="line">      des-&gt;status = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// todo: Finally, update the E1000_RDT register to be the index of the last ring descriptor processed.</span></span><br><span class="line">      regs[E1000_RDT] = index;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/15/Lab-Multithreading/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/15/Lab-Multithreading/" class="post-title-link" itemprop="url">Lab: Multithreading
</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-15 11:40:44" itemprop="dateCreated datePublished" datetime="2024-03-15T11:40:44+08:00">2024-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-17 11:29:05" itemprop="dateModified" datetime="2024-03-17T11:29:05+08:00">2024-03-17</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab-Multithreading"><a href="#Lab-Multithreading" class="headerlink" title="Lab: Multithreading"></a>Lab: Multithreading</h1><p>这个实验室将帮助你熟悉多线程编程。你将在用户级线程包中实现线程间的切换，使用多个线程加速程序，并实现一个屏障。</p>
<h2 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h2><p>在这个练习中，你将为用户级线程系统设计上下文切换机制，并实现它。为了帮助你开始，你的 xv6 包含两个文件：user&#x2F;uthread.c 和 user&#x2F;uthread_switch.S，以及 Makefile 中构建 uthread 程序的规则。uthread.c 包含了大部分用户级线程包的代码，以及三个简单测试线程的代码。线程包缺少一些创建线程和线程间切换的代码。</p>
<blockquote>
<p>你的任务是制定一个计划来创建线程，并保存&#x2F;恢复寄存器以便于线程间切换，然后实现该计划。完成后，运行 make grade 应该会显示你的解决方案通过了 uthread 测试。</p>
</blockquote>
<p>一旦你完成了任务，当你在 xv6 上运行 uthread 时，你应该会看到以下输出（三个线程可能会以不同的顺序启动）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make qemu</span></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">uthread</span></span><br><span class="line">thread_a started</span><br><span class="line">thread_b started</span><br><span class="line">thread_c started</span><br><span class="line">thread_c 0</span><br><span class="line">thread_a 0</span><br><span class="line">thread_b 0</span><br><span class="line">thread_c 1</span><br><span class="line">thread_a 1</span><br><span class="line">thread_b 1</span><br><span class="line">...</span><br><span class="line">thread_c 99</span><br><span class="line">thread_a 99</span><br><span class="line">thread_b 99</span><br><span class="line">thread_c: exit after 100</span><br><span class="line">thread_a: exit after 100</span><br><span class="line">thread_b: exit after 100</span><br><span class="line">thread_schedule: no runnable threads</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>

<p>这个输出来自三个测试线程，每个线程都有一个循环，打印一行，然后将 CPU 让给其他线程。</p>
<p>然而，在这一点上，由于没有上下文切换代码，你将看不到任何输出。</p>
<p>你需要在 <code>user/uthread.c</code> 中的 <code>thread_create()</code> 和 <code>thread_schedule()</code> 以及 <code>user/uthread_switch.S</code> 中的 <code>thread_switch</code> 添加代码。一个目标是确保当 <code>thread_schedule()</code> 首次运行给定线程时，该线程在自己的栈上执行传递给 <code>thread_create()</code> 的函数。另一个目标是确保 <code>thread_switch</code> 保存被切换的线程的寄存器，恢复被切换到的线程的寄存器，并返回到后者线程的指令中它上次停止的点。你将需要决定在哪里保存&#x2F;恢复寄存器；修改 <code>struct thread</code> 来保存寄存器是一个好计划。你需要在 <code>thread_schedule</code> 中添加对 <code>thread_switch</code> 的调用；你可以传递任何你需要的参数给 <code>thread_switch</code>，但意图是从线程 <code>t</code> 切换到 <code>next_thread</code>。</p>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul>
<li><p><code>thread_switch</code>只需要保存&#x2F;恢复<code>callee-save registers</code>。为什么？</p>
</li>
<li><p>在<code>user/uthread.asm</code>，你可以查看<code>uthread</code>的汇编代码，这可能对调试很方便。</p>
</li>
<li><p>检测代码可以单步执行<code>thread_switch</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) file user/_uthread</span><br><span class="line">Reading symbols from user/_uthread...</span><br><span class="line">(gdb) b uthread.c:60</span><br></pre></td></tr></table></figure>

<p>这在uthread.c的第60行设置了一个断点。断点可能会在您运行uthread之前触发（也可能不会）触发。这怎么可能发生？</p>
<p>一旦你的 xv6 shell 运行起来，输入 “uthread”，gdb 将会在第60行处中断。如果你从另一个进程中击中了断点，继续进行，直到在 uthread 进程中击中断点。现在，你可以输入如下命令来检查 uthread 的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p/x *next_thread</span><br></pre></td></tr></table></figure>

<p>使用 “x”，你可以检查内存位置的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/x next_thread-&gt;stack</span><br></pre></td></tr></table></figure>

<p>你可以这样跳到 thread_switch 的开始部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b thread_switch</span><br><span class="line">(gdb) c</span><br></pre></td></tr></table></figure>

<p>You can single step assembly instructions using:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) si</span><br></pre></td></tr></table></figure>

<p>On-line documentation for gdb is here.</p>
</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><code>thread</code>的本质就是共享内存的<code>process</code>，因此我们可以根据<code>process</code>中对应的<code>swtch.S</code>，<code>allocpro()</code>，<code>struct context context</code>进行修改即可。</p>
<p><code>struct context</code>中直接声明了我们需要保存的<code>callee-saved register</code>，直接将定义搬到<code>uthread.c</code>中，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Saved registers for kernel context switches.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>并为<code>struct thread</code>添加相应字段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>       <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/* the thread&#x27;s stack */</span></span><br><span class="line">  <span class="type">int</span>        state;             <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>       <span class="comment">/* the thread&#x27;s context */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>直接将<code>switch.S</code>复制到<code>uthread_switch.c</code>中，并在<code>thread_schedule()</code>中添加：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread_switch((uint64)&amp;(t-&gt;context), (uint64)&amp;(current_thread-&gt;context));</span><br></pre></td></tr></table></figure>

<h2 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h2><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/12/xv6-interrputs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/12/xv6-interrputs/" class="post-title-link" itemprop="url">xv6-interrputs</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-12 18:59:14 / 修改时间：19:00:11" itemprop="dateCreated datePublished" datetime="2024-03-12T18:59:14+08:00">2024-03-12</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/08/Lab-Copy-on-Write-Fork-for-xv6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/08/Lab-Copy-on-Write-Fork-for-xv6/" class="post-title-link" itemprop="url">Lab: Copy-on-Write Fork for xv6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-08 20:03:25" itemprop="dateCreated datePublished" datetime="2024-03-08T20:03:25+08:00">2024-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 18:22:00" itemprop="dateModified" datetime="2024-03-12T18:22:00+08:00">2024-03-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>30k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>27 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab-Copy-on-Write-Fork-for-xv6"><a href="#Lab-Copy-on-Write-Fork-for-xv6" class="headerlink" title="Lab: Copy-on-Write Fork for xv6"></a>Lab: Copy-on-Write Fork for xv6</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们先说一下整个流程</p>
<p>设备驱动器也会产生中断，这也是一种陷阱。</p>
<p>许多设备驱动器在两种上下文中执行代码：</p>
<ul>
<li><code>top half</code>运行在进程的内核线程上。上半部分是通过诸如read和write这样的系统调用来调用的，这些调用希望设备执行I&#x2F;O操作。</li>
<li><code>bottom half</code>是驱动器中断处理程序。</li>
</ul>
<h3 id="5-1-Code-Console-input"><a href="#5-1-Code-Console-input" class="headerlink" title="5.1 Code: Console input"></a>5.1 Code: Console input</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户键入字符 =&gt; RISC-V 上的 UART 串行接口 =&gt; console 驱动器 </span><br></pre></td></tr></table></figure>

<p><code>UART</code>硬件对于软件来说是一组内存映射控制寄存器,<code>RISC-V</code>硬件有一些物理地址链接<code>UART</code>设备</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main() = call =&gt;		 	consoleinit 	   =&gt;</span><br><span class="line">            		 |initialize the UART|</span><br></pre></td></tr></table></figure>

<p><code>consoleinit</code>初始化UART硬件，配置<code>UART</code>在接收到字节输入时，产生一个接收中断<code>receive interrupt</code>；在完成输出一个字节的数据时，产生一个传输中断，<code>transmit interrput</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">init.c = open =&gt; file descriptor for console (fp)</span><br><span class="line"></span><br><span class="line">xv6 shell reads from fp</span><br><span class="line"></span><br><span class="line">= call =&gt; read() = invoke =&gt; consoleread() </span><br><span class="line"></span><br><span class="line">consoleread() wait for input arrive (via interrupt) and be buffered in cons.buf</span><br></pre></td></tr></table></figure>

<p>中断是如何产生的？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用户键入字符 =&gt; UART =&gt; 让RISC-V产生中断 =&gt; 激活xv6陷阱处理程序 trap handler</span><br><span class="line"></span><br><span class="line">trap handler = invoke =&gt; devintr() = 在 scause 寄存器中发现中断来自额外设备</span><br><span class="line"></span><br><span class="line">硬件唤醒 PLIC 告知哪个设备产生的中断，如果是UART devintr 调用 uartintr</span><br></pre></td></tr></table></figure>

<p>数据如何输入的？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uartintr = 从UART硬件的等待输入字符中读取并传输给 =&gt; consoleintr</span><br><span class="line"></span><br><span class="line">consoleintr 将输入的字符存入cons.buf中，直到一行输入完成。</span><br><span class="line"></span><br><span class="line">当一个新的行到达时，consoleintr 唤醒 consoleread</span><br></pre></td></tr></table></figure>



<h3 id="kernelvec-S"><a href="#kernelvec-S" class="headerlink" title="kernelvec.S:"></a><code>kernelvec.S</code>:</h3><h4 id="kernelvec"><a href="#kernelvec" class="headerlink" title="kernelvec"></a><code>kernelvec</code></h4><p>当处于<code>Supervisor mode</code>时，中断<code>interrupts</code>和异常<code>exception</code>会来到这里。</p>
<p>当前堆栈为<code>kernel stack</code>。将所有寄存器的值推入栈中，调用<code>kerneltrap()</code>，调用完成时恢复寄存器然后返回。</p>
<blockquote>
<p>这段注释是关于寄存器<code>tp</code>（Thread Pointer）的说明，它通常包含当前硬件线程的ID（hartid）。注释指出不使用<code>tp</code>寄存器的值，以防在中断或异常发生后处理器（CPU）发生了变化。</p>
<p>在多核心或多线程的CPU环境中，每个核心或线程有一个唯一的标识符，通常称为hartid。当一个核心或线程正在执行任务时，它可能会因为中断或调度策略而切换到另一个CPU。如果在中断处理或任务切换过程中代码依赖于特定的<code>tp</code>值，而这个值在不同的CPU之间是不同的，就可能出现问题。</p>
<p>因此，这段注释表明，由于可能会发生CPU切换，代码不应该假设<code>tp</code>寄存器中的hartid在处理过程中是不变的。这是在多核处理器环境中进行系统编程时需要注意的并发和一致性问题之一。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">.globl kerneltrap</span><br><span class="line">.globl kernelvec</span><br><span class="line">.align 4</span><br><span class="line">kernelvec:</span><br><span class="line">        # make room to save registers.</span><br><span class="line">        # 在栈中开辟空间</span><br><span class="line">        addi sp, sp, -256</span><br><span class="line"></span><br><span class="line">        # save the registers.</span><br><span class="line">        sd ra, 0(sp)</span><br><span class="line">        sd sp, 8(sp)	# 保存stack pointer</span><br><span class="line">        sd gp, 16(sp)</span><br><span class="line">        sd tp, 24(sp)</span><br><span class="line">        sd t0, 32(sp)</span><br><span class="line">        sd t1, 40(sp)</span><br><span class="line">        sd t2, 48(sp)</span><br><span class="line">        sd s0, 56(sp)</span><br><span class="line">        sd s1, 64(sp)</span><br><span class="line">        sd a0, 72(sp)</span><br><span class="line">        sd a1, 80(sp)</span><br><span class="line">        sd a2, 88(sp)</span><br><span class="line">        sd a3, 96(sp)</span><br><span class="line">        sd a4, 104(sp)</span><br><span class="line">        sd a5, 112(sp)</span><br><span class="line">        sd a6, 120(sp)</span><br><span class="line">        sd a7, 128(sp)</span><br><span class="line">        sd s2, 136(sp)</span><br><span class="line">        sd s3, 144(sp)</span><br><span class="line">        sd s4, 152(sp)</span><br><span class="line">        sd s5, 160(sp)</span><br><span class="line">        sd s6, 168(sp)</span><br><span class="line">        sd s7, 176(sp)</span><br><span class="line">        sd s8, 184(sp)</span><br><span class="line">        sd s9, 192(sp)</span><br><span class="line">        sd s10, 200(sp)</span><br><span class="line">        sd s11, 208(sp)</span><br><span class="line">        sd t3, 216(sp)</span><br><span class="line">        sd t4, 224(sp)</span><br><span class="line">        sd t5, 232(sp)</span><br><span class="line">        sd t6, 240(sp)</span><br><span class="line"></span><br><span class="line">        # call the C trap handler in trap.c</span><br><span class="line">        call kerneltrap</span><br><span class="line"></span><br><span class="line">        # restore registers.</span><br><span class="line">        ld ra, 0(sp)</span><br><span class="line">        ld sp, 8(sp)</span><br><span class="line">        ld gp, 16(sp)</span><br><span class="line">        # not tp (contains hartid), in case we moved CPUs</span><br><span class="line">        # thread pointer 是当前硬件线程的ID hartid</span><br><span class="line">        </span><br><span class="line">        ld t0, 32(sp)</span><br><span class="line">        ld t1, 40(sp)</span><br><span class="line">        ld t2, 48(sp)</span><br><span class="line">        ld s0, 56(sp)</span><br><span class="line">        ld s1, 64(sp)</span><br><span class="line">        ld a0, 72(sp)</span><br><span class="line">        ld a1, 80(sp)</span><br><span class="line">        ld a2, 88(sp)</span><br><span class="line">        ld a3, 96(sp)</span><br><span class="line">        ld a4, 104(sp)</span><br><span class="line">        ld a5, 112(sp)</span><br><span class="line">        ld a6, 120(sp)</span><br><span class="line">        ld a7, 128(sp)</span><br><span class="line">        ld s2, 136(sp)</span><br><span class="line">        ld s3, 144(sp)</span><br><span class="line">        ld s4, 152(sp)</span><br><span class="line">        ld s5, 160(sp)</span><br><span class="line">        ld s6, 168(sp)</span><br><span class="line">        ld s7, 176(sp)</span><br><span class="line">        ld s8, 184(sp)</span><br><span class="line">        ld s9, 192(sp)</span><br><span class="line">        ld s10, 200(sp)</span><br><span class="line">        ld s11, 208(sp)</span><br><span class="line">        ld t3, 216(sp)</span><br><span class="line">        ld t4, 224(sp)</span><br><span class="line">        ld t5, 232(sp)</span><br><span class="line">        ld t6, 240(sp)</span><br><span class="line"></span><br><span class="line">        addi sp, sp, 256</span><br><span class="line"></span><br><span class="line">        # return to whatever we were doing in the kernel.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>

<h4 id="timervec"><a href="#timervec" class="headerlink" title="timervec:"></a><code>timervec:</code></h4><p><code>start.c</code>已经设置了<code>mscratch</code>指向的地址：</p>
<ul>
<li><code>scratch[0, 8, 16]:</code>存储寄存器的值</li>
<li><code>scratch[24]:</code>保存了CLINT的<code>MTIMECMP</code>寄存器的地址。<code>MTIMECMP</code>寄存器用于设置RISC-V系统的定时器中断阈值。</li>
<li><code>scratch[32]:</code>保存中断之间的期望时间间隔</li>
</ul>
<p>**<code>MTIMECMP</code>**是一个RISC-V架构中的一个定时寄存器，其全称为<code>Machine Time Compare Register</code>，该寄存器是<code>RISC-V</code>的机器模式定时器的一部分，用于设置下一个定时器中断的时间阈值。</p>
<p>工作原理：</p>
<ul>
<li>RISC-V 的 <code>mtime</code> 寄存器持续增加，它通常代表着机器的实时计数器，按照固定的频率（通常与处理器的时钟频率一致）递增。</li>
<li>当 <code>mtime</code> 的值等于或超过 <code>MTIMECMP</code> 寄存器中设置的值时，会触发一个定时器中断。</li>
<li>中断服务程序可以通过设置 <code>MTIMECMP</code> 为 <code>mtime</code> 当前值加上期望的延迟，来安排下一次中断。</li>
</ul>
<p>在多核 RISC-V 系统中，每个处理器核心（hart）通常有它自己的 <code>MTIMECMP</code> 寄存器，允许独立地为每个核心安排中断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># machine-mode timer interrupt.</span><br><span class="line">#</span><br><span class="line">.globl timervec</span><br><span class="line">.align 4</span><br><span class="line">timervec:</span><br><span class="line">        # start.c has set up the memory that mscratch points to:</span><br><span class="line">        # scratch[0,8,16] : register save area.</span><br><span class="line">        # scratch[24] : address of CLINT&#x27;s MTIMECMP register.</span><br><span class="line">        # scratch[32] : desired interval between interrupts.</span><br><span class="line">        </span><br><span class="line">        csrrw a0, mscratch, a0 # 读取mscratch寄存器的值到a0，并将a0的旧值写回mscratch</span><br><span class="line">        sd a1, 0(a0)</span><br><span class="line">        sd a2, 8(a0)</span><br><span class="line">        sd a3, 16(a0)</span><br><span class="line"></span><br><span class="line">        # schedule the next timer interrupt</span><br><span class="line">        # by adding interval to mtimecmp.</span><br><span class="line">        ld a1, 24(a0) # CLINT_MTIMECMP(hart)</span><br><span class="line">        ld a2, 32(a0) # interval</span><br><span class="line">        ld a3, 0(a1)  # 加载当前MTIMECMP的值到a3</span><br><span class="line">        add a3, a3, a2 # 将中断间隔时间加载到MTIMECMP上，准备下一个中断</span><br><span class="line">        sd a3, 0(a1) # 新的MTIMECMP存回到相应的内存位置</span><br><span class="line"></span><br><span class="line">        # arrange for a supervisor software interrupt</span><br><span class="line">        # after this handler returns.</span><br><span class="line">        li a1, 2 	# 2表示软件中断</span><br><span class="line">        csrw sip, a1 # 将软件中断请求写入sip寄存器中</span><br><span class="line"></span><br><span class="line">				# 恢复现场</span><br><span class="line">        ld a3, 16(a0)</span><br><span class="line">        ld a2, 8(a0)</span><br><span class="line">        ld a1, 0(a0)</span><br><span class="line">        csrrw a0, mscratch, a0</span><br><span class="line"></span><br><span class="line">        mret</span><br></pre></td></tr></table></figure>

<h3 id="plic-c-the-RISC-V-Platform-Level-Interrupt-Controller-PLIC"><a href="#plic-c-the-RISC-V-Platform-Level-Interrupt-Controller-PLIC" class="headerlink" title="plic.c: the RISC-V Platform Level Interrupt Controller (PLIC)"></a><code>plic.c:</code> the RISC-V Platform Level Interrupt Controller (PLIC)</h3><p>这段代码对应的硬件设备说明在<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2023/readings/FU540-C000-v1.0.pdf%E7%9A%8460%E9%A1%B5">https://pdos.csail.mit.edu/6.828/2023/readings/FU540-C000-v1.0.pdf的60页</a></p>
<p>给出了<code>PLIC Register Map</code></p>
<h4 id="plicinit"><a href="#plicinit" class="headerlink" title="plicinit():"></a><code>plicinit():</code></h4><ul>
<li><code>PLIC = 0x0c000000</code>是PLIC控制寄存器在物理内存中的起始地址。通过这个地址进行内存映射输入输出的操作。</li>
<li>设置UART0中断优先级</li>
<li>设为VIRTIO0设备的中断优先级</li>
<li>乘4是因为寄存器的值是32位的</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">plicinit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// set desired IRQ priorities non-zero (otherwise disabled).</span></span><br><span class="line">  	<span class="comment">// 设置中断请求优先级</span></span><br><span class="line">    *(uint32*)(PLIC + UART0_IRQ*<span class="number">4</span>) = <span class="number">1</span>;</span><br><span class="line">    *(uint32*)(PLIC + VIRTIO0_IRQ*<span class="number">4</span>) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="plicinithart"><a href="#plicinithart" class="headerlink" title="plicinithart():"></a><code>plicinithart():</code></h4><p>初始化了每个处理器核心（hart）在平台级中断控制器（PLIC）中的设置，具体操作包括启用特定的中断并设置优先级。</p>
<ul>
<li><p><code>PLIC_SENABLE(hart)</code>宏通过给定的核心编号（hart）和以上规则，计算出该核心对应到的<code>supervisor mode</code>中断启用寄存器的地址。</p>
<p>当<code>hart = 0</code>时，我们使用PLIC_SENABLE计算出物理地址<code>0x0c00_2080</code>，通过<code>PLIC Register Map</code>可知：</p>
<p><img src="/../images/Lab-Copy-on-Write-Fork-for-xv6/%E6%88%AA%E5%B1%8F2024-03-08%2019.48.22.png" alt="截屏2024-03-08 19.48.22"></p>
<p>也即使能核心0在Machine mode下的全局中断1</p>
<p>查表发现PLIC_SPRIORITY对应的地址：</p>
<p><img src="/../images/Lab-Copy-on-Write-Fork-for-xv6/%E6%88%AA%E5%B1%8F2024-03-08%2020.02.53.png" alt="截屏2024-03-08 20.02.53"></p>
<p>0会屏蔽所有优先级小于或等于阈值的PLIC中断。例如，阈值为零时允许所有非零优先级的中断，而阈值为7时则屏蔽所有中断。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">plicinithart</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> hart = cpuid();	<span class="comment">// 获取当前处理器核心的hart id ( 硬件线程id )</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set enable bits for this hart&#x27;s S-mode</span></span><br><span class="line">  <span class="comment">// for the uart and virtio disk.</span></span><br><span class="line">  *(uint32*)PLIC_SENABLE(hart) = (<span class="number">1</span> &lt;&lt; UART0_IRQ) | (<span class="number">1</span> &lt;&lt; VIRTIO0_IRQ);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set this hart&#x27;s S-mode priority threshold to 0.</span></span><br><span class="line">  <span class="comment">// 将当前hart的supervisor mode中断优先级阈值设置为0</span></span><br><span class="line">  <span class="comment">// 阈值为0 意味着所有优先级大于0的中断都会被当前hart接受</span></span><br><span class="line">  *(uint32*)PLIC_SPRIORITY(hart) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="plic-claim"><a href="#plic-claim" class="headerlink" title="plic_claim()"></a><code>plic_claim()</code></h4><p>向 <code>plant level interrupt controller</code> 询问我们应该处理什么中断</p>
<p><code>PLIC_SCLAIM</code>宏定义到</p>
<p><img src="/../images/Lab-Copy-on-Write-Fork-for-xv6/%E6%88%AA%E5%B1%8F2024-03-08%2020.09.48.png" alt="截屏2024-03-08 20.09.48"></p>
<p>现在我们知道该代码实际上是读取当前hart的supervisor mode中断 认领&#x2F;完成<code>(SCLAIM)</code>寄存器</p>
<p><img src="/../images/Lab-Copy-on-Write-Fork-for-xv6/%E6%88%AA%E5%B1%8F2024-03-08%2020.11.59.png" alt="截屏2024-03-08 20.11.59"></p>
<blockquote>
<p>读取到的零表示没有中断待处理。非零的读取结果包含了最高优先级待处理中断的ID。向这个寄存器写入数据表示完成了写入的中断ID所对应的中断处理。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这行代码实际上是读取当前hart的S模式中断认领/完成（SCLAIM）寄存器。PLIC_SCLAIM(hart)根据核心ID</span></span><br><span class="line"><span class="comment"> * 计算出SCLAIM寄存器的地址，然后通过解引用该地址获取存储在其中的值。</span></span><br><span class="line"><span class="comment"> * 读取这个寄存器会返回当前有待处理的最高优先级中断的ID。如果没有待处理的中断，寄存器会返回0。</span></span><br><span class="line"><span class="comment"> * 同时，读取操作会自动清除相应的中断源上的待处理位，这意味着中断被核心成功认领。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">plic_claim</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> hart = cpuid();</span><br><span class="line">  <span class="type">int</span> irq = *(uint32*)PLIC_SCLAIM(hart);</span><br><span class="line">  <span class="keyword">return</span> irq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="plic-complete"><a href="#plic-complete" class="headerlink" title="plic_complete()"></a><code>plic_complete()</code></h4><p>向该寄存器写入数据表示完成了写入的中断ID对应的中断处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tell the PLIC we&#x27;ve served this IRQ.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">plic_complete</span><span class="params">(<span class="type">int</span> irq)</span> &#123;</span><br><span class="line">  <span class="type">int</span> hart = cpuid();</span><br><span class="line">  *(uint32*)PLIC_SCLAIM(hart) = irq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="console-c"><a href="#console-c" class="headerlink" title="console.c:"></a><code>console.c:</code></h3><p>控制台输入输出，通过UART。<br>读取操作是一行一行进行的。<br>实现了特殊输入字符：<br>换行符 – 行尾<br>Control-H – 退格<br>Control-U – 删除行<br>Control-D – 文件结束<br>Control-P – 打印进程列表</p>
<h4 id="void-consputc"><a href="#void-consputc" class="headerlink" title="void consputc()"></a><code>void consputc()</code></h4><p>向UART发送一个字符，被函数<code>printf()</code>调用，用于回显输入字符，但不能由<code>write()</code>调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">consputc</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(c == BACKSPACE)&#123;</span><br><span class="line">    <span class="comment">// if the user typed backspace, overwrite with a space.</span></span><br><span class="line">    uartputc_sync(<span class="string">&#x27;\b&#x27;</span>); uartputc_sync(<span class="string">&#x27; &#x27;</span>); uartputc_sync(<span class="string">&#x27;\b&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    uartputc_sync(c); <span class="comment">// 向uart中发送字符c</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uartputc_sync</code>和<code>uartputc</code>的区别：</p>
<blockquote>
<p>假设你的操作系统正在运行一个用户程序，用户程序想要通过调用<code>write()</code>系统调用来输出一些字符到控制台。同时，假设操作系统也希望能够在处理某些内核事件时（如打印内核日志）输出字符到控制台。</p>
<h3 id="使用uartputc"><a href="#使用uartputc" class="headerlink" title="使用uartputc"></a>使用<code>uartputc</code></h3><p>当用户程序调用<code>write()</code>系统调用来输出字符时，内核会使用<code>uartputc</code>函数。因为用户程序的执行不是时间敏感的，如果输出缓冲区满了，它可以等待（即阻塞），直到有空间可用再继续输出。这种方式允许操作系统高效地管理UART的输出缓冲区，减少对CPU资源的占用。</p>
<ul>
<li><strong>例子</strong>：用户程序通过<code>write()</code>输出”Hello, world!”。如果输出缓冲区已满，<code>write()</code>操作会等待，直到缓冲区有足够的空间来存放这些字符。</li>
</ul>
<h3 id="使用uartputc-sync"><a href="#使用uartputc-sync" class="headerlink" title="使用uartputc_sync"></a>使用<code>uartputc_sync</code></h3><p>另一方面，如果内核需要在处理中断时输出字符（例如，打印调试信息），它不能使用会阻塞的<code>uartputc</code>，因为中断处理程序需要快速执行并返回，避免阻塞和延迟。在这种情况下，内核会使用<code>uartputc_sync</code>，它通过轮询等待，直到UART准备好发送新字符，不涉及等待或阻塞。</p>
<ul>
<li><strong>例子</strong>：内核需要在处理一个硬件中断时打印一条调试信息。使用<code>uartputc_sync</code>可以确保信息被立即输出到控制台，而不会阻塞中断处理的其余部分。即使输出寄存器不立即可用，它也会通过忙等（busy-waiting）直到可以发送字符，而不是挂起当前进程。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>uartputc</code>适合在正常的程序执行流程中使用，其中阻塞等待输出空间变得可用是可接受的。<code>uartputc_sync</code>适用于那些不能被阻塞的上下文，如内核打印或中断处理程序，需要立即输出字符而不影响系统的响应性。</p>
</blockquote>
<h4 id="struct-cons"><a href="#struct-cons" class="headerlink" title="struct cons:"></a><code>struct cons:</code></h4><p>这是一个<code>console</code>输入缓冲区的数据结构，用于管理从用户接收到的输入字符。</p>
<ul>
<li><code>spinlock</code>用于保证对缓冲区的访问是互斥的</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// input</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_BUF_SIZE 128</span></span><br><span class="line">  <span class="type">char</span> buf[INPUT_BUF_SIZE];	<span class="comment">// 字符缓冲区数组</span></span><br><span class="line">  uint r;  <span class="comment">// Read index  指向缓冲区中下一个要被读取的字符位置</span></span><br><span class="line">  uint w;  <span class="comment">// Write index 指向缓冲区下一个要写入字符的位置</span></span><br><span class="line">  uint e;  <span class="comment">// Edit index  光标位置或编辑位置</span></span><br><span class="line">&#125; cons;</span><br></pre></td></tr></table></figure>

<h4 id="consolewrite"><a href="#consolewrite" class="headerlink" title="consolewrite()"></a><code>consolewrite()</code></h4><p>用户对<code>console</code>调用的<code>write()</code>来到这里，也即：用于处理用户空间程序向控制台写入数据的请求。</p>
<ul>
<li><p><code>either_copying(void *dst, int user_src, uint64 src, uint64 len)</code></p>
<p>可以实现从用户态或者内核态拷贝数据到目的地址</p>
<p>其中<code>user_src</code>为真是表示原地址在用户态中</p>
</li>
<li><p><code>uartputc(c)</code>将字符c发送至<code>uart</code>中（该函数在uart.c中，稍后我们在讨论这个文件时会做详细解释）</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line"><span class="comment">// user write()s to the console go here.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">consolewrite</span><span class="params">(<span class="type">int</span> user_src, uint64 src, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">if</span>(either_copyin(&amp;c, user_src, src+i, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    uartputc(c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="consoleread"><a href="#consoleread" class="headerlink" title="consoleread()"></a><code>consoleread()</code></h4><p>用于处理用户空间程序从控制台读取数据的请求。</p>
<p>拷贝整个输入行到目的地址<code>dst</code></p>
<ul>
<li><p><code>Sleep(&amp;cons.r, &amp;cons.lock)</code>中传入<code>&amp;cons.r</code>的原因：</p>
<p><code>sleep</code>函数将<code>&amp;cons.r</code>作为<code>chan</code>参数传入，这表示当前进程希望在控制台输入缓冲区的读索引<code>cons.r</code>上睡眠，当前进程将等待，知道有新的数据写入缓冲区（此时<code>cons.r</code>会发生变化）并在另一个进程（可能是中断处理程序）在相同的通道（即<code>&amp;cons.r</code>）上调用<code>wakeup</code>后被唤醒。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">consoleread</span><span class="params">(<span class="type">int</span> user_dst, uint64 dst, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  uint target;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="type">char</span> cbuf;</span><br><span class="line"></span><br><span class="line">  target = n;</span><br><span class="line">  acquire(&amp;cons.lock); <span class="comment">// 尝试获取控制台缓冲区的锁，以保证对缓冲区的访问的互斥</span></span><br><span class="line">  <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// wait until interrupt handler has put some</span></span><br><span class="line">    <span class="comment">// input into cons.buffer.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不断检查是否有数据可读（即检查读索引和写索引是否相等）</span></span><br><span class="line">    <span class="keyword">while</span>(cons.r == cons.w)&#123;</span><br><span class="line">      <span class="keyword">if</span>(killed(myproc()))&#123;</span><br><span class="line">        release(&amp;cons.lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 若缓冲区为空，则当前进程睡眠</span></span><br><span class="line">      sleep(&amp;cons.r, &amp;cons.lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓冲区中读取数据</span></span><br><span class="line">    c = cons.buf[cons.r++ % INPUT_BUF_SIZE]; <span class="comment">// input is buffered in buf</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// C(&#x27;D&#x27;) control-D 表示文件结束</span></span><br><span class="line">    <span class="keyword">if</span>(c == C(<span class="string">&#x27;D&#x27;</span>))&#123;  <span class="comment">// end-of-file</span></span><br><span class="line">      <span class="keyword">if</span>(n &lt; target)&#123;</span><br><span class="line">        <span class="comment">// Save ^D for next time, to make sure</span></span><br><span class="line">        <span class="comment">// caller gets a 0-byte result.</span></span><br><span class="line">        cons.r--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy the input byte to the user-space buffer.</span></span><br><span class="line">    <span class="comment">// 将输入的字节拷贝到用户空间缓冲区</span></span><br><span class="line">    cbuf = c;</span><br><span class="line">    <span class="keyword">if</span>(either_copyout(user_dst, dst, &amp;cbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">    dst++; <span class="comment">// 移动dst一个字节</span></span><br><span class="line">    --n;   <span class="comment">// 已经拷贝了一个字节的数据，n -1 表示剩余要拷贝的数据的字节数</span></span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 已经读取了一行，返回到用户空间的read函数</span></span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// a whole line has arrived, return to</span></span><br><span class="line">      <span class="comment">// the user-level read().</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;cons.lock); <span class="comment">// 解锁</span></span><br><span class="line">  <span class="keyword">return</span> target - n; <span class="comment">// 返回实际读取到的数据的字节数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="consoleintr"><a href="#consoleintr" class="headerlink" title="consoleintr()"></a><code>consoleintr()</code></h4><ul>
<li>控制台输入处理程序</li>
<li>当输入字符时，<code>uartintr()</code>调用该函数</li>
<li>执行擦出&#x2F;删除处理，追加到cons.buf</li>
<li>如果一整行数据到来时，唤醒<code>consoleread()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">consoleintr</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">  acquire(&amp;cons.lock); <span class="comment">// 上锁</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;P&#x27;</span>)</span>:  <span class="comment">// Print process list. 打印进程的信息</span></span><br><span class="line">    <span class="title function_">procdump</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;U&#x27;</span>)</span>:  <span class="comment">// Kill line. 删除这一行</span></span><br><span class="line">    <span class="title function_">while</span><span class="params">(cons.e != cons.w &amp;&amp;</span></span><br><span class="line"><span class="params">          cons.buf[(cons.e<span class="number">-1</span>) % INPUT_BUF_SIZE] != <span class="string">&#x27;\n&#x27;</span>)</span>&#123;</span><br><span class="line">      cons.e--;</span><br><span class="line">      consputc(BACKSPACE); <span class="comment">//对每次删除发送一个退格字符以反映回显</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;H&#x27;</span>)</span>: <span class="comment">// Backspace 回退操作</span></span><br><span class="line">  <span class="keyword">case</span> &#x27;\x7f&#x27;: <span class="comment">// Delete key 删除键</span></span><br><span class="line">    <span class="title function_">if</span><span class="params">(cons.e != cons.w)</span>&#123;</span><br><span class="line">      cons.e--; <span class="comment">// 删除缓冲区的最后一个字符</span></span><br><span class="line">      consputc(BACKSPACE); <span class="comment">// 发送退格字符进行回显</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 输入字符不为空，且控制台缓冲区读取的索引 - 编辑的索引 小于缓冲区大小</span></span><br><span class="line">    <span class="keyword">if</span>(c != <span class="number">0</span> &amp;&amp; cons.e-cons.r &lt; INPUT_BUF_SIZE)&#123;</span><br><span class="line">      c = (c == <span class="string">&#x27;\r&#x27;</span>) ? <span class="string">&#x27;\n&#x27;</span> : c;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// echo back to the user.</span></span><br><span class="line">      consputc(c);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// store for consumption by consoleread().</span></span><br><span class="line">      <span class="comment">// 将该字符追加到控制台缓冲区中</span></span><br><span class="line">      cons.buf[cons.e++ % INPUT_BUF_SIZE] = c;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span> || c == C(<span class="string">&#x27;D&#x27;</span>) || cons.e-cons.r == INPUT_BUF_SIZE)&#123;</span><br><span class="line">        <span class="comment">// wake up consoleread() if a whole line (or end-of-file)</span></span><br><span class="line">        <span class="comment">// has arrived.</span></span><br><span class="line">        <span class="comment">// 整行到达，唤醒consoleread</span></span><br><span class="line">        cons.w = cons.e;</span><br><span class="line">        wakeup(&amp;cons.r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  release(&amp;cons.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="consoleinit"><a href="#consoleinit" class="headerlink" title="consoleinit()"></a><code>consoleinit()</code></h4><ul>
<li><p><code>devsw[CONSOLE]</code></p>
<ul>
<li><p>首先我们查看<code>devsw</code>和<code>CONSOLE</code>的定义：</p>
<ul>
<li>devsw用于映射主设备号到设备函数</li>
<li>定义了CONSOLE为第一个设备</li>
<li>允许操作系统根据设备号调用相应设备的读取和写入操作函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map major device number to device functions.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">devsw</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> (*read)(<span class="type">int</span>, uint64, <span class="type">int</span>);</span><br><span class="line">  <span class="type">int</span> (*write)(<span class="type">int</span>, uint64, <span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">devsw</span> <span class="title">devsw</span>[];</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONSOLE 1</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><code>consoleinit</code>函数将设备CONSOLE的读取和写入函数映射到设备号中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consoleinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;cons.lock, <span class="string">&quot;cons&quot;</span>); <span class="comment">// 初始化 控制台结构的锁</span></span><br><span class="line"></span><br><span class="line">  uartinit(); <span class="comment">// 初始化uart接口</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// connect read and write system calls</span></span><br><span class="line">  <span class="comment">// to consoleread and consolewrite.</span></span><br><span class="line">  devsw[CONSOLE].read = consoleread;</span><br><span class="line">  devsw[CONSOLE].write = consolewrite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uart-c"><a href="#uart-c" class="headerlink" title="uart.c"></a><code>uart.c</code></h3><p>这段代码是针对<code>16550A UART</code>的低级驱动程序。</p>
<p><code>16550A UART</code>是一种广泛使用的串行通信接口芯片。</p>
<h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">define</span> Reg(reg) ((volatile unsigned char *)(UART0 + reg)) <span class="comment">// 返回uart control register在内存映射中的位置。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ReadReg(reg) (*(Reg(reg)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WriteReg(reg, v) (*(Reg(reg)) = (v))</span></span><br></pre></td></tr></table></figure>

<h4 id="UART-control-registers"><a href="#UART-control-registers" class="headerlink" title="UART control registers"></a>UART control registers</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RHR 0                 <span class="comment">// receive holding register (for input bytes)      暂存接收到的输入字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THR 0                 <span class="comment">// transmit holding register (for output bytes)  暂存即将发送的输出字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IER 1                 <span class="comment">// interrupt enable register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IER_RX_ENABLE (1&lt;&lt;0)  <span class="comment">// 启动接收中断的位掩码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IER_TX_ENABLE (1&lt;&lt;1)  <span class="comment">// 启动发送中断的位掩码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FCR 2                 <span class="comment">// FIFO control register </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FCR_FIFO_ENABLE (1&lt;&lt;0) <span class="comment">// 启用FIFO位掩码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FCR_FIFO_CLEAR (3&lt;&lt;1) <span class="comment">// clear the content of the two FIFOs 清除两个FIFO内容的位掩码。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISR 2                 <span class="comment">// interrupt status register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCR 3                 <span class="comment">// line control register LCR寄存器的地址定义为3。这个寄存器用于配置数据格式，比如数据位、停止位和奇偶校验位。 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCR_EIGHT_BITS (3&lt;&lt;0) <span class="comment">// 设置数据位为8位的位掩码。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCR_BAUD_LATCH (1&lt;&lt;7) <span class="comment">// special mode to set baud rate</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR 5                 <span class="comment">// line status register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_RX_READY (1&lt;&lt;0)   <span class="comment">// input is waiting to be read from RHR</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_TX_IDLE (1&lt;&lt;5)    <span class="comment">// THR can accept another character to send</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ReadReg(reg) (*(Reg(reg)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WriteReg(reg, v) (*(Reg(reg)) = (v))</span></span><br></pre></td></tr></table></figure>

<h4 id="uartinit"><a href="#uartinit" class="headerlink" title="uartinit()"></a><code>uartinit()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// disable interrupts.</span></span><br><span class="line">  WriteReg(IER, <span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// special mode to set baud rate.</span></span><br><span class="line">  WriteReg(LCR, LCR_BAUD_LATCH);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// LSB for baud rate of 38.4K. 低字节</span></span><br><span class="line">  WriteReg(<span class="number">0</span>, <span class="number">0x03</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// MSB for baud rate of 38.4K. 高字节</span></span><br><span class="line">  WriteReg(<span class="number">1</span>, <span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// leave set-baud mode,</span></span><br><span class="line">  <span class="comment">// and set word length to 8 bits, no parity.</span></span><br><span class="line">  <span class="comment">// 离开设置波特率的模式，并配置数据字长为8位，无校验位。</span></span><br><span class="line">  <span class="comment">// 这是通过再次写入LCR寄存器，但这次使用LCR_EIGHT_BITS来完成的。</span></span><br><span class="line">  WriteReg(LCR, LCR_EIGHT_BITS);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reset and enable FIFOs.</span></span><br><span class="line">  <span class="comment">// 通过写入FIFO控制寄存器（FCR），启用并清除FIFO（先进先出队列）。</span></span><br><span class="line">  <span class="comment">// 这有助于确保发送和接收的数据能够被正确地缓存，同时清除可能存在的任何旧数据。</span></span><br><span class="line">  WriteReg(FCR, FCR_FIFO_ENABLE | FCR_FIFO_CLEAR);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable transmit and receive interrupts.</span></span><br><span class="line">  <span class="comment">// 再次写入IER寄存器，这次是为了启用发送（IER_TX_ENABLE）和接收（IER_RX_ENABLE）中断。</span></span><br><span class="line">  <span class="comment">// 这允许UART在发送缓冲区空闲或接收到数据时，通过中断通知CPU。</span></span><br><span class="line">  WriteReg(IER, IER_TX_ENABLE | IER_RX_ENABLE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化UART发送锁：</span></span><br><span class="line">  initlock(&amp;uart_tx_lock, <span class="string">&quot;uart&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uartputc()</code></p>
<ul>
<li>将一个字符添加到输出缓冲区并通知UART开始发送（如果尚未开始）</li>
<li>如果输出缓冲区已满，则阻塞</li>
<li>因为该函数可能会阻塞，所以不能被中断调用</li>
<li>所以该函数只适合被<code>write()</code>调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartputc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 如果系统遇到一个严重的错误，则panicked为真，不再执行后续代码</span></span><br><span class="line">  <span class="keyword">if</span>(panicked)&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// UART 传输缓冲区 满</span></span><br><span class="line">  <span class="keyword">while</span>(uart_tx_w == uart_tx_r + UART_TX_BUF_SIZE)&#123;</span><br><span class="line">    <span class="comment">// buffer is full.</span></span><br><span class="line">    <span class="comment">// wait for uartstart() to open up space in the buffer.</span></span><br><span class="line">    <span class="comment">// 调用sleep会导致调用线程阻塞</span></span><br><span class="line">    sleep(&amp;uart_tx_r, &amp;uart_tx_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向uart输出循环缓冲区写入字符c</span></span><br><span class="line">  uart_tx_buf[uart_tx_w % UART_TX_BUF_SIZE] = c;</span><br><span class="line">  uart_tx_w += <span class="number">1</span>; <span class="comment">// 写索引加1</span></span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="uartstart"><a href="#uartstart" class="headerlink" title="uartstart()"></a><code>uartstart()</code></h4><p>如果<code>UART</code>当前是空闲的，且一个字符正在输出缓冲区中等待，该函数将会把这个字符传输出去。</p>
<p>该函数的调用者必须先对<code>uart_tx_lock</code>上锁</p>
<p>设备中断的上半和下半部分都可以调用该函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uartstart</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(uart_tx_w == uart_tx_r)&#123;</span><br><span class="line">      <span class="comment">// transmit buffer is empty.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取 Line Status Register 并判断 UART Transmit Holding Register 是否空闲 </span></span><br><span class="line">    <span class="keyword">if</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// the UART transmit holding register is full,</span></span><br><span class="line">      <span class="comment">// so we cannot give it another byte.</span></span><br><span class="line">      <span class="comment">// it will interrupt when it&#x27;s ready for a new byte.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取 uart 输出缓冲区的一个字符</span></span><br><span class="line">    <span class="type">int</span> c = uart_tx_buf[uart_tx_r % UART_TX_BUF_SIZE];</span><br><span class="line">    uart_tx_r += <span class="number">1</span>; <span class="comment">// uart输出缓冲区读索引加1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// maybe uartputc() is waiting for space in the buffer.</span></span><br><span class="line">    <span class="comment">// 或许有uartputc正在等待uart输出缓冲区的空间</span></span><br><span class="line">    wakeup(&amp;uart_tx_r);</span><br><span class="line">    <span class="comment">// 将缓冲区读取的数据写入UART的发送保持寄存器</span></span><br><span class="line">    WriteReg(THR, c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="uartputc-sync"><a href="#uartputc-sync" class="headerlink" title="uartputc_sync()"></a><code>uartputc_sync()</code></h4><p>uartputc的另一个版本，不使用中断，用于内核的printf和回显字符。它等待循环，知道UART的输出寄存器为空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uartputc_sync</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">  push_off(); <span class="comment">// 禁止中断</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(panicked)&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 轮询等待知道THR为空</span></span><br><span class="line">  <span class="comment">// wait for Transmit Holding Empty to be set in LSR.</span></span><br><span class="line">  <span class="keyword">while</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line">  <span class="comment">// 向 THR 中写入数据c</span></span><br><span class="line">  WriteReg(THR, c);</span><br><span class="line">	</span><br><span class="line">  pop_off(); <span class="comment">// 启用中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uartputc_sync</code>并没有使用 uart输出缓冲区 <code>UART_TX_BUF</code></p>
<h4 id="uartgetc"><a href="#uartgetc" class="headerlink" title="uartgetc()"></a><code>uartgetc()</code></h4><p>从UART中读取一个输入字符，如果没有则返回-1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uartgetc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(ReadReg(LSR) &amp; <span class="number">0x01</span>)&#123;</span><br><span class="line">    <span class="comment">// input data is ready.</span></span><br><span class="line">    <span class="keyword">return</span> ReadReg(RHR); <span class="comment">// Receive Holding Register</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="uartintr"><a href="#uartintr" class="headerlink" title="uartintr()"></a><code>uartintr()</code></h4><p>处理一个uart中断，当一个输入到达时，或者uart已经准备好更多的输出时使用，被<code>devintr()</code>调用，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uartintr</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// read and process incoming characters.</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">int</span> c = uartgetc();<span class="comment">// 读取uart中的输入字符</span></span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    consoleintr(c); <span class="comment">// 将c传输给console</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send buffered characters. 传输缓冲区的字符</span></span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="printf-c"><a href="#printf-c" class="headerlink" title="printf.c"></a><code>printf.c</code></h3><h4 id="pr-struct"><a href="#pr-struct" class="headerlink" title="pr struct"></a><code>pr struct</code></h4><p>锁，用于避免并发的printf操作交互执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> locking;</span><br><span class="line">&#125; pr;</span><br></pre></td></tr></table></figure>

<h4 id="printint"><a href="#printint" class="headerlink" title="printint"></a><code>printint</code></h4><p>打印整型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">printint</span><span class="params">(<span class="type">int</span> xx, <span class="type">int</span> base, <span class="type">int</span> sign)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">16</span>];</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  uint x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(sign &amp;&amp; (sign = xx &lt; <span class="number">0</span>))</span><br><span class="line">    x = -xx;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    x = xx;</span><br><span class="line"></span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    buf[i++] = digits[x % base];</span><br><span class="line">  &#125; <span class="keyword">while</span>((x /= base) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(sign)</span><br><span class="line">    buf[i++] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(--i &gt;= <span class="number">0</span>)</span><br><span class="line">    consputc(buf[i]); <span class="comment">// 向console输入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="printptr"><a href="#printptr" class="headerlink" title="printptr"></a><code>printptr</code></h4><p>打印指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">printptr</span><span class="params">(uint64 x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  consputc(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  consputc(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span>(uint64) * <span class="number">2</span>); i++, x &lt;&lt;= <span class="number">4</span>)</span><br><span class="line">    consputc(digits[x &gt;&gt; (<span class="keyword">sizeof</span>(uint64) * <span class="number">8</span> - <span class="number">4</span>)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="printf"><a href="#printf" class="headerlink" title="printf"></a><code>printf</code></h4><ul>
<li><code>ap</code>是一个可变参数列表</li>
<li><code>va_start(ap, fmt)</code>，fmt是函数中最后一个已知的固定参数，它告诉<code>va_start</code>可变参数列表在内存中的起始位置在哪里</li>
<li><code>va_arg(ap, int)</code>，从<code>ap</code>中提取一个类型为<code>int</code>的参数</li>
<li><strong>用法示例</strong>：在处理<code>printf</code>格式字符串中的<code>%d</code>占位符时，可以使用<code>printint(va_arg(ap, int), 10, 1);</code>来读取一个整数参数，并将其按十进制格式输出。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Print to the console. only understands %d, %x, %p, %s.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">printf</span><span class="params">(<span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  <span class="type">int</span> i, c, locking;</span><br><span class="line">  <span class="type">char</span> *s;</span><br><span class="line"></span><br><span class="line">  locking = pr.locking;</span><br><span class="line">  <span class="keyword">if</span>(locking)</span><br><span class="line">    acquire(&amp;pr.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fmt == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;null fmt&quot;</span>);</span><br><span class="line"></span><br><span class="line">  va_start(ap, fmt); <span class="comment">// 初始化 va_list类型的变量 args 以便后续通过va_arg宏访问函数的可变参数列表</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; (c = fmt[i] &amp; <span class="number">0xff</span>) != <span class="number">0</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(c != <span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">      consputc(c); <span class="comment">// 如果不是%d这样的占位符，则直接输出到console中</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c = fmt[++i] &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">0</span>) <span class="comment">// 结束输出</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">      printint(va_arg(ap, <span class="type">int</span>), <span class="number">10</span>, <span class="number">1</span>); <span class="comment">// 输出整型</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">      printint(va_arg(ap, <span class="type">int</span>), <span class="number">16</span>, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">      printptr(va_arg(ap, uint64));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span>((s = va_arg(ap, <span class="type">char</span>*)) == <span class="number">0</span>)</span><br><span class="line">        s = <span class="string">&quot;(null)&quot;</span>;</span><br><span class="line">      <span class="keyword">for</span>(; *s; s++)</span><br><span class="line">        consputc(*s);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">      consputc(<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// Print unknown % sequence to draw attention.</span></span><br><span class="line">      consputc(<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">      consputc(c);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  va_end(ap);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(locking)</span><br><span class="line">    release(&amp;pr.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="panic"><a href="#panic" class="headerlink" title="panic"></a><code>panic</code></h4><p>打印panic</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">panic</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">  pr.locking = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;panic: &quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  panicked = <span class="number">1</span>; <span class="comment">// freeze uart output from other CPUs</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="printfinit"><a href="#printfinit" class="headerlink" title="printfinit"></a><code>printfinit</code></h4><p>初始化printf锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printfinit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  initlock(&amp;pr.lock, <span class="string">&quot;pr&quot;</span>);</span><br><span class="line">  pr.locking = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><p>虚拟内存提供了一定程度的间接性：内核可以通过将 PTE 标记为无效或只读来拦截内存引用，从而导致页面错误，并且可以通过修改 PTE 来更改地址的含义。 计算机系统中有一种说法，任何系统问题都可以通过一定程度的间接解决。 本实验探讨了一个示例：copy-on-write fork</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>xv6中的<code>fork()</code>系统调用会复制父进程的所有用户空间内存到子进程。如果父进程很大，复制操作可能会花费很长时间。更糟糕的是，这项工作往往大部分是浪费的：<code>fork()</code>通常会在子进程中紧接着执行<code>exec()</code>，这将丢弃已复制的内存，通常在未使用大部分已复制内存的情况下。另一方面，如果父进程和子进程都使用了复制的页面，并且它们中的一个或两个对其进行了写操作，那么真正需要这个副本。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>Copy-on-write (COW) fork() 的目标是推迟分配和复制物理内存页，直到实际需要副本（如果有）。<br>COW fork() 只为子进程创建一个页表，用户内存的 PTE 指向父进程的物理页。 COW fork() 将父级和子级中的所有用户 PTE 标记为只读。 当任一进程尝试写入其中一个 COW 页时，CPU 将强制发生页错误。 内核页面错误处理程序检测到这种情况，为错误进程分配物理内存页面，将原始页面复制到新页面，并修改错误进程中的相关 PTE 以引用新页面，这次使用 PTE 标记为可写。 当页面错误处理程序返回时，用户进程将能够写入其页面副本。</p>
<p>COW fork() 使得释放实现用户内存的物理页变得有点棘手。 给定的物理页可能被多个进程的页表引用，并且仅当最后一个引用消失时才应释放。 在像 xv6 这样的简单内核中，这种簿记相当简单，但在生产内核中，这可能很难正确执行； 例如，参见修补直到奶牛回家。</p>
<h3 id="Implement-copy-on-write-fork"><a href="#Implement-copy-on-write-fork" class="headerlink" title="Implement copy-on-write fork"></a>Implement copy-on-write fork</h3><blockquote>
<p>Your task is to implement copy-on-write fork in the xv6 kernel. You are done if your modified kernel executes both the cowtest and ‘usertests -q’ programs successfully.</p>
</blockquote>
<p>为了帮助你测试你的实现，我们提供了一个名为<code>cowtest</code>的xv6程序（源代码在<code>user/cowtest.c</code>中）。<code>cowtest</code>运行各种测试，但即使是第一个测试也会在未修改的xv6上失败。因此，最初你会看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cowtest</span><br><span class="line">simple: fork() failed</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>“simple”测试分配了超过可用物理内存一半的空间，然后执行<code>fork()</code>。<code>fork</code>失败是因为没有足够的空闲物理内存给子进程完整复制父进程的内存。</p>
<p>当你完成后，你的内核应该通过<code>cowtest</code>和<code>usertests -q</code>中的所有测试。也就是说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cowtest</span><br><span class="line">simple: ok</span><br><span class="line">simple: ok</span><br><span class="line">three: zombie!</span><br><span class="line">ok</span><br><span class="line">three: zombie!</span><br><span class="line">ok</span><br><span class="line">three: zombie!</span><br><span class="line">ok</span><br><span class="line">file: ok</span><br><span class="line">ALL COW TESTS PASSED</span><br><span class="line">$ usertests -q</span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>这表明，完成后的内核应该能够处理写时复制（COW，Copy-On-Write）机制下的内存管理，使得即使在物理内存紧张的情况下也能成功执行<code>fork()</code>，并且通过所有相关的功能和性能测试。</p>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><ol>
<li>修改<code>uvmcopy()</code>将父进程的物理页映射到子进程中，而不是分配新的页。将子进程和父进程所有设置PTE_W的PTE修改为PTE_R</li>
<li>修改<code>usertrap()</code>检测页面错误。当一个向写入页面错误在COW页上发生时，用<code>kalloc()</code>分配一个新的页面并设置PTE_W。最初只读的页面（未映射 PTE_W，如文本段中的页面）应保持只读状态并在父子之间共享； 尝试写入此类页面的进程应该被终止。</li>
<li>确保每个物理页在最后一个 PTE 引用消失时被释放——但不是在此之前。 实现此目的的一个好方法是为每个物理页保留引用该页的用户页表数量的“引用计数”。当 <code>kalloc()</code> 分配页面时，将页面的引用计数设置为 1。 当 <code>fork</code> 导致子进程共享页面时增加页面的引用计数，并在每次任何进程从其页表中删除页面时减少页面的计数。 <code>kfree()</code> 仅当其引用计数为零时才应将页面放回到空闲列表中。 将这些计数保存在固定大小的整数数组中是可以的。 您必须制定一个如何索引数组以及如何选择其大小的方案。 例如，您可以使用页面的物理地址除以 4096 来索引数组，并为数组提供与 <code>kalloc.c</code> 中的 <code>kinit()</code> 放置在空闲列表上的任何页面的最高物理地址相同的元素数。 请随意修改 <code>kalloc.c</code>（例如 <code>kalloc()</code> 和 <code>kfree()</code>）以维护引用计数。</li>
<li>修改 <code>copyout()</code> 以在遇到 <code>COW</code> 页面时使用与页面错误相同的方案。</li>
</ol>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul>
<li>It may be useful to have a way to record, for each PTE, whether it is a COW mapping. You can use the RSW (reserved for software) bits in the RISC-V PTE for this.</li>
<li><code>usertests -q</code> explores scenarios that <code>cowtest</code> does not test, so don’t forget to check that all tests pass for both.</li>
<li>Some helpful macros and definitions for page table flags are at the end of <code>kernel/riscv.h</code>.</li>
<li>If a COW page fault occurs and there’s no free memory, the process should be killed.</li>
</ul>
<h2 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h2><p>为了对每一个<strong>物理页面</strong>进行映射计数，我们首先在kalloc.c中设置一个对所有<strong>物理页面</strong>计数的全局数组，对该数组的操作需要互斥，我们用一个锁解决。</p>
<p><img src="/../images/Lab-Copy-on-Write-Fork-for-xv6/%E6%88%AA%E5%B1%8F2024-03-12%2014.31.22.png" alt="截屏2024-03-12 14.31.22"></p>
<p>从xv6的内核物理地址空间图可以看到，从PHYSTOP到KERNBASE的虚拟地址空间映射带的是物理地址用于RAM的空间，所以我们可以直接计算出最大页面的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">ref_lock</span>;</span> <span class="comment">// 锁</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXPAGES (PHYSTOP - KERNBASE) / PGSIZE</span></span><br><span class="line"><span class="type">int</span> ref_count[MAXPAGES]; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">index_ref</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (pa - KERNBASE) / PGSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">incr_ref</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">    acquire(&amp;kmem.ref_lock);</span><br><span class="line">    ref_count[index_ref(pa)]++;</span><br><span class="line">    release(&amp;kmem.ref_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decr_ref</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">    acquire(&amp;kmem.ref_lock);</span><br><span class="line">    ref_count[index_ref(pa)]--;</span><br><span class="line">    release(&amp;kmem.ref_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_ref</span><span class="params">(uint64 pa, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    acquire(&amp;kmem.ref_lock);</span><br><span class="line">    ref_count[index_ref(pa)] = n;</span><br><span class="line">    release(&amp;kmem.ref_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_ref</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    acquire(&amp;kmem.ref_lock);</span><br><span class="line">    res = ref_count[index_ref(pa)];</span><br><span class="line">    release(&amp;kmem.ref_lock);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着我们在<code>kinit()</code>函数中初始化锁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kinit</span><span class="params">()</span> &#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  initlock(&amp;kmem.ref_lock, <span class="string">&quot;reflock&quot;</span>);</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>kalloc()</code>一个页面的时候，我们将页面对应的映射计数初始化为1，当<code>kfree()</code>一个物理地址对应的页面时，我们减少页面对应的映射计数，当且仅当页面计数为0时，才真正的释放掉这个内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">kfree(<span class="type">void</span> *pa) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查pa的值是否合法</span></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// pa 对应的索引减 1</span></span><br><span class="line">  decr_ref((uint64)pa);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只有 pa 的计数为 0 时，才能把该页释放掉</span></span><br><span class="line">  <span class="keyword">if</span>(get_ref((uint64)pa) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化时置计数位1</span></span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">      set_ref((uint64)r, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，我们在<code>kinit()</code>的时候调用了<code>freerange()</code>，同时又在<code>freerange()</code>函数中调用了<code>kfree()</code>函数，所以我们需要在<code>freerange()</code>中将计数数组初始化为1，放置计数变为负数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">	<span class="comment">// 初始化计数数组</span></span><br><span class="line">  acquire(&amp;kmem.ref_lock);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXPAGES; ++i) &#123;</span><br><span class="line">    ref_count[i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.ref_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们在<code>defs.h</code>中注册这些函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">index_ref</span><span class="params">(uint64 pa)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">incr_ref</span><span class="params">(uint64 pa)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">decr_ref</span><span class="params">(uint64 pa)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">set_ref</span><span class="params">(uint64 pa, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get_ref</span><span class="params">(uint64 pa)</span>;</span><br></pre></td></tr></table></figure>

<p>接着我们修改<code>uvmcopy()</code>函数，将子进程的page table中的page table entry 直接映射到父进程的page中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果父进程的页表页是可写的，我们不允许它可写</span></span><br><span class="line">    <span class="comment">// 并且 PTE_COW 位 = 1</span></span><br><span class="line">    <span class="comment">// 如果父进程的页表本身就是不可写的，那就不需要修改PTE 的 flag</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_W) &#123;</span><br><span class="line">        *pte |= PTE_COW;</span><br><span class="line">        *pte &amp;= ~PTE_W;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mappages(new, i, PGSIZE, (uint64)pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    incr_ref((uint64)pa); <span class="comment">// 增加物理页面的映射计数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改<code>usertrap()</code>函数处理load page fault：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">()</span> &#123;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r_scause() == <span class="number">15</span>) &#123; <span class="comment">// load page fault</span></span><br><span class="line">    		<span class="comment">// 使用 cowalloc 函数分配一个新的页</span></span><br><span class="line">        <span class="keyword">if</span>(cowalloc(p-&gt;pagetable, r_stval()) != <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): cowalloc failed\n&quot;</span>);</span><br><span class="line">          setkilled(p);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    setkilled(p);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cowalloc()</code>函数的实现:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cowalloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (va &gt;= MAXVA) &#123; <span class="comment">// 判断虚拟地址是否越界</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;va cannot be greater than MAXVA: %p\n&quot;</span>, va);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    va = PGROUNDDOWN(va);</span><br><span class="line">    <span class="comment">// 拿到 va 对应的 pte</span></span><br><span class="line">    <span class="type">pte_t</span> *pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">    uint64 pa = PTE2PA(*pte); <span class="comment">// 拿到虚拟地址对应的物理地址</span></span><br><span class="line">    <span class="comment">// 抽取 pte flags</span></span><br><span class="line">    uint64 flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="keyword">if</span> (!(*pte &amp; PTE_COW))&#123; <span class="comment">// check if page is COW page</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not a COW page. Invalid va: %p\n&quot;</span>, va);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配一个新的页</span></span><br><span class="line">    <span class="type">void</span> *mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cowalloc: alloc mem runs out of memory\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把原始页的内容拷贝到 mem 中</span></span><br><span class="line">    memmove(mem, (<span class="type">void</span>*)pa, PGSIZE);</span><br><span class="line">    <span class="comment">// 置 PTE_COW 为 0，PTE_W 为 1</span></span><br><span class="line">    flags |= PTE_W;   <span class="comment">// 0 | 1 = 1</span></span><br><span class="line">    flags ^= PTE_COW; <span class="comment">// 1 ^ 1 = 0</span></span><br><span class="line">    <span class="comment">// 对原先页取消映射并释放页</span></span><br><span class="line">    uvmunmap(pagetable, va, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 映射当前mem</span></span><br><span class="line">    <span class="keyword">if</span> (mappages(pagetable, va, PGSIZE, (uint64) mem, flags) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cowalloc: mappages failed\n&quot;</span>);</span><br><span class="line">        kfree((<span class="type">void</span>*)mem);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们要修改<code>copyout</code>函数，这是因为当我们将内核空间的数据拷贝到用户空间时，目标地址可能为子进程的空间，这片空间在<code>uvmcopy</code>的时候被置为unwriteable，所以我们要为其分配一个新的page。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span> &#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva); <span class="comment">// 拿到对应的page address</span></span><br><span class="line">    <span class="keyword">if</span>(va0 &gt;= MAXVA) &#123; <span class="comment">// 判断是否越界</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;copyout: va0 cannot be greater than MAXVA\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">pte_t</span> *pte = walk(pagetable, va0, <span class="number">0</span>); <span class="comment">// 拿到 pte</span></span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;copyout: pte cannot be 0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 判断pte映射到的page是否合法</span></span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span> || (*pte &amp; PTE_U) == <span class="number">0</span> ||</span><br><span class="line">        ((*pte &amp; PTE_W) == <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_COW) == <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>((*pte &amp; PTE_W) == <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_COW) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 只有当 PTE_W == 0 且 PTE_COW == 1时，才能cowalloc</span></span><br><span class="line">      <span class="keyword">if</span>(cowalloc(pagetable, va0) != <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;copyout cowalloc failed\n&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;copyout: pa0 cannot be 0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记得在<code>defs.h</code>中注册新加的函数<code>cowalloc()</code></p>
<p>测试结果：</p>
<p><img src="/../images/Lab-Copy-on-Write-Fork-for-xv6/%E6%88%AA%E5%B1%8F2024-03-12%2014.57.58.png" alt="截屏2024-03-12 14.57.58"></p>
<p>没有time.txt。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/06/6-5840-Lab-1-MapReduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/06/6-5840-Lab-1-MapReduce/" class="post-title-link" itemprop="url">6.5840 Lab 1: MapReduce</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-06 16:04:23" itemprop="dateCreated datePublished" datetime="2024-03-06T16:04:23+08:00">2024-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-07 13:49:54" itemprop="dateModified" datetime="2024-03-07T13:49:54+08:00">2024-03-07</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="6-5840-Lab-1-MapReduce"><a href="#6-5840-Lab-1-MapReduce" class="headerlink" title="6.5840 Lab 1: MapReduce"></a>6.5840 Lab 1: MapReduce</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在这个实验中你要实现一个<code>MapReduce</code>系统。你将实现一个<code>worker</code>进程调用程序的<code>Map</code>和<code>Reduce</code>函数，并处理文件的读写，以及一个<code>coordinator</code>进程，该进程分配任务给<code>worker</code>并处理<code>failed worker</code>。你将构建的系统与<code>MapReduce</code>论文中描述的类似。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>需要配置go完成这个实验</p>
<p>使用git（版本控制系统）获取初始实验室软件。要了解有关git的更多信息，请查看Pro Git书籍或git用户手册。</p>
<p>我们为你提供了一个简单的顺序MapReduce实现，位于<code>src/main/mrsequential.go</code>。它一次运行一个map和reduce，全部在单个进程中执行。我们还提供了几个MapReduce应用程序：<code>mrapps/wc.go</code>中的单词计数，以及<code>mrapps/indexer.go</code>中的文本索引器。你可以按照以下方式顺序运行单词计数：</p>
<blockquote>
<p>其中，<code>go build -buildmode=plugin ../mrapps/wc.go</code>编译出一个go插件。go插件是一种特殊的共享库，它可以在运行时被go程序动态加载并使用。</p>
<p><code>wc.so</code>就是上面代码编译出的一个go插件。</p>
<p>在<code>mrsequential.go</code>中，<code>wc.so</code>和<code>pg*.txt</code>作为main函数的参数传入。</p>
<p>然后<code>wc.so</code>通过函数<code>loadPlugin</code>加载到程序中。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~/6.5840</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> src/main</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go build -buildmode=plugin ../mrapps/wc.go</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> mr-out*</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go run mrsequential.go wc.so pg*.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">more mr-out-0</span></span><br><span class="line">A 509</span><br><span class="line">ABOUT 2</span><br><span class="line">ACT 8</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>mrsequential.go</code>程序将其输出留在名为<code>mr-out-0</code>的文件中。输入来自于名为<code>pg-xxx.txt</code>的文本文件。</p>
<p>随意借用<code>mrsequential.go</code>中的代码。你也应该查看<code>mrapps/wc.go</code>以了解MapReduce应用程序代码的样子。</p>
<p>对于这个实验室以及所有其他实验室，我们可能会发布我们提供给你的代码的更新。为了确保你可以获取这些更新并通过<code>git pull</code>轻松合并它们，最好将我们提供的代码留在原始文件中。你可以按照实验室说明中的指示添加我们提供的代码；只是不要移动它。将你自己的新函数放在新文件中是可以的。</p>
<h2 id="你的任务："><a href="#你的任务：" class="headerlink" title="你的任务："></a>你的任务：</h2><p>你的任务是实现一个分布式MapReduce，由两个程序组成，协调者（coordinator）和工作者（worker）。系统中将只有一个协调者进程，以及一个或多个并行执行的工作者进程。在真实系统中，工作者会在不同的机器上运行，但对于这个实验室，你将在单一机器上运行它们所有。工作者将通过RPC与协调者通信。每个工作者进程将在循环中，向协调者请求任务，从一个或多个文件中读取任务的输入，执行任务，将任务的输出写入一个或多个文件，然后再次向协调者请求新任务。如果工作者在合理的时间内（对于这个实验室，使用十秒钟）没有完成其任务，协调者应该注意到这一点，并将相同的任务分配给不同的工作者。</p>
<p>我们已经给你提供了一些初始代码。协调者和工作者的“main”函数分别位于<code>main/mrcoordinator.go</code>和<code>main/mrworker.go</code>中；不要修改这些文件。你应该将你的实现放在<code>mr/coordinator.go</code>、<code>mr/worker.go</code>和<code>mr/rpc.go</code>中。</p>
<p>以下是如何在单词计数MapReduce应用程序上运行你的代码。首先，确保单词计数插件是最新构建的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go build -buildmode=plugin ../mrapps/wc.go</span></span><br></pre></td></tr></table></figure>

<p>在文件夹<code>main</code>中，运行<code>coordinator</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> mr-out*</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go run mrcoordinator.go pg-*.txt</span></span><br></pre></td></tr></table></figure>

<p>传递给<code>mrcoordinator.go</code>的<code>pg-*.txt</code>参数是输入文件；每个文件对应一个“分片”，并且是一个Map任务的输入。</p>
<p>在其他终端窗口上运行<code>worker</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go run mrworker.go wc.so</span></span><br></pre></td></tr></table></figure>

<p>当工作者和协调者完成后，查看<code>mr-out-*</code>中的输出。当你完成实验室任务后，输出文件的排序并集应该与顺序输出匹配，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat mr-out-* | sort | more</span><br><span class="line">A 509</span><br><span class="line">ABOUT 2</span><br><span class="line">ACT 8</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们为你提供了一个测试脚本，在<code>main/test-mr.sh</code>中。测试会检查当给定<code>pg-xxx.txt</code>文件作为输入时，<code>wc</code>和<code>indexer</code> MapReduce应用程序是否产生了正确的输出。测试还会检查你的实现是否并行运行Map和Reduce任务，以及你的实现是否能从执行任务时崩溃的工作者中恢复。</p>
<p>如果你现在运行测试脚本，它将会挂起，因为协调者永远不会结束：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~/6.5840/src/main</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bash test-mr.sh</span></span><br><span class="line">*** Starting wc test.</span><br></pre></td></tr></table></figure>

<p>你可以在<code>mr/coordinator.go</code>中的<code>Done</code>函数里将<code>ret := false</code>改为<code>true</code>，这样协调者就会立即退出。然后：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bash test-mr.sh</span></span><br><span class="line">*** Starting wc test.</span><br><span class="line">sort: No such file or directory</span><br><span class="line">cmp: EOF on mr-wc-all</span><br><span class="line">--- wc output is not the same as mr-correct-wc.txt</span><br><span class="line">--- wc test: FAIL</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>

<p>测试脚本期望在名为<code>mr-out-X</code>的文件中看到输出，每个reduce任务一个文件。<code>mr/coordinator.go</code>和<code>mr/worker.go</code>的空实现不会生成这些文件（或者做其他任何事情），因此测试会失败。</p>
<p>当你完成后，测试脚本的输出应该如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bash test-mr.sh</span></span><br><span class="line">*** Starting wc test.</span><br><span class="line">--- wc test: PASS</span><br><span class="line">*** Starting indexer test.</span><br><span class="line">--- indexer test: PASS</span><br><span class="line">*** Starting map parallelism test.</span><br><span class="line">--- map parallelism test: PASS</span><br><span class="line">*** Starting reduce parallelism test.</span><br><span class="line">--- reduce parallelism test: PASS</span><br><span class="line">*** Starting job count test.</span><br><span class="line">--- job count test: PASS</span><br><span class="line">*** Starting early exit test.</span><br><span class="line">--- early exit test: PASS</span><br><span class="line">*** Starting crash test.</span><br><span class="line">--- crash test: PASS</span><br><span class="line">*** PASSED ALL TESTS</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>

<p>你可能会看到一些来自Go RPC包的错误，看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019/12/16 13:27:09 rpc.Register: method &quot;Done&quot; has 1 input parameters; needs exactly three</span><br></pre></td></tr></table></figure>

<p>忽略这些消息；将协调者注册为RPC服务器是为了检查其所有方法是否适合RPC（有3个输入）；我们知道<code>Done</code>不是通过RPC调用的。<br>另外，根据你终止工作者进程的策略，你可能会看到一些形式的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2024/02/11 16:21:32 dialing:dial unix /var/tmp/5840-mr-501: connect: connection refused</span><br></pre></td></tr></table></figure>

<p>每次测试中看到少量这类消息是正常的；它们发生在协调者退出后，工作者无法联系到协调者RPC服务器时。</p>
<h3 id="一些规则："><a href="#一些规则：" class="headerlink" title="一些规则："></a>一些规则：</h3><ul>
<li>Map阶段应该将中间键分配到nReduce个reduce任务的桶中，其中nReduce是reduce任务的数量——这是<code>main/mrcoordinator.go</code>传递给<code>MakeCoordinator()</code>的参数。每个映射器应该为reduce任务创建nReduce个中间文件。</li>
<li>工作者实现应该将第X个reduce任务的输出放在文件<code>mr-out-X</code>中。</li>
<li><code>mr-out-X</code>文件应该包含每个Reduce函数输出的一行。该行应该使用Go的<code>&quot;%v %v&quot;</code>格式生成，调用键和值。可以在<code>main/mrsequential.go</code>中查看标有“这是正确的格式”的注释行。如果你的实现与这个格式偏差太大，测试脚本将会失败。</li>
<li>你可以修改<code>mr/worker.go</code>、<code>mr/coordinator.go</code>和<code>mr/rpc.go</code>。你可以临时修改其他文件进行测试，但请确保你的代码能够与原始版本一起工作；我们将使用原始版本进行测试。</li>
<li>工作者应该将Map输出的中间结果放在当前目录的文件中，以便你的工作者稍后可以将它们作为Reduce任务的输入读取。</li>
<li><code>main/mrcoordinator.go</code>期望<code>mr/coordinator.go</code>实现一个<code>Done()</code>方法，当MapReduce作业完全完成时返回true；此时，<code>mrcoordinator.go</code>将退出。</li>
<li>当作业完全完成时，工作者进程应该退出。实现这一点的一个简单方法是使用<code>call()</code>的返回值：如果工作者无法联系到协调者，它可以假设协调者已经因为作业完成而退出，因此工作者也可以终止。根据你的设计，你可能也会发现让协调者给工作者一个“请退出”的伪任务很有帮助。</li>
</ul>
<h3 id="一些提示："><a href="#一些提示：" class="headerlink" title="一些提示："></a>一些提示：</h3><ul>
<li><p>Guidance page 上有一些有关开发和调试的提示</p>
</li>
<li><p>开始的一种方法是修改<code>mr/worker.go</code>的<code>Worker()</code>，向协调员发送RPC，要求执行任务。然后修改协调员，以响应尚未启动的map任务的文件名。然后修改工作程序以读取该文件并调用应用程序Map函数，如在<code>mrsequential.go</code>中。</p>
</li>
<li><p>应用程序的Map和Reduce函数使用Go的插件包在运行时从文件加载，这些文件的名称以.so结尾。<br>如果你在<code>mr/</code>目录下更改了任何内容，你可能需要重新构建你使用的任何MapReduce插件，可以使用类似<code>go build -buildmode=plugin ../mrapps/wc.go</code>的命令。</p>
</li>
<li><p>这个实验室依赖于工作者共享文件系统。当所有工作者都在同一台机器上运行时，这很简单，但如果工作者在不同的机器上运行，则需要像GFS这样的全局文件系统。</p>
</li>
<li><p>中间文件的一个合理命名约定是<code>mr-X-Y</code>，其中X是Map任务编号，Y是reduce任务编号。</p>
</li>
<li><p>工作者的map任务代码需要一种方法将中间键&#x2F;值对存储在文件中，以便在reduce任务期间可以正确读回。一种可能性是使用Go的<code>encoding/json</code>包。将键&#x2F;值对以JSON格式写入打开的文件：</p>
</li>
<li><pre><code class="json">enc := json.NewEncoder(file)
  for _, kv := ... &#123;
    err := enc.Encode(&amp;kv)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">并回读这样的文件：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
dec := json.NewDecoder(file)
  for &#123;
    var kv KeyValue
    if err := dec.Decode(&amp;kv); err != nil &#123;
      break
    &#125;
    kva = append(kva, kv)
  &#125;
</code></pre>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/29/Lab-traps/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/29/Lab-traps/" class="post-title-link" itemprop="url">Lab: traps</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-29 09:59:40" itemprop="dateCreated datePublished" datetime="2024-02-29T09:59:40+08:00">2024-02-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-05 19:59:10" itemprop="dateModified" datetime="2024-03-05T19:59:10+08:00">2024-03-05</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>44k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>40 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab-traps"><a href="#Lab-traps" class="headerlink" title="Lab: traps"></a>Lab: traps</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="4-1-RISC-V-trap-machinery"><a href="#4-1-RISC-V-trap-machinery" class="headerlink" title="4.1 RISC-V trap machinery"></a>4.1 RISC-V trap machinery</h3><ul>
<li><p><code>stvec</code>：内核将陷阱处理程序<code>trap handler</code>的地址写入此处；<code>RISC-V</code>跳向该地址处理陷阱<code>trap</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* defined in riscv.h */</span></span><br><span class="line"><span class="comment">// Supervisor Trap-Vector Base Address</span></span><br><span class="line"><span class="comment">// low two bits are mode.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">w_stvec</span><span class="params">(uint64 x)</span> &#123; </span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw stvec, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>; <span class="comment">// write stvec</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 <span class="title function_">r_stvec</span><span class="params">()</span> &#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, stvec&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;	<span class="comment">// read stvec</span></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>sepc</code>：当陷阱<code>trap</code>发生时，<code>RISC-V</code>把程序计数器<code>PC</code>的值保存在这里（因为<code>PC</code>的值将会被<code>stvec</code>中的值覆盖）。指令<code>sret (return from trap)</code>将<code>sepc</code>的值拷贝给<code>pc</code>。内核可以写入<code>sepc</code>寄存器来控制<code>sret</code>指令跳转的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* defined in riscv.h */</span></span><br><span class="line"><span class="comment">// supervisor exception program counter, holds the</span></span><br><span class="line"><span class="comment">// instruction address to which a return from</span></span><br><span class="line"><span class="comment">// exception will go.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">w_sepc</span><span class="params">(uint64 x)</span> &#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw sepc, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>; <span class="comment">// 写 sepc 寄存器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 <span class="title function_">r_sepc</span><span class="params">()</span> &#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, sepc&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>; <span class="comment">// 读 sepc 寄存器</span></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>scause</code>：<code>RISC-V</code>将描述<code>trap</code>原因的数字放在这个寄存器里。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Supervisor Trap Cause</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 <span class="title function_">r_scause</span><span class="params">()</span> &#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, scause&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>sscratch</code>：陷阱处理代码使用sscratch寄存器来避免在保存用户寄存器之前覆盖它们。</p>
</li>
<li><p><code>sstatus</code>：<code>sstatus</code>寄存器用于跟踪处理器当前的操作状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Supervisor Status Register, sstatus</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SPP (1L &lt;&lt; 8)  <span class="comment">// Previous mode, 1=Supervisor, 0=User 在trap前是什么模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SPIE (1L &lt;&lt; 5) <span class="comment">// Supervisor Previous Interrupt Enable 之前是否启用supervisor interrupt</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_UPIE (1L &lt;&lt; 4) <span class="comment">// User Previous Interrupt Enable 之前是否启用user interrupt</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SIE (1L &lt;&lt; 1)  <span class="comment">// Supervisor Interrupt Enable 当前是否启用supervisor interrupt</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_UIE (1L &lt;&lt; 0)  <span class="comment">// User Interrupt Enable 当前是否启用user interrupt</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 <span class="title function_">r_sstatus</span><span class="params">()</span> &#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, sstatus&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;	<span class="comment">// 读</span></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">w_sstatus</span><span class="params">(uint64 x)</span>&#123; <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw sstatus, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enable device interrupts 启用设备中断</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">intr_on</span><span class="params">()</span> &#123; w_sstatus(r_sstatus() | SSTATUS_SIE); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// disable device interrupts 禁止设备中断</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">intr_off</span><span class="params">()</span> &#123; w_sstatus(r_sstatus() &amp; ~SSTATUS_SIE); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// are device interrupts enabled? 判断是否启用设备中断</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">intr_get</span><span class="params">()</span> &#123;</span><br><span class="line">  uint64 x = r_sstatus();</span><br><span class="line">  <span class="keyword">return</span> (x &amp; SSTATUS_SIE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>上述寄存器和陷阱处理函数<code>trap handler</code>相关，不能在用户态中读取或写入。</p>
<p>当需要强制陷阱时，RISC-V硬件对所有陷阱类型（计时器中断除外）进行以下操作：</p>
<ol>
<li>如果<code>trap</code>类型是设备中断，且<code>sstatus</code>的<code>SIE</code>位为<code>0</code>，则什么都不做。</li>
<li>通过置<code>sstatus</code>的<code>SIE</code>位为<code>0</code>禁用所有中断。</li>
<li>将<code>pc</code>的值复制到<code>sepc</code>中。</li>
<li>将当前模式<code>user or supervisor</code>保存到<code>sstatus</code>中的<code>SSP</code>位。</li>
<li><code>scause</code>中保存导致陷阱<code>trap</code>的原因。</li>
<li>更改模式为监管<code>supervisor mode</code>。</li>
<li>复制<code>stvec</code>的值到<code>pc</code>。</li>
<li>从新的<code>pc</code>处执行程序。</li>
</ol>
<h3 id="4-2-Trap-from-user-space"><a href="#4-2-Trap-from-user-space" class="headerlink" title="4.2 Trap from user space"></a>4.2 Trap from user space</h3><p>当用户程序执行系统调用（ecall指令）、进行非法操作或设备中断时，可能会在用户空间执行时发生陷阱。用户空间陷阱的处理路径是首先通过uservec（位于kernel&#x2F;trampoline.S:21），然后是usertrap（位于kernel&#x2F;trap.c:37）；在返回时，通过usertrapret（位于kernel&#x2F;trap.c:90）然后是userret（位于kernel&#x2F;trampoline.S:101）。</p>
<ul>
<li><p><code>uservec</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">.section trampsec</span><br><span class="line">.globl trampoline</span><br><span class="line">.globl usertrap</span><br><span class="line">trampoline:</span><br><span class="line">.align 4</span><br><span class="line">.globl uservec</span><br><span class="line">uservec:    </span><br><span class="line">	#</span><br><span class="line">        # trap.c sets stvec to point here, so</span><br><span class="line">        # traps from user space start here,</span><br><span class="line">        # in supervisor mode, but with a</span><br><span class="line">        # user page table.</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        # save user a0 in sscratch so</span><br><span class="line">        # a0 can be used to get at TRAPFRAME.</span><br><span class="line">        csrw sscratch, a0 // 将 a0 寄存器的值存储到 sscratch 寄存器中，也就是0x3f ffff e000</span><br><span class="line"></span><br><span class="line">        # each process has a separate p-&gt;trapframe memory area,</span><br><span class="line">        # but it&#x27;s mapped to the same virtual address</span><br><span class="line">        # (TRAPFRAME) in every process&#x27;s user page table.</span><br><span class="line">        li a0, TRAPFRAME # 这里开始 a0 指向 TRAPFRAME </span><br><span class="line">        </span><br><span class="line">        # save the user registers in TRAPFRAME 每个寄存器占8字节</span><br><span class="line">        sd ra, 40(a0)</span><br><span class="line">        sd sp, 48(a0)</span><br><span class="line">        sd gp, 56(a0)</span><br><span class="line">        sd tp, 64(a0)</span><br><span class="line">        sd t0, 72(a0)</span><br><span class="line">        sd t1, 80(a0)</span><br><span class="line">        sd t2, 88(a0)</span><br><span class="line">        sd s0, 96(a0)</span><br><span class="line">        sd s1, 104(a0)</span><br><span class="line">        sd a1, 120(a0)</span><br><span class="line">        sd a2, 128(a0)</span><br><span class="line">        sd a3, 136(a0)</span><br><span class="line">        sd a4, 144(a0)</span><br><span class="line">        sd a5, 152(a0)</span><br><span class="line">        sd a6, 160(a0)</span><br><span class="line">        sd a7, 168(a0)</span><br><span class="line">        sd s2, 176(a0)</span><br><span class="line">        sd s3, 184(a0)</span><br><span class="line">        sd s4, 192(a0)</span><br><span class="line">        sd s5, 200(a0)</span><br><span class="line">        sd s6, 208(a0)</span><br><span class="line">        sd s7, 216(a0)</span><br><span class="line">        sd s8, 224(a0)</span><br><span class="line">        sd s9, 232(a0)</span><br><span class="line">        sd s10, 240(a0)</span><br><span class="line">        sd s11, 248(a0)</span><br><span class="line">        sd t3, 256(a0)</span><br><span class="line">        sd t4, 264(a0)</span><br><span class="line">        sd t5, 272(a0)</span><br><span class="line">        sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# save the user a0 in p-&gt;trapframe-&gt;a0</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, 112(a0) # 将 t0 寄存器的值存储到 a0 寄存器指向的偏移量为 112 字节的位置</span><br><span class="line"></span><br><span class="line">        # initialize kernel stack pointer, from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">        ld sp, 8(a0) # 将 a0 寄存器指向的地址加上8字节偏移后的内存位置的内容加载到栈指针sp寄存器中</span><br><span class="line">        # a0 寄存器指向的地址加上8字节偏移后的内存位置就是 内核栈指针</span><br><span class="line"></span><br><span class="line">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">        ld tp, 32(a0)</span><br><span class="line"></span><br><span class="line">        # load the address of usertrap(), from p-&gt;trapframe-&gt;kernel_trap</span><br><span class="line">        ld t0, 16(a0) # t0 指向 usertrap() 的地址</span><br><span class="line"></span><br><span class="line">        # fetch the kernel page table address, from p-&gt;trapframe-&gt;kernel_satp.</span><br><span class="line">        ld t1, 0(a0) 	# </span><br><span class="line"></span><br><span class="line">        # wait for any previous memory operations to complete, so that</span><br><span class="line">        # they use the user page table.</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # install the kernel page table.</span><br><span class="line">        csrw satp, t1</span><br><span class="line"></span><br><span class="line">        # flush now-stale user entries from the TLB.</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # jump to usertrap(), which does not return</span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure>

<p>这里解释一下<code>satp</code>寄存器。<code>satp</code>寄存器用于监督模式下的地址转换和保护。这个寄存器包含根页表的物理页号（PPN）、一个地址空间标识符（ASID），以及选择当前地址转换方案的MODE字段。ASID用于基于每个地址空间的地址转换隔离，而PPN是根页表的监督物理地址除以4KiB的结果。</p>
<p>也即，<code>satp</code>寄存器指向<code>page table</code></p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-02-29%2012.01.53.png" alt="截屏2024-02-29 12.01.53"></p>
</li>
<li><p><code>usertrap()</code>处理来自用户空间的中断、异常或系统调用。由<code>trampoline.S</code>调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* 寄存器 sstatus 的 SSP 位指明 trap 是否来自用户态 */</span></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  <span class="comment">// 在发生用户陷阱（user trap）时，硬件自动将用户程序计数器的值存储到sepc寄存器中。</span></span><br><span class="line">  <span class="comment">// 现在我们将该值存储到 trapframe 中以用于之后恢复现场</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(killed(p))</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    <span class="comment">// 因为系统调用时程序计数器指向 ecall 指令</span></span><br><span class="line">    <span class="comment">// trap处理完后要执行 ecall 指令的下一条指令</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sepc, scause, and sstatus,</span></span><br><span class="line">    <span class="comment">// so enable only now that we&#x27;re done with those registers.</span></span><br><span class="line">    intr_on();	<span class="comment">// 允许supervisor interrupt</span></span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok device interrupt</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// exception</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    setkilled(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(killed(p))</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>usertrapret()</code>用于返回到用户态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// return to user space</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">  <span class="comment">// 在回到用户态之前，禁用所有中断</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to uservec in trampoline.S</span></span><br><span class="line">  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);</span><br><span class="line">  w_stvec(trampoline_uservec);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">  <span class="comment">// the process next traps into the kernel.</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jump to userret in trampoline.S at the top of memory, which </span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="type">void</span> (*)(uint64))trampoline_userret)(satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>userret</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        # userret(pagetable)</span><br><span class="line">        # called by usertrapret() in trap.c to</span><br><span class="line">        # switch from kernel to user.</span><br><span class="line">        # a0: user page table, for satp.</span><br><span class="line"></span><br><span class="line">        # switch to the user page table.</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line">        csrw satp, a0</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        li a0, TRAPFRAME</span><br><span class="line"></span><br><span class="line">        # restore all but a0 from TRAPFRAME</span><br><span class="line">        ld ra, 40(a0)</span><br><span class="line">        ld sp, 48(a0)</span><br><span class="line">        ld gp, 56(a0)</span><br><span class="line">        ld tp, 64(a0)</span><br><span class="line">        ld t0, 72(a0)</span><br><span class="line">        ld t1, 80(a0)</span><br><span class="line">        ld t2, 88(a0)</span><br><span class="line">        ld s0, 96(a0)</span><br><span class="line">        ld s1, 104(a0)</span><br><span class="line">        ld a1, 120(a0)</span><br><span class="line">        ld a2, 128(a0)</span><br><span class="line">        ld a3, 136(a0)</span><br><span class="line">        ld a4, 144(a0)</span><br><span class="line">        ld a5, 152(a0)</span><br><span class="line">        ld a6, 160(a0)</span><br><span class="line">        ld a7, 168(a0)</span><br><span class="line">        ld s2, 176(a0)</span><br><span class="line">        ld s3, 184(a0)</span><br><span class="line">        ld s4, 192(a0)</span><br><span class="line">        ld s5, 200(a0)</span><br><span class="line">        ld s6, 208(a0)</span><br><span class="line">        ld s7, 216(a0)</span><br><span class="line">        ld s8, 224(a0)</span><br><span class="line">        ld s9, 232(a0)</span><br><span class="line">        ld s10, 240(a0)</span><br><span class="line">        ld s11, 248(a0)</span><br><span class="line">        ld t3, 256(a0)</span><br><span class="line">        ld t4, 264(a0)</span><br><span class="line">        ld t5, 272(a0)</span><br><span class="line">        ld t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# restore user a0</span><br><span class="line">        ld a0, 112(a0)</span><br><span class="line">        </span><br><span class="line">        # return to user mode and user pc.</span><br><span class="line">        # usertrapret() set up sstatus and sepc.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ECALL-指令之前的状态"><a href="#ECALL-指令之前的状态" class="headerlink" title="ECALL 指令之前的状态"></a>ECALL 指令之前的状态</h3><p>跟踪一个xv6的系统调用，也就是Shell将它的提示信息通过write系统调用走到操作系统再输出到console的过程。</p>
<p>在代码<code>sh.c</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">getcmd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> nbuf)</span></span><br><span class="line">&#123;</span><br><span class="line">  write(<span class="number">2</span>, <span class="string">&quot;$ &quot;</span>, <span class="number">2</span>); <span class="comment">// 	write 系统调用</span></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, nbuf);</span><br><span class="line">  gets(buf, nbuf);</span><br><span class="line">  <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="number">0</span>) <span class="comment">// EOF</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动<code>gdb</code>。</p>
<p>作为用户代码的<code>Shell</code>调用<code>write</code>时，实际上调用的是关联到<code>Shell</code>一个库函数。查看这个库的源代码，在<code>usys.S</code>中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.global write</span><br><span class="line">write:</span><br><span class="line"> li a7, SYS_write	# 将SYS_write 加载到 寄存器a7 中</span><br><span class="line"> ecall	# 执行ecall指令</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>

<p>我们通过在ecall指令处放置一个断点展示系统调用，为了放置断点，我们首先要知道指令地址，查看<code>XV6</code>编译过程产生的<code>sh.asm</code>找出这个地址。<code>sh.asm</code>是带有指令地址的汇编代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000000e2c &lt;write&gt;:</span><br><span class="line">.global write</span><br><span class="line">write:</span><br><span class="line"> li a7, SYS_write</span><br><span class="line">     e2c:	48c1                	li	a7,16</span><br><span class="line"> ecall</span><br><span class="line">     e2e:	00000073          	ecall</span><br><span class="line"> ret</span><br><span class="line">     e32:	8082                	ret</span><br></pre></td></tr></table></figure>

<p>在<code>ecall</code>指令处放置一个断点，这条指令的地址是<code>0xe2e</code>。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2010.05.14.png" alt="截屏2024-03-01 10.05.14"></p>
<p>从<code>gdb</code>中，我们看到下一条要执行的指令就是<code>ecall</code>。打印并检查程序计数器，确实是在<code>0xe2e</code>的位置。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2010.07.06.png" alt="截屏2024-03-01 10.07.06"></p>
<p>通过<code>info reg</code>打印全部用户寄存器。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2010.10.28.png" alt="截屏2024-03-01 10.10.28"></p>
<p><code>a0 a1 a2</code>是<code>Shell</code>传递给<code>write</code>系统调用的参数。所以<code>a0</code>是文件描述符<code>2</code>，<code>a1</code>是<code>Shell</code>想要写入字符串的指针，<code>a2</code>是想要写入的字符数。还可以通过打印<code>Shell</code>想要写入的字符串内容，来证明断点停留在我们认为它应该停在的位置。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2010.14.21-9259264.png" alt="截屏2024-03-01 10.14.21"></p>
<p>一个美元符号和一个空格。</p>
<p>值得注意的是，寄存器中程序计数器<code>pc</code>和堆栈指针<code>sp</code>（上图没显示全<code>sp = 0x4f80</code>都在距离0较近的地址，这进一步说明当前代码运行在用户空间，因为<strong>用户空间中所有地址都比较小</strong>，一旦进入内核，<strong>内核会使用大得多的内存空间</strong>。</p>
<p>系统调用的时间点会有大量状态的变更，其中一个最重要的需要变更的状态，并且在它变更之前我们对它还有依赖的，就是当前的<code>page table</code>。可以查看<code>SATP</code>寄存器。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2010.20.40.png" alt="截屏2024-03-01 10.20.40"></p>
<p>这是物理内存地址，它并没有说明有关<code>page table</code>中的映射关系是什么，<code>page table</code>长什么样。<code>QEMU</code>中有一个方法可以打印当前<code>page table</code>。从<code>QEMU</code>界面中输入<code>ctrl a + c</code>可以进入到<code>QEMU</code>的<code>console</code>，之后输入<code>info mem</code>，<code>QEMU</code>会打印完整的<code>page table</code>。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2011.03.07.png" alt="截屏2024-03-01 11.03.07"></p>
<p>接着在<code>Shell</code>中打印出<code>write</code>函数的内容。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2010.30.34.png" alt="截屏2024-03-01 10.30.34"></p>
<p>程序计数器现在指向<code>ecall</code>指令，我们接下来要执行<code>ecall</code>指令。现在我们还在用户空间，但是即将进入内核空间了。</p>
<h3 id="ECALL指令之后的状态"><a href="#ECALL指令之后的状态" class="headerlink" title="ECALL指令之后的状态"></a><code>ECALL</code>指令之后的状态</h3><p>执行<code>ecall</code>指令，</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2011.16.13.png" alt="截屏2024-03-01 11.16.13"></p>
<p>看到程序计数器的值变为一个大得多的地址。但是通过<code>QEMU</code>执行<code>info mem</code>后发现<code>page table</code>并没有改变。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2011.16.33.png" alt="截屏2024-03-01 11.16.33"></p>
<p>在<code>memlayout.h</code>中定义了<code>TRAMPOLINE</code>和<code>TRAPFRAME</code>的物理地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map the trampoline page to the highest address,</span></span><br><span class="line"><span class="comment">// in both user and kernel space.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAMPOLINE (MAXVA - PGSIZE)</span></span><br><span class="line"><span class="comment">// User memory layout.</span></span><br><span class="line"><span class="comment">// Address zero first:</span></span><br><span class="line"><span class="comment">//   text</span></span><br><span class="line"><span class="comment">//   original data and bss</span></span><br><span class="line"><span class="comment">//   fixed-size stack</span></span><br><span class="line"><span class="comment">//   expandable heap</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   USYSCALL (shared with kernel)</span></span><br><span class="line"><span class="comment">//   TRAPFRAME (p-&gt;trapframe, used by the trampoline)</span></span><br><span class="line"><span class="comment">//   TRAMPOLINE (the same page as in the kernel)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE)</span></span><br></pre></td></tr></table></figure>

<p>在<code>riscv.h</code>中定义了<code>MAXVA</code>，<code>MAXVA = 0x40 0000 0000</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// one beyond the highest possible virtual address.</span></span><br><span class="line"><span class="comment">// MAXVA is actually one bit less than the max allowed by</span></span><br><span class="line"><span class="comment">// Sv39, to avoid having to sign-extend virtual addresses</span></span><br><span class="line"><span class="comment">// that have the high bit set.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))</span></span><br></pre></td></tr></table></figure>

<p>因此我们得到<code>TRAMPOLINE = 0x3f ffff f000</code>，<code>TRAPFRAM = 0x3f ffff e000</code>。</p>
<p>程序计数器指示代码正在<code>trampoline page</code>得最开始，这是用户内存中一个非常大的地址。我们可以查看一下将要运行的指令。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2011.19.56.png" alt="截屏2024-03-01 11.19.56"></p>
<p>这些指令是内核在<code>supervisor mode</code>中将要执行的最开始的几条指令，也是在<code>trap</code>机制中最开始要执行的几条指令。</p>
<p>查看寄存器:</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2011.28.24.png" alt="截屏2024-03-01 11.28.24"></p>
<p>发现并没有变化，这里还是用户程序拥有的一些寄存器内容。所以现在寄存器里还是用户程序的数据，并且这些数据也还只保存在这些寄存器中，所以我们将这些寄存器的值保存在某处之前，<strong>我们在这个时间点不能使用任何寄存器</strong>，内核会覆盖寄存器内的用户数据，之后如果我们尝试要恢复用户程序，我们就不能回复寄存器中的正确数据，用户程序执行将会出错。</p>
<p>我们现在所在的地址为<code>0x3f ffff ffff</code>，这是<code>page table</code>的最后一个<code>page</code>，这是<code>trampoline page</code>。我们现在正在<code>trampoline page</code>中执行程序，这个<code>page</code>包含了内核的<code>trap</code>处理代码。**<code>ecall</code>并不会切换<code>page table</code>，这是<code>ecall</code>指令非常重要的一个特点。**所以这意味着，<code>trap</code>处理代码必须存在于每个<code>user page table</code>中。因为<code>ecall</code>并不会切换<code>page table</code>，我们需要在<code>user page table</code>中的某个地方来执行最初的内核代码。而这个<code>trampoline page</code>，是由内核小心映射到每一个<code>user page table</code>中，以使我们仍然在使用<code>user page table</code>时，内核在一个地方能够执行<code>trap</code>机制的最开始的一些指令。</p>
<p>这里的控制是通过<code>stvec</code>寄存器完成的，这是一个只能在<code>supervisor mode</code>下读写的特权寄存器。在从内核空间进入到用户空间之前，内核会设置好<code>stvec</code>寄存器指向内核希望<code>trap</code>代码允许的位置。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2011.47.27-9264852.png" alt="截屏2024-03-01 11.47.27"></p>
<p>如图所示，内核已经事先设置好了<code>STVEC</code>寄存器的内容为<code>0x3f ffff f000</code>，这就是<code>trampoline page</code>的起始位置。<code>STVEC</code>寄存器的内容，就是在<code>ecall</code>指令执行之后，我们会在这个特定地址执行指令的原因。</p>
<p>即使<code>trampoline page</code>是在用户地址空间的<code>user page table</code>完成的映射，用户代码不能写它，因为这些<code>page</code>对应的<code>PTE</code>并没有设置<code>PTE_u</code>标志位。因此<code>trap</code>机制是安全的。</p>
<p>虽然一直说已经在supervisor mode 中了，但是实际上并没有任何能直接确认当前在哪种mode下的方法。不过我们的确发现程序计数器正在<code>trampoline page</code>执行代码，而这些page对应的PTE并没有设置PTE_u标识位。所以现在只有当代码在supervisor mode时，才可能在程序运行的同时而不崩溃。所以我们推导出当前必然在<code>supervisor mode</code></p>
<p>通过<code>ecall</code>走到<code>trampoline page</code>，<code>ecall</code>实际上指改变三件事：</p>
<p>第一，<code>ecall</code>将代码从<code>user mode</code>改到<code>supervisor mode</code></p>
<p>第二，<code>ecall</code>将程序计数器的值保存在<code>sepc</code>寄存器。通过打印程序计数器看到这里的效果，</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2013.29.24.png" alt="截屏2024-03-01 13.29.24"></p>
<p>尽管其他的寄存器还是原来用户寄存器的值，但是这里的程序计数器明显已经不是用户代码的程序计数器了。这里的程序计数器是从<code>stvec</code>寄存器拷贝过来的值。我们打印<code>sepc</code>寄存器，这是<code>ecall</code>保存用户程序计数器的地方。</p>
<p>这个寄存器里面有熟悉的地址<code>0xe2e</code>，这是<code>ecall</code>指令在用户空间的地址。所以<code>ecall</code>至少保存了程序计数器的数值。</p>
<p>第三，<code>ecall</code>会跳转到<code>stvec</code>寄存器指向的指令。</p>
<p>所以现在，ecall 帮我们做了一点点工作，但实际上我们离执行内核中的c代码还差的很远。接下来：</p>
<ul>
<li>我们需要保存32个用户寄存器的内容，这样当我们想要恢复用户代码执行时，我们才能恢复这些寄存器的内容。</li>
<li>因为现在我们还在user page table，我们需要切换到kernel page table</li>
<li>我们需要创建或者找到一个kernel stack，并将stack pointer 寄存器的内容指向那个kernel stack。这样才能给c代码提供栈。</li>
<li>我们还需要跳转到内核中c代码的某些合理的位置。</li>
</ul>
<p>然而<code>ecall</code>并不会做这里的任何一件事。</p>
<p>当然可以通过修改硬件让<code>ecall</code>完成这些工作，而不是交给软件完成。并且，我们也将会看到，在软件中完成这些工作并不是特别简单。那为什么<code>ecall</code>不多做点工作来讲代码执行从用户态切换到内核空间呢？为什么ecall不会保存用户寄存器，或者切换<code>page table</code>的指针来指向<code>kernel page table</code>，或者自动的设置<code>Stack Pointer</code>指向<code>kernel stack</code>，或者直接跳转到kernel的c代码，而不是在这里运行复杂的汇编代码？</p>
<p>实际上，有的机器在执行系统调用时，会在硬件中完成所有这些工作。但是<code>RISC-V</code>并不会，<code>RISC-V</code>秉持了这样一个观点：ecall只完成尽量少必须要完成的工作，其他的工作都交给软件完成。这里的原因是，RISC-V设计者想要为软件和操作系统的程序员提供最大的灵活性，这样他们就能按照他们想要的方式开发操作系统。所以你可以这样想，尽管XV6并没有使用这里提供的灵活性，但是一些其他操作系统用到了。</p>
<ul>
<li>举个例子，因为这里的ecall是如此简单，或许某些操作系统可以在不切换page table的前提下，执行部分系统调用。切换page table的代价比较高，如果ecall打包完成了这部分工作，那就不能对一些系统调用进行改进，使其不用在不必要的场景切换page table。</li>
<li>某些操作系统同时将user和kernel的虚拟地址映射到一个page table中，这样在user和kernel之间切换时根本就不需要切换page table。对于这样的操作系统来说，如果ecall切换了page table那将会是一种浪费，并且也减慢了程序的运行。</li>
<li>或许在一些系统调用过程中，一些寄存器不用保存，而哪些寄存器需要保存，哪些不需要，取决于软件，编程语言和编译器。通过不保存所有的32个寄存器获取可以节省大量的程序运行时间，所以你不会想ecall迫使你保存所有的寄存器。</li>
<li>最后，对于某些简单的系统调用或许根本就不要任何stack，所以对于一些非常关注性能的操作系统，ecall不会自动位你完成stack切换是极好的。</li>
</ul>
<p>所以，ecall尽量的简单可以提升软件设计的灵活性。</p>
<p>在代码或者gdb中看不到ecall的具体内容的原因：</p>
<p><strong>ecall实际上是cpu的指令，自然在gdb或者代码中看不到具体内容</strong></p>
<h3 id="uservec函数"><a href="#uservec函数" class="headerlink" title="uservec函数"></a>uservec函数</h3><p>在ecall指令执行后，现在程序位于trampoline page的起始，也就是<code>uservec</code>函数的起始。现在需要做的第一件事就是保存寄存器内容。</p>
<p>在一些机器中，可以直接将寄存器中的内容写到物理内存的合适位置。但是我们不能在<code>RISC-V</code>中这样做，因为在RISV-V中，supervisor mode下的代码不允许直接访问物理内存。所以只能使用page table中的内容，但是从输出来看（见下文**<code>ECALL</code>指令之后的状态**），page table中也没有多少内容。</p>
<p>虽然xv6并没有使用，但是另一种可能的操作是，直接讲satp寄存器指向kernel page table，之后我们就可以直接使用所有的kernel mapping来帮助我们存储用户寄存器。这是合法的，因为supervisor mode可以更改satp寄存器。但是在trap机制的最开始，我们并不知道kernel page table的地址。并且更改satp寄存器的指令，要求写入satp寄存器的内容来自于另一个寄存器。所以，位了能执行更新page table的指令，我们需要一些空闲寄存器，这样才能先将page table的地址存在这些寄存器中，然后再执行修改satp寄存器的指令。</p>
<p>对于保存用户寄存器，XV6在RISC-V上的实现包括了两个部分。第一个部分是，XV6在每个user page table映射了trapframe page，这样每个进程都有自己的trapframe page。这个page包含了很多有趣的数据，但是现在最重要的数据是用来保存用户寄存器的32个空槽位。所以，在trap处理代码中，现在的好消息是，我们在user page table有一个之前由kernel设置好的映射关系，这个映射关系指向了一个可以用来存放这个进程的用户寄存器的内存位置。这个位置的虚拟地址总是0x3ffffffe000。</p>
<p>xv6的trapframe中存储了如下信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// per-process data for the trap handling code in trampoline.S.</span></span><br><span class="line"><span class="comment">// sits in a page by itself just under the trampoline page in the</span></span><br><span class="line"><span class="comment">// user page table. not specially mapped in the kernel page table.</span></span><br><span class="line"><span class="comment">// uservec in trampoline.S saves user registers in the trapframe,</span></span><br><span class="line"><span class="comment">// then initializes registers from the trapframe&#x27;s</span></span><br><span class="line"><span class="comment">// kernel_sp, kernel_hartid, kernel_satp, and jumps to kernel_trap.</span></span><br><span class="line"><span class="comment">// usertrapret() and userret in trampoline.S set up</span></span><br><span class="line"><span class="comment">// the trapframe&#x27;s kernel_*, restore user registers from the</span></span><br><span class="line"><span class="comment">// trapframe, switch to the user page table, and enter user space.</span></span><br><span class="line"><span class="comment">// the trapframe includes callee-saved user registers like s0-s11 because the</span></span><br><span class="line"><span class="comment">// return-to-user path via usertrapret() doesn&#x27;t return through</span></span><br><span class="line"><span class="comment">// the entire kernel call stack.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// kernel page table tarp处理代码将要加载到satp寄存器的数值</span></span><br><span class="line">  <span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// top of process&#x27;s kernel stack</span></span><br><span class="line">  <span class="comment">/*  16 */</span> uint64 kernel_trap;   <span class="comment">// usertrap()</span></span><br><span class="line">  <span class="comment">/*  24 */</span> uint64 epc;           <span class="comment">// saved user program counter</span></span><br><span class="line">  <span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp</span></span><br><span class="line">  <span class="comment">/*  40 */</span> uint64 ra;</span><br><span class="line">  <span class="comment">/*  48 */</span> uint64 sp;</span><br><span class="line">  <span class="comment">/*  56 */</span> uint64 gp;</span><br><span class="line">  <span class="comment">/*  64 */</span> uint64 tp;</span><br><span class="line">  <span class="comment">/*  72 */</span> uint64 t0;</span><br><span class="line">  <span class="comment">/*  80 */</span> uint64 t1;</span><br><span class="line">  <span class="comment">/*  88 */</span> uint64 t2;</span><br><span class="line">  <span class="comment">/*  96 */</span> uint64 s0;</span><br><span class="line">  <span class="comment">/* 104 */</span> uint64 s1;</span><br><span class="line">  <span class="comment">/* 112 */</span> uint64 a0;</span><br><span class="line">  <span class="comment">/* 120 */</span> uint64 a1;</span><br><span class="line">  <span class="comment">/* 128 */</span> uint64 a2;</span><br><span class="line">  <span class="comment">/* 136 */</span> uint64 a3;</span><br><span class="line">  <span class="comment">/* 144 */</span> uint64 a4;</span><br><span class="line">  <span class="comment">/* 152 */</span> uint64 a5;</span><br><span class="line">  <span class="comment">/* 160 */</span> uint64 a6;</span><br><span class="line">  <span class="comment">/* 168 */</span> uint64 a7;</span><br><span class="line">  <span class="comment">/* 176 */</span> uint64 s2;</span><br><span class="line">  <span class="comment">/* 184 */</span> uint64 s3;</span><br><span class="line">  <span class="comment">/* 192 */</span> uint64 s4;</span><br><span class="line">  <span class="comment">/* 200 */</span> uint64 s5;</span><br><span class="line">  <span class="comment">/* 208 */</span> uint64 s6;</span><br><span class="line">  <span class="comment">/* 216 */</span> uint64 s7;</span><br><span class="line">  <span class="comment">/* 224 */</span> uint64 s8;</span><br><span class="line">  <span class="comment">/* 232 */</span> uint64 s9;</span><br><span class="line">  <span class="comment">/* 240 */</span> uint64 s10;</span><br><span class="line">  <span class="comment">/* 248 */</span> uint64 s11;</span><br><span class="line">  <span class="comment">/* 256 */</span> uint64 t3;</span><br><span class="line">  <span class="comment">/* 264 */</span> uint64 t4;</span><br><span class="line">  <span class="comment">/* 272 */</span> uint64 t5;</span><br><span class="line">  <span class="comment">/* 280 */</span> uint64 t6;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以，如何保存用户寄存器的一半答案是，内核非常方便的将trapframe page 映射到了每个user page table。</p>
<p>另一半的答案在于我们之前提到过的SSCRATCH寄存器。这个由RISC-V提供的SSRCATCH寄存器，就是为接下来的目的而创建的。内核会将trapframe page的地址保存在这个寄存器中，也就是0x3fffffe000这个地址。更重要的是，RISC-V有一个指令允许交换任意两个寄存器的值。而SSCRATCH寄存器的作用就是保存另一个寄存器的值，并将自己的值加载给另一个寄存器。如果我查看trampoline.S代码，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">.section trampsec</span><br><span class="line">.globl trampoline</span><br><span class="line">.globl usertrap</span><br><span class="line">trampoline:</span><br><span class="line">.align 4</span><br><span class="line">.globl uservec</span><br><span class="line">uservec:    </span><br><span class="line">	#</span><br><span class="line">        # trap.c sets stvec to point here, so</span><br><span class="line">        # traps from user space start here,</span><br><span class="line">        # in supervisor mode, but with a</span><br><span class="line">        # user page table.</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        # save user a0 in sscratch so</span><br><span class="line">        # a0 can be used to get at TRAPFRAME.</span><br><span class="line">        csrw sscratch, a0 // 将 a0 寄存器的值存储到 sscratch 寄存器中，也就是0x3f ffff e000</span><br><span class="line"></span><br><span class="line">        # each process has a separate p-&gt;trapframe memory area,</span><br><span class="line">        # but it&#x27;s mapped to the same virtual address</span><br><span class="line">        # (TRAPFRAME) in every process&#x27;s user page table.</span><br><span class="line">        li a0, TRAPFRAME # 这里开始 a0 指向 TRAPFRAME </span><br><span class="line">        </span><br><span class="line">        # save the user registers in TRAPFRAME 每个寄存器占8字节</span><br><span class="line">        sd ra, 40(a0)</span><br><span class="line">        sd sp, 48(a0)</span><br><span class="line">        sd gp, 56(a0)</span><br><span class="line">        sd tp, 64(a0)</span><br><span class="line">        sd t0, 72(a0)</span><br><span class="line">        sd t1, 80(a0)</span><br><span class="line">        sd t2, 88(a0)</span><br><span class="line">        sd s0, 96(a0)</span><br><span class="line">        sd s1, 104(a0)</span><br><span class="line">        sd a1, 120(a0)</span><br><span class="line">        sd a2, 128(a0)</span><br><span class="line">        sd a3, 136(a0)</span><br><span class="line">        sd a4, 144(a0)</span><br><span class="line">        sd a5, 152(a0)</span><br><span class="line">        sd a6, 160(a0)</span><br><span class="line">        sd a7, 168(a0)</span><br><span class="line">        sd s2, 176(a0)</span><br><span class="line">        sd s3, 184(a0)</span><br><span class="line">        sd s4, 192(a0)</span><br><span class="line">        sd s5, 200(a0)</span><br><span class="line">        sd s6, 208(a0)</span><br><span class="line">        sd s7, 216(a0)</span><br><span class="line">        sd s8, 224(a0)</span><br><span class="line">        sd s9, 232(a0)</span><br><span class="line">        sd s10, 240(a0)</span><br><span class="line">        sd s11, 248(a0)</span><br><span class="line">        sd t3, 256(a0)</span><br><span class="line">        sd t4, 264(a0)</span><br><span class="line">        sd t5, 272(a0)</span><br><span class="line">        sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# save the user a0 in p-&gt;trapframe-&gt;a0</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, 112(a0) # 将 t0 寄存器的值存储到 a0 寄存器指向的偏移量为 112 字节的位置</span><br><span class="line"></span><br><span class="line">        # initialize kernel stack pointer, from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">        ld sp, 8(a0) # 将 a0 寄存器指向的地址加上8字节偏移后的内存位置的内容加载到栈指针sp寄存器中</span><br><span class="line">        # a0 寄存器指向的地址加上8字节偏移后的内存位置就是 内核栈指针</span><br><span class="line"></span><br><span class="line">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">        ld tp, 32(a0)</span><br><span class="line"></span><br><span class="line">        # load the address of usertrap(), from p-&gt;trapframe-&gt;kernel_trap</span><br><span class="line">        ld t0, 16(a0) # t0 指向 usertrap() 的地址</span><br><span class="line"></span><br><span class="line">        # fetch the kernel page table address, from p-&gt;trapframe-&gt;kernel_satp.</span><br><span class="line">        ld t1, 0(a0) 	# </span><br><span class="line"></span><br><span class="line">        # wait for any previous memory operations to complete, so that</span><br><span class="line">        # they use the user page table.</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # install the kernel page table.</span><br><span class="line">        csrw satp, t1</span><br><span class="line"></span><br><span class="line">        # flush now-stale user entries from the TLB.</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # jump to usertrap(), which does not return</span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure>

<p>这里解释一下<code>satp</code>寄存器。<code>satp</code>寄存器用于监督模式下的地址转换和保护。这个寄存器包含根页表的物理页号（PPN）、一个地址空间标识符（ASID），以及选择当前地址转换方案的MODE字段。ASID用于基于每个地址空间的地址转换隔离，而PPN是根页表的监督物理地址除以4KiB的结果。</p>
<p>也即，<code>satp</code>寄存器指向<code>page table</code></p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-02-29%2012.01.53.png" alt="截屏2024-02-29 12.01.53"></p>
<p>指令csrrw执行完后，交换了a0和sscratch的值，寄存器a0中的值为<code>0x3f ffff e000</code>，这是trapframe的虚拟地址。他之前保存在<code>SSCRATCH</code>寄存器中，但是现在交换到了a0中。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2015.08.25.png" alt="截屏2024-03-01 15.08.25"></p>
<p>我们也可以打印<code>sscratch</code>寄存器的值：</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2015.12.37.png" alt="截屏2024-03-01 15.12.37"></p>
<p>他现在的内容是2，这就是a0寄存器之前的值。a0寄存器保存的是write函数的第一个参数，在这个场景下，是Shell传入的文件描述符2。所以我们现在将a0的值保存起来了，并且我们有了指向trapframe page的指针。现在我们正在朝着保存用户寄存器的道路上前进。实际上，这就是trampoline.S中接下来30多个奇怪指令的工作。这些指令就是的执行sd，将每个寄存器保存在trapframe的不同偏移位置。因为a0在交换完之后包含的是trapframe page地址，也就是0x3fffffe000。所以，每个寄存器被保存在了偏移量+a0的位置。这些存储的指令比较无聊，我就不介绍了。</p>
<p>trapframe的地址是怎么出现在sscratch寄存器中的？</p>
<p>在内核前一次切换回用户空间时，内核会执行set sscratch指令，将这个寄存器的内容设置为<code>0x3f ffff e000</code>，也就是trapframe page的虚拟地址。所以，当我们运行用户代码，比如运行Shell时，sscratch保存的就是指向trapframe的地址。之后，Shell执行了ecall指令，跳转到了trampoline page，这个page中的第一条指令和第二条指令会将a0的值保存到sscratch中，然后将TRAPFRAME的地址加载到a0寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># save user a0 in sscratch so</span><br><span class="line"># a0 can be used to get at TRAPFRAME.</span><br><span class="line">csrw sscratch, a0</span><br><span class="line"></span><br><span class="line"># each process has a separate p-&gt;trapframe memory area,</span><br><span class="line"># but it&#x27;s mapped to the same virtual address</span><br><span class="line"># (TRAPFRAME) in every process&#x27;s user page table.</span><br><span class="line">li a0, TRAPFRAME</span><br></pre></td></tr></table></figure>

<p><strong>sscratch寄存器存在于cpu上</strong>，是一个特殊寄存器。</p>
<p>需要注意的是，一台机器总是从内核开始运行的，当机器启动的时候，它就是在内核中。任何时候，不管是进程第一次启动还是从一个系统调用返回，进入到用户空间的唯一方法就是执行sret指令。sret指令是由RISC-V定义的用来从supervisor mode 转换到 user mode。所以，在执行任何用户代码之前，都会调用函数<code>usertrapret()</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jump to userret in trampoline.S at the top of memory, which </span></span><br><span class="line"><span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line"><span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">((<span class="type">void</span> (*)(uint64))trampoline_userret)(satp);</span><br></pre></td></tr></table></figure>

<p>在该函数的最后通过<code>((void (*)(uint64))trampoline_userret)(satp);</code>将satp传入trampoline.S的userret中。</p>
<p>现在运行程序并停留在寄存器拷贝结束的位置：</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2016.46.17.png" alt="截屏2024-03-01 16.46.17"></p>
<p>这条指令将从a0指向的内存地址往后数的第8个字节开始的数据加载到stack pointer寄存器。当前a0的内容为trapframe page的地址，在<code>proc.h</code>中的<code>trapframe</code>结构体也可以看出第8个字节开始的数据是内核的stack pointer（kernel_sp）。trapframe中的kernel_sp是由内核在进入用户空间前就设置好的，他的值是这个进程的kernel stack的最顶端。执行完这条指令之后，我们打印当前stack pointer寄存器。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2016.52.39.png" alt="截屏2024-03-01 16.52.39"></p>
<p>这是这个进程的kernel stack。因为xv6在每个kernel stack下面放置一个guard page，所以kernel stack的地址都比较大。</p>
<p>下一条指令向tp寄存器写入数据。因为在RISC-V中，没有一个直接的方法来确认当前运行在多处理器的哪个核上，<strong>XV6会将CPU核的编号，也就是hartid保存在tp寄存器中</strong>。在内核中好几个地方都会使用这个值，例如，内核可以通过这个值确定某个CPU核上运行了哪些进程。我们执行这条指令，并打印tp寄存器。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2017.04.19-9283865.png" alt="截屏2024-03-01 17.04.19"></p>
<p>现在我们知道当前进程运行在CPU的0核，这是因为我们配置的QEMU只给xv6分配了一个核，所以我们只能运行在核0上。</p>
<p>下一条指令向t0寄存器中写入数据。这里写入的是我们将要执行的第一个c函数的指针，也就是函数<code>usertrap()</code>的指针。我们在后面会使用这个指针。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2017.07.39.png" alt="截屏2024-03-01 17.07.39"></p>
<p>检索文件后发现，usertrap函数的地址确实为<code>0x80001e4e</code></p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2017.13.59.png" alt="截屏2024-03-01 17.13.59"></p>
<p>下一条指令是向<code>t1</code>寄存器中写入<code>kernel page table</code>的地址，我们可以打印<code>t1</code>寄存器的内容。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2018.33.41.png" alt="截屏2024-03-01 18.33.41"></p>
<p>严格来说，t1的内容并不是kernel page table的地址，这是你需要向SATP寄存器写入的数据。它包含了kernel page table的地址，但是移位了，并且包含了各种标志位。</p>
<p>下一条指令是交换satp和t1寄存器。这条指令执行完之后，当前程序会从user page table切换到 kernel page table。现在我们在QEMU中打印page table，可以看出与之前的page table完全不一样。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2018.43.58.png" alt="截屏2024-03-01 18.43.58"></p>
<p>现在这里输出的是由内核设置好的巨大的kernel page table。所以现在我们成功的切换了page table，我们在这个位置进展的很好，Stack Pointer指向了kernel stack；我们有了kernel page table，可以读取kernel data。我们已经准备好了执行内核中的C代码了。</p>
<p>这里还有个问题，为什么代码没有崩溃？毕竟我们在内存中的某个位置执行代码，程序计数器保存的是虚拟地址，如果我们切换了page table，为什么同一个虚拟地址不会通过新的page table寻址走到一些无关的page中？看起来我们现在没有崩溃并且还在执行这些指令。</p>
<blockquote>
<p>这是因为我们还在 trampoline page 中，而trampoline代码在用户空间和内核空间都映射到了同一个地址。</p>
</blockquote>
<p>完全正确。我不知道你们是否还记得user page table的内容，trampoline page在user page table中的映射与kernel page table中的映射是完全一样的。这两个page table中其他所有的映射都是不同的，只有trampoline page的映射是一样的，因此我们在切换page table时，寻址的结果不会改变，我们实际上就可以继续在同一个代码序列中执行程序而不崩溃。这是trampoline page的特殊之处，它同时在user page table和kernel page table都有相同的映射关系。</p>
<p>之所以叫trampoline page，是因为你某种程度在它上面“弹跳”了一下，然后从用户空间走到了内核空间。</p>
<p>最后一条指令是<code>jr t0</code>。执行了这条指令，我们就要从trampoline跳到内核的c代码中。这条指令的作用是跳转到t0指向的函数中。我们打印t0对应的一些命令。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2018.49.11.png" alt="截屏2024-03-01 18.49.11"></p>
<p>可以看到t0的位置对应于usertrap函数的开始。接下来就要以kernel stack，kernel page table跳转到usertrap函数。</p>
<h3 id="usertrap-函数"><a href="#usertrap-函数" class="headerlink" title="usertrap 函数"></a>usertrap 函数</h3><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2018.58.03.png" alt="截屏2024-03-01 18.58.03"></p>
<p>有很多原因都可以让程序运行进入到usertrap函数中来，比如系统调用，运算时除以0，使用了一个未被映射的虚拟地址，或者是设备中断。<code>usertrap</code>某种程度上存储并恢复硬件状态，但是它也需要检查触发trap的原因，以确定相应的处理方式。</p>
<p>接下来，让我们一步步执行usertrap函数。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2019.02.00.png" alt="截屏2024-03-01 19.02.00"></p>
<p>它做的第一件事情是更改<code>stvec</code>寄存器。取决于trap是来自于用户空间还是内核空间，实际上xv6处理trap的方法是不一样的。目前为止，我们只讨论过当trap是由用户空间发起时会发生什么。如果trap从内核空间发起，将会是一个不同的处理流程，因为从内核发起的话，程序已经在使用kernel page table。所以当trap发生时，程序执行仍然在内核的话，很多处理不必要存在。</p>
<p>在内核中执行任何操作之前，usertrap中先将stvec指向kernelvec变量，这是内核空间trap处理代码的位置，而不是用户空间trap处理代码的位置。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2019.14.07.png" alt="截屏2024-03-01 19.14.07"></p>
<p>我们需要知道当前运行的是什么进程，我们通过调用myproc函数来做到这一点。myproc函数实际上会查找一个根据当前CPU核的编号索引的数组，CPU核的编号是hartid，如果你还记得，我们之前在uservec函数中将它存在了tp寄存器。这是myproc函数找出当前运行进程的方法。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2019.15.42.png" alt="截屏2024-03-01 19.15.42"></p>
<p>接下来我们要保存用户程序计数器，它仍然保存在SEPC寄存器中，但是可能发生这种情况：当程序还在内核中执行时，我们可能切换到另一个进程，并进入到那个程序的用户空间，然后那个进程可能再调用一个系统调用进而导致SEPC寄存器的内容被覆盖。所以，我们需要保存当前进程的SEPC寄存器到一个与该进程关联的内存中，这样这个数据才不会被覆盖。这里我们使用trapframe来保存这个程序计数器。</p>
<p>接下来我们需要找出我们现在会在usertrap函数的原因。根据触发trap的原因，RISC-V的SCAUSE寄存器会有不同的数字。数字8表明，我们现在在trap代码中是因为系统调用。可以打印SCAUSE寄存器，它的确包含了数字8，我们的确是因为系统调用才走到这里的。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2019.17.39.png" alt="截屏2024-03-01 19.17.39"></p>
<p>所以，我们可以进到这个if语句中。接下来第一件事情是检查是不是有其他的进程杀掉了当前进程，但是我们的Shell没有被杀掉，所以检查通过。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2019.19.16.png" alt="截屏2024-03-01 19.19.16"></p>
<p>在RISC-V中，存储在SEPC寄存器中的程序计数器，是用户程序中触发trap的指令的地址。但是当我们恢复用户程序时，我们希望在下一条指令恢复，也就是ecall之后的一条指令。所以对于系统调用，我们对于保存的用户程序计数器加4，这样我们会在ecall的下一条指令恢复，而不是重新执行ecall指令。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2019.19.52.png" alt="截屏2024-03-01 19.19.52"></p>
<p>XV6会在处理系统调用的时候使能中断，这样中断可以更快的服务，有些系统调用需要许多时间处理。中断总是会被RISC-V的trap硬件关闭，所以在这个时间点，我们需要显式的打开中断。</p>
<p>下一行代码中，我们会调用syscall函数。这个函数定义在syscall.c</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2019.21.36.png" alt="截屏2024-03-01 19.21.36"></p>
<p>它的作用是从syscall表单中，根据系统调用的编号查找相应的系统调用函数。如果你还记得之前的内容，Shell调用的write函数将a7设置成了系统调用编号，对于write来说就是16。所以syscall函数的工作就是获取由trampoline代码保存在trapframe中a7的数字，然后用这个数字索引实现了每个系统调用的表单。</p>
<p>我们可以打印num，的确是16。这与Shell调用的write函数写入的数字是一致的。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2015.08.25-9294458.png" alt="截屏2024-03-01 15.08.25"></p>
<p>之后查看通过num索引得到的函数，正是sys_write函数。sys_write函数是内核对于write系统调用的具体实现。这里再往后的代码执行就非常复杂了，我就不具体介绍了。在这节课中，对于系统调用的实现，我只对进入和跳出内核感兴趣。这里我让代码直接执行sys_write函数。</p>
<p>这里有件有趣的事情，系统调用需要找到它们的参数。你们还记得write函数的参数吗？分别是文件描述符2，写入数据缓存的指针，写入数据的长度2。syscall函数直接通过trapframe来获取这些参数，就像这里刚刚可以查看trapframe中的a7寄存器一样，我们可以查看a0寄存器，这是第一个参数，a1是第二个参数，a2是第三个参数。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2020.01.59.png" alt="截屏2024-03-01 20.01.59"></p>
<p>现在syscall执行了真正的系统调用，之后sys_write返回了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use num to lookup the system call function for num, call it,</span></span><br><span class="line"><span class="comment">// and store its return value in p-&gt;trapframe-&gt;a0</span></span><br><span class="line">p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br></pre></td></tr></table></figure>

<p>这里向trapframe中的a0赋值的原因是：所有的系统调用都有一个返回值，比如write会返回实际写入的字节数，而RISC-V上的C代码的习惯是函数的返回值存储于寄存器a0，所以为了模拟函数的返回，我们将返回值存储在trapframe的a0中。之后，当我们返回到用户空间，trapframe中的a0槽位的数值会写到实际的a0寄存器，Shell会认为a0寄存器中的数值是write系统调用的返回值。执行完这一行代码之后，我们打印这里trapframe中a0的值，可以看到输出2。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-02%2009.58.11.png" alt="截屏2024-03-02 09.58.11"></p>
<p>这意味这sys_write的返回值是2，符合传入的参数，这里只写入了2个字节。</p>
<p>从syscall函数返回之后，我们回到了trap.c中的usertrap函数。</p>
<p>我们再次检查当前用户进程是否被杀掉了，因为我们不想恢复一个被杀掉的进程。当然，在我们的场景中，Shell没有被杀掉。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-02%2009.59.40.png" alt="截屏2024-03-02 09.59.40"></p>
<p>最后，usertrap调用了一个函数usertrapret。</p>
<h3 id="usertrapret函数"><a href="#usertrapret函数" class="headerlink" title="usertrapret函数"></a>usertrapret函数</h3><p>usertrap函数的最后调用了usertrapret函数，来设置好之前说过的，在返回到用户空间之前内核要做的工作。查看usertrapret函数的内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// return to user space</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to uservec in trampoline.S</span></span><br><span class="line">  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);</span><br><span class="line">  w_stvec(trampoline_uservec);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">  <span class="comment">// the process next traps into the kernel.</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jump to userret in trampoline.S at the top of memory, which </span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="type">void</span> (*)(uint64))trampoline_userret)(satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><pre><code class="c">  // we&#39;re about to switch the destination of traps from
  // kerneltrap() to usertrap(), so turn off interrupts until
  // we&#39;re back in user space, where usertrap() is correct.
  intr_off();
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   该函数首先关闭中断。因为之前我们在系统调用过程中是打开了中断的，这里关闭中断是因为我们将要更新stvec寄存器来指向用户空间的trap处理代码，而之前在内核中的时候，我们指向的是内核空间的trap处理代码。我们关闭中断是因为当我们将stvec更新到指向用户空间的trap处理代码时，我们仍然在内核中执行代码。如果这时发生了一个中断，那么程序执行会走向用户空间的trap处理代码，即便我们现在仍然在内核中，处于各种各样具体细节的原因，这会导致内核出错。所以我们这里关闭中断。</span><br><span class="line"></span><br><span class="line">2. ```c</span><br><span class="line">     // send syscalls, interrupts, and exceptions to uservec in trampoline.S</span><br><span class="line">     uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);</span><br><span class="line">     w_stvec(trampoline_uservec);</span><br></pre></td></tr></table></figure>

接着设置stvec寄存器指向trampoline代码，在那里终会执行sret指令返回到用户空间。位于trampoline代码的最后sret指令会重新打开中断。这样，即使我们刚刚关闭中断，当我们在执行用户代码时中断是打开的。
</code></pre>
</li>
<li><pre><code class="c">  // set up trapframe values that uservec will need when
  // the process next traps into the kernel.
  p-&gt;trapframe-&gt;kernel_satp = r_satp();         // kernel page table
  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; // process&#39;s kernel stack
  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;
  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         // hartid for cpuid()
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   接下来填入trapframe的内容，这些内容对于执行trampoline代码非常有用。</span><br><span class="line"></span><br><span class="line">   - 存储kernel page table的地址</span><br><span class="line">   - 存储当前用户进程的kernel stack</span><br><span class="line">   - 存储usertrap函数的地址，这样trampoline代码才能跳转到这个函数</span><br><span class="line">   - 从tp寄存器中读取当前的cpu核编号，并存储在trapframe中，这样trampoline代码才能恢复这个数字，因为用户代码可能会修改这个数字</span><br><span class="line"></span><br><span class="line">   现在我们在usertrapret函数中并正在设置trapframe中的数据，这样下一次从用户空间转换到内核空间时可以用到这些数据。</span><br><span class="line"></span><br><span class="line">4. ```c</span><br><span class="line">   // set S Previous Privilege mode to User.</span><br><span class="line">     unsigned long x = r_sstatus();</span><br><span class="line">     x &amp;= ~SSTATUS_SPP; // clear SPP to 0 for user mode</span><br><span class="line">     x |= SSTATUS_SPIE; // enable interrupts in user mode</span><br><span class="line">     w_sstatus(x);</span><br></pre></td></tr></table></figure>

接下来设置sstatus寄存器，这是一个控制寄存器。这个寄存器的spp bit位控制了sret指令的行为，该bit为0表示下次执行sret时，我们想要返回到user mode 而不是 supervisor mode。这个寄存器的SPIE bit位控制了在执行完sret后是否打开中断。因为我们在返回到用户空间后，的确希望打开中断，所以我们这里设置SPIE bit 为1，修改完这些bit之后，我们会把新的值写回到sstatus寄存器。
</code></pre>
</li>
<li><pre><code class="c"> // set S Exception Program Counter to the saved user pc.
  w_sepc(p-&gt;trapframe-&gt;epc);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   trampoline的最后会执行sret指令。这条指令会将程序计数器设置成spec寄存器的值，所以现在我们将sepc寄存器的值设置成之前保存的用户程序计数器的值。在不久之前，我们在usertrap函数中将用户程序计数器保存在trapframe中的epc字段。</span><br><span class="line"></span><br><span class="line">6. ```c</span><br><span class="line">    // tell trampoline.S the user page table to switch to.</span><br><span class="line">     uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br></pre></td></tr></table></figure>

接着根据user page table地址生成相应的satp值，这样我们在返回到用户空间的时候才能完成page table的切换。实际上，我们会在汇编代码trampoline中完成page table的切换，并且也只能在trampoline中完成切换，因为只有trampoline中的代码是同时在用户和内核空间中映射的。但我们现在还没有在trampoline代码中，我们现在还在一个普通的c函数中，所以这里我们将page table地址准备好，并将这个地址作为参数传递给汇编代码，这个参数会出现在a0寄存器中。
</code></pre>
</li>
<li><pre><code class="c">// jump to userret in trampoline.S at the top of memory, which 
// switches to the user page table, restores user registers,
// and switches to user mode with sret.
uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);
((void (*)(uint64))trampoline_userret)(satp);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   然后计算出我们将要跳转到的汇编代码的地址。我们期望跳转的地址是trampoline中的userret函数，这个函数包含了所有能将我们带回到用户空间的指令。所以这里我们计算出userret函数的地址。</span><br><span class="line"></span><br><span class="line">   最后一行将 trampoline_userret地址作为一个函数指针，执行相应的函数，即userret函数，并传入参数satp，存储在a0寄存器中。</span><br><span class="line"></span><br><span class="line">### userret 函数</span><br><span class="line"></span><br><span class="line">现在跳转到trampoline代码。</span><br><span class="line"></span><br><span class="line">```assembly</span><br><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        # userret(pagetable)</span><br><span class="line">        # called by usertrapret() in trap.c to</span><br><span class="line">        # switch from kernel to user.</span><br><span class="line">        # a0: user page table, for satp.</span><br><span class="line"></span><br><span class="line">        # switch to the user page table.</span><br><span class="line">        sfence.vma zero, zero		# 清空页表缓存</span><br><span class="line">        csrw satp, a0</span><br><span class="line">        sfence.vma zero, zero 	# 清空页表缓存</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p>首先切换page table。在执行完<code>csrw satp, a0</code>之前，page table还是巨大的kernel page table。这条指令将a0寄存器中的值存储到satp中。执行完后page table变成了小得多的user page table。幸运的是user page table也映射了trampoline page，所以程序还能继续执行而不是崩溃。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">li a0, TRAPFRAME</span><br></pre></td></tr></table></figure>

<p>将trapframe的地址加载到a0中，到目前为止，所有的寄存器内容还是属于内核。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># restore all but a0 from TRAPFRAME</span><br><span class="line">        ld ra, 40(a0)</span><br><span class="line">        ld sp, 48(a0)</span><br><span class="line">        ld gp, 56(a0)</span><br><span class="line">        ld tp, 64(a0)</span><br><span class="line">        ld t0, 72(a0)</span><br><span class="line">        ld t1, 80(a0)</span><br><span class="line">        ld t2, 88(a0)</span><br><span class="line">        ld s0, 96(a0)</span><br><span class="line">        ld s1, 104(a0)</span><br><span class="line">        ld a1, 120(a0)</span><br><span class="line">        ld a2, 128(a0)</span><br><span class="line">        ld a3, 136(a0)</span><br><span class="line">        ld a4, 144(a0)</span><br><span class="line">        ld a5, 152(a0)</span><br><span class="line">        ld a6, 160(a0)</span><br><span class="line">        ld a7, 168(a0)</span><br><span class="line">        ld s2, 176(a0)</span><br><span class="line">        ld s3, 184(a0)</span><br><span class="line">        ld s4, 192(a0)</span><br><span class="line">        ld s5, 200(a0)</span><br><span class="line">        ld s6, 208(a0)</span><br><span class="line">        ld s7, 216(a0)</span><br><span class="line">        ld s8, 224(a0)</span><br><span class="line">        ld s9, 232(a0)</span><br><span class="line">        ld s10, 240(a0)</span><br><span class="line">        ld s11, 248(a0)</span><br><span class="line">        ld t3, 256(a0)</span><br><span class="line">        ld t4, 264(a0)</span><br><span class="line">        ld t5, 272(a0)</span><br><span class="line">        ld t6, 280(a0)</span><br></pre></td></tr></table></figure>

<p>接下来的指令将之前保存在trapframe中的寄存器的值加载到对应的各个寄存器中。之后，我们离能真正运行用户代码就很近了。</p>
<p>现在打印所有的寄存器。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-02%2011.12.27.png" alt="截屏2024-03-02 11.12.27"></p>
<p>这些寄存器的值就是我们在最开始的时候看到的寄存器的值。但是a0寄存器现在还是个例外，它仍然指向trapframe的指针，而不是保存了的用户数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># restore user a0</span><br><span class="line"> ld a0, 112(a0)</span><br><span class="line">       </span><br><span class="line"> # return to user mode and user pc.</span><br><span class="line"> # usertrapret() set up sstatus and sepc.</span><br><span class="line"> sret</span><br></pre></td></tr></table></figure>

<p>接下来，我们将进入内核态前存储在trapframe + 112 处的用户态a0寄存器的值重新加载到a0中，然后执行我们在kernel中的最后一条指令sret，当我们执行完这条指令：</p>
<ul>
<li>程序会切换回user mode</li>
<li>sepc寄存器的数值会被拷贝到pc寄存器</li>
<li>重新打开中断</li>
</ul>
<p>现在我们回到了用户空间。打印pc寄存器</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-02%2011.21.13.png" alt="截屏2024-03-02 11.21.13"></p>
<p>程序计数器的值的确对应<code>sh.asm</code>文件中<code>write</code>函数的<code>ret</code>指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000000e2c &lt;write&gt;:</span><br><span class="line">.global write</span><br><span class="line">write:</span><br><span class="line"> li a7, SYS_write</span><br><span class="line">     e2c:	48c1                	li	a7,16</span><br><span class="line"> ecall</span><br><span class="line">     e2e:	00000073          	ecall</span><br><span class="line"> ret</span><br><span class="line">     e32:	8082                	ret</span><br></pre></td></tr></table></figure>

<p>所以我们回到了用户空间，执行完ret指令后就可以从write系统调用返回到shell中了。更严格的说，是从触发了系统调用的write库函数中返回到shell中。</p>
<p>最后总结一下，系统调用被刻意设计的看起来像是函数调用，但是背后的user&#x2F;kernel转换比函数调用要复杂的多。之所以这么复杂，很大一部分原因是要保持user&#x2F;kernel之间的隔离性，内核不能信任来自用户空间的任何内容。</p>
<p>另一方面，XV6实现trap的方式比较特殊，XV6并不关心性能。但是通常来说，操作系统的设计人员和CPU设计人员非常关心如何提升trap的效率和速度。必然还有跟我们这里不一样的方式来实现trap，当你在实现的时候，可以从以下几个问题出发：</p>
<ul>
<li>硬件和软件需要协同工作，你可能需要重新设计XV6，重新设计RISC-V来使得这里的处理流程更加简单，更加快速。</li>
<li>另一个需要时刻记住的问题是，恶意软件是否能滥用这里的机制来打破隔离性。</li>
</ul>
<h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><h3 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h3><p>知道一些RISC-V 汇编代码是重要的。在xv6资源中有<code>user/call.c</code>文件。通过make fs.img编译它并产生一些可读的程序汇编代码<code>user/call.asm</code></p>
<p>阅读call.asm中函数g、f和main的代码。RISC-V的说明手册在参考页面上。在answers-traps.txt中回答以下问题：</p>
<ul>
<li><p><code>Which registers contain arguments to functions? For example, which register holds 13 in main&#39;s call to printf ?</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%d %d\n&quot;, f(8)+1, 13);</span><br><span class="line">24:	4635                	li	a2,13</span><br></pre></td></tr></table></figure>

<p><code>a2</code>寄存器保存值13</p>
</li>
<li><p><code>Where is the call to function </code>f<code>in the assembly code for main? Where is the call to</code>g<code>? (Hint: the compiler may inline functions.)</code></p>
<p>对函数g 和函数f 已经被编译器内联，所以在汇编代码中没有对它们的调用</p>
</li>
<li><p>At what address is the function <code>printf</code> located?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000000000630 &lt;printf&gt;:</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">  1c:	1141                	add	sp,sp,-16</span><br><span class="line">  1e:	e406                	sd	ra,8(sp)</span><br><span class="line">  20:	e022                	sd	s0,0(sp)</span><br><span class="line">  22:	0800                	add	s0,sp,16</span><br><span class="line">  printf(&quot;%d %d\n&quot;, f(8)+1, 13);</span><br><span class="line">  24:	4635                	li	a2,13</span><br><span class="line">  26:	45b1                	li	a1,12</span><br><span class="line">  28:	00000517          	auipc	a0,0x0</span><br><span class="line">  2c:	7a850513          	add	a0,a0,1960 # 7d0 &lt;malloc+0xe8&gt;</span><br><span class="line">  30:	00000097          	auipc	ra,0x0</span><br><span class="line">  34:	600080e7          	jalr	1536(ra) # 630 &lt;printf&gt;</span><br></pre></td></tr></table></figure>

<p>通过上面两段代码，我们可以知道函数<code>printf</code>的地址为<code>0x630</code></p>
</li>
<li><p><code>What value is in the register ra just after the jalr to printf in main ?</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">  1c:	1141                	add	sp,sp,-16</span><br><span class="line">  1e:	e406                	sd	ra,8(sp)</span><br><span class="line">  20:	e022                	sd	s0,0(sp)</span><br><span class="line">  22:	0800                	add	s0,sp,16</span><br><span class="line">  printf(&quot;%d %d\n&quot;, f(8)+1, 13);</span><br><span class="line">  24:	4635                	li	a2,13</span><br><span class="line">  26:	45b1                	li	a1,12</span><br><span class="line">  28:	00000517          	auipc	a0,0x0</span><br><span class="line">  2c:	7a850513          	add	a0,a0,1960 # 7d0 &lt;malloc+0xe8&gt;</span><br><span class="line">  30:	00000097          	auipc	ra,0x0</span><br><span class="line">  34:	600080e7          	jalr	1536(ra) # 630 &lt;printf&gt;</span><br><span class="line">  exit(0);</span><br><span class="line">  38:	4501                	li	a0,0</span><br><span class="line">  3a:	00000097          	auipc	ra,0x0</span><br><span class="line">  3e:	28e080e7          	jalr	654(ra) # 2c8 &lt;exit&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在执行<code>jalr</code>指令调用<code>printf</code>函数后，<code>ra</code>（返回地址寄存器）中的值将是该<code>jalr</code>指令的下一条指令的地址。<code>jalr</code>（Jump and Link Register）指令的作用是跳转到通过寄存器和偏移量计算得到的地址执行，并将下一条指令的地址（即<code>jalr</code>指令后面那条指令的地址）保存到<code>ra</code>寄存器中，以便函数执行完后可以通过<code>ra</code>寄存器中的地址返回到调用位置继续执行。</p>
</blockquote>
<p>在<code>jalr</code>指令后，<code>ra</code>寄存器将包含下一条指令的地址，即<code>exit(0)</code>对应的第一条地址<code>0x38</code>，这确保了在<code>printf</code>函数执行完后，程序能够通过<code>ra</code>寄存器中的返回地址继续执行。</p>
</li>
<li><pre><code>Run the following code.

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned int i = 0x00646c72;</span><br><span class="line">printf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</span><br><span class="line">     </span><br></pre></td></tr></table></figure>

What is the output? [Here&#39;s an ASCII table](https://www.asciitable.com/) that maps bytes to characters.

The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set `i` to in order to yield the same output? Would you need to change `57616` to a different value?
</code></pre>
<p>输出<code>Hello World</code></p>
<p>在小端序系统中，使用<code>i = 0x00646c72;</code>。</p>
<p>要在大端序系统中获得相同的输出，应设置<code>i = 0x726c6400;</code>。</p>
<p><code>57616</code>的值保持不变</p>
</li>
<li><pre><code>In the following code, what is going to be printed after `&#39;y=&#39;`? (note: the answer is not a specific value.) Why does this happen?

printf(&quot;x=%d y=%d&quot;, 3);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 打印`x=3 y=`之后的内容不会是一个具体的值，而是未定义的行为（Undefined Behavior）。这是因为`printf`函数期望根据格式字符串中的占位符（这里有两个`%d`）接收相同数量的参数，但实际上只提供了一个参数（`3`）。对于第二个`%d`占位符，`printf`会尝试从调用的参数列表中读取下一个值来打印，但因为没有提供足够的参数，所以它会尝试读取未初始化的内存或超出了函数调用提供的参数范围的内存位置。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 结果是，`y=`之后打印的值将是那个内存位置的当前值，这个值是不确定的，可能每次运行时都不同，甚至可能导致程序崩溃，因为这是典型的未定义行为。在C语言中，未定义行为意味着编译器不保证程序会有任何特定的行为，程序的行为可能不可预测。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 为了避免这种情况，应该确保为`printf`（或任何函数）提供的参数数量与格式字符串中指定的占位符数量一致：</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
&gt; printf(&quot;x=%d y=%d&quot;, 3, /* 需要一个额外的整数参数 */);
&gt; <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">只有这样，才能保证程序的正确和可预测的行为。</span><br><span class="line"></span><br><span class="line">### BackTrace</span><br><span class="line"></span><br><span class="line">为了调试，通常需要有一个回溯（backtrace）：在发生错误的点以上的堆栈上的函数调用列表。为了帮助进行回溯，编译器生成的机器码会在堆栈上为当前调用链中的每个函数维护一个堆栈帧。每个堆栈帧由返回地址和指向调用者堆栈帧的“帧指针”组成。寄存器`s0`包含指向当前堆栈帧的指针（实际上，它指向堆栈上保存的返回地址的地址加上8）。你的回溯应该使用帧指针在堆栈上向上遍历，并打印每个堆栈帧中保存的返回地址。</span><br><span class="line"></span><br><span class="line">在`kernel/printf.c`中实现`backtrace()`函数。在`sys_sleep`中插入对该函数的调用，然后执行`bttest`，该测试会调用sys_sleep。你的输出应该是一系列的返回地址，格式如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<blockquote>
<p>backtrace:<br>0x0000000080002cda<br>0x0000000080002bb6<br>0x0000000080002898</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在`bitetest`退出qemu后。在终端窗口中运行：`addr2line -e kernel/kernel (or riscv64-unknown-elf-addr2line -e kernel/kernel)` 并复制粘贴`backtrace`中返回的地址：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$ addr2line -e kernel&#x2F;kernel<br>0x0000000080002cda<br>0x0000000080002bb6<br>0x0000000080002898<br>Ctrl-D</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">终端会输出：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>kernel&#x2F;sysproc.c:74<br>kernel&#x2F;syscall.c:224<br>kernel&#x2F;trap.c:85</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">一些提示：</span><br><span class="line"></span><br><span class="line">- 在文件`kernel/defs.h`中添加`backtrace()`函数的原型，这样才能在`sys_sleep`中调用`backtrace`</span><br><span class="line"></span><br><span class="line">- GCC编译器将当前执行函数的栈桢指针（地址）保存在寄存器a0中。在`kernel/riscv.h`中添加如下函数：</span><br><span class="line"></span><br><span class="line"> ```c</span><br><span class="line"> static inline uint64 r_fp() &#123;</span><br><span class="line">   uint64 x;</span><br><span class="line">   asm volatile(&quot;mv %0, s0&quot; : &quot;=r&quot; (x) );</span><br><span class="line">   return x;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>  然后调用函数<code>backtrace</code>读取当前栈帧。函数<code>r_fp</code>使用内联汇编代码读取<code>s0</code>。</p>
<ul>
<li><p>课程笔记有栈帧指针（地址）的分布情况。请注意，返回地址位于堆栈帧的帧指针的固定偏移处（-8），而保存的帧指针位于帧指针的固定偏移处（-16）。</p>
</li>
<li><p><code>backtrace()</code>函数需要能够识别到最后一个栈，然后停止。一个有用的事实是，为每个内核栈分配的内存由一个单独的、与页面对齐的页面组成，因此给定栈的所有栈帧都位于同一个页面上。你可以使用<code>PGROUNDDOWN(fp)</code>（参见<code>kernel/riscv.h</code>）来识别帧指针所指向的页面。</p>
</li>
</ul>
<p>一旦你的回溯功能正常工作，就从<code>kernel/printf.c</code>中的<code>panic</code>函数调用它，这样当内核出现panic时，你就能看到内核的回溯信息。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-04%2019.43.45.png" alt="截屏2024-03-04 19.43.45"></p>
<h3 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h3><blockquote>
<p>在这个练习中，你将为xv6添加一个特性，该特性会定期提醒一个进程关于它所使用的CPU时间。这对于想要限制自己消耗CPU时间的计算密集型进程来说可能很有用，或者对于想要计算同时又想定期执行某些操作的进程来说也很有用。更一般地，你将实现一种原始形式的用户级中断&#x2F;故障处理器；例如，你可以使用类似的机制来处理应用中的页面故障。如果你的解决方案通过了alarmtest和’usertests -q’，则认为是正确的。</p>
</blockquote>
<p>你应该添加一个新的<code>sigalarm(interval, handler)</code>系统调用。如果一个应用程序调用了<code>sigalarm(n, fn)</code>，那么在程序消耗了每<code>n</code>个”ticks”的CPU时间后，内核应该使应用程序函数<code>fn</code>被调用。当<code>fn</code>返回时，应用程序应该从中断处继续执行。在xv6中，一个tick是一个相当任意的时间单位，由硬件定时器产生中断的频率决定。如果应用程序调用<code>sigalarm(0, 0)</code>，内核应该停止生成周期性的警报调用。</p>
<p>在你的xv6仓库中，你会找到一个名为<code>user/alarmtest.c</code>的文件。将它添加到Makefile中。在你添加了<code>sigalarm</code>和<code>sigreturn</code>系统调用之前（见下文），它不会正确编译。</p>
<p><code>alarmtest</code>在<code>test0</code>中调用<code>sigalarm(2, periodic)</code>，请求内核每2个ticks强制调用一次<code>periodic()</code>函数，然后进行一段时间的循环。你可以在<code>user/alarmtest.asm</code>中看到<code>alarmtest</code>的汇编代码，这可能对调试很有帮助。当<code>alarmtest</code>产生如下输出，并且<code>usertests -q</code>也正确运行时，你的解决方案就是正确的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">alarmtest</span></span><br><span class="line">test0 start</span><br><span class="line">........alarm!</span><br><span class="line">test0 passed</span><br><span class="line">test1 start</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">test1 passed</span><br><span class="line">test2 start</span><br><span class="line">................alarm!</span><br><span class="line">test2 passed</span><br><span class="line">test3 start</span><br><span class="line">test3 passed</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">usertest -q</span></span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>

<p>完成这个任务时，你的解决方案只需要几行代码，但要做到正确可能会有些棘手。我们将使用原始仓库中的<code>alarmtest.c</code>版本来测试你的代码。你可以修改<code>alarmtest.c</code>来帮助你调试，但请确保原始的<code>alarmtest</code>表示所有测试都通过了。</p>
<h4 id="Test0-invoke-handler"><a href="#Test0-invoke-handler" class="headerlink" title="Test0: invoke handler"></a>Test0: invoke handler</h4><p>开始时，通过修改内核来跳转到用户空间的警报处理程序，这将导致<code>test0</code>打印”alarm!”。目前不用担心alarm后会发生什么；如果你的程序在打印”alarm!”之后崩溃，目前这样也是可以的。以下是一些提示：</p>
<ul>
<li><p>修改Makefile文件，是的<code>alarmtest.c</code>将被当作xv6的用户程序被编译</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">	$U/_alarmtest\</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>user/user.h</code>中声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigalarm</span><span class="params">(<span class="type">int</span> ticks, <span class="type">void</span> (*handler)())</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigreture</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更新<code>user/usys.pl</code>（该文件会生成<code>user/usys.S</code>），<code>kernel/syscall.h</code>，和<code>kernel/syscall.c</code>以允许<code>alarmtest</code>调用<code>sigalarm</code>和<code>sigreturn</code>系统调用。</p>
<p>In <code>user/usys.pl</code>:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">entry(<span class="string">&quot;sigalarm&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sigreturn&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>In <code>kernel/syscall.h</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sigalarm 22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sigreturn 23</span></span><br></pre></td></tr></table></figure>

<p>In <code>kernel/syscall.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span>;   <span class="comment">// add syscall</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// add syscall</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123; </span><br><span class="line">  ...</span><br><span class="line">	[SYS_sigalarm] sys_sigalarm,</span><br><span class="line">	[SYS_sigreturn] sys_sigreturn,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当前，<code>sys_sigreturn</code>只用返回0。</p>
</li>
<li><p>函数<code>sys_sigalarm</code>应该在结构体<code>proc</code>的新区域中保存<code>alarm interval</code>和<code>the pointer to the handler function</code>。</p>
<p>In <code>kernel/proc.h</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="type">int</span> alarm_interval;</span><br><span class="line">  uint64 handler_pointer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>In <code>kernel/sysproc.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get the alarm interval and handler pointer from syscall</span></span><br><span class="line"><span class="comment">     * and store them in process</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="type">int</span> alarm_interval = <span class="number">0</span>;</span><br><span class="line">    uint64 handler_pointer = <span class="number">0</span>;</span><br><span class="line">    argint(<span class="number">0</span>, &amp;alarm_interval);</span><br><span class="line">    argaddr(<span class="number">1</span>, &amp;handler_pointer);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> * <span class="title">proc</span> =</span> myproc();</span><br><span class="line">    proc-&gt;alarm_interval = alarm_interval;</span><br><span class="line">    proc-&gt;handler_pointer = handler_pointer;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>你需要跟踪自上一次调用（或距离下一次调用）进程的警报处理程序以来已经过去了多少个ticks；为此你还需要在<code>struct proc</code>中添加一个新的字段。你可以在<code>proc.c</code>中的<code>allocproc()</code>函数中初始化<code>proc</code>字段。</p>
<p>In <code>kernel/proc.h</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> passed_time;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>In <code>kernel/proc.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc* <span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  	...</span><br><span class="line">found:</span><br><span class="line">  p-&gt;passed_time = <span class="number">0</span>;</span><br><span class="line">  p-&gt;alarm_interval = <span class="number">0</span>;</span><br><span class="line">  p-&gt;handler_pointer = <span class="number">0</span>;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每个tick，硬件时钟产生一个中断，该中断在<code>kernel/trap.c</code>中的函数<code>usertrap()</code>里被处理。</p>
</li>
<li><p>你只想在有定时器中断的情况下操作进程的警报计时器；你需要像如下的东西一样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) ... <span class="comment">// this is a timer interrupt</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>只需要在计时器超时时调用警报函数。注意用户的警报函数的地址看可能为0。</p>
</li>
<li><p>你需要修改<code>usertrap()</code>，这样当进程的警报间隔到期时，用户进程执行处理函数。当RISC-V上的一个陷阱返回到用户空间时，决定用户空间代码恢复执行的指令地址是什么？</p>
<p>从<code>trampoline.S</code>的<code>userret</code>函数中我们可以看到，内核通过<code>sret</code>指令返回到用户空间。</p>
<p>In <code>kernel/trap.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">    ++p-&gt;passed_time;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;passed_time % p-&gt;alarm_interval == <span class="number">0</span>) &#123;</span><br><span class="line">        p-&gt;trapframe-&gt;epc = p-&gt;handler_pointer;</span><br><span class="line">    &#125;</span><br><span class="line">    yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你告诉 QEMU 只使用一个 CPU，在 GDB 中查看陷阱会更容易，你可以通过运行以下命令来实现这一点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make CPUS=1 qemu-gdb</span><br></pre></td></tr></table></figure>
</li>
<li><p>You’ve succeeded if alarmtest prints “alarm!”.</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-05%2015.48.18.png" alt="截屏2024-03-05 15.48.18"></p>
</li>
</ul>
<h4 id="test1-x2F-test2-x2F-test3-resume-interrupted-code"><a href="#test1-x2F-test2-x2F-test3-resume-interrupted-code" class="headerlink" title="test1&#x2F;test2()&#x2F;test3(): resume interrupted code"></a>test1&#x2F;test2()&#x2F;test3(): resume interrupted code</h4><p>有可能在<code>alarmtest</code>执行<code>test0</code>或<code>test1</code>并打印出”alarm!”之后会发生崩溃，或者<code>alarmtest</code>最终打印出”test1 failed”，或者<code>alarmtest</code>退出而没有打印出”test1 passed”。为了解决这个问题，你必须确保当警报处理器完成时，控制权返回到用户程序原本由于定时器中断而被打断的那条指令处。你必须确保寄存器内容被恢复到中断时的值，这样用户程序在警报之后可以继续无干扰地运行。最后，你应该在每次警报计数器触发后重新设置它，以便定期调用处理器。</p>
<p>作为一个起点，我们已经为你做了一个设计决定：用户警报处理程序在完成后需要调用<code>sigreturn</code>系统调用。可以查看<code>alarmtest.c</code>中的<code>periodic</code>函数作为一个例子。这意味着你可以在<code>usertrap</code>和<code>sys_sigreturn</code>中添加代码，使它们协作，以便在用户处理完警报之后，用户进程能够正确地恢复执行。</p>
<p>提示：</p>
<ul>
<li><p>你的解决方案需要你保存和恢复寄存器——你需要保存和重新加载哪些寄存器来恢复中断的程序？</p>
</li>
<li><p>当定时器触发时，让<code>usertrap</code>在<code>struct proc</code>中保存足够的状态，以便<code>sigreturn</code>可以正确返回到被中断的用户代码。</p>
</li>
<li><p>防止对处理程序的重入调用——如果一个处理程序还没有返回，内核不应该再次调用它。<code>test2</code>就是用来测试这一点的。</p>
</li>
<li><p>确保恢复<code>a0</code>。<code>sigreturn</code>是一个系统调用，它的返回值存储在<code>a0</code>中。</p>
</li>
</ul>
<p>首先我们在<code>struct proc</code>中增加两个成员，用于表示当前进程是否正在执行<code>handler</code>和保存执行<code>handler</code>之前的<code>trapframe</code>：</p>
<p>In <code>kernel/proc.h</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="type">int</span> is_handling;             <span class="comment">// indicates that the process is handling the handler</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">saved_trapframe</span>;</span>    <span class="comment">// used to save the trapframe</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，我们要在<code>kernel/proc.c</code>中的<code>allocproc()</code>函数中初始化它们；并在<code>freeproc()</code>函数中释放它们。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc* <span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  p-&gt;is_handling = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;saved_trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">      freeproc(p);</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;saved_trapframe)</span><br><span class="line">      kfree((<span class="type">void</span>*)p-&gt;saved_trapframe);</span><br><span class="line">  p-&gt;saved_trapframe = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着在<code>usertrap</code>函数中处理时间中断<code>timer interrupt</code>:</p>
<p>在这里我们把当前进程的<code>trapframe-&gt;epc</code>设置为<code>handler</code>的地址，这是因为在函数<code>usertrap()</code>执行完成后会调用<code>usertrapret()</code>函数，在该函数中会通过：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br></pre></td></tr></table></figure>

<p>将<code>sepc</code>寄存器设置为<code>p-&gt;trapframe-&gt;epc</code>的值，使程序跳转到其指向的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">	<span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">      p-&gt;passed_time++;	<span class="comment">// 每一次时间中断，使进程的passed_time增加1</span></span><br><span class="line">    	<span class="comment">// 如果增加的时间为间隔时间的倍数，且当前进程没有执行处理函数</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;passed_time % p-&gt;alarm_interval == <span class="number">0</span> &amp;&amp; p-&gt;is_handling == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="comment">// 保存现场</span></span><br><span class="line">          memmove(p-&gt;saved_trapframe, p-&gt;trapframe, PGSIZE);</span><br><span class="line">        	<span class="comment">// 将当前进程的trapframe-&gt;epc设置为handler函数的地址上</span></span><br><span class="line">          p-&gt;trapframe-&gt;epc = p-&gt;handler_pointer;</span><br><span class="line">        	<span class="comment">// 置正在处理为1</span></span><br><span class="line">          p-&gt;is_handling = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      yield();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后修改<code>sys_sigreturn</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  	<span class="comment">// 恢复现场</span></span><br><span class="line">    memmove(myproc()-&gt;trapframe, myproc()-&gt;saved_trapframe, PGSIZE);</span><br><span class="line">    <span class="comment">// 置为0</span></span><br><span class="line"> 		myproc()-&gt;is_handling = <span class="number">0</span>;</span><br><span class="line">  	<span class="comment">// 恢复寄存器a0的值</span></span><br><span class="line">    <span class="keyword">return</span> myproc()-&gt;trapframe-&gt;a0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试通过：</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-05%2019.39.18.png" alt="截屏2024-03-05 19.39.18"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/27/GDBtutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/27/GDBtutorial/" class="post-title-link" itemprop="url">GDBtutorial</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-27 20:19:04" itemprop="dateCreated datePublished" datetime="2024-02-27T20:19:04+08:00">2024-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-28 10:15:45" itemprop="dateModified" datetime="2024-02-28T10:15:45+08:00">2024-02-28</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>36</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="GDBtutorial"><a href="#GDBtutorial" class="headerlink" title="GDBtutorial"></a>GDBtutorial</h2><h3 id="打断点"><a href="#打断点" class="headerlink" title="打断点"></a>打断点</h3><ol>
<li>断点在函数上面：<code>b main</code></li>
<li>断点在文件的gu</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/22/HOT-COLD-DATA-SEPARATION-POLICIES/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/22/HOT-COLD-DATA-SEPARATION-POLICIES/" class="post-title-link" itemprop="url">HOT/COLD DATA SEPARATION POLICIES</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-22 15:50:49" itemprop="dateCreated datePublished" datetime="2024-01-22T15:50:49+08:00">2024-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-23 09:44:27" itemprop="dateModified" datetime="2024-01-23T09:44:27+08:00">2024-01-23</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SSD中冷热数据分类策略的总结"><a href="#SSD中冷热数据分类策略的总结" class="headerlink" title="SSD中冷热数据分类策略的总结"></a>SSD中冷热数据分类策略的总结</h1><h2 id="2-Level-LRU"><a href="#2-Level-LRU" class="headerlink" title="2-Level LRU"></a>2-Level LRU</h2><p>两级<code>LRU</code>策略使用了两种<code>LRU-based</code>列表：热列表<code>(hot list)</code>和候选列表<code>(candidate list)</code>。每个列表包含逻辑页号<code>(LPNs) Logic Page Number</code>。基本上，只有存储在<code>hot list</code>上的逻辑页号才被当作热数据。在这个策略下，当一个写操作被接收时，<code>FTL</code>在两个列表中寻找相关的<code>LPN</code>，如果逻辑页号在<code>host list</code>中，它被提升到<code>host list</code>的首位，以减少被驱逐的机会。如果<code>LPN</code>在<code>candidate list</code>上，将其从<code>candidate list</code>中移除并放入<code>hot list</code>中。如果两个<code>list</code>中都没有该<code>LPN</code>，则将其放到<code>candidate list</code>中。每个<code>list</code>的大小是固定的。如果<code>hot list</code>满了，<code>candidate list</code>中的最后一个<code>LPN</code>会被丢弃。</p>
<p>该策略简单但有问题。固定大小的<code>hot list</code>意味着它无法适应热数据量超过热列表大小的各种工作负载。另一个问题是基于<code>LRU list</code>的查找操作因为线性查找会消耗大量时间。</p>
<h2 id="Multiple-Bloom-Filter"><a href="#Multiple-Bloom-Filter" class="headerlink" title="Multiple Bloom Filter"></a>Multiple Bloom Filter</h2><p><code>MBF</code>策略使用<code>bloom filters (BF)</code>测试当前<code>LPN</code>是否属于热数据集<code>set of hot data</code>。<code>BF</code>由一个位数组组成，其大小是<code>BLOOM_FILTER_SIZE</code>（即位数）。每个逻辑页号<code>(LPN)</code>通过多个不同的哈希函数进行哈希处理，根据每个<code>LPN</code>的哈希结果，BF中相应的位被设置为1。这意味着每个LPN的哈希结果会影响BF中特定位的状态。这个策略通过将<code>LPN</code>映射到BF的特定位来跟踪哪些<code>LPN</code>属于热数据集。如果一个LPN的哈希结果对应的位在BF中已经被设置为1，那么这个<code>LPN</code>被认为是热数据的一部分。这种方法用于快速检测和过滤热数据，优化数据存储和访问效率。</p>
<p>为了最小化错误地将一些非热数据错误分类为热数据的假阳性错误，多重布隆过滤器（MBF）策略利用了多个布隆过滤器（BF）。BF（数字过滤器）的实际数量是可配置的，建议至少有四个BF。在某一点上，其中一个布隆过滤器被指定为当前过滤器<code>cur_filter</code>。对于每个写请求，如果当前过滤器中相应的位已经被设置为<code>1</code>，<code>MBF</code>策略会尝试以循环方式在下一个布隆过滤器的相同位置设置该位。在每个衰减周期之后，当前过滤器被设置为最长时间间隔内未被选中的布隆过滤器，并且该布隆过滤器中的所有位都被清除，以去除旧信息。在<code>MBF</code>策略下，通过使用相同的哈希函数对<code>LPN</code>进行哈希处理，然后计算所有布隆过滤器中对应位位置的置<code>1</code>位数，来估计<code>LPN</code>的热度。如果所有哈希位置的计数超过预定义的阈值，该LPN被分类为热数据。</p>
<p><code>MBF</code>的优点之一是它只消耗很少的内存空间。然而<code>MBF</code>的性能很大程度上依赖于哈希函数的选择，过滤器的数量，过滤器的规模，阈值等。</p>
<blockquote>
<p>什么是布隆过滤器</p>
<p><strong>数据结构：</strong>它实际上是一个很长的二进制向量和一系列随机映射函数。以Redis中的布隆过滤器实现为例，Redis中的布隆过滤器底层是</p>
<ul>
<li><strong>一个大型位数组（二进制数组）</strong></li>
<li><strong>多个无偏hash函数：</strong>无偏hash函数就是能把元素的hash值计算的比较均匀的hash函数，能使得计算后的元素下标比较均匀的映射到位数组中。</li>
</ul>
<p><strong>空间计算：</strong>在布隆过滤器增加元素之前，首先需要初始化布隆过滤器的空间，也就是上面说的二进制数组，除此之外还需要计算无偏hash函数的个数。布隆过滤器提供了两个参数，分别是预计加入元素的大小n，运行的错误率f。布隆过滤器中有算法根据这两个参数会计算出二进制数组的大小l，以及无偏hash函数的个数k。<br>它们之间的关系比较简单：</p>
<ul>
<li>错误率越低，位数组越长，控件占用较大</li>
<li>错误率越低，无偏hash函数越多，计算耗时较长</li>
</ul>
</blockquote>
<h2 id="Dynamic-dAta-Clustering"><a href="#Dynamic-dAta-Clustering" class="headerlink" title="Dynamic dAta Clustering"></a>Dynamic dAta Clustering</h2><p>在<code>LRU</code>和<code>MBF</code>策略中，数据被简单的分为冷热两种。然而，<code>DAC</code>策略通过<code>regions</code>提供更细粒度的数据分类。所有的逻辑页<code>LPN</code>一开始被放在<code>region 0 (coldest)</code>中接着会被慢慢的提升到更高的区域当对同一个逻辑页号有连续的写操作时。另一方面，当一个块被选为垃圾回收对象时，该块中的所有有效页会被降级到更低的<code>region</code>中。</p>
<p><code>DAC</code>中的<code>region</code>数量通常来说被置为4或者更多，当通常是根据工作负载而改变的。此外，由于每个分区都分配了单独的更新块，当干净块的数量紧张时，<code>DAC</code>策略可能表现不佳。</p>
<h2 id="A-New-LSM-style-Garbage-Collection-Scheme-for-ZNS-SSDs中的方法"><a href="#A-New-LSM-style-Garbage-Collection-Scheme-for-ZNS-SSDs中的方法" class="headerlink" title="A New LSM-style Garbage Collection Scheme for ZNS SSDs中的方法"></a>A New LSM-style Garbage Collection Scheme for ZNS SSDs中的方法</h2><p>基于我们的观察，具有类似寿命的数据表现出强烈的空间局部性。例如，在键值存储中，每个层级显示不同的寿命，而同一层级中的<code>SSTables</code>是以批量方式写入的，这一点在之前的研究中也有观察到。</p>
<blockquote>
<ol>
<li><strong>CAO, Z., DONG, S., VEMURI, S., AND DU, D. H. Characteriz- ing, modeling, and benchmarking rocksdb key-value workloads at facebook. In <em>USENIX FAST</em> (2020).</strong></li>
<li><strong>KIM, T., HONG, D., HAHN, S. S., CHUN, M., LEE, S., HWANG, J., LEE, J., AND KIM, J. Fully automatic stream management for multi-streamed ssds using program contexts. In <em>FAST</em> (2019).</strong></li>
</ol>
</blockquote>
<p><img src="/../images/HOT-COLD-DATA-SEPARATION-POLICIES/%E6%88%AA%E5%B1%8F2024-01-22%2019.06.46.png" alt="截屏2024-01-22 19.06.46"></p>
<p>为了分别冷热数据并将它们分到不同的区域中，我们定义四种状态的区域，<code>C0_Zone</code>，<code>C1C_Zone</code>，<code>C1H_Zone</code>和<code>C2_Zone</code>。新到的数据顺序写入<code>C0_zone</code>，删除的数据从图中的状态中删除。</p>
<p>假设<code>LSM_ZGC</code>选择一个状态为<code>C0_zone</code>的候选区域。它读取区域中所有的段并尝试识别冷热数据。我们定义当段的利用率大于阈值<code>thresholdcold</code>时被称为冷。被识别为冷的段中有效块被合并和写入状态为<code>C1C_zone</code>的区域中。其他段中的有效块被合并和写入状态为<code>C1H_zone</code>中。</p>
<p>当候选区域是C1C区域或C1H区域时，LSM ZGC会读取所有段，并将所有有效块视为冷数据。这是因为这些有效块在两次垃圾收集尝试后仍然存在。它们被合并并写入到状态为C2区域的区域中。我们可以进一步扩展，例如C3区域等，但在这项研究中，我们在此停止，并将从C2区域存活下来的有效块写入另一个C2区域。我们期望这种机制能够将冷数据与其他数据隔离开来，这将增加在垃圾收集期间找到利用率较低的候选区域的机会。</p>
<h2 id="Dynamic-Hot-Data-Identification-Using-a-Stack-Distance-Approximation"><a href="#Dynamic-Hot-Data-Identification-Using-a-Stack-Distance-Approximation" class="headerlink" title="Dynamic Hot Data Identification Using a Stack Distance Approximation"></a>Dynamic Hot Data Identification Using a Stack Distance <strong>Approximation</strong></h2><p>热数据的鉴别需要同时考虑最近性<code>(recency)</code>和频率<code>(frequency)</code>。</p>
<p>本文提出一种利用堆栈距离近似的动态热数据鉴别策略。包含三部分：工作负载分析器，负载分配器，冷热数据鉴别器。</p>
<p>我们提议的热&#x2F;冷数据标识符还采用了多个<code>bloom filter</code>和多个<code>hash function</code>。多个<code>bloom filter</code>可以捕获最近性和频率。然而，我们的动态方案和MBF之间的主要区别在于<code>bloom filter</code>选择机制。我们提议的方案明智地选择了其中一个<code>bloom filter</code>，并由我们的<code>workload analyzer</code>和<code>weight allocator</code>协助。</p>
<p>工作负载分析仪通过采用堆栈距离来提供工作负载特征分析。栈距离<code>stack distance</code>是指两次连续访问同一对象之间访问的不同对象的数量。对于时间局部访问模式<code>temporally localized access patterns</code>来说，最近性<code>recency</code>是一个更有价值的因素，堆栈距离是衡量这种时间位置的良好指标。因此，所有引用的平均堆栈距离小，表明时间局部性良好，这意味着堆栈距离较小的工作负载应将最近因素<code>recency</code>视为更重要的因素。栈距离可用于测量最近性，但同时需要高计算复杂度和高空间消耗。因此一个高效的栈距离计算方法是该设计的关键。它只使用一个哈希表，为每个桶维护简单的信息，并通过非常简单的计算生成近似的堆栈距离。因此，拟议的近似机制大大减少了开销，并以非常高的精度表现出显著的性能。</p>
<p>根据工作负载分析，权重分配器通过智能地（而不仅仅是顺序地）选择每个布隆过滤器，动态地赋予最近性或频率更多的权重。此外，与MBF不同，我们的初步工作[1]采用了一个线性递减的最近性权重函数，而我们选择了一个指数递减的权重函数，以更真实地为每个布隆过滤器分配最近性权重。因此，这种动态方案更有效地捕捉了最近性以及频率。</p>
<p><strong>A dynamic hot data identification scheme:</strong> 当工作负载有小的栈距离时，通过选择存储数据最新的重置<code>bloom filter</code>给最近性<code>recency</code>分配更多的权重。当工作负载变现出更大的栈距离时，通过选择相邻的下一个<code>bloom filter</code>分配更多的权重给频率。</p>
<p><strong>A stack distance approximation algorithm:</strong> 它采用了一个哈希表，该哈希表维护简单信息并执行非常简单的计算（即简单的两个值的平均值），从而大幅度降低计算复杂度（O(1)）。权重分配基本上基于这个近似算法。广泛的评估表明，它表现出极高的精确性和优异的性能。</p>
<p><strong>A novel baseline scheme:</strong> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/18/Improving-Flash-Write-Performance-by-Using-Update-Frequency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/18/Improving-Flash-Write-Performance-by-Using-Update-Frequency/" class="post-title-link" itemprop="url">Improving Flash Write Performance by Using Update Frequency</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-18 14:18:15" itemprop="dateCreated datePublished" datetime="2024-01-18T14:18:15+08:00">2024-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-22 11:51:27" itemprop="dateModified" datetime="2024-01-22T11:51:27+08:00">2024-01-22</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Improving-Flash-Write-Performance-by-Using-Update-Frequency"><a href="#Improving-Flash-Write-Performance-by-Using-Update-Frequency" class="headerlink" title="Improving Flash Write Performance by Using Update Frequency"></a>Improving Flash Write Performance by Using Update Frequency</h1><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>由于擦除块的规尺寸很大，有效数据和无效数据通常会被拼接在一起，导致回收空间需要高昂的数据移动。经验表明<code>FTL</code>通常很难”正确”，这是因为闪存清洁开销复杂的依赖性：</p>
<ul>
<li><code>I/O</code>负载性。</li>
<li>多种<code>FTL</code>设计选择，例如空间过度配置，数据放置算法，数据清理策略。</li>
</ul>
<p>尽管有大量的研究工作，但最终结果是低且不可预测的<code>SSD</code>写性能。特别对于产生小而分散的数据库<code>I/O</code>写入密集型工作负载。</p>
<h3 id="这片文章回答的问题：通过利用写斜来指导数据放置，我们可以在多大程度上减少FTL的写入开销？"><a href="#这片文章回答的问题：通过利用写斜来指导数据放置，我们可以在多大程度上减少FTL的写入开销？" class="headerlink" title="这片文章回答的问题：通过利用写斜来指导数据放置，我们可以在多大程度上减少FTL的写入开销？"></a>这片文章回答的问题：通过利用写斜来指导数据放置，我们可以在多大程度上减少FTL的写入开销？</h3><p>我们用一组基本的<code>I/O</code>写入模式（k模态更新分布）、数据放置策略和清理策略的清理开销进行分析建模。基于分析结果，我们提出了一种新的数据放置算法，利用更新频率来减少<code>FTL</code>清理开销，从而提高写入性能和设备寿命。</p>
<h2 id="贡献："><a href="#贡献：" class="headerlink" title="贡献："></a>贡献：</h2><ul>
<li>模拟了空间过度配置、写入频率、数据放置策略和垃圾收集策略对FTL清理开销的影响。该模型对于验证和指导<code>FTL</code>的数据放置算法的设计很有用。通过详细的模拟来验证分析结果。</li>
<li>我们在误差范围内估算出任何给定 I&#x2F;O 工作负载可实现的最小清理开销，这使我们能够量化减少任何 FTL 清理开销的空间。</li>
<li>基于建模结果，提出了一种数据放置算法，该算法以原则性的方式利用更新频率，并且能够动态适应 I&#x2F;O 写入模式，而不依赖于特定于工作负载的参数。 新的数据放置算法可以集成到现有的混合或页面级映射 FTL 中（正如我们在 2.4 节中讨论的）。 实验结果表明，与从标准 DBMS 基准（例如 TPC-C）收集的各种微基准和 I&#x2F;O 跟踪的最先进技术相比，我们的算法将清理开销减少了 20%-75% [24] 或 TATP [19]。</li>
</ul>
<h2 id="相关工作："><a href="#相关工作：" class="headerlink" title="相关工作："></a>相关工作：</h2><h3 id="一些数据放置算法："><a href="#一些数据放置算法：" class="headerlink" title="一些数据放置算法："></a>一些数据放置算法：</h3><p>我们强调了异地更新的数据放置算法的演变，并深入了解为什么一种新方法可以降低FTL清洁开销。事实上，所有<code>FTL</code>数据放置建议都尝试根据数据的更新频率对数据进行分组。</p>
<h3 id="数据放置挑战："><a href="#数据放置挑战：" class="headerlink" title="数据放置挑战："></a>数据放置挑战：</h3><p>在两个区域间移动数据的两个挑战。</p>
<ul>
<li>第一、一个区域<code>(region)</code>的占用率与其清洁成本<code>(cleaning cost)</code>之间存在高度非线性的关系。</li>
<li>第二、各区域<code>(region)</code>清理成本的增加或减少不能立即评估，而在很长一段时间后才能感受到（评估到）。</li>
</ul>
<p>例如，考虑两个分区，第一个分区与第二个分区相比，其占用率和清理成本异常高。显然我们需要将一些数据从第一个分区移动到第二个分区：然而，移动多少数据以及哪些数据并不明确。一个静态的数据提升策略（例如，尝试平衡两个分区之间的清理成本，或者简单的始终提升&#x2F;降级策略）会导致由区域占用率的变化而非工作负载偏差的变化触发的数据移动波动。页面最初从第一个分区向德格清理成本较低的分区移动。在某个点上，清理频率和&#x2F;或清理成本变得相似，页面迁移就停止了。不幸的是，到了这个时候，已经有太多页面被移动，第二个分区的清理成本继续增加。最终，迁移过程反向进行。</p>
<p>在这篇论文中，我们通过对清理成本与数据放置决策之间关系的原理性理解，解决了以往数据放置方法的局限性。我们为足够通用的更新分布建立了清理成本的分析模型，这使我们能够推理出任何给定<code>I/O</code>工作负载的基本清理开销。基于分析模型的发现，我们提出了一个原理性的数据放置算法，该算法在一定误差范围内解决最优解&#x2F;我们的数据放置算法与以往的提议有以下不同之处：</p>
<ul>
<li>没有可调参数。以前的提案依赖于工作负载特点的可变参数。例如区域的数量，从一个区域迁移到下一个区域的时间阈值，经验概率模型。</li>
<li>区域大小与页面更新频率之间没有不匹配。之前的方法建议固定大小的区域，可能导致将更新频率非常不同的页面放在一起；我们的数据提案在运行时确定最优的区域数量（即日志结构）及其最优大小。</li>
<li>准确的页面提升&#x2F;降级。<code>strawman strategy</code>总是将更新的页面提升到热区域， 将擦除的页面降级为冷区域。这样的策略会导致次优性能。清理时，我们可以区分页面是否因区域占用而被清理，还是因为它确实具有较低的更新频率。更新时，当页面足够热以证明将其推广到更热的区域时，我们可以识别精确的阈值。</li>
</ul>
<h2 id="符号和假设"><a href="#符号和假设" class="headerlink" title="符号和假设"></a>符号和假设</h2><ul>
<li><code>α</code>: 过度配置：用户空间和额外空间的比例。</li>
<li><code>μ</code>: 设备利用率：用户空间和总空间。</li>
</ul>
<p>清理块（又称垃圾收集）的开销由有效且需要在擦除块之前重新定位的页面分数给出。表示为<code>Pgc</code>：可解释为百分比或概率，块中的有效页数 &#x2F; 块的总页数。</p>
<p>清理开销 &#x3D; 需要重新定位的有效页面数量 &#x2F; 块中的总页面数量<br>$$<br>P_{gc}&#x3D;\frac{P_{valid}}{P_{total}}<br>$$<br>擦除操作带来的好处，即回收的可用空间量，是块的容量减去页面迁移所消耗的空间。因此，我们定义写放大的概念，即每次用户写入时<code>FTL</code>写入的额外物理空间。<br>$$<br>WA&#x3D;1+\frac{P_{gc}}{1-P_{gc}}&#x3D;1+\frac{P_{valid}}{P_{total}-P_{valid}}<br>$$<br>其中，<code>1</code>代表了存储新写入的用户数据所需的物理写入，只能通过压缩或去重才能避免。第二项代表了由于非原地写入而产生的实际清理开销。我们同样把第二项称为<code>GC (Garbage Collection)</code>。</p>
<p> <strong><code>I/O</code>工作负载：</strong>这篇文章对<code>k-model I/O</code>工作负载的变体进行建模。<code>k-model I/O</code>工作负载代表一种更新分布，其中任何页面的更新频率只能有<code>k</code>个可能的离散值<code>(fi,...,fk)</code>。我们将具有给定更新频率的所有页面称为一个更新集。每个更新集都有一个相关的大小，定义为总用户数据的一部分<code>si</code>，并接收到总更新的一部分<code>fsi</code>。</p>
<p><code>k-model</code>工作负载有两个优势：</p>
<ul>
<li>建模简单。</li>
<li>足够通用，可以近似模拟真实的<code>I/O</code>工作负载。通过将具有相似更新频率的页面”分箱”组合在一起，可以通过<code>k</code>模态工作负载来抽象一般的<code>I/O</code>工作负载。正如我们将看到，页面可以安全地分组到具有指数级增常更新频率的箱中。</li>
</ul>
<h3 id="模型假设"><a href="#模型假设" class="headerlink" title="模型假设"></a>模型假设</h3><p>建模清理开销时，做出如下假设：</p>
<ul>
<li>我们排除了顺序写入。利用顺序写入模式是一个正交的主题，相对容易实现，例如通过检测顺序写入模式并将更新存储在同一个擦除块中。如果同样的页面再次顺序写入，该块被置为无效，并且可以在不进行任何数据移动的情况下被擦除。然而，我们的模型支持任何偏斜的<code>I/O</code>工作负载。</li>
<li>我们只建模长期<code>FTL</code>擦除开销。新格式化的<code>SSD</code>没有立即的清理开销，因为所有闪存块都被擦除并可用于写入，这导致好的但是短暂的写入性能。</li>
</ul>
<h2 id="FTL清理策略"><a href="#FTL清理策略" class="headerlink" title="FTL清理策略"></a><code>FTL</code>清理策略</h2><h3 id="随机更新-1-Modal-Distribution"><a href="#随机更新-1-Modal-Distribution" class="headerlink" title="随机更新(1-Modal Distribution)"></a>随机更新<code>(1-Modal Distribution)</code></h3><p>假设一个由单页更新组成的随机更新工作负载。所有页面拥有相同的更新概率，因此，数据放置并不重要，例如，将任何页面存储在一起没有任何好处，清除成本只依赖于块选择策略。</p>
<p>贪婪策略：选择具有最少有效页的块进行更新。由于所有页面的更新频率相同，并且更新不相关，因此贪婪政策是最佳的。</p>
<p>我们首先对<code>LRU</code>和<code>Greedy policy</code>进行建模，表明<code>LRU</code>清洁政策接近最佳是实际重要性的。</p>
<p>闪存设备可以考虑为圆形日志结构，其中更新附加到尾部，每当需要空间时，清理总是从日志头开始，写入最古老的块。</p>
<p>在完整的日志循环中，写入操作要么是由页面迁移引起的，要么是由实际用户更新引起的。</p>
<p>在每次用户更新时，一个给定页面不会被置为无效的概率是，其中<code>N</code>是页面的总数：<br>$$<br>1-\frac{1}{N}<br>$$<br>而清理过程不会产生无效化（一旦有效页面被重新定位，一个块就会立即被擦除）。因此，一个给定页面在整个日志循环期间保持有效的概率是它在一次更新中避免无效化的概率的总用户更新次数的幂。</p>
<p>假设总共有<code>(1 + α) * N</code>个物理页，<code>Pgc</code>的一部分会因为擦除过程中的重新分配被”浪费”，而<code>(1 - Pgc)</code>的物理页面事实上存储新的用户数据。因此，我们可以通过方程的极限推导出<code>Pgc</code>。<br>$$<br>P_{gc}&#x3D;(1-\frac{1}{N})^{N(1+α)(1-p_{gc})}<br>$$<br>当<code>N</code>足够大的时候，我们应用欧拉极限<code>Euler&#39;s limit</code> :<br>$$<br>P_{gc}&#x3D;e^{-(1+α)(1-p_{gc})}<br>$$<br>它接受解析解：<br>$$<br>P_{gc}&#x3D;-\frac{W(-(1+α)e^{-(1+α)})}{1+α}<br>$$<br>上面公式中的<code>W</code>是<code>Lambert-W</code>函数，即:<br>$$<br>z&#x3D;W(z)e^{W(z)}<br>$$<br>的解。<code>W</code>不能表示为代数函数的组合。然而，<code>W</code>可以进行数值计算（例如通过泰勒展开），尽管从实际角度来看，这相当繁琐。</p>
<p>因此我们提出一种简单的近似方法。注意到：<br>$$<br>-(1+α)e^{-α}⊂(-e^{-1},0)\quadα ∈ R^+<br>$$<br>因此我们需要在一个相当小的范围内近似<code>W</code>。最终得到代数近似：<br>$$<br>P_{gc}\approx\frac{e^{-0.9\alpha}}{1+\alpha}<br>$$<br>方程<code>(9)</code>提供了在分配额外容量和清理性能之间的定量权衡，它表明，随着超额配置的增加，<code>Pgc</code>的减少速度略快于指数级。</p>
<h4 id="贪婪清除策略Greedy-cleaning-policy"><a href="#贪婪清除策略Greedy-cleaning-policy" class="headerlink" title="贪婪清除策略Greedy cleaning policy"></a>贪婪清除策略<code>Greedy cleaning policy</code></h4><p>为了量化贪婪清洁政策的好处，我们需要考虑超过方程4给出的平均pgc值：我们还需要对有效页面在擦除块上的分布进行建模。</p>
<p>对于<code>LRU</code>和<code>Greedy</code>策略：无论何时我们需要回收空间时，我们选择具有最少有效页数量的最老写入的<code>B</code>个块。当<code>B = 1</code>时，清除策略变为<code>LRU</code>；当<code>B = (1 + α) N / C</code>时变为贪婪策略。建模时考虑如下：</p>
<ul>
<li><p>概率分布函数<code>Pgc</code>，简称为<code>(PDF)</code>，是关于<code>α</code>过量配置的函数。</p>
<p>块中的有效页数量遵循二项分布，块中任何两个页拥有相等且无关的<code>Pgc</code>概率是有效的。因此，一个块有<code>k</code>个有效页面的概率是：<br>$$<br>p(k)&#x3D;\begin{pmatrix}<br>C\<br>k\<br>\end{pmatrix}\cdot {P_{pc}}^k \cdot (1-p_{gc})^{C-k}<br>$$<br>请注意，<code>Pgc(α)</code>由方程4给出，概率分布函数<code>PDF(Pgc)</code>是一个向量：<br>$$<br>PDF(p_{gc})&#x3D;\begin{bmatrix}p(C) &amp; p(C - 1) &amp; … &amp; p(0)\end{bmatrix}<br>$$<br>标准差为：<br>$$<br>stddev&#x3D;\sqrt{C\cdot p_{gc}\cdot (1-p_{gc})}<br>$$</p>
</li>
<li></li>
<li><p>PDF更改为块在清洁窗口中位置的函数。</p>
<p>使页面失效的过程可以用以下马尔可夫链过渡矩阵表示：<br>$$<br>M&#x3D;\begin{bmatrix}<br>\frac{N-C}{N} &amp; \frac{C}{N} &amp; … &amp; 0 \<br>. &amp; . &amp; . &amp; \<br>&amp; &amp; \frac{1}{N} &amp; \frac{C-1}{N}\<br>0 &amp; 0 &amp; 0 &amp; 1\<br>\end{bmatrix}<br>$$<br><code>M(i, i)</code> 代表一个块在更新时所有页面避免无效化的概率，并且该块保持有<code> C - i</code> 个有效页面的同一状态。<code>M(i, i + 1)</code> 代表迁移到下一个状态的概率，这个状态定义为有 <code>C - i - 1</code> 个有效页面。在 <code>n</code> 次更新后的 <code>PDF</code> 变化简单地表示为<br>$$<br>PDF_{new} &#x3D; PDF_{old} · M^n<br>$$<br>而更新的次数 n 反过来由块在清理窗口中的位置决定。</p>
</li>
<li><p>如何计算通过增加<code>B</code>窗口获得的收益。</p>
<p>我们无法推断出分析公式来给出<code>Pgc</code>和窗口大小<code>B</code>之间的简明关系，但是，<code>Pgc</code>减少可以计算为：<br>$$<br>Benefit&#x3D;\sum_{i&#x3D;2}^{B}(PDF_{old}-PDF_i)\cdot \begin{bmatrix}<br>C &amp; C-1 &amp;…&amp; 1 &amp; 0\end{bmatrix}’<br>$$<br>“Benefit” 指的是通过设置大小为 B 的清理窗口，从而节省的平均有效页面数量，这些页面不需要重新定位。请注意，所有的术语都是向量，而且最后一个元素代表马尔可夫链模型状态的有效页面数量。</p>
<p>最终结果表明窗口贪婪策略只有很少的好处。</p>
<p>于是我们总结<code>Greedy</code>和<code>Window-Greedy</code>策略对于随机更新来说不是必须的。</p>
</li>
</ul>
<h3 id="2-modal-Distribution"><a href="#2-modal-Distribution" class="headerlink" title="2-modal Distribution"></a>2-modal Distribution</h3><p>我们模拟两种不同情况下双模态工作负载（页面要么是热的，要么是冷的）的清理开销：a) 当页面是随机共置的，b) 当页面根据它们的更新频率分开存储时。</p>
<h4 id="随机数据放置"><a href="#随机数据放置" class="headerlink" title="随机数据放置"></a>随机数据放置</h4><p>页面更新的频率只有<code>f1</code>和<code>f2</code>两种情况，两种集合的大小为<code>s1</code>和<code>s2</code>，并让<code>fr = f1 / f2</code>为两个更新集之间的相对页面更新频率。我们假设页面是随机配置的，并且使用LRU策略（即日志结构化数据放置）清理块。</p>
<p>设<code>Pgc1</code>、<code>Pgc2</code>为更新集1和更新集2的页面分别在垃圾收集中有效的概率，并设<code>Pavg</code>为随机选择的页面有效的概率。<code>Pgc1</code>、<code>Pgc2</code>可以使用与第4.1节类似的逻辑表示，经过一系列操作后我们得到：<br>$$<br>\frac{log(p_{gc1})}{log(p_{gc2})}&#x3D;f_r ⇔ p_{gc1}&#x3D;p_{gc2}^{f_r}<br>$$<br>公式(16)总结了两组的有效页面概率之间的关系，并表明在垃圾收集中必须重新放置较冷的页面的概率与<code>fr-th</code>根向1增长。例如，如果集合2是冷<code>cold</code>则<code>fr &gt; 1</code>且<br>$$<br>P_{gc2}&#x3D;\sqrt[fr]{p_{gc1}}<br>$$<br><code>Pavg</code>和<code>pgc1</code>,<code>pgc2</code>之间的关系是从以下条件下推导出的，即总清洁开销等于与每个更新集相关的部分清洁开销的总和。也即：<br>$$<br>p_{avg}&#x3D;1-\frac{(1-p_{gc1})(1-p_{gc2})}{f_{s1}(1-p_{gc2})+f_{s2}(1-p_{gc1})}<br>$$<br><strong>解析近似：</strong>为了便于理解清理开销，我们还提出了一个封闭公式近似，用于<code>Pavg</code>，<code>Pgc1</code>，<code>Pgc2</code>。该近似基于对每个更新集的页面数量计数。如果我们在某一时刻抓取日志结构<code>log-structure</code>中的所有页面，会发现有<br>$$<br>\frac{s_1+s_2}{1+\alpha}<br>$$<br>比例的页面包含集合1和集合2的有效用户页。</p>
<h4 id="基于频率的数据放置策略"><a href="#基于频率的数据放置策略" class="headerlink" title="基于频率的数据放置策略"></a>基于频率的数据放置策略</h4><p>直观上，根据更新频率，可以通过分页减少清洁开销，正如之前的工作所观察到的那样。在第4.2.1节中，我们确定了热数据和冷数据之间的相对差异，根据更新频率来分离页面是合理的。<strong>接下来，我们将展示如何优化分离数据并计算最低清洁开销。</strong></p>
<p>规定<br>$$<br>\beta \cdot N \quad (\beta &lt; \alpha)<br>$$<br>为分配给第一个日志结构的过度配置页数。剩余的过度配置分配给第二个日志结构。</p>
<p>由于每个页面有单一的更新频率，新的页面更新概率可以用方程<code>(9)</code>来计算。</p>
<p>全局清洁开销，<code>GCavg</code>，是每个区域的单个清洁开销的总和，按区域的更新频率加权：<br>$$<br>GC_{tot}&#x3D;f_{s1}\frac{p_{gc1}}{1-p_{gc1}}+f_{s2}\frac{p_{gc2}}{1-p_{gc2}}<br>$$<br>由于<code>Pgc1</code>，<code>Pgc2</code>依赖于额外的空间分配，剩余的挑战是如何将额外的容量预算最优地分配给每个更新集合。即如何选择β以减小<code>GCtot</code>。</p>
<p>通过对方程10求导，我们找到了使 <code>GC(β)</code> 达到全局最小值的 <code>β</code> （<code>GC(β)</code> 是一个凸函数）。将方程3代入方程10之后，我们将导数表示为：<br>$$<br>\frac{\partial GC_{tot}}{\partial \beta} &#x3D; \frac{f_{s1} W_1}{s_1(W_1 + 1)(W_1 + z_1)} - \frac{f_{s2} W_2}{s_2(W_2 + 1)(W_2 + z_2)}<br>$$<br>使用简化符号：<br>$$<br>z_1&#x3D;1+\frac{\beta}{s_1};\<br>z_2&#x3D;1+\frac{\alpha-\beta}{s_2};\<br>W_i&#x3D;W(-z_ie^{z_i});\<br>$$<br>最优点<code>β</code>是导数为0的点，也即当：<br>$$<br>f_r&#x3D;\frac{W_1}{(W_1+1)(W_1+z_1)}&#x3D;\frac{W_2}{(W_2+1)(W_2+z_2)}<br>$$<br>影响最优点<code>β</code>的参数有三个：</p>
<ul>
<li>过度配置<code>α</code></li>
<li>相对更新频率<code>fr</code></li>
<li>更新集合的大小<code>si</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/17/SSD-based-Workload-Characteristics-and-Their-Performance-Implications/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/17/SSD-based-Workload-Characteristics-and-Their-Performance-Implications/" class="post-title-link" itemprop="url">SSD-based Workload Characteristics and Their Performance Implications</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-17 11:11:02" itemprop="dateCreated datePublished" datetime="2024-01-17T11:11:02+08:00">2024-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-27 19:49:15" itemprop="dateModified" datetime="2024-01-27T19:49:15+08:00">2024-01-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SSD-based-Workload-Characteristics-and-Their-Performance-Implications"><a href="#SSD-based-Workload-Characteristics-and-Their-Performance-Implications" class="headerlink" title="SSD-based Workload Characteristics and Their Performance Implications"></a>SSD-based Workload Characteristics and Their Performance Implications</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction:"></a>Introduction:</h2><h3 id="SSD的优化目标与硬盘不同："><a href="#SSD的优化目标与硬盘不同：" class="headerlink" title="SSD的优化目标与硬盘不同："></a>SSD的优化目标与硬盘不同：</h3><ul>
<li>SSD上组织数据，目标是最大化并行性和最小化垃圾收集开销。</li>
<li>SSD优化以数据移动为目标，而不是数据放置。</li>
<li>允许进行复杂的优化并快速调整工作负载的变化。</li>
</ul>
<h3 id="与SSD设计和性能相关的特征："><a href="#与SSD设计和性能相关的特征：" class="headerlink" title="与SSD设计和性能相关的特征："></a>与SSD设计和性能相关的特征：</h3><ul>
<li>温度范围。</li>
<li>逻辑局部性（概括了简单的空间局部性和顺序性）。</li>
<li>增加SSD页面大小的敏感性。</li>
</ul>
<h3 id="将上述特征与SSD性能相关联："><a href="#将上述特征与SSD性能相关联：" class="headerlink" title="将上述特征与SSD性能相关联："></a>将上述特征与SSD性能相关联：</h3><ul>
<li>写放大：设备上写入的数据量与应用程序写入的数据量之间的比率与高尾延迟和降低的耐用性相关。</li>
<li>读放大：从SSD读取的数据量与应用程序请求的数据量之间的比率。</li>
<li>闪存读取成本：包括从闪存介质读取数据并将其传输到控制器的低级延迟。</li>
</ul>
<h3 id="发现证实了建议的特征与SSD设计和优化的相关性："><a href="#发现证实了建议的特征与SSD设计和优化的相关性：" class="headerlink" title="发现证实了建议的特征与SSD设计和优化的相关性："></a>发现证实了建议的特征与SSD设计和优化的相关性：</h3><ul>
<li>增加 SSD 内逻辑分区的数量可减少写入放大。 然而，这需要大量的开销并且带来收益递减。 最佳分区数量小于以前研究中建议的数量。</li>
<li>读取放大随着页面大小的增加而增加，并且主要取决于请求大小的分布。 然而，对地址范围的重复访问会显着降低读取放大。 这种减少的程度可以通过逻辑空间局部性来估计。</li>
<li>通过有选择地从大页中读取部分字节范围，可以有效降低闪存读取成本。 我们简单的贪婪算法足以达到此目的，展示了向主机导出“部分读取”接口的潜在好处。</li>
</ul>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background:"></a>Background:</h2><h3 id="工作负载"><a href="#工作负载" class="headerlink" title="工作负载"></a>工作负载</h3><ul>
<li>the University of Massachusetts (SPC traces) </li>
<li>Microsoft Research at Cambridge</li>
<li>Microsoft production servers</li>
<li>Florida International University</li>
</ul>
<p>我们关注这些工作负载上的普遍属性</p>
<ul>
<li>Request arrival time (relative to the beginning of the trace) 请求到达时间，与trace的开始相关。</li>
<li>Volume number 存储体编号</li>
<li>Request size (in byte) 请求大小</li>
<li>I&#x2F;O operation I&#x2F;O操作（读或写）</li>
</ul>
<h3 id="温度范围"><a href="#温度范围" class="headerlink" title="温度范围"></a>温度范围</h3><p>工作负载偏斜传统上被用来通过使用缓存来优化性能。如果缓存足够大能存储应用程序的工作集，则大部分请求不需要访问底层设备。在这种情况下，常用的经验法则，比如80-20法则——它指出80%的请求访问了20%的数据——经常被用来估计工作负载所需的缓存大小。因此，传统的分析通过评估工作集大小或热数据（频繁访问的数据）的数量来描述工作负载的偏斜程度。虽然这些对于优化硬盘和缓存性能是足够的，但对于固态硬盘（SSD）的优化，更详细的分析可能会带来更多的好处。</p>
<p>在闪存层的设计中，通过分离冷热数据到不同的逻辑分区中可以减小写放大，垃圾回收开销，和单元磨损。这样的分类同样也可以优化磨损均衡和页面重用。因此，许多闪存将数据分类到两个区域。</p>
<p>Stoica和Ailamaki的研究表明，只要每个分区内的访问偏斜足够小，就可以将几种不同的温度级别的数据分组到同一个分区中，而不会增加写放大的现象。我们基于这一分析，根据工作负载所需的最小分区数量来进行特征描述。然后我们量化了在最佳数量过高时分配较少分区的成本。我们特别感兴趣的是常见的两个分区情况，用于热数据和冷数据。</p>
<h4 id="表征温度范围"><a href="#表征温度范围" class="headerlink" title="表征温度范围"></a>表征温度范围</h4><p>​	当一个逻辑页被写入SSD时，FTL将原来的物理地址标记为无效的然后选择芯片和平面，根据条带和负载均匀策略将一页写入。然后将页写入平面中的一个活跃块（一个已经被擦除但还没有完全写满的块）。将数据分别放入N个逻辑分区需要每个平面有N个活跃块。</p>
<p>​	根据<code>Stoica 和 Ailamaki</code>的定义，<code>fi</code>表示页面<code>i</code>的更新频率。理想的情况下，每个分区将包含具有相同更新频率的页面。这显然是不切实际的，因为现代芯片每个平面只有512个块。相反，具有多个访问频率的逻辑页面被分组到每个分区（读者认为这里的一个分区<code>partition</code>就是一个块<code>block</code>）中。<code>fr(p)</code>表示分区<code>p</code>中的更新频率比，这是存储在<code>p</code>中的页面的最大和最小更新频率之间的比率。<code>fr</code>表示所有分区的最大比率。参考[57]中的理论分析表明，确保<code>fr ≤ 2</code>足以最小化垃圾回收开销。然而，这个结果没有考虑到维护所需分区数量的开销。</p>
<p>​	为了确定在现代芯片组织下这种优化是否现实，我们计算了确保<code>fr ≤ 2</code>所需的最小分区数量。我们根据更新的频率对每个工作负载中的逻辑扇区进行排名，并贪婪的将他们分配给不同的分区：：我们从第一个分区开始，分配给它更新频率最高的页面<code>i</code>以及所有满足<code>fj ≥ fi /2</code>的页面<code>&#123;j&#125;</code>。然后我们将下一个页面分配给第二个分区，以此类推。我们在分析基于硬件驱动器<code>(HDD)</code>的迹象和基于固态硬盘<code>SSD</code>的<code>RocksDB</code>迹象时，分别使用了512字节和4KB的扇区大小，以反映这些迹象中观察到的访问粒度。我们将在第4节中更详细地讨论访问粒度。</p>
<p>​	我们的结果显示，所需的最少分区数量在2到16之间变化，并且在不同类别之间有所不同。图<code>1(a)</code>展示了每个类别的第25、50和第75百分位数，垂直线显示了每个类别所需的最小和最大分区数量（键值类别包括单个RocksDB迹象，因此用一个小圆圈表示）。例如，对于75%的数据库管理系统（DBMS）工作负载和键值工作负载，9个分区就足够了，而75%的邮件服务器工作负载至少需要14个分区。我们在不同限制下的<code>fr</code>上重复了这个实验。不出所料，位了维持更低的比例，需要更多的分区。所需最少分区数量从3到26不等，用于<code>fr ≤ 1.5</code>，当<code>fr ≤ 3</code>时，需要2到11个分区。</p>
<p>​	<strong>发现一：</strong>实现写入放大的理论下限需要大量的分区。</p>
<p>​	为了理解这些结果的影响，考虑最先进的企业<code>SSD</code>，每个平面有521个块和<code>28%</code>的过度配置空间。每个平面将有400个可用的逻辑块。因此为了维持<code>16</code>个分区，<code>4%</code>的块需要作为活跃块，平均<code>2%</code>的逻辑容量将无法利用。除了这种开销外，还必须考虑在<code>SSD</code>的<code>RAM</code>中将页面维护和分类为几个分区的成本。</p>
<p>​	SSD设计可能会限制分区数量，以利用专用硬件，或最大限度地减少分区开销。为了评估次优分区的影响，我们重复上述过程以穷尽地找到<code>fmin(N)</code>–贪婪分区方案导致N个预定数量的分区时的最低比率。图<code>1(c)</code>展示了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="theLonging"
      src="/images/touxiang.JPG">
  <p class="site-author-name" itemprop="name">theLonging</p>
  <div class="site-description" itemprop="description">不捨晝夜。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/chantchanH7" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chantchanH7" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/562879980@qq.com" title="E-Mail → 562879980@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-07 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">theLonging</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">526k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:58</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
