<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="不捨晝夜。">
<meta property="og:type" content="website">
<meta property="og:title" content="talk is cheap, show me the code.">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="talk is cheap, show me the code.">
<meta property="og:description" content="不捨晝夜。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="theLonging">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>talk is cheap, show me the code.</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">talk is cheap, show me the code.</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/10/kernelInside/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/10/kernelInside/" class="post-title-link" itemprop="url">kernelInside</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-10 18:35:09" itemprop="dateCreated datePublished" datetime="2023-11-10T18:35:09+08:00">2023-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-15 20:34:32" itemprop="dateModified" datetime="2023-11-15T20:34:32+08:00">2023-11-15</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>35k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>32 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Kernel-Inside"><a href="#Kernel-Inside" class="headerlink" title="Kernel Inside!"></a>Kernel Inside!</h1><p>说是要做<code>zns ssd</code>存储开发，但是好像离不开<code>linux</code>内核，既然如此，那就开始<del>愉快的</del>Linux内核之旅吧！</p>
<p>用到的参考资料包括（其实就是kernel inside 的学习笔记）：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://0xax.gitbooks.io/linux-insides/content/">Kernel Inside</a> </li>
<li>深入理解Linux内核</li>
</ul>
<h1 id="Booting"><a href="#Booting" class="headerlink" title="Booting"></a>Booting</h1><p>启动！</p>
<h1 id="Kernel-booting-process-Part-1"><a href="#Kernel-booting-process-Part-1" class="headerlink" title="Kernel booting process. Part 1."></a>Kernel booting process. Part 1.</h1><h2 id="From-the-boot-loader-to-the-kernel"><a href="#From-the-boot-loader-to-the-kernel" class="headerlink" title="From the boot loader to the kernel"></a>From the boot loader to the kernel</h2><h3 id="The-Magical-Power-Button-What-happens-next"><a href="#The-Magical-Power-Button-What-happens-next" class="headerlink" title="The Magical Power Button, What happens next?"></a>The Magical Power Button, What happens next?</h3><p>​	当按下开机键后，计算机首先会唤醒<code>cpu</code>，<code>80386</code>及之后的<code>cpu</code>会在其寄存器中定义如下数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP						0xfff0</span><br><span class="line">CS selector		0xf000</span><br><span class="line">CS base				0xffff0000</span><br></pre></td></tr></table></figure>

<p>​	处理器会在实模式<code>(real mode)</code>下运行</p>
<blockquote>
<ul>
<li><code>real mode</code>：所有的<code>x86</code>机器支持实模式，<code>8086</code>处理器的总线地址有20位，能处理<code>0 - 0xfffff</code>地址空间，但是该处理器的寄存器只有<code>16 bit</code>，只能处理<code>0-0xffff</code>位。</li>
<li><code>Memory segmentation</code>：使得所有地址空间都可以被访问，内存被分为小的，固定的<code>65536 bytes (64KB) segments</code>。但由于我们无法通过<code>16-bit</code>寻址<code>64KB</code>地址，下面会给出一个解决方法。</li>
<li><code>IP</code>： instruction pointer</li>
<li><code>CS selector</code>：Code Segment Selector</li>
<li><code>CS Base</code>：Code Segment Base Address</li>
</ul>
</blockquote>
<p>因此，一个<code>address</code>包括：<code>a segment selector</code>，<code>offset</code>；物理地址的计算公式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhysicalAddress = Segment Selector * 16 + Offset</span><br></pre></td></tr></table></figure>

<p>但如果<code>segment selector</code>和<code>offset</code>太大了，就会发生溢出，如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hex((0xffff &lt;&lt; 4) + 0xffff) = 0x10ffef</span><br></pre></td></tr></table></figure>

<p>由于实模式下只有20位地址位，所以<code>0x10ffef</code>会变成<code>0x00ffef</code>，这叫作<code>A20 line disabled</code>。</p>
<p>回到开机后的寄存器值：</p>
<p><code>CS register</code>包含：</p>
<ul>
<li><code>the visible segment selector</code></li>
<li><code>the hidden base address</code></li>
</ul>
<p>结合之前定义的<code>CS</code>基址和<code>IP</code>值，<code>CS:IP</code>是<code>0xf000:0xfff0</code>，经过物理地址公式的计算得到<code>0xfff0</code>.</p>
<p>该物理地址加上基址我们最终得到·存储在 <code>EIP register</code>中的值：<code>0xfffffff0</code>。</p>
<blockquote>
<ul>
<li><code>Extended Instruction Pointer</code>：该寄存器的作用是存储CPU当前正在执行的指令的地址。当CPU执行程序时，EIP寄存器会连续更新，以指向下一条要执行的指令。这对于程序的流程控制至关重要。</li>
</ul>
</blockquote>
<p>得到的值<code>0xfffffff0</code>被叫做复位向量<code>reset vector</code>，该内存地址是CPU在重置后希望找到第一个指令的地方。该内存地址包含一个<code>jump</code>指令，该指令通常指向<code>BIOS(Basic Input/ Output System)</code>入口。看看源代码，我们这里看的是 <a target="_blank" rel="noopener" href="https://www.coreboot.org`src/cpu/x86/16bit/reset16.inc%60%EF%BC%9A">https://www.coreboot.org`src/cpu/x86/16bit/reset16.inc`：</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> .section &quot;.reset&quot;, &quot;ax&quot;, %progbits</span><br><span class="line">    .code16</span><br><span class="line">.globl    _start</span><br><span class="line">_start:</span><br><span class="line">    .byte  0xe9</span><br><span class="line">    .int   _start16bit - ( . + 2 )</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p><code>0xe9</code>是<code>jump</code>指令的<code>opcode</code>，目的地址是<code>_start16bit - ( . + 2 )</code>。</p>
<p>同样，我们能找到之前说的其实地址是如何计算的<code>0xfffffff0 (src/cpu/x86/16bit/reset16.ld):</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    /* Trigger an error if I have an unuseable start address */</span><br><span class="line">    _bogus = ASSERT(_start16bit &gt;= 0xffff0000, &quot;_start16bit too low. Please report.&quot;);</span><br><span class="line">    _ROMTOP = 0xfffffff0;</span><br><span class="line">    . = _ROMTOP;</span><br><span class="line">    .reset . : &#123;</span><br><span class="line">        *(.reset);</span><br><span class="line">        . = 15;</span><br><span class="line">        BYTE(0x00);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<code>BIOS</code>启动，在检查完硬件后，<code>BIOS</code>需要找到一个可启动的设备，启动顺序是设定在<code>BIOS</code>中的，当尝试从硬盘中启动时，<code>BIOS</code>需要找到一个启动扇区<code>boot sector</code>。在硬盘上有一个分区叫作主引导记录<code>Main Boot Record</code>，<code>boot sector</code>在该分区的前<code>446</code>个字节，每个扇区有<code>512 bytes</code>，第一个扇区的最后两个字节为<code>0x55, 0xaa</code>，向<code>BIOS</code>说明该设备是可启动的。</p>
<p>​	下表给出实模式下的内存映射：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0x00000000 - 0x000003FF - Real Mode Interrupt Vector Table</span><br><span class="line">0x00000400 - 0x000004FF - BIOS Data Area</span><br><span class="line">0x00000500 - 0x00007BFF - Unused</span><br><span class="line">0x00007C00 - 0x00007DFF - Our Bootloader</span><br><span class="line">0x00007E00 - 0x0009FFFF - Unused</span><br><span class="line">0x000A0000 - 0x000BFFFF - Video RAM (VRAM) Memory</span><br><span class="line">0x000B0000 - 0x000B7777 - Monochrome Video Memory</span><br><span class="line">0x000B8000 - 0x000BFFFF - Color Video Memory</span><br><span class="line">0x000C0000 - 0x000C7FFF - Video ROM BIOS</span><br><span class="line">0x000C8000 - 0x000EFFFF - BIOS Shadow Area</span><br><span class="line">0x000F0000 - 0x000FFFFF - System BIOS</span><br></pre></td></tr></table></figure>

<p>​	之前我们说<code>CPU</code>尝试执行的第一个指令是存储在地址<code>0xffff fff0</code>中的，这比上表的地址大的多。<code>CPU</code>如何访问改地址？在<a target="_blank" rel="noopener" href="https://www.coreboot.org/Developer_Manual/Memory_map">coreboot</a>文档中给出了答案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xFFFE_0000 - 0xFFFF_FFFF: 128 kilobyte ROM mapped into address space</span><br></pre></td></tr></table></figure>

<p>​	现在我们知道，<code>BIOS</code>程序是存储在<code>ROM</code>中的。</p>
<h3 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h3><blockquote>
<p>​	现在 BIOS 已经选择了一个启动设备，并且将控制权转移给了启动扇区中的代码，在我们的例子中，启动扇区代码是 <a target="_blank" rel="noopener" href="http://git.savannah.gnu.org/gitweb/?p=grub.git;a=blob;f=grub-core/boot/i386/pc/boot.S;hb=HEAD">boot.img</a>。因为这段代码只能占用一个扇区，因此非常简单，只做一些必要的初始化，然后就跳转到 GRUB 2’s core image 去执行。 Core image 的代码请参考 <a target="_blank" rel="noopener" href="http://git.savannah.gnu.org/gitweb/?p=grub.git;a=blob;f=grub-core/boot/i386/pc/diskboot.S;hb=HEAD">diskboot.img</a>，一般来说 core image 在磁盘上存储在启动扇区之后到第一个可用分区之前。core image 的初始化代码会把整个 core image （包括 GRUB 2的内核代码和文件系统驱动） 引导到内存中。 引导完成之后，<a target="_blank" rel="noopener" href="http://git.savannah.gnu.org/gitweb/?p=grub.git;a=blob;f=grub-core/kern/main.c">grub_main</a>将被调用。</p>
<p>​	<code>grub_main</code> 初始化控制台，计算模块基地址，设置 root 设备，读取 grub 配置文件，加载模块。最后，将 GRUB 置于 normal 模式，在这个模式中，<code>grub_normal_execute</code>(from <code>grub-core/normal/main.c</code>) 将被调用以完成最后的准备工作，然后显示一个菜单列出所用可用的操作系统。当某个操作系统被选择之后，<code>grub_menu_execute_entry</code> 开始执行，它将调用 GRUB 的 <code>boot</code> 命令，来引导被选中的操作系统。</p>
<p>​	就像 kernel boot protocol 所描述的，引导程序必须填充 kernel setup header （位于 kernel setup code 偏移 <code>0x01f1</code> 处） 的必要字段。kernel setup header的定义开始于<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S">arch&#x2F;x86&#x2F;boot&#x2F;header.S</a>：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	.globl	hdr</span><br><span class="line">hdr:</span><br><span class="line">setup_sects:	.byte 0			/* Filled in by build.c */</span><br><span class="line">root_flags:	.word ROOT_RDONLY</span><br><span class="line">syssize:	.long 0			/* Filled in by build.c */</span><br><span class="line">ram_size:	.word 0			/* Obsolete */</span><br><span class="line">vid_mode:	.word SVGA_MODE</span><br><span class="line">root_dev:	.word 0			/* Filled in by build.c */</span><br><span class="line">boot_flag:	.word 0xAA55</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>.globl hdr</code>: <code>hdr</code>是一个全局符号，全局符号对程序的所有部分都是可见的，同时它也是一个标签，标记当前位置。</li>
<li>在后续的数据中遵循：<code>varible: .type value</code>，即<code>变量：类型 值</code>的形式。<ul>
<li><code>boot_flag:	.word 0xAA55</code>：<code>0xAA55</code>是可启动标志。</li>
</ul>
</li>
</ul>
</blockquote>
<p>​	我们将在<code>kernel boot protocol</code>中看到，内存在加载内核后是如何映射的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">         | Protected-mode kernel  |</span><br><span class="line">100000   +------------------------+</span><br><span class="line">         | I/O memory hole        |</span><br><span class="line">0A0000   +------------------------+</span><br><span class="line">         | Reserved for BIOS      | Leave as much as possible unused</span><br><span class="line">         ~                        ~</span><br><span class="line">         | Command line           | (Can also be below the X+10000 mark)</span><br><span class="line">X+10000  +------------------------+</span><br><span class="line">         | Stack/heap             | For use by the kernel real-mode code.</span><br><span class="line">X+08000  +------------------------+</span><br><span class="line">         | Kernel setup           | The kernel real-mode code.</span><br><span class="line">         | Kernel boot sector     | The kernel legacy boot sector.</span><br><span class="line">       X +------------------------+</span><br><span class="line">         | Boot loader            | &lt;- Boot sector entry point 0x7C00</span><br><span class="line">001000   +------------------------+</span><br><span class="line">         | Reserved for MBR/BIOS  |</span><br><span class="line">000800   +------------------------+</span><br><span class="line">         | Typically used by MBR  |</span><br><span class="line">000600   +------------------------+</span><br><span class="line">         | BIOS use only          |</span><br><span class="line">000000   +------------------------+</span><br></pre></td></tr></table></figure>

<p>当启动程序把控制权交给内核后，内核将从:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X + sizeof(KernelBootSector) + 1</span><br></pre></td></tr></table></figure>

<p><code>X</code>是内核启动扇区被加载的地址。启动程序现在加载<code>Linux</code>内核到内存中去，填充好头文件，然后跳转到相应的内存地址中去，我们去看内核建立程序。</p>
<h3 id="The-Beginning-of-the-Kernel-Setup-Stage"><a href="#The-Beginning-of-the-Kernel-Setup-Stage" class="headerlink" title="The Beginning of the Kernel Setup Stage"></a>The Beginning of the Kernel Setup Stage</h3><p>​	首先内核需要建立，这包括一些配置，如解压器和一些内存管理相关的东西，仅举几例。完成所有这些事情之后，内核设置部分将解压实际的内核并跳转到它。在代码<code>arch/x86/boot/header.S</code>的 <code>__start</code>标签是<code>setup part</code>。</p>
<pre><code> 为了能够作为`bootloader`来使用，`header.S`在开始处定义了 `MZ`，并且定义了`PE`头文件。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_EFI_STUB</span><br><span class="line">	# &quot;MZ&quot;, MS-DOS header</span><br><span class="line">	.word	MZ_MAGIC</span><br><span class="line">#endif</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">#ifdef CONFIG_EFI_STUB</span><br><span class="line">pe_header:</span><br><span class="line">	.long	PE_MAGIC</span><br></pre></td></tr></table></figure>

<p> 之所以代码需要这样写，这个是因为遵从 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">UEFI</a> 的硬件需要这样的结构才能正常引导操作系统。</p>
<p>除开这些作为<code>bootloader</code>的代码，真正的内核建立从下面开始：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// header.S line 299</span><br><span class="line">_start:</span><br><span class="line">		# Explicitly enter this as bytes, or the assembler</span><br><span class="line">		# tries to generate a 3-byte jump here, which causes</span><br><span class="line">		# everything else to push off to the wrong offset.</span><br><span class="line">		.byte	0xeb		# short (2-byte) jump</span><br><span class="line">		.byte	start_of_setup-1f</span><br></pre></td></tr></table></figure>

<p>bootloader 知道这个开始点，并且直接跳转到该点， 因此， bootloader将不会再从<code>.bstext section</code>开始。因为我们会在<code>arch/x86/boot/setup.ld</code>中看见：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// arch/x86/boot/setup.ld</span><br><span class="line">//</span><br><span class="line">. = 0;                    // current position</span><br><span class="line">.bstext : &#123; *(.bstext) &#125;  // put .bstext section to position 0</span><br><span class="line">.bsdata : &#123; *(.bsdata) &#125;</span><br></pre></td></tr></table></figure>

<p>​	这段代码是一个连接器脚本的一部分，用于指定程序编译后在内存中的布局。</p>
<blockquote>
<ul>
<li>设置当前位置：<code>. = 0;</code>设置连接器的当前位置指针为0。意味着紧接着的定义段将从内存地址0开始放置。</li>
<li>定义了<code>.bstext</code>段：<code>.bstext : &#123; *(.bstext) &#125;</code>，这行代码定义了一个名为 <code>.bstext</code> 的段。<code>&#123; *(.bstext) &#125;</code> 的意思是将所有标记为 <code>.bstext</code> 的部分（即汇编代码中用 <code>.section &quot;.bstext&quot;</code> 定义的部分）集中到这个段里。由于当前位置已经设置为0，所以这个段的内容将被放置在内存的开始位置。</li>
<li>定义了<code>.bsdata</code>段：<code>.bsdata : &#123; *(.bsdata) &#125;</code>：这行代码定义了一个名为 <code>.bsdata</code> 的段，并将所有标记为 <code>.bsdata</code> 的部分集中到这个段里。这允许链接器将这些数据放置在内存中的特定位置。</li>
</ul>
</blockquote>
<p>接着我们来看看内核设置的进入点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	# offset 512, entry point</span><br><span class="line"></span><br><span class="line">	.globl	_start</span><br><span class="line">_start:</span><br><span class="line">		# Explicitly enter this as bytes, or the assembler</span><br><span class="line">		# tries to generate a 3-byte jump here, which causes</span><br><span class="line">		# everything else to push off to the wrong offset.</span><br><span class="line">		.byte	0xeb		# short (2-byte) jump</span><br><span class="line">		.byte	start_of_setup-1f</span><br><span class="line">1:</span><br><span class="line"></span><br><span class="line">	# Part 2 of the header, from the old setup.S</span><br><span class="line"></span><br><span class="line">		.ascii	&quot;HdrS&quot;		# header signature</span><br><span class="line">		.word	0x020f		# header version number (&gt;= 0x0105)</span><br></pre></td></tr></table></figure>

<p>上述代码中， <code>0xeb</code>是<code>jmp</code>指令的<code>opcode</code>，表示将要跳转到<code>start_of_setup - 1f</code>。</p>
<p><code>Nf</code>声明：<code>2f</code>表示<code>local label 2</code>。在上述代码中，<code>1f</code>就是后面的<code>1:</code>，这部分代码包含了剩余的<code>setup header</code>，当<code>setup header</code>结束后，我们会看见<code>.entrytext</code>代码段，在<code>start_of_setup</code>标签处开始。	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># End of setup header #####################################################</span><br><span class="line">	.section &quot;.entrytext&quot;, &quot;ax&quot;</span><br><span class="line">start_of_setup:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这是第一段实际运行的代码。当内核配置<code>kernel setup</code>部分收到来自启动程序<code>bootloader</code>，第一个<code>jump</code>指令跳转到离内核起始点<code>(kernel real mode)``0x200 offset</code>。</p>
<p>终于，代码跳转到了<code>start_of_setup</code>，接着内核会做如下几件事：</p>
<ul>
<li><p>保证所有的段寄存器<code>segment register</code>值是相等的。</p>
</li>
<li><p>如果需要的话，建配置一个正确的栈。</p>
</li>
<li><p>配置bss</p>
<blockquote>
<p>BSS（Block Started by Symbol）是一个用来描述可执行文件或内存中的一部分的术语，它代表了一个程序中未初始化的全局变量和静态变量的集合。在程序的二进制文件中，BSS段通常不占用实际的磁盘空间，因为它只是一系列的零值。然而，在程序加载到内存时，操作系统为BSS段分配内存，并将其全部初始化为零。</p>
<p>BSS段的主要特点和作用包括：</p>
<ol>
<li><strong>未初始化的变量</strong>：BSS段用于存储程序中未显式初始化为特定值的全局变量和静态变量。这些变量在程序启动时默认被初始化为零。</li>
<li><strong>节省空间</strong>：由于BSS段中的数据默认为零，因此在程序的磁盘文件中不需要为它们分配空间。这有助于减少程序的文件大小。</li>
<li><strong>内存中的初始化</strong>：虽然在磁盘上不占用空间，但在程序加载到内存时，操作系统会为BSS段中的变量分配内存，并将它们初始化为零。</li>
<li><strong>与数据段的区别</strong>：BSS段通常与数据段（用于存储已初始化的全局变量和静态变量）相区分。数据段中的变量在程序的二进制文件中会占用相应的存储空间，以保持它们的初始值。</li>
</ol>
</blockquote>
</li>
<li><p>调转到c代码<code>arch/x86/boot/main.c</code></p>
</li>
</ul>
<h3 id="Aligning-the-Segment-Registers"><a href="#Aligning-the-Segment-Registers" class="headerlink" title="Aligning the Segment Registers"></a>Aligning the Segment Registers</h3><p>首先，内核保证，<code>ds</code>和<code>es</code>段寄存器指向同一个地址。接着使用<code>cld</code>指令，清除方向标志<code>direction flag</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Force %es = %ds</span><br><span class="line">	movw	%ds, %ax</span><br><span class="line">	movw	%ax, %es</span><br><span class="line">	cld</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>Direction Flag：在x86架构的CPU中，direction flag是标志寄存器（Flags Register）的一部分，用于控制字符串操作指令（如 <code>movsb</code>, <code>movsw</code>, <code>movsd</code>, <code>stosb</code>, <code>stosw</code>, <code>stosd</code>, <code>lodsb</code>, <code>lodsw</code>, <code>lodsd</code>, <code>scasb</code>, <code>scasw</code>, <code>scasd</code> 等）的处理方向。</p>
<p><code>direction flag = 1</code>时，这些操作指令处理字符串时会从高地址向底地址移动。为0时则相反。</p>
</li>
<li><p><code>cld</code>指令：<code>clear Direction Flag</code>，会将<code>Direction Flag</code>置为0。</p>
</li>
<li><p><code>es</code>：附加段寄存器</p>
</li>
<li><p><code>ds</code>：数据段寄存器</p>
</li>
<li><p><code>cs</code>：代码段寄存器</p>
</li>
<li><p><code>ss</code>：段寄存器</p>
</li>
<li><p><code>sp</code>：堆栈指针寄存器</p>
</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">segment = grub_linux_real_target &gt;&gt; 4;</span><br><span class="line">state.gs = state.fs = state.es = state.ds = state.ss = segment;</span><br><span class="line">state.cs = segment + 0x20; // cs = 0x1000 + 0x20 = 0x1020</span><br></pre></td></tr></table></figure>

<p><code>grub2</code>默认将<code>kernel setup</code>代码，加载到地址<code>0x10000</code>处，而<code>cs</code>是在<code>0x1020</code>处，这是因为代码的执行不会在文件的起始位置开始，而是跳转到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br><span class="line">    .byte 0xeb</span><br><span class="line">    .byte start_of_setup-1f</span><br></pre></td></tr></table></figure>

<p>这段代码是位于 <code>4d 5a</code>的<code>512 bytes</code>偏移处。之后开始配置栈。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> We will have entered with %cs = %ds+0x20, normalize %cs so</span><br><span class="line"># it is on par with the other segments.</span><br><span class="line">	pushw	%ds</span><br><span class="line">	pushw	$6f</span><br><span class="line">	lretw</span><br></pre></td></tr></table></figure>

<p>这段代码将 <code>ds</code>的值推入栈，紧跟着的是标签<code>6</code>的地址也推入栈，然后执行<code>lretw</code>。当执行<code>lretw</code>时，它将标签<code>6</code>的地址加载到<code>instruction pointer register</code>中，将<code>ds</code>的值加载到<code>cs</code>中。最终，<code>cs</code>和<code>ds</code>的值会保持一致。</p>
<blockquote>
<p><code>lretw</code>：这是一个远返回指令，用于从子程序返回。<code>lretw</code> 会从堆栈中弹出返回地址，并将其加载到指令指针寄存器（%ip）中。同时，它还会从堆栈中弹出一个值加载到代码段寄存器（%cs）中，这是远调用和远返回的特性。</p>
</blockquote>
<h3 id="Stack-Setup"><a href="#Stack-Setup" class="headerlink" title="Stack Setup"></a>Stack Setup</h3><p>​	几乎所有的配置代码是为了准备实模式下的<code>c</code>语言环境。下一个步骤是判断并纠正<code>ss</code>寄存器的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Force %es = %ds</span><br><span class="line">	movw	%ds, %ax</span><br><span class="line">	movw	%ax, %es</span><br><span class="line">	cld</span><br><span class="line"></span><br><span class="line"># Apparently some ancient versions of LILO invoked the kernel with %ss != %ds,</span><br><span class="line"># which happened to work by accident for the old code.  Recalculate the stack</span><br><span class="line"># pointer if %ss is invalid.  Otherwise leave it alone, LOADLIN sets up the</span><br><span class="line"># stack behind its own code, so we can&#x27;t blindly put it directly past the heap.</span><br><span class="line"></span><br><span class="line">	movw	%ss, %dx</span><br><span class="line">	cmpw	%ax, %dx	# %ds == %ss?</span><br><span class="line">	movw	%sp, %dx 	# move %sp to %dx</span><br></pre></td></tr></table></figure>

<p>我们首先要保证<code>%ss == %ds</code>，会出现三种情况：</p>
<p><code>ss</code>值合法</p>
<p><code>ss</code>值不合法且<code>CAN_USE_HEAP</code>被设置。</p>
<p><code>ss</code>值不合法且<code>CAN_USE_HEAP</code>未被设置。</p>
<ul>
<li>当<code>ss</code>值<code>(0x1000)</code>合法时，程序跳转到标签2：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2:	# Now %dx should point to the end of our stack space</span><br><span class="line">	andw	$~3, %dx	# dword align (might as well...)</span><br><span class="line">	jnz	3f					# jump if not zero</span><br><span class="line">	movw	$0xfffc, %dx	# Make sure we&#x27;re not zero</span><br><span class="line">3:	movw	%ax, %ss</span><br><span class="line">	movzwl	%dx, %esp	# Clear upper half of %esp</span><br><span class="line">	sti			# Now we should have a working stack</span><br></pre></td></tr></table></figure>

<p>​	首先将3取反得到<code>1111 1111 1111 1111 1111 1111 1111 1100</code> 之后和<code>%dx</code>做与运算，这将使 <code>%dx</code>的最后两位为0，以达到<code>dword align</code>双字对齐。即如果一个地址是4的倍数，我们就可以说它是双字对齐的。接着判断<code>andw</code>操作后的结果是否为0。如果为0，我们要将<code>%dx</code>的值设置为<code>0xfffc</code>（这是在 <code>64KB segment</code> 下的最大按四字对齐的地址）以保证<code>%dx</code>不为0。反之直接跳转到标签3。</p>
<p>​	标签3将<code>%ax</code>的值赋值给<code>%ss</code>。得到一个正确的栈：</p>
<p>​	<img src="/../images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-11%2010.58.21.png" alt="截屏2023-11-11 10.58.21"></p>
<ul>
<li>当<code>ss</code>值不合法且<code>CAN_USE_HEAP</code>被设置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Invalid %ss, make up a new stack</span><br><span class="line">	movw	$_end, %dx</span><br><span class="line">	testb	$CAN_USE_HEAP, loadflags</span><br><span class="line">	jz	1f</span><br><span class="line">	movw	heap_end_ptr, %dx</span><br><span class="line">1:	addw	$STACK_SIZE, %dx</span><br><span class="line">jnc	2f</span><br><span class="line">xorw	%dx, %dx	# Prevent wraparound</span><br></pre></td></tr></table></figure>

<p>我们首先将<code>$_end</code>赋值给 <code>%dx</code>，然后检查 <code>loadflag</code>中的 <code> $CAN_USE_HEAP</code>位。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S#L320">loadflags</a> is a bitmask header defined as:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOADED_HIGH     (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUIET_FLAG      (1&lt;&lt;5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEEP_SEGMENTS   (1&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_USE_HEAP    (1&lt;&lt;7)</span></span><br></pre></td></tr></table></figure>

<p>我们在<code>boot protocol</code>中了解到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Field name: loadflags</span><br><span class="line"></span><br><span class="line">  This field is a bitmask.</span><br><span class="line"></span><br><span class="line">  Bit 7 (write): CAN_USE_HEAP</span><br><span class="line">    Set this bit to 1 to indicate that the value entered in the</span><br><span class="line">    heap_end_ptr is valid.  If this field is clear, some setup code</span><br><span class="line">    functionality will be disabled.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>因此，如果<code>CAN_USE_HEAP</code>为1时 ，代表<code>heap_end_ptr</code>是合法的（指向栈底：<code>_end</code>）。然后将<code>%dx</code>加上一个<code>$STACK_SIZE</code>（这可能使得<code>%dx</code>指向栈顶）。如果没有溢出，则跳转到标签2，继续配置一个正确的栈。</p>
<p><img src="/../images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-11%2011.14.17.png" alt="截屏2023-11-11 11.14.17"></p>
<ul>
<li>当<code>ss</code>值不合法且<code>CAN_USE_HEAP</code>未被设置。那就只能用一个最小的栈，大小为from <code>_end</code> to <code>_end + STACK_SIZE</code></li>
</ul>
<p><img src="/../images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-11%2011.16.57.png" alt="截屏2023-11-11 11.16.57"></p>
<h3 id="BSS-Setup"><a href="#BSS-Setup" class="headerlink" title="BSS Setup"></a>BSS Setup</h3><p>在我们能跳向<code>main C code</code>之前，还有两个步骤需要配置，一个是配置<code>BSS</code>，第二个是检查<code>magic</code>签名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Check signature at end of setup</span><br><span class="line">	cmpl	$0x5a5aaa55, setup_sig</span><br><span class="line">	jne	setup_bad</span><br></pre></td></tr></table></figure>

<p>检查签名，如果不对，会报告一个<code>fatal error</code>。</p>
<p>签名匹配后，我们拥有了正确的段寄存器和栈，现在只需要配置正确的<code>BSS</code>段就可以跳转到<code>C</code>代码了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Zero the bss</span><br><span class="line">	movw	$__bss_start, %di</span><br><span class="line">	movw	$_end+3, %cx</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	subw	%di, %cx</span><br><span class="line">	shrw	$2, %cx</span><br><span class="line">	rep; stosl</span><br></pre></td></tr></table></figure>

<p><code>__bss_start</code>的地址赋值给<code>%di</code>，接着<code>__end + 3</code>的结果赋值给<code>%cx</code>。通过异或操作清空<code>%eax</code>的值。计算<code>cx -di</code>得到<code>bss section</code>的大小并存储到<code>cx</code>中。 <code>cx</code>除以4（右移2位）并重复执行<code>stosl</code>，该命令将持续把<code>eax</code>中的值（这里是0）存到<code>di</code>指向的地址中去，并将<code>di</code>的值增加4（这也是为什么<code>cx</code>要除以4的原因）。直到<code>cx</code>的值递减到0。以上的操作将<code>BSS section</code>的所有内存赋值为0：</p>
<p><img src="/../images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-11%2011.32.50.png" alt="截屏2023-11-11 11.32.50"></p>
<h3 id="Jump-to-main"><a href="#Jump-to-main" class="headerlink" title="Jump to main"></a>Jump to main</h3><p>现在我们跳转到主函数，<code>arch/x86/boot/main.c</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Jump to C code (should not return)</span><br><span class="line">	calll	main</span><br></pre></td></tr></table></figure>

<h1 id="Kernel-booting-process-Part-2"><a href="#Kernel-booting-process-Part-2" class="headerlink" title="Kernel booting process. Part 2."></a>Kernel booting process. Part 2.</h1><h2 id="First-steps-in-the-kernel-setup"><a href="#First-steps-in-the-kernel-setup" class="headerlink" title="First steps in the kernel setup"></a>First steps in the kernel setup</h2><p>现在我们将继续阅读<code>arch/x86/boot/main.c</code>，将学习如下内容：</p>
<ul>
<li>保护模式<code>protected mode</code>是什么。</li>
<li>计算机是怎样进入保护模式。</li>
<li>堆<code>heap</code>和控制台<code>console</code>的初始化。</li>
<li>内存检测，CPU确认，键盘初始化。</li>
<li><code>and much much more</code>。</li>
</ul>
<p>So, let‘s go ahead!</p>
<h2 id="Protected-mode"><a href="#Protected-mode" class="headerlink" title="Protected mode"></a>Protected mode</h2><p>在我们在进入<code>intel Long Mode</code>之前，内核需要将<code>CPU</code>转换到保护模式。</p>
<blockquote>
<ul>
<li><p>在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/X86-64">x86-64</a>处理器架构中，当处于<strong>长模式</strong>（Long mode）时，64位应用程序（或者是操作系统）可以使用64位指令和寄存器，而32位程序将以一种兼容子模式运行。<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC86%E6%A8%A1%E5%BC%8F">虚拟86模式</a>在长模式下不可用，也就是说，长模式不兼容16位程序。</p>
</li>
<li><p>不在长模式下运行时，处理器支持<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AE%9E%E6%A8%A1%E5%BC%8F">实模式</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BF%9D%E8%AD%B7%E6%A8%A1%E5%BC%8F">保护模式</a>两个子模式，在这两个模式下的x86-64处理器与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/X86-32">x86-32</a>处理器运行方式完全相同。</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CPUID">CPUID</a>扩展属性域中的一个位可以令运行在实模式或者保护模式的程序得知处理器能否转换到长模式，这使得程序能够检测是否使用了x86-64处理器。这类似于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Intel">Intel</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IA-64">IA-64</a>处理器使用CPUID中的一个属性位来让程序检测自己是否运行在IA-32仿真模式下。</p>
</li>
<li><p>保护模式在1982年第一次加入到<code>x86</code>架构，并在<code>intel 64</code>和长模式出现之前，一直是<code>intel</code>处理器的主模式。</p>
</li>
</ul>
</blockquote>
<p>从实模式<code>Real Mode</code>跳转出来的原因主要是实模式只提供非常有限的<code>RAM</code>访问。在前一章我们提到实模式只支持<code>1MB</code>，有时甚至只支持<code>640KB</code>的<code>RAM</code>。</p>
<p>保护模式带来了很多改变，其中最重要的是内存管理。实模式中20位地址总线被32位地址总线所替代。因此，它允许访问<code>4GB</code>的内存。同样，分页技术在保护模式中也可用。</p>
<p>实模式中的内存管理被分为两个部分：</p>
<ul>
<li>分段<code>Segmentation</code></li>
<li>分页<code>Paging</code></li>
</ul>
<p>在本节先讨论分段<code>segmentation</code>。在下一章我们会讨论分页<code>Paging</code>。</p>
<p>在之前我们介绍了实模式下的地址包含如下两部分：</p>
<ul>
<li>段基址<code>Base address of the segment</code></li>
<li>从段基址的偏移量<code>Offset from the segment base</code></li>
</ul>
<p>我们可以通过上述两部分获得物理地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhysicalAddress = Segment_Base * <span class="number">16</span> + Offset</span><br></pre></td></tr></table></figure>

<p>在保护模式，内存分段的方式则完全不同。不同于实模式下的固定<code>64KB</code>分段，保护模式中的段大小和位置被一个特殊的数据结构<code>Segment Descriptor</code>描述。这些段描述符<code>Segment Descriptor</code>存储在<code>Global Descriptor Table (GDT)</code>中。</p>
<p><code>GDT</code>常驻于内存中，但它在内存中没有固定的位置，因此它的地址存储在一个叫<code>GDTR</code>的寄存器中。</p>
<p>接着，我们介绍<code>GDT</code>是如何被加载到Linux内核代码中的。会有一个将它从内存中加载的操作，就像下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lgdt gdt	#	load global descriptor table 	</span><br></pre></td></tr></table></figure>

<p><code>lgdt</code>命令加载<code>GDT(global descriptor table)</code>的基址和大小加载到<code>GDTR</code>寄存器中，<code>GDTR</code>寄存器占48位：</p>
<ul>
<li><code>16</code>位表示<code>global descriptor table</code>的大小。</li>
<li><code>32</code>位表示<code>global descriptor table</code>的地址。</li>
</ul>
<p>之前提到，<code>GDT</code>包含<code>segment descriptors</code>，这是内存段的描述符。每个描述符占<code>64</code>位。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 63         56         51   48    45           39        32 </span><br><span class="line">------------------------------------------------------------</span><br><span class="line">|             | |B| |A|       | |   | |0|E|W|A|            |</span><br><span class="line">| BASE 31:24  |G|/|L|V| LIMIT |P|DPL|S|  TYPE | BASE 23:16 |</span><br><span class="line">|             | |D| |L| 19:16 | |   | |1|C|R|A|            |</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"> 31                         16 15                         0 </span><br><span class="line">------------------------------------------------------------</span><br><span class="line">|                             |                            |</span><br><span class="line">|        BASE 15:0            |       LIMIT 15:0           |</span><br><span class="line">|                             |                            |</span><br><span class="line">------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>51:48</code>和<code>15:0</code>表示段大小<code>length_of_segment - 1</code>，总共<code>20</code>位，同时段大小还取决于第<code>55</code>位<code>G (Granularity)</code>。</p>
<ul>
<li>当<code>G = 0</code>且<code>(segment) Limit = 0</code>时，段大小为<code>1 B</code>。</li>
<li>当<code>G = 1</code>且<code>(segment) Limit = 1</code>时，段大小为<code>4096 B</code>。</li>
<li>当<code>G = 0</code>且<code>(segment) Limit = 0xfffff</code>时，段大小为<code>1 MB。</code></li>
<li>当<code>G = 1</code>且<code>(segment) Limit = 0xfffff</code>时，段大小为<code>4 GB</code>。</li>
</ul>
<p>从上面的例子可以知道：</p>
<ul>
<li><code>G = 0</code>时，<code>Limit</code>被解释为<code>1 B</code>。</li>
<li><code>G = 1</code>时，<code>Limit</code>被解释为<code>4096 B = 4 KB = 1 页(page)</code>。</li>
</ul>
</li>
<li><p><code>Base</code>是<code>32位</code>，占<code>63:56</code>，<code>39:32</code>和<code>31:16</code>。表示段的起始物理地址。</p>
</li>
<li><p><code>Type/Attribute</code>为<code>5位</code>，占<code>44:40</code>，确定的段的属性。</p>
<ul>
<li><code>44位</code>的<code>S = 0</code>时，表示该段为系统段；<code>S = 1</code>时代表该段为数据段（栈段也属于数据段，且支持读和写）。</li>
<li><code>43位</code>的<code>Ex</code>规定该段是数据段还是代码段，<code>Ex = 0</code>表示数据段，反之为代码段。</li>
</ul>
</li>
</ul>
<p>下面列出所有类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">|           Type Field        | Descriptor Type | Description                        |</span><br><span class="line">|-----------------------------|-----------------|------------------------------------|</span><br><span class="line">| Decimal                     |                 |                                    |</span><br><span class="line">|             0    E    W   A |                 |                                    |</span><br><span class="line">| 0           0    0    0   0 | Data            | Read-Only                          |</span><br><span class="line">| 1           0    0    0   1 | Data            | Read-Only, accessed                |</span><br><span class="line">| 2           0    0    1   0 | Data            | Read/Write                         |</span><br><span class="line">| 3           0    0    1   1 | Data            | Read/Write, accessed               |</span><br><span class="line">| 4           0    1    0   0 | Data            | Read-Only, expand-down             |</span><br><span class="line">| 5           0    1    0   1 | Data            | Read-Only, expand-down, accessed   |</span><br><span class="line">| 6           0    1    1   0 | Data            | Read/Write, expand-down            |</span><br><span class="line">| 7           0    1    1   1 | Data            | Read/Write, expand-down, accessed  |</span><br><span class="line">|                  C    R   A |                 |                                    |</span><br><span class="line">| 8           1    0    0   0 | Code            | Execute-Only                       |</span><br><span class="line">| 9           1    0    0   1 | Code            | Execute-Only, accessed             |</span><br><span class="line">| 10          1    0    1   0 | Code            | Execute/Read                       |</span><br><span class="line">| 11          1    0    1   1 | Code            | Execute/Read, accessed             |</span><br><span class="line">| 12          1    1    0   0 | Code            | Execute-Only, conforming           |</span><br><span class="line">| 14          1    1    0   1 | Code            | Execute-Only, conforming, accessed |</span><br><span class="line">| 13          1    1    1   0 | Code            | Execute/Read, conforming           |</span><br><span class="line">| 15          1    1    1   1 | Code            | Execute/Read, conforming, accessed |</span><br><span class="line">--------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p><code>40, 41, 42</code>位表示<code>EXW</code>：<code>(Expansion, Writable, Accessiable)</code>或<code>CRA</code>：<code>(Conforming Readable Accesible)</code>。</p>
<ul>
<li><p><code>E = 0</code>，表示<code>expand up</code>，反之表示<code>expand down</code></p>
<blockquote>
<ul>
<li><strong>Expand Up</strong> 当一个内存段被定义为 “expand up” 时，这意味着段的大小可以向上扩展，也就是说，段的起始地址保持不变，而它的结束地址可以增大。在段描述符中，如果一个段是 “expand up” 类型的，当执行如堆（heap）内存分配这样的操作时，可以不断地向高地址扩展，增加段的大小。</li>
<li><strong>Expand Down</strong> 相反，”expand down” 段是指其结束地址固定，而起始地址可以减小（即向更低的内存地址扩展）。这通常用于如栈（stack）这样的数据结构，它们在增长时是向低地址扩展的。例如，在x86架构中，栈是向下增长的，这意味着如果栈需要更多空间，它的起始地址会向内存地址更低的方向移动。</li>
<li>在保护模式下的段描述符中，可以通过设置特定的标志位来定义段是 “expand up” 还是 “expand down”。这些标志位告诉处理器段的界限是如何随着数据的增长而变化的。</li>
</ul>
</blockquote>
</li>
<li><p><code>W = 1</code>，表示该段是写允许的；反之，该段为只读。</p>
</li>
<li><p><code>A = 1</code>，表示该段可被处理器访问。</p>
</li>
<li><p><code>C = 1</code>，该位仅在<code>43</code>位为1时有效，表示段代码可以被更低优先级的状态（例如用户态）执行。</p>
</li>
<li><p><code>R = 1</code>，表示可以从该段读取数据。</p>
</li>
</ul>
<ol>
<li><p><code>DPL[2 bits], (Descriptor privilege Level)</code>，占<code>46:45</code>两位。表示段的优先级，其中0为最高优先级。</p>
</li>
<li><p><code>47</code>位的<code>P</code>标志，表示该段是否存在内存中。<code>p = 0</code>表示该段不在内存中，如果处理器尝试访问一个不在内存中的段，会产生一个段不存在的异常。</p>
</li>
<li><p><code>52</code>位的<code>AVL</code>：保留位。</p>
</li>
<li><p><code>53</code>位的<code>L</code>表示该代码段是否包含<code>native 64-bit code</code>，如果包含，该代码段会在<code>64 bit</code>模式下执行。</p>
<blockquote>
<p>“Native 64-bit code”指的是为64位处理器架构专门编写和编译的程序代码。这些代码直接利用64位处理器能提供的特性，如更广泛的寄存器集合、更大的地址空间以及64位数据宽度，从而可以更高效地执行指令和处理数据。</p>
<p>当段描述符中的L标志（位53）被设置时，它表明该代码段包含的是原生的64位代码，且将在64位模式下执行。这与32位代码不同，后者即使在64位处理器上运行，也仅能使用32位架构的特性。</p>
</blockquote>
</li>
<li><p><code>54</code>位的<code>D/B</code>标志<code>(Default/Big flag)</code>表示操作数大小<code>32/16</code>位。</p>
<blockquote>
<p>操作数大小（Operand Size）是指在计算机架构中，CPU执行指令时所能处理的数据的位宽。这涉及到CPU指令能直接操作的数据单元的大小，例如，16位、32位或64位整数。</p>
<p>例如，在x86架构中：</p>
<ul>
<li>如果操作数大小是16位，那么CPU指令将会操作16位的数据单元，即它可以一次性读取、写入或处理16位（2字节）的数据。</li>
<li>如果操作数大小是32位，那么CPU指令将操作32位的数据单元，即它可以一次性读取、写入或处理32位（4字节）的数据。</li>
</ul>
</blockquote>
</li>
</ol>
<p>在实模式<code>real mode</code>下，段寄存器包<code>segment register</code>含了段选择器<code>segment selector</code>。然而在保护模式<code>protected mode</code>下，段选择器有所不同。每个段描述符拥有一个<code>16</code>位的段选择器<code>segment selector</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 15             3 2  1     0</span><br><span class="line">-----------------------------</span><br><span class="line">|      Index     | TI | RPL |</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Index</code>：存储描述符在<code>Gobal Descriptor Table</code>中的索引。</li>
<li><code>TI (Table Indicator)</code>：表示在什么地方寻找描述符。当<code>TI = 0</code>时，在<code>GDT</code>中寻找<code>Descriptor</code>。否则，在<code>Local Descriptor Table (LDT)</code>中寻找。</li>
<li><code>RPL</code>：存储请求者的优先级。</li>
</ul>
<p>每个段寄存器都有可见<code>visible</code>的和不可见<code>hidden</code>的部分：</p>
<ul>
<li><code>Visible</code>：存储段选择器。</li>
<li><code>Hidden</code>：存储段描述符（base, limit, attributes &amp; flags）</li>
</ul>
<p>在保护模式下，获取物理地址的步骤是：</p>
<ol>
<li><p>将段选择器<code>segment selector</code>加载到任意一个段寄存器<code>segment register</code>中。</p>
</li>
<li><p><code>CPU</code>从选择器<code>selector</code>中通过偏移<code>GDT address + Index</code>找到段描述符。然后将描述符加载到寄存器的不可见<code>hidden</code>部分。</p>
</li>
<li><p>如果不允许分页<code>paging disabled</code>，段的物理地址的计算公式如下：<br>$$<br>BaseAddress(found In The Descriptor Obtained In The Previous Step) + Offset<br>$$</p>
</li>
<li></li>
</ol>
<p>如下图所示：</p>
<p><img src="/../images/kernelInside/%E6%88%AA%E5%B1%8F2023-11-13%2011.10.19.png" alt="截屏2023-11-13 11.10.19"></p>
<p>从实模式跳转到保护模式的流程如下：</p>
<ul>
<li>禁止中断</li>
<li>通过<code>lgdt</code>命令描述并加载<code>GDT</code></li>
<li>在<code>CR0 (Control Register 0)</code>中配置<code>PE (Protection Enable)</code></li>
<li>跳转到保护模式的代码</li>
</ul>
<p>在跳转到保护模式前，我们需要做一些准备。</p>
<p>阅读<code>arch/x86/boot/main.c</code>，我们会看见一些实现，键盘初始化，堆初始化等等，的函数。</p>
<p>查看<code>main.c</code>中的<code>main</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* First, copy the boot header into the &quot;zeropage&quot; */</span></span><br><span class="line">	copy_boot_params();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize the early-boot console */</span></span><br><span class="line">	console_init();</span><br><span class="line">	<span class="keyword">if</span> (cmdline_find_option_bool(<span class="string">&quot;debug&quot;</span>))</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;early console in setup code\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* End of heap check */</span></span><br><span class="line">	init_heap();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure we have all the proper CPU support */</span></span><br><span class="line">	<span class="keyword">if</span> (validate_cpu()) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Unable to boot - please use a kernel appropriate &quot;</span></span><br><span class="line">		     <span class="string">&quot;for your CPU.\n&quot;</span>);</span><br><span class="line">		die();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Tell the BIOS what CPU mode we intend to run in. */</span></span><br><span class="line">	set_bios_mode();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Detect memory layout */</span></span><br><span class="line">	detect_memory();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set keyboard repeat rate (why?) and query the lock flags */</span></span><br><span class="line">	keyboard_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Query Intel SpeedStep (IST) information */</span></span><br><span class="line">	query_ist();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Query APM information */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_APM) || defined(CONFIG_APM_MODULE)</span></span><br><span class="line">	query_apm_bios();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Query EDD information */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_EDD) || defined(CONFIG_EDD_MODULE)</span></span><br><span class="line">	query_edd();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set the video mode */</span></span><br><span class="line">	set_video();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Do the last things and invoke protected mode */</span></span><br><span class="line">	go_to_protected_mode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Copyinh-boot-parameters-into-the-“zeropage”"><a href="#Copyinh-boot-parameters-into-the-“zeropage”" class="headerlink" title="Copyinh boot parameters into the “zeropage”"></a>Copyinh boot parameters into the “zeropage”</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* First, copy the boot header into the &quot;zeropage&quot; */</span></span><br><span class="line">	copy_boot_params();</span><br></pre></td></tr></table></figure>

<p>该函数将内核配置头拷贝到对应的结构体<code>boot_params</code>（也叫<code>zeropage</code>，定义在<code>arch/x86/include/uapi/asm/bootparam.h</code>）对应的成员<code>setup_header</code>中。</p>
<blockquote>
<p>在Linux内核启动过程中，“kernel setup header”通常指的是一个特定的数据结构，它包含了启动时内核所需的各种参数和信息。这个数据结构在启动早期由引导程序填充，然后由启动加载器（比如GRUB）传递给内核。</p>
<p>“kernel setup header”结构定义了内核如何被加载，包含了以下信息：</p>
<ul>
<li>内核的加载模式（实模式或保护模式）</li>
<li>启动设备</li>
<li>内存布局信息</li>
<li>初始化RAM盘的位置和大小</li>
<li>视频模式选择</li>
<li>其他硬件参数</li>
</ul>
<p>这个头部信息是由启动代码中的一部分，比如Linux的bootsect.S（启动扇区）和setup.S（设置代码）所使用。这些信息对于内核来说非常关键，因为它们告诉内核它被加载到内存中的哪个位置，以及硬件的配置如何。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">struct setup_header &#123;</span><br><span class="line">	__u8	setup_sects;	// 	引导扇区的大小。</span><br><span class="line">	__u16	root_flags;		// 	根文件系统的挂载标志。</span><br><span class="line">	__u32	syssize;			// 	内核映像的大小（单位为16字节段）。</span><br><span class="line">	__u16	ram_size;			//	旧式的RAM大小指示，现在不常用。</span><br><span class="line">	__u16	vid_mode;			//	视频模式标识。</span><br><span class="line">	__u16	root_dev;			//	根设备的编号。</span><br><span class="line">	__u16	boot_flag;		//	引导标志，用来指示有效的引导扇区。</span><br><span class="line">	__u16	jump;					//	引导代码中跳转指令的起始位置。</span><br><span class="line">	__u32	header;				//	Magic Number，用来识别这个结构体。</span><br><span class="line">	__u16	version;			//	结构体的版本号。</span><br><span class="line">	__u32	realmode_swtch;		</span><br><span class="line">	__u16	start_sys_seg;</span><br><span class="line">	__u16	kernel_version;</span><br><span class="line">	__u8	type_of_loader;</span><br><span class="line">	__u8	loadflags;</span><br><span class="line">	__u16	setup_move_size;</span><br><span class="line">	__u32	code32_start;</span><br><span class="line">	__u32	ramdisk_image;</span><br><span class="line">	__u32	ramdisk_size;</span><br><span class="line">	__u32	bootsect_kludge;</span><br><span class="line">	__u16	heap_end_ptr;</span><br><span class="line">	__u8	ext_loader_ver;</span><br><span class="line">	__u8	ext_loader_type;</span><br><span class="line">	__u32	cmd_line_ptr;</span><br><span class="line">	__u32	initrd_addr_max;</span><br><span class="line">	__u32	kernel_alignment;</span><br><span class="line">	__u8	relocatable_kernel;</span><br><span class="line">	__u8	min_alignment;</span><br><span class="line">	__u16	xloadflags;</span><br><span class="line">	__u32	cmdline_size;</span><br><span class="line">	__u32	hardware_subarch;</span><br><span class="line">	__u64	hardware_subarch_data;</span><br><span class="line">	__u32	payload_offset;</span><br><span class="line">	__u32	payload_length;</span><br><span class="line">	__u64	setup_data;</span><br><span class="line">	__u64	pref_address;</span><br><span class="line">	__u32	init_size;</span><br><span class="line">	__u32	handover_offset;</span><br><span class="line">	__u32	kernel_info_offset;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>boot_params</code>结构体包含 <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/x86/boot.txt">linux boot protocol</a>定义的域，这些域会在启动器启动电脑、内核编译时填充。<code>copy_boot_protocal</code>做了以下两件事：</p>
<ol>
<li>将汇编代码<code>header.S</code>中的<code>hdr</code>标签复制到结构体<code>boot_params</code>中的<code>setup_header</code>成员。</li>
<li>如果加载内核时用了旧的命令行工具，它负责跟新指针指向新的内核命令行工具。</li>
</ol>
<p>顺便看一看实现复制<code>hdr</code>功能的<code>memcpy</code>在<code>arch/x86/boot/copy.S</code>中是如何实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Memory copy routines</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">	.code16</span><br><span class="line">	.text</span><br><span class="line"></span><br><span class="line">SYM_FUNC_START_NOALIGN(memcpy)</span><br><span class="line">	pushw	%si						# si 是源索引寄存器</span><br><span class="line">	pushw	%di						#	di 是目标寄存器</span><br><span class="line">	movw	%ax, %di			# ax 通常存放目的地址</span><br><span class="line">	movw	%dx, %si			# dx 通常存放源地址</span><br><span class="line">	pushw	%cx						# cx 计数寄存器</span><br><span class="line">	shrw	$2, %cx</span><br><span class="line">	rep; movsl					# rep 重复执行标志；movsl：move string long。这条指令用于从源地址复制一个双字（32位，或者说4个字节）到目标地址。</span><br><span class="line">	popw	%cx</span><br><span class="line">	andw	$3, %cx</span><br><span class="line">	rep; movsb</span><br><span class="line">	popw	%di</span><br><span class="line">	popw	%si</span><br><span class="line">	retl</span><br><span class="line">SYM_FUNC_END(memcpy)</span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>SYM_FUNC_START_NOALIGN</code>定义在<code>include/linux/linkage.h</code>中，表示这是一个全局函数。其中 <code>w/o</code>表示 <code>without alignment</code>，即无对齐。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SYM_FUNC_START_NOALIGN -- use for global functions, w/o alignment */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SYM_FUNC_START_NOALIGN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYM_FUNC_START_NOALIGN(name)			\</span></span><br><span class="line"><span class="meta">	SYM_START(name, SYM_L_GLOBAL, SYM_A_NONE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>memcpy</code>的汇编代码很简单。</p>
<ul>
<li>首先将<code>%si</code>和<code>%di</code>寄存器中的值压入栈中以保留它们的值，这是因为接下来的操作会改变它们的值。</li>
<li>然后将<code>%ax</code>和<code>%dx</code>的值存储到<code>%di</code>和<code>%si</code>中。</li>
<li>将<code>%cx</code>的值保存在栈中，然后对<code>%cx</code>的值右移2位（除以4）。</li>
<li>循环复制（一次复制4字节）源寄存器<code>si</code>指向的地址中的值，到目的寄存器<code>di</code>指向的地址空间中，直到计数寄存器<code>cx</code>减小为0。</li>
</ul>
<p>因为上面的操作都是4个字节4个字节的复制，而在实际使用<code>memcpy</code>时肯定会出现复制的字节不是4的倍数的情况。</p>
<ul>
<li>这种情况下，我们取出在栈中保存的<code>%cx</code>值，然后重复使用<code>movsb</code>命令（b代表每次复制一个字节）复制剩下的字节。</li>
<li>最后取出保存在<code>%di</code>和<code>%si</code>中的值并返回。</li>
</ul>
<p>在<code>arch/x86/Makefile</code>中的<code>REALMODE_CFLAGS</code>中可以看到，构建内核时通过<code>-mregparm = 3</code>的<code>GCC</code>选项。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How to compile the 16-bit code.  Note we always compile for -march=i386;</span></span><br><span class="line"><span class="comment"># that way we can complain to the user if the CPU is insufficient.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The -m16 option is supported by GCC &gt;= 4.9 and clang &gt;= 3.5. For</span></span><br><span class="line"><span class="comment"># older versions of GCC, include an *assembly* header to make sure that</span></span><br><span class="line"><span class="comment"># gcc doesn&#x27;t play any games behind our back.</span></span><br><span class="line">CODE16GCC_CFLAGS := -m32 -Wa,<span class="variable">$(srctree)</span>/arch/x86/boot/code16gcc.h</span><br><span class="line">M16_CFLAGS	 := <span class="variable">$(<span class="built_in">call</span> cc-option, -m16, <span class="variable">$(CODE16GCC_CFLAGS)</span>)</span></span><br><span class="line"></span><br><span class="line">REALMODE_CFLAGS	:= <span class="variable">$(M16_CFLAGS)</span> -g -Os -DDISABLE_BRANCH_PROFILING -D__DISABLE_EXPORTS \</span><br><span class="line">		   -Wall -Wstrict-prototypes -march=i386 -mregparm=3 \</span><br><span class="line">		   -fno-strict-aliasing -fomit-frame-pointer -fno-pic \</span><br><span class="line">		   -mno-mmx -mno-sse <span class="variable">$(<span class="built_in">call</span> cc-option,-fcf-protection=none)</span></span><br></pre></td></tr></table></figure>

<p>现在我们知道，函数<code>memcpy</code>的三个参数分别存储在<code>ax</code>,<code>dx</code>和<code>cx</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(&amp;boot_params.hdr, &amp;hdr, <span class="keyword">sizeof</span> hdr);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ax</code> 存储<code>boot_params.hdr</code>的地址</li>
<li><code>dx</code> 存储 <code>hdr</code>的地址</li>
<li><code>cx</code> 存储 <code>hdr</code> 的大小</li>
</ul>
<h2 id="Console-initialization"><a href="#Console-initialization" class="headerlink" title="Console initialization"></a>Console initialization</h2><p>使用函数<code>console_init</code>初始化控制台，该函数定义在<code>arch/x86/boot/early_serial_console.c</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">console_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	parse_earlyprintk();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!early_serial_base)</span><br><span class="line">		parse_console_uart8250();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数在启动参数中寻找<code>earlyprintk</code>选项，如果成功找到，则解析端口地址和端口的波特率并初始化端口。<code>earlyprintk</code>命令行的参数是其中的下一个：</p>
<ul>
<li><code>serial, 0x3f8, 115200</code></li>
<li><code>serial, ttyS0, 115200</code></li>
<li><code>ttyS0, 115200</code></li>
</ul>
<p>串行端口初始化成功后，我们会看见第一个输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cmdline_find_option_bool(<span class="string">&quot;debug&quot;</span>))</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;early console in setup code\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>函数<code>puts</code>定义在：<code>arch/x86/boot/tty.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __section(<span class="string">&quot;.inittext&quot;</span>) <span class="built_in">putchar</span>(<span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (ch == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;\r&#x27;</span>);	<span class="comment">/* \n -&gt; \r\n */</span></span><br><span class="line"></span><br><span class="line">	bios_putchar(ch);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (early_serial_base != <span class="number">0</span>)</span><br><span class="line">		serial_putchar(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __section(<span class="string">&quot;.inittext&quot;</span>) <span class="built_in">puts</span>(<span class="type">const</span> <span class="type">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (*str)</span><br><span class="line">		<span class="built_in">putchar</span>(*str++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在c语言中，<code>__section</code>属性告诉编译器将特定的函数或者变量放置在指定的段<code>(section)</code>中。<code>&quot;.inittext&quot;</code>是一个段名，用于指定内核初始化代码的位置。</p>
<p>即，指示连接器将<code>putchar</code>函数放置在<code>ELF</code>二进制文件的<code>.inittext</code>段中。这个段专门用于内核启动时需要执行，但是一旦完成初始化过程后就不再需要的代码。内核通常在启动完成后会释放这些初始化代码占用的内存，因为这段时间内核已经开始运行正常的运行时代码了。</p>
<p>使用这个属性可以帮助减少内核的运行时内存占用，因为初始化代码在它不再需要之后不会占用宝贵的内存资源。这在嵌入式系统中尤其有用，其中内存资源可能非常有限。</p>
</blockquote>
<p>我们在链接文件<code>arch/x86/boot/setup.ld</code>可以看到上述代码的<code>.inittext</code>段的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> */</span><br><span class="line">OUTPUT_FORMAT(&quot;elf32-i386&quot;)</span><br><span class="line">OUTPUT_ARCH(i386)</span><br><span class="line">ENTRY(_start)</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">	. = 0;</span><br><span class="line">	.bstext		: &#123; *(.bstext) &#125;</span><br><span class="line">	.bsdata		: &#123; *(.bsdata) &#125;</span><br><span class="line"></span><br><span class="line">	. = 495;</span><br><span class="line">	.header		: &#123; *(.header) &#125;</span><br><span class="line">	.entrytext	: &#123; *(.entrytext) &#125;</span><br><span class="line">	.inittext	: &#123; *(.inittext) &#125;</span><br><span class="line">	.initdata	: &#123; *(.initdata) &#125;</span><br><span class="line">	__end_init = .;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们回到函数<code>putchar</code>，该函数在将<code>\n</code>转换为<code>\r</code>后。调用<code>bios_putchar</code>，通过<code>0x10</code>中断，在<code>VGA screen</code>上输出。</p>
<blockquote>
<ul>
<li>在计算机术语中，“VGA screen”指的是通过视频图形阵列（Video Graphics Array，VGA）接口显示的屏幕。</li>
<li>BIOS（基本输入输出系统）提供了一系列的中断调用，用于低级别的硬件交互，其中<code>0x10</code>是视频服务的中断号。软件可以通过设置相应的寄存器，然后触发这个中断来执行特定的视频操作，如在屏幕上显示字符。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __section(<span class="string">&quot;.inittext&quot;</span>) bios_putchar(<span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">biosregs</span> <span class="title">ireg</span>;</span></span><br><span class="line"></span><br><span class="line">	initregs(&amp;ireg);</span><br><span class="line">	ireg.bx = <span class="number">0x0007</span>;</span><br><span class="line">	ireg.cx = <span class="number">0x0001</span>;</span><br><span class="line">	ireg.ah = <span class="number">0x0e</span>;</span><br><span class="line">	ireg.al = ch;</span><br><span class="line">	intcall(<span class="number">0x10</span>, &amp;ireg, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>initregs</code>调用<code>memset</code>函数将<code>biosregs ireg</code>置为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initregs</span><span class="params">(<span class="keyword">struct</span> biosregs *reg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(reg, <span class="number">0</span>, <span class="keyword">sizeof</span>(*reg));</span><br><span class="line">	reg-&gt;eflags |= X86_EFLAGS_CF;</span><br><span class="line">	reg-&gt;ds = ds();</span><br><span class="line">	reg-&gt;es = ds();</span><br><span class="line">	reg-&gt;fs = fs();</span><br><span class="line">	reg-&gt;gs = gs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阅读<code>memset</code>的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SYM_FUNC_START_NOALIGN(memset)</span><br><span class="line">	pushw	%di</span><br><span class="line">	movw	%ax, %di</span><br><span class="line">	movzbl	%dl, %eax		# move with Zero-Extend from Byte to Longword	</span><br><span class="line">	imull	$0x01010101,%eax</span><br><span class="line">	pushw	%cx</span><br><span class="line">	shrw	$2, %cx</span><br><span class="line">	rep; stosl</span><br><span class="line">	popw	%cx</span><br><span class="line">	andw	$3, %cx</span><br><span class="line">	rep; stosb</span><br><span class="line">	popw	%di</span><br><span class="line">	retl</span><br><span class="line">SYM_FUNC_END(memset)</span><br></pre></td></tr></table></figure>

<ul>
<li>同样接受三个参数，存放在<code>ax dx cx</code>中。</li>
<li>将8位<code>%dl</code>零扩展到32位并移动到<code>%eax</code>中。</li>
<li>然后通过<code>imull $0x01010101, %eax</code>将高<code>24</code>位全复制为低<code>8</code>位的值。</li>
<li><code>stosl</code>：<code>Store String long</code>（存储字符串长字）。该指令将累加器（<code>AL</code>、<code>AX</code>或<code>EAX</code>）中的数据复制到目标索引寄存器（<code>DI</code>或<code>EDI</code>）指向的内存地址，并根据当前设置的方向标志（Direction Flag）在标志寄存器中自动增加或减少<code>DI</code>&#x2F;<code>EDI</code>的值。直到计数寄存器<code>cx</code>归<code>0</code>。</li>
</ul>
<h2 id="Heap-initialization"><a href="#Heap-initialization" class="headerlink" title="Heap initialization"></a>Heap initialization</h2><p>在<code>header.S</code>中，我们初始化了栈<code>stack</code>和<code>bss</code>段。现在内核需要使用<code>init_heap</code>初始化堆<code>heap</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_heap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *stack_end;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (boot_params.hdr.loadflags &amp; CAN_USE_HEAP) &#123;</span><br><span class="line">		<span class="keyword">asm</span>(<span class="string">&quot;leal %P1(%%esp),%0&quot;</span></span><br><span class="line">		    : <span class="string">&quot;=r&quot;</span> (stack_end) : <span class="string">&quot;i&quot;</span> (-STACK_SIZE));</span><br><span class="line"></span><br><span class="line">		heap_end = (<span class="type">char</span> *)</span><br><span class="line">			((<span class="type">size_t</span>)boot_params.hdr.heap_end_ptr + <span class="number">0x200</span>);</span><br><span class="line">		<span class="keyword">if</span> (heap_end &gt; stack_end)</span><br><span class="line">			heap_end = stack_end;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Boot protocol 2.00 only, no heap available */</span></span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;WARNING: Ancient bootloader, some functionality &quot;</span></span><br><span class="line">		     <span class="string">&quot;may be limited!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先检查启动文件头的<code>loadflag</code>中是否配置了<code>CAN_USE_HEAP</code>，如果配置了<code>CAN_USE_HEAP</code>，使用内链汇编代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;leal %P1(%%esp),%0&quot;</span></span><br><span class="line">		    : <span class="string">&quot;=r&quot;</span> (stack_end) : <span class="string">&quot;i&quot;</span> (-STACK_SIZE));</span><br></pre></td></tr></table></figure>

<p>计算栈的结束位置。也即：<code>stack_end = esp - STACK_SIZE</code></p>
<p>接着是计算堆结束位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap_end = (<span class="type">char</span> *)((<span class="type">size_t</span>)boot_params.hdr.heap_end_ptr + <span class="number">0x200</span>);</span><br></pre></td></tr></table></figure>

<p>最后检查堆结束地址<code>heap_end</code>是否大于栈结束地址<code>stack_end</code>，如果是，则要保持<code>heap_end = stack_end</code>。</p>
<p>堆初始化之后，我们可以使用<code>GET_HEAP</code>方法，在下一章我们会介绍它。</p>
<h2 id="CPU确认"><a href="#CPU确认" class="headerlink" title="CPU确认"></a>CPU确认</h2><p>下一步是确认<code>CPU，函数</code>validate_cpu<code>定义在</code><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/cpu.c"><code>arch/x86/boot/cpu.c</code></a>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">validate_cpu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 *err_flags;</span><br><span class="line">	<span class="type">int</span> cpu_level, req_level;</span><br><span class="line"></span><br><span class="line">	check_cpu(&amp;cpu_level, &amp;req_level, &amp;err_flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cpu_level &lt; req_level) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;This kernel requires an %s CPU, &quot;</span>,</span><br><span class="line">		       cpu_name(req_level));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;but only detected an %s CPU.\n&quot;</span>,</span><br><span class="line">		       cpu_name(cpu_level));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err_flags) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;This kernel requires the following features &quot;</span></span><br><span class="line">		     <span class="string">&quot;not present on the CPU:\n&quot;</span>);</span><br><span class="line">		show_cap_strs(err_flags);</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (check_knl_erratum()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数<code>check_cpu</code>判断当前CPU等级<code>cpu_level</code>和需要的CPU等级<code>req_level</code>是否一致。该函数还检查CPU标志，对于x86_64（64位）CPU，它会检查长模式（long mode）是否存在，检查处理器的供应商，并为特定供应商做准备，比如如果AMD缺失SSE+SSE2，就关闭它们等等。</p>
<p>当cpu被确认后，调用<code>set_bios_mode</code>，该函数告诉<code>BIOS</code>我们会在哪种<code>CPU</code>模式下运行。该函数只在<code>x86_64</code>模式下运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Tell the BIOS what CPU mode we intend to run in.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_bios_mode</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">biosregs</span> <span class="title">ireg</span>;</span></span><br><span class="line"></span><br><span class="line">	initregs(&amp;ireg);</span><br><span class="line">	ireg.ax = <span class="number">0xec00</span>;</span><br><span class="line">	ireg.bx = <span class="number">2</span>;</span><br><span class="line">	intcall(<span class="number">0x15</span>, &amp;ireg, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数通过<code>0x15 BIOS</code>中断告诉<code>BIOS</code>使用长模式<code>long mode</code>。</p>
<blockquote>
<p>在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/X86-64">x86-64</a>处理器架构中，当处于<strong>长模式</strong>（Long mode）时，64位应用程序（或者是操作系统）可以使用64位指令和寄存器，而32位程序将以一种兼容子模式运行。</p>
</blockquote>
<h2 id="Memory-detection"><a href="#Memory-detection" class="headerlink" title="Memory detection"></a>Memory detection</h2><p>接着主函数会调用<code>detect_memory</code>检测内存，该函数为<code>CPU</code>提供了基础的<code>RAM</code>映射表。使用了不同的编程接口<code>0xe820 0xe801</code>和<code>0x88</code>用于内存检测。以<code>0xE820</code>为例，<code>detect_memory_e820</code>定义在<code>arch/x86/boot/memory.c</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">detect_memory_e820</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">biosregs</span> <span class="title">ireg</span>, <span class="title">oreg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">boot_e820_entry</span> *<span class="title">desc</span> =</span> boot_params.e820_table;</span><br><span class="line">	<span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">boot_e820_entry</span> <span class="title">buf</span>;</span> <span class="comment">/* static so it is zeroed */</span></span><br><span class="line"></span><br><span class="line">	initregs(&amp;ireg);</span><br><span class="line">	ireg.ax  = <span class="number">0xe820</span>;</span><br><span class="line">	ireg.cx  = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">	ireg.edx = SMAP;</span><br><span class="line">	ireg.di  = (<span class="type">size_t</span>)&amp;buf;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Note: at least one BIOS is known which assumes that the</span></span><br><span class="line"><span class="comment">	 * buffer pointed to by one e820 call is the same one as</span></span><br><span class="line"><span class="comment">	 * the previous call, and only changes modified fields.  Therefore,</span></span><br><span class="line"><span class="comment">	 * we use a temporary buffer and copy the results entry by entry.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This routine deliberately does not try to account for</span></span><br><span class="line"><span class="comment">	 * ACPI 3+ extended attributes.  This is because there are</span></span><br><span class="line"><span class="comment">	 * BIOSes in the field which report zero for the valid bit for</span></span><br><span class="line"><span class="comment">	 * all ranges, and we don&#x27;t currently make any use of the</span></span><br><span class="line"><span class="comment">	 * other attribute bits.  Revisit this if we see the extended</span></span><br><span class="line"><span class="comment">	 * attribute bits deployed in a meaningful way in the future.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		intcall(<span class="number">0x15</span>, &amp;ireg, &amp;oreg);</span><br><span class="line">		ireg.ebx = oreg.ebx; <span class="comment">/* for next iteration... */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* BIOSes which terminate the chain with CF = 1 as opposed</span></span><br><span class="line"><span class="comment">		   to %ebx = 0 don&#x27;t always report the SMAP signature on</span></span><br><span class="line"><span class="comment">		   the final, failing, probe. */</span></span><br><span class="line">		<span class="keyword">if</span> (oreg.eflags &amp; X86_EFLAGS_CF)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Some BIOSes stop returning SMAP in the middle of</span></span><br><span class="line"><span class="comment">		   the search loop.  We don&#x27;t know exactly how the BIOS</span></span><br><span class="line"><span class="comment">		   screwed up the map at that point, we might have a</span></span><br><span class="line"><span class="comment">		   partial map, the full map, or complete garbage, so</span></span><br><span class="line"><span class="comment">		   just return failure. */</span></span><br><span class="line">		<span class="keyword">if</span> (oreg.eax != SMAP) &#123;</span><br><span class="line">			count = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		*desc++ = buf;</span><br><span class="line">		count++;</span><br><span class="line">	&#125; <span class="keyword">while</span> (ireg.ebx &amp;&amp; count &lt; ARRAY_SIZE(boot_params.e820_table));</span><br><span class="line"></span><br><span class="line">	boot_params.e820_entries = count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数首先为寄存器填充调用<code>0xe820</code>所需的特定值。</p>
<ul>
<li><code>ax</code>：包含了函数的名字。</li>
<li><code>cx</code>：缓存的大小，该缓存将用于存储内存中的数据。</li>
<li><code>edx</code>：包含了<code>SMAP magic number</code>。</li>
<li><code>es:di</code>：指向上面提到的缓存的地址（cx中）。</li>
<li><code>ebx</code>：必须为0.</li>
</ul>
<p>然后是一个循环，该循环收集内存中的数据。首先调用<code>0x15</code>的<code>BIOS</code>中断，该中断从地址分配表中写入一行。为了获取下一行，我们需要再次调用该中断。在下一次调用之前，ebx必须包含之前返回的值。</p>
<p>最终，该函数从地址分配表收集数据，并将这些数据写入e820_entry数组：</p>
<ul>
<li>内存段的起点</li>
<li>内存段的大小</li>
<li>内存段的类型（可用或者保留）</li>
</ul>
<p><code>dmesg</code>的输出是像下面给出的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[    0.000000] e820: BIOS-provided physical RAM map:</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x0000000000000000-0x000000000009fbff] usable</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x000000000009fc00-0x000000000009ffff] reserved</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x00000000000f0000-0x00000000000fffff] reserved</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x0000000000100000-0x000000003ffdffff] usable</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x000000003ffe0000-0x000000003fffffff] reserved</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x00000000fffc0000-0x00000000ffffffff] reserved</span><br></pre></td></tr></table></figure>

<h2 id="Keyboard-initialization"><a href="#Keyboard-initialization" class="headerlink" title="Keyboard initialization"></a>Keyboard initialization</h2><p>接着调用函数<code>keyboard_init</code>初始化键盘，同样通过函数<code>initregs</code>初始化寄存器。然后调用<code>0x16</code>中断查询键盘状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">keyboard_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">biosregs</span> <span class="title">ireg</span>, <span class="title">oreg</span>;</span></span><br><span class="line">	initregs(&amp;ireg);</span><br><span class="line"></span><br><span class="line">	ireg.ah = <span class="number">0x02</span>;		<span class="comment">/* Get keyboard status */</span></span><br><span class="line">	intcall(<span class="number">0x16</span>, &amp;ireg, &amp;oreg);</span><br><span class="line">	boot_params.kbd_status = oreg.al;</span><br><span class="line"></span><br><span class="line">	ireg.ax = <span class="number">0x0305</span>;	<span class="comment">/* Set keyboard repeat rate */</span></span><br><span class="line">	intcall(<span class="number">0x16</span>, &amp;ireg, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此之后，它再次调用0x16来设置重复率和延迟。</p>
<h2 id="Querying"><a href="#Querying" class="headerlink" title="Querying"></a>Querying</h2><p>接下来的几个步骤是对不同参数的查询。我们不会深入研究这些查询的细节，但稍后会回复它们。让我们简要看看这些功能：</p>
<ul>
<li><p><code>query_ist</code>：获取<code>Intel SpeedStep</code>信息。检查<code>CPU</code>的等级，如果正确，调用<code>0x15</code>中断获取信息并存储到<code>boot_params</code>中</p>
<blockquote>
<p>ST（Intel SpeedStep Technology）是英特尔开发的一种处理器技术，旨在优化处理器的性能和电源使用效率。它通过根据当前计算机负载动态调整处理器的频率和电压来实现这一目标。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get Intel SpeedStep (IST) information.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">query_ist</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">biosregs</span> <span class="title">ireg</span>, <span class="title">oreg</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Some older BIOSes apparently crash on this call, so filter</span></span><br><span class="line"><span class="comment">	   it from machines too old to have SpeedStep at all. */</span></span><br><span class="line">	<span class="keyword">if</span> (cpu.level &lt; <span class="number">6</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	initregs(&amp;ireg);</span><br><span class="line">	ireg.ax  = <span class="number">0xe980</span>;	 <span class="comment">/* IST Support */</span></span><br><span class="line">	ireg.edx = <span class="number">0x47534943</span>;	 <span class="comment">/* Request value */</span></span><br><span class="line">	intcall(<span class="number">0x15</span>, &amp;ireg, &amp;oreg);</span><br><span class="line"></span><br><span class="line">	boot_params.ist_info.signature  = oreg.eax;</span><br><span class="line">	boot_params.ist_info.command    = oreg.ebx;</span><br><span class="line">	boot_params.ist_info.event      = oreg.ecx;</span><br><span class="line">	boot_params.ist_info.perf_level = oreg.edx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>query_apm_bios</code>：从<code>BIOS</code>中获取<code>Advanced Power Management</code>信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Query_apm_bios也调用0x15 BIOS中断，但用ah = 0x53检查APM安装。0x15完成执行后，query_apm_bios函数检查PM签名（必须是0x504d）、携带标志（如果支持APM，则必须是0）和cx寄存器的值（如果是0x02，则支持受保护模式接口）。</span><br><span class="line"></span><br><span class="line">接下来，它再次调用0x15，但使用ax = 0x5304断开APM接口并连接32位保护模式接口。最后，它用从BIOS获得的值填充boot_params.apm_bios_info。</span><br><span class="line"></span><br><span class="line">请注意，只有在配置文件中设置了CONFIG_APM或CONFIG_APM_MODULE编译时间标志时，query_apm_bios才会执行：</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>query_edd</code>：查询<code>Enhanced Disk Drive</code>信息。</p>
<p>函数首先从内核命令行中读取<code>edd</code>设置，如果没有该选择则直接退出函数。</p>
<p>如果启用EDD，query_edd会检查BIOS支持的硬盘，并在循环中查询EDD信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">query_edd</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> eddarg[<span class="number">8</span>];</span><br><span class="line">	<span class="type">int</span> do_mbr = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EDD_OFF</span></span><br><span class="line">	<span class="type">int</span> do_edd = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">int</span> do_edd = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span> be_quiet;</span><br><span class="line">	<span class="type">int</span> devno;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">edd_info</span> <span class="title">ei</span>, *<span class="title">edp</span>;</span></span><br><span class="line">	u32 *mbrptr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cmdline_find_option(<span class="string">&quot;edd&quot;</span>, eddarg, <span class="keyword">sizeof</span>(eddarg)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(eddarg, <span class="string">&quot;skipmbr&quot;</span>) || !<span class="built_in">strcmp</span>(eddarg, <span class="string">&quot;skip&quot;</span>)) &#123;</span><br><span class="line">			do_edd = <span class="number">1</span>;</span><br><span class="line">			do_mbr = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(eddarg, <span class="string">&quot;off&quot;</span>))</span><br><span class="line">			do_edd = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(eddarg, <span class="string">&quot;on&quot;</span>))</span><br><span class="line">			do_edd = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	be_quiet = cmdline_find_option_bool(<span class="string">&quot;quiet&quot;</span>);</span><br><span class="line"></span><br><span class="line">	edp    = boot_params.eddbuf;</span><br><span class="line">	mbrptr = boot_params.edd_mbr_sig_buffer;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!do_edd)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Bugs in OnBoard or AddOnCards Bios may hang the EDD probe,</span></span><br><span class="line"><span class="comment">	 * so give a hint if this happens.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!be_quiet)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Probing EDD (edd=off to disable)... &quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (devno = <span class="number">0x80</span>; devno &lt; <span class="number">0x80</span>+EDD_MBR_SIG_MAX; devno++) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Scan the BIOS-supported hard disks and query EDD</span></span><br><span class="line"><span class="comment">		 * information...</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!get_edd_info(devno, &amp;ei)</span><br><span class="line">		    &amp;&amp; boot_params.eddbuf_entries &lt; EDDMAXNR) &#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(edp, &amp;ei, <span class="keyword">sizeof</span>(ei));</span><br><span class="line">			edp++;</span><br><span class="line">			boot_params.eddbuf_entries++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (do_mbr &amp;&amp; !read_mbr_sig(devno, &amp;ei, mbrptr++))</span><br><span class="line">			boot_params.edd_mbr_sig_buf_entries = devno<span class="number">-0x80</span>+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!be_quiet)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ok\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中0x80是第一个硬盘驱动器，EDD_MBR_SIG_MAX宏的值为16。它收集数据到<code>edd_info</code>结构数组中。</p>
<p><code>get_edd_info</code>通过调用0x13中断和<code>ah = 0x41</code>来检查EDD是否存在，如果EDD存在，get_edd_info再次调用0x13中断，但<code>ah=0x48</code>和<code>si</code>包含存储EDD信息的缓冲区地址。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/24/framewave-study/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/24/framewave-study/" class="post-title-link" itemprop="url">framewave_study</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-24 19:49:26" itemprop="dateCreated datePublished" datetime="2023-10-24T19:49:26+08:00">2023-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-25 19:00:37" itemprop="dateModified" datetime="2023-10-25T19:00:37+08:00">2023-10-25</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Framewave-tutorial"><a href="#Framewave-tutorial" class="headerlink" title="Framewave tutorial"></a>Framewave tutorial</h1><h2 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h2><p>​	去官网下载压缩包，解压后打开<code>readme</code>按照readme里面的步骤来就好了。</p>
<ul>
<li>提示：<code>readme</code>里面的<code>ExampleDir</code>直接换成绝对路径。</li>
<li>提示：后面那个<code>export</code>操作笔者没做出来，不过大概意思是把这个链接放到全局链接里去</li>
</ul>
<h2 id="Framewave-FW-是做什么的："><a href="#Framewave-FW-是做什么的：" class="headerlink" title="Framewave(FW)是做什么的："></a>Framewave(FW)是做什么的：</h2><p>​	Framewave (FW) is a collection of libraries that contain highly-optimized functions for use in a variety of programming domains. All implementations of the libraries provide C and C++ programmers ANSI C style interfaces.</p>
<p>​	Framewave consists of the following libraries:</p>
<ul>
<li>The <a target="_blank" rel="noopener" href="https://framewave.sourceforge.net/Manual/fw_section_010.html#fw_section_010">Base Library</a> functions are essential for primary tasks such as memory allocation and functions that manage the performance of other library functions.</li>
<li>The <a target="_blank" rel="noopener" href="https://framewave.sourceforge.net/Manual/fw_section_020.html#fw_section_020">Image Processing Library</a> functions perform a variety of tasks related to image processing.</li>
<li>The <a target="_blank" rel="noopener" href="https://framewave.sourceforge.net/Manual/fw_section_030.html#fw_section_030">JPEG Library</a> functions perform a variety of tasks related to Joint Photographic Experts Group image manipulation.</li>
<li>The <a target="_blank" rel="noopener" href="https://framewave.sourceforge.net/Manual/fw_section_040.html#fw_section_040">Signal Processing Library</a> functions perform a variety of tasks related to signal processing.</li>
<li>The <a target="_blank" rel="noopener" href="https://framewave.sourceforge.net/Manual/fw_section_050.html#fw_section_050">Video Library</a> functions perform video manipulation, encoding and decoding.</li>
</ul>
<h1 id="RTFM！！！！！"><a href="#RTFM！！！！！" class="headerlink" title="RTFM！！！！！"></a>RTFM！！！！！</h1><p>​	现在的任务就是读手册，手册里写的很清楚了！！！</p>
<p>​	</p>
<h2 id="Base-Library："><a href="#Base-Library：" class="headerlink" title="Base Library："></a>Base Library：</h2><p>​	This chapter provides an overview of the information contained in the functional descriptions. Base library functional descriptions include the following types of information.</p>
<h3 id="Data-Structures"><a href="#Data-Structures" class="headerlink" title="Data Structures"></a>Data Structures</h3><ul>
<li><strong>FwLibraryVersion</strong> Library version information.</li>
<li><strong>FwRoundMode</strong> Rounding mode used in data type conversion.</li>
<li><strong>FwWinType</strong> Type of window used to generate FIR filter coefficients.</li>
</ul>
<h3 id="Enumerator"><a href="#Enumerator" class="headerlink" title="Enumerator"></a>Enumerator</h3><ul>
<li><strong>FwBool</strong> Type of Boolean values.</li>
<li><strong>FwCmpOp</strong> Type of comparison operation.</li>
<li><strong>FwCpuType</strong> Type of CPU with presence of streaming SIMD extensions.</li>
<li><strong>FwHintAlgorithm</strong> Hint to favor speed or accuracy.</li>
</ul>
<h3 id="Parameter-Glossary"><a href="#Parameter-Glossary" class="headerlink" title="Parameter Glossary"></a>Parameter Glossary</h3><ul>
<li><em>StsCode</em> Specifies the status code used by the FwStatus function</li>
<li><em>alignBytes</em> Specifies the number of bytes for alignment, must be a power of 2. NULL is returned if the value is less than 2.</li>
<li><em>cpu</em> Specifies a CPU type.</li>
<li><em>length</em> Specifies a number of bytes to be allocated.</li>
<li><em>numThr</em>  Specifies the maximum number of threads that can be used by any Framewave function.</li>
<li><em>param</em> Specifies some parameter.</li>
<li><em>ptr</em>  Pointer to a memory buffer.</li>
<li><em>workFn</em> Specifies work function.</li>
</ul>
<h3 id="Core-Function"><a href="#Core-Function" class="headerlink" title="Core Function:"></a>Core Function:</h3><p>​	好像被标上<code>This function is reserved for FW internal use.</code>（此功能保留给FW内部使用）和程序员的关系不大。</p>
<ul>
<li><h4 id="GetStatusString"><a href="#GetStatusString" class="headerlink" title="GetStatusString"></a>GetStatusString</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> *	获取状态信息字符串</span><br><span class="line"> *  StsCode 指定FwStatus函数使用的状态代码。</span><br><span class="line"> *	返回一个字符串，该字符串描述了任何FwStatus枚举整数的含义。</span><br><span class="line"> */</span><br><span class="line">const char * fwGetStatusString ( FwStatus StsCode );</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="GetCpuType"><a href="#GetCpuType" class="headerlink" title="GetCpuType"></a>GetCpuType</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	获取 CPU 类型</span><br><span class="line"> *	返回存在的SSE支持级别。</span><br><span class="line"> *  它可用于识别CPU类型。</span><br><span class="line">*/</span><br><span class="line">FwCpuType fwGetCpuType();</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="GetCpuClocks"><a href="#GetCpuClocks" class="headerlink" title="GetCpuClocks"></a>GetCpuClocks</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 获取 CPU 时钟周期</span><br><span class="line"> * Fw64u 表示 64位 unsigned int 类型</span><br><span class="line"> * 此功能返回自CPU开机以来经过的CPU时钟周期数。</span><br><span class="line"> * 可以通过在两个不同点调用函数，然后从第二个返回值中减去第一个返回值来计时代码段。</span><br><span class="line">*/</span><br><span class="line">Fw64u fwGetCpuClocks();</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="StaticInit"><a href="#StaticInit" class="headerlink" title="StaticInit"></a>StaticInit</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 初始化为适当的CPU类型</span><br><span class="line"> * 此功能初始化FW内部调度器，</span><br><span class="line"> * 以使用最合适的CPU类型。</span><br><span class="line">*/</span><br><span class="line">FwStatus fwStaticInit();</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="StaticInitCpu"><a href="#StaticInitCpu" class="headerlink" title="StaticInitCpu"></a>StaticInitCpu</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	初始化为指定的CPU类型</span><br><span class="line"> *  参数cpu： 初始化为指定的CPU类型</span><br><span class="line"> *	此函数初始化FW内部调度器以使用指定的CPU类型。</span><br><span class="line">*/</span><br><span class="line">FwStatus	 	fwStaticInitCpu	(	FwCpuType cpu );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="SetNumThreads"><a href="#SetNumThreads" class="headerlink" title="SetNumThreads"></a>SetNumThreads</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *  设置线程数</span><br><span class="line"> *  参数numThr：指定任何Framewave函数可以使用的最大线程数。</span><br><span class="line"> *  此函数定义了任何FW函数可以使用的最大线程数。将numThr设置为1以关闭线程。</span><br><span class="line">*/</span><br><span class="line">FwStatus	 	fwSetNumThreads	(	unsigned int numThr );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="GetNumThreads"><a href="#GetNumThreads" class="headerlink" title="GetNumThreads"></a>GetNumThreads</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	获取线程数</span><br><span class="line"> *	此函数返回任何FW函数可以使用的最大线程数。</span><br><span class="line">*/</span><br><span class="line">Fw32u	 	fwGetNumThreads	(	  );</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="Allocate-memory"><a href="#Allocate-memory" class="headerlink" title="Allocate memory"></a>Allocate memory</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	分配空间</span><br><span class="line"> *	参数length:	指定分配的字节数量</span><br><span class="line"> *	此函数分配一个长度字节的内存缓冲区，并返回一个指针。</span><br><span class="line">*/</span><br><span class="line">void *	 	fwMalloc	(	int length );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="Free"><a href="#Free" class="headerlink" title="Free"></a>Free</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	释放空间</span><br><span class="line"> *	ptr	 	Pointer to a memory buffer.</span><br><span class="line"> *	此函数释放ptr指向的内存缓冲区。</span><br><span class="line">*/</span><br><span class="line">void	 	fwFree	(	void * ptr );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="AlignPtr"><a href="#AlignPtr" class="headerlink" title="AlignPtr"></a>AlignPtr</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	对齐缓冲区</span><br><span class="line"> *	alignBytes	指定对齐的字节数，必须是2的幂。如果值小于2，则返回NULL。 </span><br><span class="line"> *  ptr	指向内存缓冲区的指针。</span><br><span class="line"> *	此函数将ptr指向的缓冲区对齐到指定的对齐边界。</span><br><span class="line"> */</span><br><span class="line"> void *	 	fwAlignPtr	(	void * ptr, int alignBytes );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="SetNumThreads-local"><a href="#SetNumThreads-local" class="headerlink" title="SetNumThreads_local"></a>SetNumThreads_local</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	设置局部的线程数量</span><br><span class="line"> *	numThr	指定任何Framewave函数可以使用的最大线程数。</span><br><span class="line"> *	此功能保留给FW内部使用。</span><br><span class="line">*/</span><br><span class="line">FwStatus	 	fwSetNumThreads_local	(	unsigned int numThr );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	运行？</span><br><span class="line"> *	param	 	Specifies some parameter.</span><br><span class="line"> *	workFn	 	Specifies work function.</span><br><span class="line"> * 	此功能保留给FW内部使用。</span><br><span class="line">*/</span><br><span class="line">void	 	fwRun	(	WorkFn workFn, void* param );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	等待</span><br><span class="line"> *  此功能保留给FW内部使用。</span><br><span class="line">*/</span><br><span class="line">void	 	fwWait	(	  );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="GetInitType"><a href="#GetInitType" class="headerlink" title="GetInitType"></a>GetInitType</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	GetInitType</span><br><span class="line"> *	此功能保留给FW内部使用</span><br><span class="line">*/</span><br><span class="line">int	 	fwGetInitType	(	  );</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="BaseData"><a href="#BaseData" class="headerlink" title="BaseData"></a>BaseData</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	BaseData</span><br><span class="line"> *	This function is reserved for FW internal use.</span><br><span class="line">*/</span><br><span class="line">void *	 	fwBaseData	(	  );</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Signal-Processing-Library"><a href="#Signal-Processing-Library" class="headerlink" title="Signal Processing Library:"></a>Signal Processing Library:</h2><p>​	这个库里面的函数大概就是本次作业的重点了，大部分是关于向量加减乘除法的，现在我们看着lab1的代码，直接在手册中找到对应的代码进行替换就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fwsCosh_64f_A53					  MT</span><br><span class="line">fwsAddC_64f_I							MT</span><br><span class="line">fwsMalloc_64f					not	MT</span><br><span class="line">fwsAdd_64f								MT</span><br><span class="line">fwsMulC_64f_I							MT</span><br><span class="line">fwsSqrt_64f								MT</span><br><span class="line">fwsFree								not	MT</span><br><span class="line">fwsThreshold_LT_64f				MT</span><br><span class="line">fwSetNumThreads				not	MT</span><br><span class="line">fwsDivC_64f_I							MT</span><br><span class="line">fwsCopy_64fc							MT</span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/20/parallelComputingLab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/20/parallelComputingLab/" class="post-title-link" itemprop="url">parallelComputingLab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-20 15:35:46" itemprop="dateCreated datePublished" datetime="2023-10-20T15:35:46+08:00">2023-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-21 14:39:53" itemprop="dateModified" datetime="2023-11-21T14:39:53+08:00">2023-11-21</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>48</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Parallel-Computing-Lab-1"><a href="#Parallel-Computing-Lab-1" class="headerlink" title="Parallel Computing Lab_1"></a>Parallel Computing Lab_1</h2><iframe src="../../../../pdf_file/parallelComputingLab/Lab1_report.pdf" style="width:100%; height:800px;" frameborder="0"></iframe>

<h2 id="Parallel-Computing-Lab-2"><a href="#Parallel-Computing-Lab-2" class="headerlink" title="Parallel Computing Lab_2"></a>Parallel Computing Lab_2</h2><iframe src="../../../../pdf_file/parallelComputingLab/Lab2_report.pdf" style="width:100%; height:800px;" frameborder="0"></iframe>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/18/FEMU-STUDY/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/18/FEMU-STUDY/" class="post-title-link" itemprop="url">FEMU_STUDY</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-18 15:40:36" itemprop="dateCreated datePublished" datetime="2023-10-18T15:40:36+08:00">2023-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-21 14:37:39" itemprop="dateModified" datetime="2023-11-21T14:37:39+08:00">2023-11-21</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>31k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>28 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="The-CASE-of-FEMU-Cheap-Accurate-Scalable-and-Extensible-Flash-Emulator"><a href="#The-CASE-of-FEMU-Cheap-Accurate-Scalable-and-Extensible-Flash-Emulator" class="headerlink" title="The CASE of FEMU: Cheap, Accurate, Scalable and Extensible Flash Emulator"></a>The CASE of FEMU: Cheap, Accurate, Scalable and Extensible Flash Emulator</h1><h2 id="FEMU是什么："><a href="#FEMU是什么：" class="headerlink" title="FEMU是什么："></a><code>FEMU</code>是什么：</h2><p>​	<code>femu</code>是一个基于 <code>QEMU</code> 的闪存仿真器，旨在促进未来的全栈软件&#x2F;硬件SSD研究。</p>
<h3 id="问题1-硬件SSD和闪存有什么关系吗？为什么闪存模拟器可以促进全栈软件-x2F-硬件SSD研究？"><a href="#问题1-硬件SSD和闪存有什么关系吗？为什么闪存模拟器可以促进全栈软件-x2F-硬件SSD研究？" class="headerlink" title="问题1:硬件SSD和闪存有什么关系吗？为什么闪存模拟器可以促进全栈软件&#x2F;硬件SSD研究？"></a>问题1:硬件SSD和闪存有什么关系吗？为什么闪存模拟器可以促进全栈软件&#x2F;硬件SSD研究？</h3><blockquote>
<p>​		SSD(固态硬盘)是一种数据存储设备，它使用闪存作为其主要的存储介质</p>
</blockquote>
<h3 id="问题2-为什么要模拟闪存？"><a href="#问题2-为什么要模拟闪存？" class="headerlink" title="问题2:为什么要模拟闪存？"></a>问题2:为什么要模拟闪存？</h3><blockquote>
<p>​		模拟闪存为研究者、开发者和工程师提供了一个灵活、可控的环境，使他们能够在没有实际硬件的情况下进行研究、测试和开发。</p>
</blockquote>
<h3 id="问题3-现有哪些闪存-x2F-SSD仿真器-x2F-模拟器？"><a href="#问题3-现有哪些闪存-x2F-SSD仿真器-x2F-模拟器？" class="headerlink" title="问题3: 现有哪些闪存&#x2F;SSD仿真器&#x2F;模拟器？"></a>问题3: 现有哪些闪存&#x2F;SSD仿真器&#x2F;模拟器？</h3><blockquote>
<ol>
<li><p>DiskSim’s SSD：</p>
<ul>
<li>DiskSim是一个相当受欢迎的、由微软研究院开发的磁盘系统仿真器。</li>
<li>它最初是为磁盘驱动器设计的，但后来又增加了对固态硬盘(SSD)的仿真支持。</li>
<li>DiskSim可以仿真现实中的磁盘驱动器或SSD的性能，并帮助研究人员和工程师进行存储系统设计、优化和评估。</li>
</ul>
</li>
<li><p>FlashSim</p>
<ul>
<li>FlashSim是一个针对NAND闪存的仿真器。</li>
<li>它仿真闪存的基本操作，如读、写和擦除，以及其他与闪存有关的特性和行为。</li>
<li>FlashSim是为了研究和开发针对闪存的管理策略和算法（如垃圾收集和擦写均衡）而设计的。</li>
</ul>
</li>
<li><p>SSDSim</p>
<ul>
<li>SSDSim是一个专门为固态硬盘(SSD)设计的仿真器。</li>
<li>它考虑了SSD的各种组件和特性，如控制器、缓存和多通道&#x2F;多飞道操作。</li>
<li>与FlashSim不同，SSDSim更关注整个SSD设备的仿真，而不仅仅是闪存。</li>
</ul>
</li>
<li><p>FPGA boards</p>
<ul>
<li>PGA（Field-Programmable Gate Array）是一种可以由用户在购买后进行配置的集成电路。</li>
<li>FPGA板卡通常包含一个或多个FPGA芯片、电源、记忆体、I&#x2F;O接口以及其他必要的电子元件。</li>
<li>FPGA被广泛应用于原型设计、硬件加速、数字信号处理、嵌入式系统等领域，因为它们提供了一种在硬件级别自定义设计的能力。</li>
</ul>
</li>
<li><p>OpenSSD</p>
<ul>
<li>OpenSSD项目是一个开源项目，提供了关于固态硬盘(SSD)控制器的参考设计和源代码。</li>
<li>该项目旨在推动学术界和工业界对SSD技术的研究和创新。</li>
<li>OpenSSD为研究者提供了一个实验平台，使他们能够开发和测试新的算法、策略和技术，而无需从零开始构建SSD控制器。</li>
</ul>
</li>
<li><p>OpenChannel SSD</p>
</li>
</ol>
<ul>
<li>OpenChannel SSD是一种新的SSD架构，它允许主机操作系统直接管理SSD的物理块。</li>
<li>传统的SSD随机地在内部闪存块之间移动数据来实现擦除均衡和性能优化，这是通过一个称为Flash Translation Layer (FTL)的软件组件来实现的。OpenChannel SSD通过移除或简化FTL，允许更直接的控制，从而为应用提供更高的性能和更低的延迟。</li>
<li>OpenChannel SSD需要特殊的驱动和支持，如Linux内核中的LightNVM。</li>
</ul>
<ol start="7">
<li><p>基于QEMU的VSSIM</p>
<p>​	is a QEMU&#x2F;KVM-based platform that emulates NAND flash latencies on a RAM disk, and has been used in several papers. The major drawback of VSSIM is that it is built within QEMU’s IDE interface im- plementation, which is not scalable. The upper-left red line (IDE line) in Figure 2a shows the user-perceived IO read latency through VSSIM without any NAND-delay emulation added. More concurrent IO threads (x-axis) easily multiply the average IO latency (y-axis). For ex- ample from 1 to 4 IO threads, the average latency spikes up from 152 to 583μs. The root cause is that IDE is not supported with virtualization optimizations.</p>
</li>
<li><p>FlashEm</p>
<p>​	is an emulator built in the Linux block level layer, hence less portable; it is rigidly tied to its Linux version; to make changes, one must modify Linux kernel. FlashEm is not open-sourced and its development stopped two years ago (confirmed by the creators).</p>
</li>
<li><p>LightNVM的QEMU </p>
<p>​	is still in its early stage. Currently, it cannot emulate multiple channels (as in OpenChannel SSD) and is only used for basic testing of 1 target (1 chip behind 1 channel). Worse, LightNVM’s QEMU performance is not scalable to emulate NAND latencies as it depends on vanilla QEMU NVMe interface.</p>
</li>
</ol>
</blockquote>
<h3 id="问题4-既然已经有这些多仿真器了，那我们为什么要提出FEMU？"><a href="#问题4-既然已经有这些多仿真器了，那我们为什么要提出FEMU？" class="headerlink" title="问题4: 既然已经有这些多仿真器了，那我们为什么要提出FEMU？"></a>问题4: 既然已经有这些多仿真器了，那我们为什么要提出<code>FEMU</code>？</h3><blockquote>
<p>因为上述1-3的模拟器均<strong>only support internal-SSD research but not kernel-level extensions.</strong></p>
<p>这句话的原因是：</p>
<ul>
<li><p>这些仿真器重点关注的是如何在SSD内部处理请求、如何进行数据放置、垃圾收集、擦除均衡等。它们为研究者提供了一个详细、精确的工具，以研究和优化这些内部过程。</p>
</li>
<li><p>然而，SSD的性能和行为不仅仅是由其内部结构决定的。当一个应用或操作系统向SSD发出I&#x2F;O请求时，该请求首先会经过操作系统的I&#x2F;O堆栈，包括文件系统、块层、驱动等。操作系统中的这些组件也会影响I&#x2F;O的性能和行为。</p>
</li>
</ul>
<p> 所以对这句话更详细的解释应该是：</p>
<ul>
<li>当我们说这些仿真器”only support internal-SSD research but not kernel-level extensions”时，我们是指<strong>它们不模拟整个I&#x2F;O路径，特别是操作系统层面的部分。这意味着，如果你想研究如何修改文件系统或块层来优化SSD性能，这些仿真器可能不会为你提供足够的信息或支持。</strong></li>
</ul>
<p>而上述4-6的模拟器则<strong>support full-stack software&#x2F;hardware research but their high costs (thousands of dollars per de- vice) impair large-scale SSD research.</strong></p>
<p>最后提到的7-9硬件平台虽然更经济，但<strong>它们要么已经过时，要么不可扩展，要么并不是开源的</strong>。其中，对于可扩展的理解是，<code>VSSIM</code>只支持<code>IDE(Integrated Drive Electronics)</code>硬件接口技术，我们或许需要增加SATA、NVMe等接口。</p>
<p>所以我们要提出的<code>FEMU</code>，有下述优点:</p>
<ol>
<li><p><strong>Cheap:</strong> open-sourced software</p>
</li>
<li><p>**(relatively) Accurate: ** 0.5-38% variance in our tests</p>
</li>
<li><p><strong>Scalable:</strong> 由于我们使用了各种技术来优化QEMU栈，例如无退出中断和跳过QEMU AIO组件，FEMU可以扩展到32个IO线程，同时仍然实现低延迟（在2.3GHz的CPU下延迟低至52微秒）。因此，FEMU可以准确地模拟32个并行通道&#x2F;芯片，而不会产生不希望的排队延迟。</p>
</li>
<li><p><strong>Extensible:</strong> 对于可扩展性，我的理解是，在使用<code>FEMU</code>模拟器时会有一个<code>guest os</code>(即运行在虚拟机中的操作系统)和一个<code>host os</code>(即宿主操作系统)。如下图所示，<code>FEMU</code>基于<code>QEMU</code>运行在<code>host os</code>，我们要模拟的<code>guest os</code>运行在虚拟机(VM)上，通过’NVMe(Non-Volatile Memory express)’接口访问<code>FEMU</code>（因为<code>FEMU</code>是一个<code>NVMe SSD</code>的模拟器）。因此 <code>FEMU</code>运行研究人员在<code>guest os</code>上进行内核级的改变，借口级的改变，和<code>FTL（Flash Translation Layer</code>）级的改变。</p>
<p><img src="/../images/FEMU-STUDY/%E6%88%AA%E5%B1%8F2023-10-21%2010.12.04.png" alt="截屏2023-10-21 10.12.04"></p>
<p>同时，<strong>FEMU also provides many new features not existent in other emulators, such as OpenChannel and multi-device&#x2F;RAID support, extensible interfaces via NVMe commands, and page-level latency variability.</strong></p>
</li>
</ol>
</blockquote>
<p>​	</p>
<h2 id="设计FEMU的主要挑战和解决办法："><a href="#设计FEMU的主要挑战和解决办法：" class="headerlink" title="设计FEMU的主要挑战和解决办法："></a>设计<code>FEMU</code>的主要挑战和解决办法：</h2><ol>
<li><h3 id="scalability："><a href="#scalability：" class="headerlink" title="scalability："></a>scalability：</h3><ul>
<li><strong>问题1：</strong><code>QEMU</code> 通过传统的 <code>trap-and-emulate</code>方式仿真IO<code>。当客户机的</code>NVMe<code>驱动向设备</code>(QEMU)这里的情况是因为客户机(guest os)是运行在QEMU仿真的环境上<code>发出</code>ring the doorbell<code>的信号，用于表示设备队列中有一些IO请求。由于该</code>doorbell<code>表示一个</code>memory mapped input output<code>操作，这将会导致 </code>VM-exit(word switch)<code> 即从客户机到</code>QEMU<code>的转换。同样，当</code>IO&#96;请求完成时，也会存在一样的切换。</li>
<li><strong>问题2：</strong><code>QEMU</code>使用<code>异步IO（AIO）</code>执行实际读&#x2F;写（字节传输）到备份图像文件。此AIO组件用来避免QEMU被缓慢的IO（例如，在磁盘映像上）阻止。然而，当存储后端是RAM支持的映像时，AIO开销变得很重要。</li>
<li><strong>解决办法</strong>：<ol>
<li>首先将<code>QEMU</code>的中断转换为基于轮询的设计，并在<code>guest os</code>中禁止通过<code>doorbell write</code>的操作。并在<code>QEMU</code>中创建一个专门的线程，用来持续轮询设备队列的状态。以这种方式，<code>guest os</code> 仍将控制权交给<code>QEMU</code>并且不会有昂贵的<code>word switch</code>。</li>
<li>同样，我们将不使用<code>virual image file</code>（这一思想是为了避免进入<code>AIO</code>模块），我们通过在<code>QEMU&#39;s heap space</code>创建一个 <code>RAM-backed storage</code> (笔者认为这个操作类似于在安装操作系统时为操作系统划分物理空间)。然后修改<code>QEMU</code>中的<code>DMA emulator logic</code>，将数据读取或者写入到上面模拟的<code>RAM-backed storage</code>，在整个过程中，<code>guest os</code>并不会意识到它已经将数据写到了我们规定的<code>RAM-backed storage</code>中。</li>
</ol>
</li>
<li><strong>实验结果：</strong>在1-32个IO线程之间，<code>FEMU</code>可以在低于52μs的时间内保持IO延迟的稳定，甚至在64个IO线程下保持在90μs以下。 </li>
<li><strong>遗留问题：</strong>剩余的可扩展性瓶颈现在只来自QEMU的单线程“事件循环”，它执行主要的IO例程，如取消设备队列，触发DMA仿真，并将终端IO完成发送到<code>guest os</code>。最近的作品解决了这些限制（有重大变化），但尚未简化为QEMU的主要属性。我们将探索在未来FEMU开发中整合其他解决方案的可能性。</li>
</ul>
</li>
<li><h3 id="accuracy"><a href="#accuracy" class="headerlink" title="accuracy"></a>accuracy</h3><ol>
<li><p><strong>Delay Emulation:</strong></p>
<p>​	<code>FEMU</code>中对<code>IO</code>的延迟模拟采用了一种专用的<code>end-io queue</code>，该队列基于IO完成时间进行排序。当队列中<code>IO</code>的模拟完成时间超过当前时间，将该<code>IO</code>从队列中取出。例如，模拟的<code>IO</code>完成时间是在<code>IO</code>进入时间的基础上加<code>50us</code>。</p>
</li>
<li><p><strong>Basic Delay Model:</strong></p>
<ul>
<li><p>那该如何给出一个准确的<code>IO</code>模拟完成时间呢?</p>
</li>
<li><p><code>channel1</code>的下一次空闲时间，其中 <code>Ttransfer</code>表示给定的页在通道上的传输时间。<br>$$<br>T_{freeOfChannel1}&#x3D;T_{now}+T_{transfer}<br>$$<br>而plane2的下一次空闲时间如下，其中<code>Twrite</code>是给定的一个NAND页面的写&#x2F;program时间<br>$$<br>T_{freeOfPlane2}&#x3D;T_{now}+T_{transfer}+T_{write}<br>$$<br>于是该写操作的<code>end-io time</code>等于 <code>TfreeOfPlane2</code></p>
</li>
<li><p>假设当写操作正在进行时，到同一平面的页面读取到达。在这里，我们会将TfreeOfPlane2增加Tread的值，其中Tread是一个可配置的NAND页面的读取时间，并将TfreeOfChannel1增加Ttransfer的值。这次读取的结束时间将是Tendio&#x3D;TfreeOfChannel1（因为这是一个读取操作，而不是写操作）。</p>
</li>
<li><p>这只是一个简单的延迟模型，模拟了一个单寄存器，统一页面延迟的模型。即每一个plane只有一个页寄存器，因此不支持多IO的并行操作。同时，传输时间，读写时间也被设置为固定的值。</p>
</li>
</ul>
</li>
<li><p><strong>Advanced “OC” Delay Model:</strong></p>
<p>展示了如何扩展我们的模型，并实现对OpenChannel SSD更准确的延迟模拟。</p>
<ul>
<li><p>openChannel的每一个<code>plane</code>使用了两个寄存器<code>(data + cache registers)</code>。<code>data register</code>用于读写、擦除数据。<code>cache register</code>用于传输数据。例如，当数据从NAND页面读取到数据寄存器时，另一组数据可以从缓存寄存器传输到通道，或者相反。这种设计增加了并行性，因为两个操作可以在同一个时间段内同时进行，而不是顺序进行。</p>
</li>
<li><p>第二，OpenChannel (OC) 使用一个非均匀页面延迟模型。具体来说，映射到MLC单元的上位位（“上层”页面）的页面比映射到下位位（“下层”页面）的页面具有更高的延迟。例如，下层&#x2F;上层页面的读取时间分别为48&#x2F;64微秒，而写入时间则为900&#x2F;2400微秒。更为复杂的是，每个NAND块中的512个页面并不是以“LuLuLuLu…”的方式均匀交错映射的，而是以特定的方式映射，即“LLLLLLuLLuLLuu…”。其中，页面#0-6是映射到下层页面，页面#7和#10到#8-9是映射到上层页面，其余的页面有“LLuu”的重复模式。</p>
</li>
<li><p>“lower bits” 和 “lower” pages 指的是MLC（Multi-Level Cell）NAND闪存中的较低电压状态或较低的存储位。MLC闪存可以在每个单元中存储多个比特，通常是2比特。这些比特可以表示四种不同的电压状态，从而允许存储4个不同的值。</p>
<p>在MLC中，每个单元有两个比特：一个是“upper bit”（上位比特），另一个是“lower bit”（下位比特）。由于读取和编程的方式，这两个比特可能具有不同的延迟特性。</p>
<ul>
<li>“lower pages”：与MLC单元的“lower bits”相关联的页面。</li>
<li>“upper pages”：与MLC单元的“upper bits”相关联的页面。</li>
</ul>
<p>由于MLC的物理和电气特性，通常“upper”页面的读取和写入延迟要比“lower”页面的延迟更高。这是由于MLC的工作机制，特别是在编程和读取多个电压状态时的复杂性。这种差异经常需要在闪存管理和调度策略中进行特别处理，以最大化性能并平衡耐用性。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="increasing-usability-and-extensibility"><a href="#increasing-usability-and-extensibility" class="headerlink" title="increasing usability and extensibility"></a>increasing usability and extensibility</h3><h3 id="FEMU是可以被扩展的："><a href="#FEMU是可以被扩展的：" class="headerlink" title="FEMU是可以被扩展的："></a><code>FEMU</code>是可以被扩展的：</h3><ul>
<li><p>FTL and GC schemes：<code>FTL</code>使用<code>dynamic mapping</code>。可以用 <code>FEMU</code>对比不同的 <code>garbage collection</code>策略，如 <code>controller-blocking</code>，<code>channel-blocking</code>，<code>plane-blocking</code>。</p>
</li>
<li><p>White-box vs. Black-box：FEMU 可以被用来模拟白盒设备，例如<code>OpenChannel SSD</code>，即设备将物理页面地址直接暴露给操作系统，且<code>FTL</code>层被操作系统管理，例如Linux LightNVM。而黑盒设备，如商用SSDs，FTL层驻留在FEMU中，只有逻辑地址被暴露给操作系统。</p>
</li>
<li><p>Multi-device support for flash-array research: FEMU可配置为在<code>guest os</code>中显示为多个设备。例如，如果FEMU暴露了4个SSD，在FEMU内部，单个QEMU实例中将有4个单独的NVMe实例和FTL结构（没有重叠通道）。以前的模拟器（VSSIM和LightNVM的QEMU）不支持这一点。</p>
</li>
<li><p>Extensible OS-SSD NVMe commands:</p>
<p>可以为NVMe添加更多的OS-to-SSD 命令。</p>
</li>
<li><p>Page-level latency variability:</p>
</li>
</ul>
<p>  FEMU支持页面级别的延迟可变性。</p>
<ul>
<li><p>Distributed SSDs: FEMU的多个实例可以很容易地部署在多台机器上（就像运行Linux虚拟机管理程序KVM一样简单），这促进了更大规模的SSD研究。</p>
</li>
<li><p>Page-level fault injection: FEMU除了支持性能相关的研究，也支持闪存可靠性的研究。（例如，通过注入页面级损坏和故障，并观察高级软件堆栈的反应）。</p>
</li>
<li><p>Limitations: FEMU是DRAM支持的，因此无法模拟大容量SSD。此外，对于崩溃一致性研究，FEMU用户必须手动emu-后期“软”崩溃，因为硬重启将擦除DRAM中的数据。此外，如前所述（§3.2），还有提高准确性的空间。</p>
</li>
</ul>
</li>
</ol>
<h2 id="Research-Papers-using-FEMU"><a href="#Research-Papers-using-FEMU" class="headerlink" title="Research Papers using FEMU"></a>Research Papers using FEMU</h2><ol>
<li><p><strong>Holistic and Opportunistic Scheduling of Background I&#x2F;Os in Flash-based SSDs</strong>. <strong>(TC’23)</strong>. Yu Wang, You Zhou, Fei Wu, Yu Zhong, Jian Zhou, Zhonghai Lu, Shu Li, Zhenghong Wang, Changsheng Xie</p>
<blockquote>
<p>​	在从应用程序到基于闪存的SSD的多个存储系统层中，背景 (BG) 任务是不可或缺的。它们发起大量的I&#x2F;O操作，与前台（FG）I&#x2F;O性能产生显著的干扰。我们的关键洞察是，为了减轻这种干扰，需要在整个系统范围内对多源背景I&#x2F;O进行全面调度，而这只能在底层的SSD层实现。只有SSD对所有的FG和BG I&#x2F;O以及关于闪存存储资源的直接信息和控制都有一个全局的视图。因此，我们受到启发，提出了一个新颖的I&#x2F;O调度架构，称为HuFu。它为主机软件提供了一个框架，用于注册BG任务并将其I&#x2F;O调度卸载到SSD。然后，SSD内部的I&#x2F;O调度器优先处理FG I&#x2F;O，而BG I&#x2F;O则通过利用闪存并行性和闲置来有机会地进行调度。为了验证HuFu，我们对RocksDB进行了案例研究，并将其与几种最先进的主机端I&#x2F;O调度方案进行了比较。实验结果显示，HuFu可以显著减轻由BG I&#x2F;O引起的性能干扰并提高SSD带宽利用率，从而提高FG吞吐量、平均和尾部延迟（例如，在写入密集型工作负载中约提高18%）。</p>
</blockquote>
</li>
<li><p><strong>NVMeVirt: A Versatile Software-defined Virtual NVMe Device</strong>. <strong>(FAST’23)</strong>. Sang-Hoon Kim, Jaehoon Shim, Seongyeop Jeong, Jin-Soo Kim</p>
<blockquote>
<p>​	 近期，存储设备领域发生了剧烈的变化。在多种存储景观的中心是NVMe接口，它允许这些新一代设备类型所需的高性能和灵活的通信模型。然而，其以硬件为中心的定义和规范正成为新的革命性存储设备的开发和评估周期的瓶颈。在本文中，我们提出了NVMeVirt，一种促进软件定义NVMe设备的新方法。用户可以定义带有自定义功能的任何NVMe设备类型，而NVMeVirt则允许在软件中将主机I&#x2F;O堆栈和虚拟NVMe设备之间的差距进行桥接。我们通过实现各种存储类型和配置来展示NVMeVirt的优点和功能，例如传统SSD、低延迟高带宽NVM SSD、分区命名空间SSD以及支持PCI对等DMA和NVMe-oF目标卸载的键值SSD。我们还利用NVMeVirt进行存储研究，如研究数据库引擎的性能特征和扩展NVMe规范以提高键值SSD性能。</p>
</blockquote>
</li>
<li><p><strong>DECC: Differential ECC for Read Performance Optimization on High-Density NAND Flash Memory</strong>. <strong>(ASPDAC ‘23)</strong>. Yunpeng Song, Yina Lv, Liang Shi</p>
<blockquote>
<p>​	由于其高密度，采用 先进的多电平单元技术的3D NAND闪存已被广泛采用，但其可靠性明显降低。为了解决这一可靠性问题，闪存通常采用低密度奇偶校验码（LDPC）作为纠错码（ECC）来编码数据并提供容错能力。对于低码率的LDPC，它可以提供强大的纠错能力，但能耗较高。为避免这一成本，通常采用较高码率的LDPC。当访问的数据未成功解码时，LDPC将依赖读重试操作来提高纠错能力。但是，读重试操作会导致读取性能下降。在这项工作中，我们提出了一种差分ECC（DECC）方法来提高读取性能。DECC的基本思想是为具有不同访问特性的数据采用不同码率的LDPC。具体来说，当数据因可靠性而被热读和重试时，将采用低码率的LDPC来优化性能。通过这种方法，最大程度地减少了低码率LDPC的成本并优化了性能。通过在3D三电平单元（TLC）NAND闪存上对真实工作负载的仔细设计和评估，DECC实现了鼓舞人心的读取性能优化。</p>
</blockquote>
</li>
<li><p><strong>ConfZNS : A Novel Emulator for Exploring Design Space of ZNS</strong>. <strong>(SYSTOR’23)</strong>. Inho Song, Myounghoon Oh, Bryan S. Kim, Seehwan Yoo, Jaedong Lee, Jongmoo Choi</p>
<blockquote>
<p>​	ZNS（分区命名空间）接口将大部分存储维护责任从底层的SSD（固态驱动器）转移到了主机。此外，它为在硬件和软件级别利用SSD的内部并行性提供了新的机会。通过调整区域与SSD内部资源之间的映射并控制线程之间的区域分配，ZNS SSD在并行性和隔离性之间提供了明显的性能权衡。为了理解和探索ZNS SSD的设计空间，我们提出了基于QEMU的易于配置和时序精确的模拟器ConfZNS（可配置的ZNS）。ConfZNS允许用户研究各种ZNS SSD的内部架构以及它如何与现有的主机软件配合工作。我们使用真实的ZNS SSD验证了ConfZNS的准确性，并探索了使用诸如RocksDB、F2FS和Docker环境等真实应用程序的不同ZNS SSD设计的性能特性。</p>
</blockquote>
</li>
<li><p><strong>Optimizing Data Migration for Garbage Collection in ZNS SSDs</strong>. <strong>(DATE’23)</strong>. Zhenhua Tan, Linbo Long, Renping Liu, Congming Gao, Yi Jiang, Yan Liu</p>
<blockquote>
<p>ZNS SSD将垃圾回收（GC）的责任转移到了主机。然而，在GC中的数据迁移需要先将数据移至主机的缓冲区，然后再写回到新的位置，导致了不必要的端到端传输开销。此外，由于区域和块之间的预配置映射，GC需要在区域之间执行大量不必要的块到块的数据迁移。为了解决这些问题，本文提出了一种简单且高效的数据迁移方法，名为IS-AR，具有存储内数据迁移和地址重映射功能。基于全栈SSD模拟器，我们的评估显示IS-AR平均降低了6.78倍的GC延迟，并提高了1.17倍的SSD寿命。</p>
</blockquote>
</li>
<li><p><strong>zCeph: Achieving High Performance On Storage System Using Small Zoned ZNS SSD</strong>. <strong>(SAC’23)</strong>. Jin Yong Ha, Heon Young Yeom</p>
<blockquote>
<p>​	ZNS SSD（分区命名空间SSD）是块设备，通过强制顺序写入提供稳定的性能和低价格，但用户必须付出代价来保证强烈的写入顺序。此外，为了从给予用户对设备内部并行元素的控制的小分区ZNS SSD中获得最佳性能，用户需要详细地使用SSD。由于这些开销，与使用传统SSD相比，使用ZNS SSD的分布式存储系统之一Ceph的性能降低了高达69%。在本文中，我们提出了zCeph，它解决了在存储系统中使用小分区ZNS SSD时出现的问题。我们基于传统的Ceph实现了zCeph，并使用合成和真实工作负载对其进行了评估，结果显示，与使用ZNS SSD的传统Ceph相比，性能分别提高了最多4.1倍和7倍。</p>
</blockquote>
</li>
<li><p><strong>Design of a High-Performance, High-Endurance Key-Value SSD for Large-Key Workloads</strong>. <strong>(IEEE CAL’23)</strong>. Chanyoung Park, Chun-Yi Liu, Kyungtae Kang, Mahmut Kandemir, Wonil Choi</p>
<blockquote>
<p>​	当前的KV-SSD设计假设了一定范围的典型工作负载，其中值的大小相对较大，而键的大小相对较小。然而，我们发现：(i) 存在另一种工作负载，其键的大小相对于其值的大小较大；(ii) 在这种大键工作负载下，当前的KV-SSD设计遭受长尾延迟和低存储利用率的问题。为此，我们提出了一种新颖的KV-SSD设计（称为LK-SSD），它可以在大键工作负载下减少尾部延迟并提高存储利用率，并为其增加了增强功能以延长设备寿命。通过广泛的实验，我们展示了LK-SSD更适合大键工作负载，同时也适用于典型工作负载。</p>
</blockquote>
</li>
<li><p><strong>CFIO: A conflict-free I&#x2F;O mechanism to fully exploit internal parallelism for Open-Channel SSDs</strong>. <strong>(JSA’23)</strong>. Jinbin Zhu, Liang Wang, Limin Xiao, Lei Liu, Guangjun Qi</p>
<blockquote>
<p>​	I&#x2F;O访问冲突严重降低了NVMe SSDs的利用率，导致其性能损失不可预测。尽管现有的研究采用I&#x2F;O隔离或冲突感知的I&#x2F;O调度来避免访问冲突，但它们可能导致利用率不平衡并减少NVMe SSDs的寿命。在本文中，我们设计并实现了CFIO，一个低开销的冲突感知I&#x2F;O机制，实现了无冲突的I&#x2F;O，以利用NVMe SSDs中的内部并行性。CFIO通过两种新颖的机制提高了PU利用率并减少了I&#x2F;O延迟。首先，提出了一个无冲突（CF）通道，通过根据物理地址将I&#x2F;O请求划分到无冲突的PU队列中，以消除冲突。这些PU队列对应于NVMe SSDs内的PU资源。其次，设计了一个k-RR调度器，批量地并分别将读写请求分派到NVMe SSDs。K-RR调度器可以充分利用NVMe SSDs的内部并行性，并基于PU的双寄存器形成一个I&#x2F;O流水线。最后，我们将CFIO集成到带有Open-Channel NVMe SSD (OCSSD) 的LightNVM中，并与几种现有的解决方案进行比较。我们的评估显示，与最先进的方法相比，CFIO提高了OCSSD的吞吐量19.32%，并将其尾部延迟降低了23.71%。</p>
</blockquote>
</li>
<li><p><strong>An Efficient F2FS GC Scheme for Improving I&#x2F;O Latency of Foreground Application</strong>. <strong>(ICCE’23)</strong>. Manjong Lee, Jonggyu Pa, Young Ik Eom</p>
<blockquote>
<p>​	近年来，由于其迷人的功能，ZNS吸引了移动设备制造商，并预计将合并到移动I&#x2F;O子系统中。与此同时，由于F2FS采用了只追加写入策略，因此它是支持移动设备中ZNS的可行选项之一。然而，F2FS在文件系统级的垃圾收集（GC）上表现不佳，这增加了前台应用的尾部延迟。为了克服这个问题，我们提出了一种新的F2FS GC方案，当这样做有利时，该方案会抢占正在进行的GC，以防止前台应用等待过长时间。我们的评估表明，与传统的F2FS GC方案相比，我们的方案将前台应用的尾部延迟减少了高达87%。</p>
</blockquote>
</li>
<li><p><strong>SimBricks: End-to-End Network System Evaluation with Modular Simulation</strong>. <strong>(SIGCOMM’22)</strong>. Hejing Li, Jialin Li, Antoine Kaufmann</p>
<blockquote>
<p>​	在物理测试环境中进行的全系统“端到端”测量是网络系统评估的金标准，但往往不可行。当没有物理测试环境时，我们经常转向仿真进行评估。遗憾的是，现有的模拟器对于端到端评估来说是不足够的，因为它们要么不能模拟所有组件，要么模拟它们的细节不足。我们通过模块化仿真来解决这个问题，灵活地组合和连接多个现有的模拟器，用于不同的组件，包括处理器和内存、设备和网络，形成针对每个用例调优的虚拟端到端测试环境。我们的架构，SimBricks，结合了明确定义的组件接口，用于扩展性和模块化，高效的通信通道，用于本地和分布式仿真，以及一个共同设计的高效同步机制，用于跨模拟器的精确时序。我们展示SimBricks可以扩展到1000个模拟主机，每个都运行着完整的软件堆栈，包括Linux，而且它可以模拟具有现有NIC和交换机RTL实现的测试环境。我们还在SimBricks中再现了先前关于拥塞控制、NIC架构和网络内计算的关键发现。</p>
</blockquote>
</li>
<li><p><strong>Meta-Block: Exploiting Cross-Layer and Direct Storage Access for Decentralized Blockchain Storage Systems</strong>. <strong>(TC’22)</strong>. Yi Wang, Jing Liao, Jing Yang, Zhengda Li, Chenlin Ma, Rui Mao</p>
<blockquote>
<p>​	去中心化存储系统，如基于区块链的存储应用，采用分布式存储技术，并使用分布式存储节点存储持久数据。对于每个链下存储节点，通常使用键值（KV）存储来管理数据。作为KV存储的最常见数据结构，日志结构化合并树（LSM-Tree）消除了随机写操作，同时保持了可接受的读性能。尽管基于LSM-Tree的去中心化存储系统可以提供安全可靠的存储平台，但区块链应用的独特特性并没有得到充分利用。在区块链存储应用中，KV存储的键的生成是基于加密数据的。一个固态硬盘（SSD）中的物理块可能会被不同系统用户的数据填充，这种混合工作负载会导致SSD物理空间的低效使用，并为LSM-Tree引起额外的压缩操作。本文提出了Meta-Block，一种针对去中心化区块链存储应用的跨层和高效的存储管理策略。目标是捕获区块链存储应用的特点，并减少不同存储层之间不必要的读写操作。作为一个跨层设计，Meta-Block重新设计了LSM-Tree的组织，可以有效地减少写放大。我们还设计了一个数据预取策略，以加速索引并启用直接存储访问。通过一系列广泛的实验，我们展示了所提技术的可行性。实验结果表明，与代表性方案相比，Meta-Block可以有效地减少写放大并延长SSD的寿命。</p>
</blockquote>
</li>
<li><p><strong>Improving the Reliability of Next Generation SSDs using WOM-v Codes</strong>. <strong>(FAST’22)</strong>. Shehbaz Jaffer, Kaveh Mahdaviani, Bianca Schroeder. <strong>(Best Paper Award)</strong></p>
<blockquote>
<p>​	高密度固态硬盘，如QLC驱动器，提供了增加的存储容量，但其编程和擦除（P&#x2F;E）周期减少了一个数量级，限制了它们的耐用性和可用性。我们介绍了非二进制的基于电压的一次性存储（WOM-v）代码的设计和实现，以提高QLC驱动器的使用寿命。首先，我们开发了一个基于FEMU的模拟器测试平台，以评估WOM-v代码在实际工作负载上的收益。其次，我们提出并实施了两种优化，一个高效的垃圾收集机制和一个编码优化，以极大地提高WOM-v代码的耐用性，同时不影响性能。通过仔细评估，包括微基准测试和基于迹线的评估，结果表明WOM-v代码可以为实际工作负载减少QLC驱动器的擦除周期4.4 x-11.1 x，带有最小的性能开销，从而提高QLC SSD的使用寿命。</p>
</blockquote>
</li>
<li><p><strong>Generating Realistic Wear Distributions for SSDs</strong>. <strong>(HotStorage’22)</strong>. Ziyang Jiao, Bryan S. Kim</p>
<blockquote>
<p>​	我们介绍了FF-SSD，一个基于机器学习的SSD老化框架，可以生成代表性的未来磨损状态。FF-SSD准确性高（相似度高达99%）、效率高（加速模拟时间2倍）、并且模块化（可以与现有的模拟器和仿真器集成）。</p>
</blockquote>
</li>
<li><p><strong>When F2FS Meets Address Remapping</strong>. <strong>(HotStorage’22)</strong>. Yongmyung Lee, Jong-Hyeok Park, Jonggyu Park, Hyunho Gwak, Dongkun Shin, Young Ik Eom, Sang-Won Lee</p>
<blockquote>
<p>​	虽然在移动设备中越来越受欢迎，但F2FS（一个针对闪存友好的日志结构文件系统变种）揭示了三个缺点：段清理开销、元数据更新开销和文件碎片化，这在随机更新工作负载下变得尤为明显。本文首次建议在闪存中利用地址重映技术来弥补F2FS中的这些缺陷。我们的方法在保留日志结构写入的好处的同时，可以实现就地更新的最终效果，完全防止F2FS的三个缺陷。因此，它在随机更新工作负载下可以显著优于ext4和原始F2FS。配备了另一种写入模式，F2FS将在更广泛的应用范围内变得有竞争力。</p>
</blockquote>
</li>
<li><p><strong>TailCut: Improving Performance and Lifetime of SSDs Using Pattern-Aware State Encoding</strong>. <strong>(DAC’22)</strong>. Jaeyong Lee, Myungsunk Kim, Wonil Choi, Sanggu Lee, Jihong Kim</p>
<blockquote>
<p>​	尽管在3D NAND闪存中，横向电荷扩散被视为主要的误差来源，但我们对其在存储系统级别的详细特性知之甚少。从设备特性研究中，我们观察到横向电荷扩散强烈依赖垂直相邻的状态模式，并且少数特定模式对于横向电荷扩散的位错误负有很大的责任。我们提出了一种新的状态编码方案，称为TailCut，它通过修改编码状态来删除容易受到影响的状态模式。通过删除容易受到影响的模式，TailCut可以分别提高SSD的使用寿命和读取延迟，增长率达到80%和25%。</p>
</blockquote>
</li>
<li><p><strong>Selective Power-Loss-Protection Method for Write Buffer in ZNS SSDs</strong>. <strong>(Electronics’22)</strong>. Junseok Yang, Seokjun Lee, Sungyong Ahn</p>
<blockquote>
<p>​	大多数SSD（固态硬盘）使用内部DRAM（动态随机存取内存）来提高I&#x2F;O性能，并通过吸收写请求来延长SSD的寿命。然而，在突然断电的情况下，这种易失性存储器不能保证缓冲数据的持久性。因此，高可靠性的企业级SSD采用断电保护（PLP）逻辑，利用电容的备用电源来确保缓冲数据的耐久性。SSD必须根据易失性缓冲区的大小为PLP提供足够的电容。与此同时，新兴的ZNS（分区命名空间）SSD正受到关注，因为它们可以支持多租户系统中有用的多个I&#x2F;O流。虽然ZNS SSD不使用内部映射表，与传统的块接口SSD不同，但需要一个大的写缓冲区来提供多个I&#x2F;O流。原因是每个I&#x2F;O流都需要自己的写缓冲区来进行写缓冲，其中主机可以为不同的I&#x2F;O流分配不同的区域。此外，ZNS SSD支持的容量越大，I&#x2F;O流越多，所需的写缓冲区就越大。然而，写缓冲区的大小取决于电容量，这不仅受到SSD内部空间的限制，而且受到成本的限制。因此，在本文中，我们提出了一套技术，它可以在确保在突然断电时缓冲数据的耐久性的同时，显著减少ZNS SSD所需的电容量。首先，我们注意到现代文件系统或数据库都有自己的数据恢复解决方案，如WAL（预写式日志）和日志。因此，我们提出了一种选择性断电保护方法，只确保数据恢复所需的WAL或日志的耐久性，而不是整个缓冲数据。其次，为了最小化PLP所需的时间，我们提出了一种平衡刷新方法，该方法将缓冲数据暂时写入多个区域以最大化并行性，并在恢复电源时保留数据在其原始位置。所提出的方法通过修改FEMU（基于QEMU的Flash仿真器）和RocksDB来实现和评估。根据实验结果，所提出的选择性PLP在保持ZNS SSD的可靠性的同时，将电容量减少了50%到90%。此外，平衡刷新方法将PLP延迟减少了高达96%。</p>
</blockquote>
</li>
<li><p><strong>CoDiscard: A Revenue Model based Cross-layer Cooperative Discarding Mechanism for Flash Memory Devices</strong>. <strong>(JSA’22)</strong>. Xiaoliu Feng, Xianzhang Chen, Ruolan Li, Jiali Li, Chunlin Song, Duo Liu, Yujuan Tan, Lei Qiao</p>
<blockquote>
<p>​	在闪存中的写放大是一个严重的问题，它缩短了闪存的寿命并降低了其性能。TRIM命令被提出来通过避免在闪存设备中进行不必要的重定位来减少写放大。然而，巨大的开销导致当I&#x2F;O忙时，常见的文件系统完全禁止使用TRIM命令。这种完全禁止的TRIM策略不仅影响了闪存设备的寿命，而且由于巨大的写放大，降低了性能。在本文中，我们提出了CoDiscard，一个基于收益模型的跨层协作丢弃机制，用于优化I&#x2F;O性能并在密集工作负载下减少写放大。CoDiscard的核心思想是将高性价比的TRIM命令筛选到闪存设备，因为它们可以显著减少写放大，从而提高性能。为了识别这样的TRIM命令，我们提出了一个收益模型来预测写放大减少和相应的开销。基于收益模型，CoDiscard采用了一个跨层协作方案来调度TRIM命令。文件系统中的CoDiscard调度器负责做出决策。闪存设备中的CoDiscard监视器用于监控与收益模型相关的信息变化。我们在真实工作负载下进行了实验。结果显示，性能提高了113%和118.4%，写放大减少了最多12.12和8.18。</p>
</blockquote>
</li>
<li><p><strong>NASA: NVM-Assisted Secure Deletion for Flash Memory</strong>. <strong>(TCAD’22)</strong>. Weidong Zhu, Kevin R. B. Butler</p>
<blockquote>
<p>​	在基于闪存的存储中，安全删除对于数据安全至关重要。然而，现有的针对闪存的安全删除方案存在性能下降和可靠性问题，无法提供安全删除保证。尽管新兴的非易失性内存（NVM）允许就地更新并提供高性能，但它无法完全替代闪存，因此无法解决安全删除问题。在本文中，我们提出了一个针对闪存的NVM辅助安全删除方案（NASA），这是一个没有陈旧数据的存储系统，它结合了NVM和闪存，旨在为SSDs提供即时的安全删除，而不会导致显著的性能下降。NASA使用块擦除为闪存提供安全删除保证，并利用NVM来隐藏耗时的擦除操作。我们证明，除非考虑到NVM的独特特性，否则仅实现现有的安全删除方法的方案最终将在其存储介质中留下陈旧的数据副本。此外，我们使用不同的真实工作负载评估NASA，并证明与LRU相比，NASA增加了0.01%的平均延迟，并比FIFO缓存策略减少了2.1%的平均延迟。NASA是一个提供强大的安全删除保证和高性能的新型存储系统。</p>
</blockquote>
</li>
<li><p><strong>Understanding and Exploiting the Full Potential of SSD Address Remapping</strong>. <strong>(TCAD’22)</strong>. Qiulin Wu, You Zhou, Fei Wu, Hong Jiang, Jian Zhou, Changsheng Xie.</p>
<blockquote>
<p>​	存储系统中的重复写入是普遍存在的，来源于数据重复、日志记录和数据重新定位等。由于基于闪存的固态硬盘（SSDs）已被广泛部署，重复写入可以显著降低其性能和使用寿命。先前的研究提出了创新的方法，利用SSD内部的地址重映射工具消除重复写入。然而，重映射操作修改了逻辑到物理（L2P）的地址映射表，而在闪存上持续的物理到逻辑（P2L）映射保持不变。L2P和P2L映射之间的这种不一致性可能导致数据损坏，并长期以来一直是使用SSD地址重映射的主要障碍。</p>
<p>​	在本文中，我们提出了一个新颖的SSD设计，称为Remap-SSD-LH，实现了SSD地址重映射的全部潜力。它提供了一个重映射原语，允许主机软件和SSD固件以几乎零成本执行重复数据的逻辑写入。为了确保映射一致性以及快速的映射查找，Remap-SSD-LH采用基于混合存储的本地日志方案。每个闪存垃圾收集单元都维护一个本地日志，用于记录由重映射操作引起的相关P2L映射更改。日志存储在小型的非易失性RAM（NVRAM）中，例如电容保护的DRAM，并且如果NVRAM已满，可以将其写入闪存。</p>
<p>​	我们在一个软件SSD模拟器上验证了Remap-SSD-LH，并进行了三个案例研究：1）SSD内部去重；2）SQLite日志记录；以及3）F2FS清理。实验结果显示，Remap-SSD-LH可以最大限度地并高效地利用地址重映射来提高SSD的性能和使用寿命。</p>
</blockquote>
</li>
<li><p><strong>Finding the Optimal Execution Scheme of External Mergesort on Solid State Drives</strong>. <strong>(World Wide Web 2021)</strong>. Yubiao Chen, Jianzhong Li, Hong Gao</p>
<blockquote>
<p>​	随着基于闪存的固态硬盘(SSDs)逐渐取代机械硬盘(HDDs)成为主流存储，与HDDs不同，SSDs具有丰富的内部并行性，这使得它具有HDDs所没有的出色特性。外部合并排序作为许多系统和算法中采用的外部排序的经典算法，对整体性能有着重要的影响。因此，优化并提高外部合并排序算法的效率具有重要意义。针对SSDs上的原始外部合并排序算法的优化研究相对较少。因此，针对外部合并排序问题，基于SSDs的特点，本文提出了SortDecision算法，该算法可以计算其最优执行方案，包括决定外部合并排序执行过程的合并方式、读缓冲区大小和写缓冲区大小。利用上述最优执行方案，外部合并排序可以获得更好的效率。在SortDecision算法中，SSDs上的外部合并排序问题被形式化并转化为分段凸优化问题。然后，通过枚举每个子凸问题的解来获得最优的外部合并排序方案。实验结果表明，在提供有限内存的情况下，由SortDecision算法指导的外部合并排序与传统的外部合并排序算法相比，可以实现16.7倍的加速。SSDs内部并行资源越丰富，SortDecision的加速效果越好。</p>
</blockquote>
</li>
<li><p><strong>SW-WAL: Leveraging Address Remapping of SSDs to Achieve Single-Write Write-Ahead Logging</strong>, <strong>(DATE’21)</strong>. Qiulin Wu, You Zhou, Fei Wu, Ke Wang, Hao Lv, Jiguang Wan, Changsheng Xie</p>
<blockquote>
<p>​	写前日志 (WAL) 在数据库中被广泛使用，如SQLite和MySQL&#x2F;InnoDB，以提供事务的原子性。然而，WAL导入了重复的写入，即在WAL文件中记录的更改随后会写入到数据库文件中，这称为检查点写入。另一方面，基于NAND闪存的SSDs有一个固有的间接软件层，称为闪存转换层 (FTL)，它在现代存储系统中变得很普遍。已经提出了创新的SSD设计，通过利用FTL来消除WAL的开销，例如提供一个原子写入接口或利用其地址重映射。然而，这些设计引入了维护和持续保存额外的事务信息的显著性能开销，以保证事务的原子性或映射一致性。</p>
<p>​	在本文中，我们提出了单写WAL (SW-WAL)，一个新的跨层设计，用于在SSDs上消除WAL引入的重复写入，带有最小的开销。SSD向主机公开一个地址重映射接口，通过该接口，检查点写入可以在不进行真实数据写入的情况下完成。为了确保事务的原子性和映射一致性，我们让SSD知道对WAL文件的事务写入。具体来说，当事务数据被写入WAL文件时，事务和映射语义从主机传递到SSD，并持久化在相关的闪存页面中作为管理元数据，没有任何额外的开销。我们实现了一个SW-WAL的原型，在一个模拟的NVMe SSD上运行流行的数据库SQLite。实验结果显示，与承受WAL开销的原始SQLite相比，SW-WAL提高了数据库性能高达62%，与消除WAL开销的最新设计相比，提高了高达32%。</p>
</blockquote>
</li>
<li><p><strong>IODA: A Host&#x2F;Device Co-Design for Strong Predictability Contract on Modern Flash Storage</strong>, <strong>(SOSP’21)</strong>. Huaicheng Li, Martin L. Putra, Ronald Shi, Xing Lin, Gregory R. Ganger, Haryadi S. Gunawi</p>
<blockquote>
<p>​	在闪存存储上预测延迟一直是一个长期追求的目标，但由于许多众所周知的SSD内部活动带来的不可避免的干扰，这种不可预测性仍然存在。为了应对这个问题，最近的NVMe IO确定性（IOD）接口主张对SSD内部管理任务进行主机级控制。尽管这很有前景，但如何利用它实现真正可预测的性能仍然面临挑战。</p>
<p>​	我们提出了IODA，一个建立在IOD接口之上的I&#x2F;O确定性闪存阵列设计，通过强大但简单的扩展便于部署。IODA利用IOD上下文中的数据冗余来提供强大的延迟可预测性合约。在IODA中，SSDs预期会故意迅速地使I&#x2F;O失败，以便通过主动的数据重构允许可预测的I&#x2F;O。在并发内部操作的情况下，IODA引入了繁忙剩余时间暴露和可预测延迟窗口的制定，以保证可预测的数据重构。总体上，IODA只增加了5个新字段到NVMe接口和闪存固件中的一个小修改，同时保持主机OS中的大部分复杂性。我们的评估显示，IODA将95-99.99th的延迟提高了高达75倍。与7种最新的抢占、暂停、GC协调、分区、微小尾部闪存控制器、预测和主动方法相比，IODA也是最接近理想的无干扰情况。</p>
</blockquote>
</li>
<li><p><strong>Lightweight Data Lifetime Classification using Migration Counts to Improve Performance and Lifetime of Flash-based SSDs</strong>, <strong>(APSys’21)</strong>. Hyunseung Park, Eunjae Lee, Jaeho Kim, Sam H. Noh</p>
<blockquote>
<p>本文提出了一种策略，有效地根据其寿命对固态硬盘(SSD)中的数据进行分类，以减少基于闪存的存储的写放大。虽然已有许多研究针对数据的生命周期或热度进行分离，但它们要么需要硬件接口支持，要么产生不小的管理开销。特别地，最近提出的多流技术存在一个限制，即数据流必须由主机给出。此外，数据流分离需要用户程序实现或额外的计算。在本文中，我们提出了\sys（基于迁移计数的数据年龄分类），这是一种轻量级且有效的数据生命周期分离策略。具体来说，它利用闪存块的数据移动模式，因此只需可忽略的开销即可有效地进行分类。它是在存储设备级别上实现的，从而不需要对主机进行任何修改。使用各种合成和真实世界的数据库工作负载，我们在FEMU上评估了这种技术，这是一个NVMe SSD模拟器。我们发现它既提高了基于闪存的SSD的性能，也提高了其寿命。</p>
</blockquote>
</li>
<li><p><strong>ZNS+: Advanced Zoned Namespace Interface for Supporting In-Storage Zone Compaction</strong>, <strong>(OSDI’21)</strong>. Kyuhwa Han, Hyunho Gwak, Dongkun Shin, Joo-Young Hwang.</p>
<blockquote>
<p>​	NVMe分区命名空间(ZNS)正逐渐成为一种新的存储接口，其中逻辑地址空间被划分为固定大小的区域，每个区域必须顺序写入以实现对闪存友好的访问。由于ZNS的顺序写入只区域方案，需要日志结构文件系统(LFS)来访问ZNS固态硬盘(SSD)。尽管在当前的ZNS接口下SSD可以被简化，但其对应的LFS必须承受段合并的开销。为了解决这个问题，我们提出了一个新的LFS感知ZNS接口，称为ZNS+，以及其实现，其中主机可以将数据复制操作卸载到SSD以加速段合并。ZNS+还允许每个区域使用稀疏的顺序写请求进行覆盖写入，这使得LFS可以使用基于线程日志的块回收代替段合并。我们还提出了两种针对ZNS+感知LFS的文件系统技术。考虑到SSD内部不同复制路径上的不同复制成本，提出了copyback-aware块分配。混合段回收根据它们的成本，在段合并和线程日志之间选择适当的块回收策略。我们在一个SSD模拟器和一个真实的SSD上实现了ZNS+ SSD。所提出的ZNS+存储系统的文件系统性能比正常的基于ZNS的存储系统好1.33-2.91倍。</p>
</blockquote>
</li>
<li><p><strong>Remap-SSD: Safely and Efficiently Exploiting SSD Address Remapping to Eliminate Duplicate Writes</strong>, <strong>(FAST’21)</strong>. You Zhou, Qiulin Wu, Fei Wu, Hong Jiang, Jian Zhou, Changsheng Xie.</p>
<blockquote>
<p>​	在各种存储系统中，重复写入是普遍存在的，起源于数据重复、日志记录和数据重新定位等。随着基于闪存的SSD被广泛部署，这些写入操作会显著降低其性能和使用寿命。为了消除重复的写入，先前的研究已提出了利用SSD内部地址重映射工具的创新方法。然而，重映射操作导致了映射不一致问题，这可能会导致数据丢失，并且在现有研究中尚未得到妥善解决。在本文中，我们提出了一种名为Remap-SSD的新型SSD设计，具有两个显著特点。首先，它提供了一个重映射原语，允许主机软件和SSD固件以几乎零成本执行重复数据的逻辑写入。其次，采用了混合存储架构来保持映射一致性。小字节可寻址的非易失性RAM（NVRAM）用于以日志结构方式持久化重映射元数据，并与闪存协同管理。我们在一个软件SSD模拟器上验证了Remap-SSD，并进行了三个案例研究：SSD内部去重、SQLite日志记录和F2FS清理。实验结果显示，Remap-SSD可以实现地址重映射的全部潜力，以提高SSD的性能和使用寿命。</p>
</blockquote>
</li>
<li><p><strong>Prolonging 3D NAND SSD Lifetime via Read Latency Relaxation</strong>, <strong>(ASPLOS’21)</strong>. Chun-Yi Liu, Yunju Lee, Myoungsoo Jung, Mahmut Taylan Kandemir, Wonil Choi.</p>
<blockquote>
<p>​	3D NAND的采用显著提高了SSD的密度；然而，如多层电池层的堆叠等3D NAND密度增加技术可能会放大读取干扰并缩短SSD的使用寿命。从我们对8个最先进的SSD的寿命影响特性分析中，我们观察到，由于背景中执行了大量因读干扰引起的重写，3D TLC&#x2F;QLC SSD可能会在其保修期内由低读取工作负载磨损。为了了解其他的读干扰缓解机会，我们还对另外2个没有背景重写机制的SSD进行了读取延迟特性分析。收集的结果表明，没有背景重写，随着数据的读取次数增加，大多数数据的读取延迟都会增加。受到这两种特性分析的启发，本文提议放宽高密度3D SSD上的短读取延迟约束。具体而言，我们的提议依赖于从应用程序传递到SSD的提示信息，该信息指定了预期的读取性能。这样，由读取引起的写入造成的寿命消耗就可以减少，从而延长SSD的使用寿命。详细的实验评估显示，我们的提议可以在文件服务器应用程序下，减少多达56%的重写引起的已用寿命，而性能仅降低2%。</p>
</blockquote>
</li>
<li><p><strong>QBLKe: Host-side flash translation layer management for Open-Channel SSDs</strong>, <strong>Journal of Systems Architecture (2021)</strong>, Hongwei Qin, Dan Feng, Wei Tong, Yutong Zhao, Mengye Peng, Jingning Liu</p>
<blockquote>
<p>​	开放通道SSD (OCSSD) 在高性能存储系统中展现出巨大潜力。现有的应用程序或文件系统依赖基于主机的Flash转换层(FTL)来使用OCSSDs。然而，现有解决方案在多线程工作负载下不能充分发挥OCSSD的性能。在读&#x2F;写关键路径上，我们发现三个组件（环形缓冲区、转换映射和DMA内存池）使用全局自旋锁来实现原子性。自旋锁耗尽CPU时间，从而损害系统的可扩展性。此外，随着OCSSD并行单元数量的增加，现有解决方案的垃圾收集（GC）的粒度也增加。这导致GC期间不必要的页面迁移。在本文中，我们提出QBLKe作为OCSSD基于主机的FTL。QBLKe采用三种技术来提高可扩展性并最小化软件开销：(1) 每CPU环形缓冲区，(2) 无锁转换映射，和(3) 每CPU DMA池。为了进一步减少GC页面迁移和对I&#x2F;O性能的影响，QBLKe实现了每通道GC和一种称为基于评分的速率限制器的新方案。实验结果显示，与现有解决方案相比，QBLKe将写带宽提高了高达78.9%。它还将峰值读IOPS提高了139.31%，GC效率提高了49.11%。</p>
</blockquote>
</li>
<li><p><strong>Better Atomic Writes by Exposing the Flash Out-of-Band Area to File Systems</strong>, <strong>(LCTES’21)</strong>. Hongwei Qin, Dan Feng, Wei Tong, Yutong Zhao, Sheng Qiu, Fei Liu, Shu Li</p>
<blockquote>
<p>​	移动设备的文件系统通常通过有序I&#x2F;O来保持数据的一致性。然而，维护I&#x2F;O顺序阻碍了应用程序充分利用设备的并行性，从而降低了存储性能。在本文中，我们提出NBStack，旨在在不妥协数据一致性的情况下消除有序I&#x2F;O。首先，我们增强现有的块接口，以将Flash的带外区域暴露给文件系统。其次，我们构建了一个增强的块设备原型，支持新的接口。第三，我们开发了NBFS，一个Linux文件系统，利用新的块接口实现原子写入，而不需要强制I&#x2F;O排序。实验结果显示，NBStack的性能是F2FS的两倍，同时提供了强有力的一致性和持久性保证。如果应用程序愿意牺牲持久性，NBStack可以进一步大幅提高性能。</p>
</blockquote>
</li>
<li><p><strong>Determinizing Crash Behavior with a Verified Snapshot-Consistent Flash Translation Layer</strong>, <strong>(OSDI’20)</strong>. Yun-Sheng Chang, Yao Hsiao, Tzu-Chi Lin, Che-Wei Tsao, Chun-Feng Wu, Yuan-Hao Chang, Hsiang-Shang Ko, Yu-Fang Chen.</p>
<blockquote>
<p>​	本文介绍了一个为闪存磁盘设计的快照一致性的闪存转换层(SCFTL)。它比传统设计提供了更强的关于崩溃后可能的行为的保证。具体来说，SCFTL的flush操作还具有制作“磁盘快照”的功能。当发生崩溃时，闪存磁盘保证恢复到最后一次flush操作之前的状态。SCFTL的主要优点是它允许在存储堆栈的上层设计得更高效。例如，建立在SCFTL上的文件系统不需要使用日志进行崩溃恢复。相反，它只需要在每个原子事务结束时执行SCFTL的flush操作。我们使用一个证明助手、一个符号执行器和一个SMT求解器，正式验证我们的SCFTL实现的正确性。我们修改了xv6文件系统以支持组提交，并利用SCFTL更强的崩溃保证。我们使用文件系统基准测试进行评估，结果显示，修改后的xv6在SCFTL上的速度比在传统FTLs上使用日志的xv6快3到30倍，并且在最坏的情况下只比最先进的设置慢两倍：ext4文件系统在物理块设备(pblk) FTL上。</p>
</blockquote>
</li>
<li><p><strong>LeapIO: Efficient and Portable Virtual NVMe Storage on ARM SoCs</strong>, <strong>(ASPLOS’20)</strong>. Huaicheng Li, Mingzhe Hao, Stanko Novakovic, Vaibhav Gogte, Sriram Govindan, Dan R. K. Ports, Irene Zhang, Ricardo Bianchini, Haryadi S. Gunawi, Anirudh Badam.</p>
<blockquote>
<p>​	今天的云存储堆栈对资源的需求极高，消耗了数据中心x86核心的10-20%，这是云服务提供商必须支付的主要”存储税”。然而，复杂的云存储堆栈并不完全适用于当今的IO加速器。我们介绍了LeapIO，一个新的云存储堆栈，它利用基于ARM的协处理器来卸载复杂的存储服务。LeapIO解决了许多部署挑战，如硬件的可替换性、软件的可移植性、可虚拟化性、可组合性和效率。它使用了一套操作系统&#x2F;软件技术和新的硬件属性，这些属性为x86和ARM核心提供了统一的地址空间，并将虚拟NVMe存储暴露给未修改的客户虚拟机，其性能与裸机服务器相媲美。</p>
</blockquote>
</li>
<li><p><strong>DualFS: A Coordinative Flash File System with Flash Block Dual-mode Switching</strong>, <strong>(ICCD’20)</strong>. Bing Wu, Mengye Peng, Dan Feng, Wei Tong.</p>
<blockquote>
<p>​	随着用户对大容量存储的需求持续增长，广泛使用的NAND闪存始终采用每个单元的多位和3D堆叠技术来提高存储密度，但这会损害闪存的性能。现代闪存芯片允许闪存块在多位每单元和一位每单元之间切换，这为从单级单元(SLC，即一位每单元)的高性能中受益提供了可能性。然而，由块I&#x2F;O接口和闪存转换层(FTL)引起的语义差距阻止了底层闪存的性能得到充分利用。在本文中，我们提出了一个日志结构文件系统，称为DualFS。DualFS允许闪存块自由地在原始模式和SLC模式之间切换，并使用这些SLC块来加速关键请求。DualFS根据有效数据的总大小动态调整SLC模式区域的容量，以保持设备的容量损耗可以忽略不计。此外，DualFS利用Open-Channel固态硬盘(SSD)的优点，使用软件语义信息来指导数据的放置和管理。特别是，由于向SLC块写入相同数量的数据会损害更多的耐久性，DualFS提出了一种新颖的生命周期管理方案，它在一定的窗口内限制了写入SLC模式区域的比率，从而准确地控制了SSD的耐久性。最后，DualFS整合了由文件系统直接驱动的垃圾收集(GC)过程，并合并了SLC模式区域和原始模式区域的GC。实验结果表明，与基于开放通道SSD的最新闪存文件系统相比，DualFS提供了平均22.2%的性能提升。与基于闪存块双模式切换特性的其他存储系统相比，DualFS的平均性能也表现出13.3%到24.6%的显著改善。此外，DualFS在不同的读&#x2F;写比率下有效地减少了读响应时间，并精确地管理了设备的耐久性。</p>
</blockquote>
</li>
<li><p><strong>HMB-I&#x2F;O: Fast Track for Handling Urgent I&#x2F;Os inNonvolatile Memory Express Solid-State Drives</strong>, <strong>(Appl. Sci. 2020)</strong>. Kyusik Kim, Seongmin Kim, Taeseok Kim.</p>
<blockquote>
<p>​	为满足各自需求的应用程序提供差异化的I&#x2F;O服务对于用户满意度非常重要。非易失性内存快速通道（NVMe）固态硬盘（SSD）架构可以通过其众多的提交队列来提高I&#x2F;O带宽，但每个I&#x2F;O请求的服务质量（QoS）从未得到保证。特别是，如果由于突发的I&#x2F;O工作负载，在提交队列中有很多I&#x2F;O请求待处理，紧急的I&#x2F;O请求可能会被延迟，因此，需要快速服务的应用程序的QoS要求可能无法得到满足。本文提出了一种处理紧急I&#x2F;O请求的方案，即使有很多挂起的I&#x2F;O请求，也不会延迟。由于提交队列中的待处理I&#x2F;O请求不能由主机控制，所以使用主机内存缓冲区（HMB）——这是可以从控制器访问的主机的DRAM的一部分——来处理紧急的I&#x2F;O请求。该方案并不是通过传统的I&#x2F;O路径将紧急I&#x2F;O请求发送到SSD中，而是通过直接将它们插入HMB来消除延迟。模拟器实验表明，该方案可以将平均延迟和尾部延迟分别降低高达99%和86%。</p>
</blockquote>
</li>
<li><p><strong>QBLK: Towards Fully Exploiting the Parallelism of Open-Channel SSDs</strong>, <strong>(DATE’19)</strong>. Hongwei Qin, Dan Feng, Wei Tong, Jingning Liu, Yutong Zhao.</p>
<blockquote>
<p>​	通过将物理通道暴露给主机软件，Open-Channel SSD在未来的高性能存储系统中展现出巨大的潜力。然而，现有的方案在重负载下无法达到令人满意的性能。主要原因不仅在于其单一缓冲体系结构，更重要的是其基于行的物理地址管理。此外，在重负载下，地址映射表的锁也是一个性能负担。我们提出了QBLK，一个开源驱动程序，试图更好地利用Open-Channel SSDs的并行性。特别地，QBLK采用了四个关键技术，分别是：（1）基于多队列的缓冲，（2）基于每个通道的地址管理，（3）无锁地址映射，以及（4）细粒度的排放。实验结果显示，与现有的最先进的PBLK方案相比，QBLK实现了高达97.4%的带宽提升。</p>
</blockquote>
</li>
<li><p><strong>An Efficient Design and Implementation of Deduplication on Open-Channel SSDs</strong>, <strong>(HPCC’19)</strong>. Qiqi Hu, Jianxi Chen, Dan Feng, Qing Yang, Bo Liu.</p>
<blockquote>
<p>​	由于NAND闪存的写入周期达到上限，数据无法可靠地存储。因此，固态硬盘（SSDs）的寿命受到限制，使其无法成为写入密集型数据中心的可靠存储设备。数据去重可以有效减少写入流量并延长SSDs的使用寿命。但是，传统数据去重方案中的指纹计算开销太大，这将降低SSDs的写入性能。在本文中，我们提出了一种基于Open-Channel SSDs (OCSSDs)的新的去重方案D-pblk，它可以配合现代高性能CPU来减少指纹计算的开销。在D-pblk中，我们使用轻量级的哈希CRC32来过滤大部分非重复数据，当CRC32首次被命中时，我们从Open-Channel SSDs中读取数据并计算重量级的哈希SHA-1进行精确比较，这减少了指纹计算的开销，几乎不影响工作负载的去重率。我们还使用多线程并行计算指纹，进一步减少了指纹计算的开销。此外，我们使用双环缓冲区来解决去重后的数据大小可能不匹配闪存页面大小的问题。我们使用FEMU模拟Open-Channel SSDs进行评估。实验结果显示，D-pblk可以实现从4.61%到31.63%的去重率，写入延迟提高了高达29倍。</p>
</blockquote>
</li>
</ol>
<h2 id="Slides："><a href="#Slides：" class="headerlink" title="Slides："></a>Slides：</h2><iframe src="../../../../pdf_file/FEMU_STUDY/FEMU_10.23.pdf" style="width:100%; height:800px;" frameborder="0"></iframe>

<h2 id="Appendix："><a href="#Appendix：" class="headerlink" title="Appendix："></a>Appendix：</h2><h3 id="一些名词解释："><a href="#一些名词解释：" class="headerlink" title="一些名词解释："></a>一些名词解释：</h3><blockquote>
<ul>
<li><p><strong>virtio</strong>：<code>virtio</code> 是一个虚拟化标准，用于提供一种高效、标准化的方式在宿主（host）和虚拟机（guest）之间进行 IO 操作。它是一个设备抽象标准，但不依赖于任何特定的虚拟化环境或物理硬件，通常用于改进网络和磁盘性能。使用 <code>virtio</code>，虚拟机与一个“虚拟化的”设备通信，而不是模拟实际的硬件设备，从而提高性能。</p>
</li>
<li><p>**dataplane (或称 data plane)**：数据平面通常指的是网络设备（如路由器或交换机）中处理数据包转发的部分。与之相对的是控制平面，它决定数据如何转发。在虚拟化语境中，当我们谈论 “dataplane”，我们通常指的是为了提高性能而进行优化的数据处理路径，例如 <code>vhost-user</code> 或 <code>dpdk</code> 在 <code>QEMU/KVM</code> 环境中。这些优化路径旨在减少不必要的上下文切换和缓冲，从而提供接近本机的 IO 性能。</p>
</li>
<li><p><strong>“trap-and-emulate”</strong> 是虚拟化技术中的一个术语。</p>
<ol>
<li><strong>Trap</strong>：在虚拟化中，当虚拟机（guest）尝试执行某些特定的、不能在其权限级别下直接执行的操作时，会触发一个异常或中断。这种异常或中断被称为“陷阱”（trap）。</li>
<li><strong>Emulate</strong>：一旦产生了这种陷阱，虚拟机监控器（如QEMU、KVM等）会接管控制权，然后在更高的权限级别上模拟或解释执行那些操作，就像真实硬件上的操作一样，但是实际上是通过软件来完成的。</li>
</ol>
<p>所以，“trap-and-emulate”意味着：当虚拟机尝试执行某些它没有权限直接执行的操作时，这些操作会被陷阱捕获，并由宿主机上的虚拟机监控器以模拟的方式执行。这是传统虚拟化技术的基本工作原理。</p>
</li>
<li><p><strong>rings the doorbell</strong>：“rings the doorbell”是一个比喻，用于描述一种通知或信号机制。在NVMe协议中，当驱动程序想要通知控制器有新的命令已经放入命令队列中，准备被处理时，它会写入一个特定的内存映射输入&#x2F;输出（MMIO）寄存器。这个动作被称为”ringing the doorbell”，就好像是敲门铃一样，通知某人来处理某事。简而言之，当Guest OS的NVMe驱动有IO请求准备发送时，它通过“敲门铃”来通知设备（在这种情况下是QEMU）开始处理这些IO请求。</p>
</li>
<li><p>**MMIO:**是 “Memory-Mapped Input&#x2F;Output” 的缩写，翻译为“内存映射输入&#x2F;输出”。在计算机系统中，MMIO 是一种将设备的寄存器映射到主存储器地址空间的技术，这样CPU可以通过访问这个内存地址来读写设备的寄存器，而不是使用专门的I&#x2F;O指令。</p>
<p>​	当提到“doorbell”是一个 MMIO 操作时，意思是说，为了通知设备有新的IO请求，驱动程序会写入一个特定的内存地址，这个地址实际上是映射到设备寄存器的。然后这个写操作会被设备捕获并做出响应。</p>
<p>​	“会导致一个昂贵的VM-exit”部分则表示，当虚拟机的Guest OS进行这样的MMIO操作时，它实际上需要从Guest OS切换到宿主机的上下文（在这种情况下是QEMU），这个上下文切换过程是有性能开销的，因此被称为“昂贵”。</p>
</li>
<li><p><strong>为什么说：然而，当存储后端是RAM支持的映像时，AIO的开销变得非常显著。</strong></p>
<p>​	当存储后端是RAM支持的映像时，数据访问速度非常快，因为RAM（随机存取存储器）是计算机中最快的存储介质。与硬盘或SSD相比，从RAM读取或写入数据的延迟是非常低的。</p>
<p>​	AIO（异步I&#x2F;O）的主要优势是允许系统在等待I&#x2F;O操作完成时进行其他工作，从而提高效率。但这个优势主要在于处理慢速存储设备时更为明显，例如传统硬盘，因为这时I&#x2F;O操作可能需要很长时间。</p>
<p>​	但是，当后端存储是RAM时，由于RAM的快速响应，同步I&#x2F;O操作的完成时间非常短，几乎可以立即完成。因此，引入AIO的额外开销（如设置和管理异步操作）可能不仅不会提高性能，反而可能导致性能降低。简而言之，为了处理非常快速的RAM操作，引入AIO可能会增加不必要的复杂性和开销，这就是为什么说在这种情况下，AIO的开销变得非常显著。</p>
</li>
<li><p><strong>end-to-end IO time</strong>:是指从输入&#x2F;输出操作开始到完成的总时间。在计算机领域中，”端到端”通常指的是一个过程从开始到结束的整个周期。所以，端到端的IO时间是指从IO请求发起（例如，应用程序请求读取或写入数据）到请求被完全处理并得到响应的总时间。这包括了所有中间过程，如数据传输、数据转换、系统调度和任何其他可能的延迟。</p>
</li>
<li><p>**Lantency tail:**（延迟尾）指的是在性能测量中，尤其是分布式系统或网络服务中，某些请求的响应时间比大多数请求都要长的那部分请求。在很多场景下，这些高延迟的请求，即使只是很小的一部分，也可能对系统的整体性能和用户体验产生显著的负面影响。</p>
<p>例如，考虑一个在线服务，其中99%的请求在10毫秒内得到响应，但1%的请求需要1秒。这1%的请求就构成了延迟的尾部。尽管它们的比例很小，但它们的延迟对用户体验产生的负面影响可能与其它99%的请求一样大，甚至更大。</p>
</li>
<li><p><strong>Plane</strong>: 在NAND闪存中，一个plane代表存储芯片中的一个独立存储区域。每个plane可以独立地执行读、写和擦除操作。一个NAND芯片可以有一个或多个plane，多plane架构可以提高存储的并行性和性能。</p>
</li>
<li><p><strong>Channel</strong>: 通道是连接NAND闪存和控制器之间的接口，用于数据传输。多通道架构允许同时访问多个NAND芯片，从而提高数据读取和写入的速度。每个通道可能连接到一个或多个NAND芯片。</p>
</li>
<li><p><strong>MLC：</strong><code>(multi-level Cell)</code>它是一种 NAND 闪存存储技术。<code>MLC</code> 可以在每个存储单元中存储多于一位的数据，通常是2位。这与 <code>SLC (Single-Level Cell)</code> 闪存不同，<code>SLC </code>每个单元只存储1位数据。</p>
</li>
<li><p><strong>controller-blocking GC</strong>：这是最具侵入性的GC类型。当垃圾回收在整个存储控制器上进行时，其他所有操作（如读取或写入）都会被阻塞，直到GC完成。这可以对性能产生显著的负面影响，因为它停止了所有其他I&#x2F;O操作。</p>
</li>
<li><p><strong>channel-blocking GC</strong>：在这种情况下，当某个特定的通道正在进行垃圾回收时，该通道上的其他操作会被阻塞。但是，其他通道上的操作可以继续进行，从而允许一定程度的并行性。这减少了GC对整体性能的影响，但在被GC阻塞的通道上仍可能会看到性能下降。</p>
</li>
<li><p><strong>plane-blocking GC</strong>：这是最具局部性的GC，仅在特定的平面上阻塞操作。其他平面上的操作可以正常进行，使得性能影响最小化。由于仅影响特定的平面，这种方法可能是对性能影响最小的。</p>
</li>
<li><p><strong>FTL 指的是“Flash Translation Layer”</strong>。这是固态硬盘（SSD）和其他基于闪存的存储设备中的一个关键组件。FTL 的主要任务是管理如何在物理NAND闪存上存储数据，同时为上层应用提供一个标准的块设备接口。</p>
<p>以下是 FTL 的主要功能和特点：</p>
<ol>
<li><strong>地址转换</strong>：FTL 负责将逻辑块地址（LBA，通常由操作系统提供）转换为物理块地址（PBA），从而隐藏闪存的物理细节。</li>
<li><strong>Wear Leveling</strong>：由于NAND闪存单元有限的擦除周期（通常是几千到几万次），FTL 通过均匀分布写入和擦除操作来确保所有的闪存块都具有相似的使用寿命。这就是所谓的“wear leveling”。</li>
<li><strong>Garbage Collection</strong>：当数据被重写或删除时，其旧版本在闪存上不会被立即删除。相反，这些块会被标记为“无效”。FTL 会定期运行垃圾回收，移动有效数据并擦除包含大量无效块的块。</li>
<li><strong>Bad Block Management</strong>：由于制造缺陷或使用过程中的损耗，NAND闪存可能会有坏块。FTL 负责检测这些坏块并将它们从使用中排除。</li>
<li><strong>随机到顺序的转换</strong>：闪存优先处理顺序写入，因为它们可以更高效地处理大量的连续数据。FTL 试图将随机写入转化为顺序写入，从而优化性能。</li>
</ol>
<p>FTL 的实现和策略可能会因不同的SSD制造商和模型而异。FTL 的效率和策略对SSD的整体性能、寿命和可靠性都有着直接的影响</p>
</li>
<li><p><strong>NVMe（Non-Volatile Memory Express）</strong>是一种协议，专为高速固态存储驱动器（如使用NAND闪存的SSDs）设计，以最大化其性能并减少延迟。它被设计为替代旧的AHCI协议，AHCI最初是为HDDs设计的，因此它在管理SSDs时存在一些效率和性能的瓶颈。</p>
<p>以下是NVMe的主要特点和优势：</p>
<ol>
<li><strong>接口</strong>：NVMe通常使用PCI Express (PCIe)总线作为其物理接口，这允许更高的带宽和更低的延迟。</li>
<li><strong>并行性</strong>：NVMe支持多个命令队列，每个队列可容纳上千个命令。这与AHCI的单一队列形成了对比，AHCI的队列只能容纳32个命令。这种高度的并行性尤其适合现代多核处理器。</li>
<li><strong>低延迟</strong>：NVMe协议被优化，减少了命令处理的总体开销，这使得存储I&#x2F;O操作的延迟得到了显著的减少。</li>
<li><strong>针对SSD优化</strong>：与AHCI相比，NVMe专为固态存储优化，省略了许多与旋转硬盘相关的冗余操作。</li>
<li><strong>扩展性</strong>：NVMe为未来的存储技术，如3D XPoint等，提供了良好的扩展性。</li>
<li><strong>功能丰富</strong>：NVMe提供了许多先进的特性，如支持多路径、安全擦除和更细粒度的功耗管理。</li>
</ol>
<p>由于上述优势，NVMe SSDs在许多应用场景中，特别是需要高性能和低延迟的场景中，已经成为首选。不过，值得注意的是，为了充分利用NVMe SSDs的优势，系统需要一个支持NVMe的主板和操作系统。</p>
</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/25/computerSystemDesignLab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/25/computerSystemDesignLab/" class="post-title-link" itemprop="url">computerSystemDesignLab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-25 09:19:19" itemprop="dateCreated datePublished" datetime="2023-09-25T09:19:19+08:00">2023-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-15 10:15:46" itemprop="dateModified" datetime="2023-11-15T10:15:46+08:00">2023-11-15</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>122</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Computer-System-Design-Lab-1"><a href="#Computer-System-Design-Lab-1" class="headerlink" title="Computer System Design Lab_1"></a>Computer System Design Lab_1</h2><iframe src="../../../../pdf_file/computerSystemDesignLab/Lab1_report.pdf" style="width:100%; height:800px;" frameborder="0"></iframe>

<h2 id="Computer-System-Design-Lab-2"><a href="#Computer-System-Design-Lab-2" class="headerlink" title="Computer System Design Lab_2"></a>Computer System Design Lab_2</h2><iframe src="../../../../pdf_file/computerSystemDesignLab/Lab2_report.pdf" style="width:100%; height:800px;" frameborder="0"></iframe>

<h2 id="Computer-System-Design-Lab-3"><a href="#Computer-System-Design-Lab-3" class="headerlink" title="Computer System Design Lab_3"></a>Computer System Design Lab_3</h2><iframe src="../../../../pdf_file/computerSystemDesignLab/Lab3_report.pdf" style="width:100%; height:800px;" frameborder="0"></iframe>

<h2 id="Computer-System-Design-Lab-4"><a href="#Computer-System-Design-Lab-4" class="headerlink" title="Computer System Design Lab_4"></a>Computer System Design Lab_4</h2><iframe src="../../../../pdf_file/computerSystemDesignLab/lab4_report.pdf" style="width:100%; height:800px;" frameborder="0"></iframe>

<h2 id="coursework"><a href="#coursework" class="headerlink" title="coursework"></a>coursework</h2><iframe src="../../../../pdf_file/computerSystemDesignLab/coursework.pdf" style="width:100%; height:800px;" frameborder="0"></iframe>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/14/PA1-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0%E7%9A%84%E7%AF%87%E7%AB%A0-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/14/PA1-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0%E7%9A%84%E7%AF%87%E7%AB%A0-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="post-title-link" itemprop="url">PA1 - 开天辟地的篇章: 最简单的计算机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-14 19:17:02" itemprop="dateCreated datePublished" datetime="2023-09-14T19:17:02+08:00">2023-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-20 16:10:05" itemprop="dateModified" datetime="2023-10-20T16:10:05+08:00">2023-10-20</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="PA1-开天辟地的篇章-最简单的计算机"><a href="#PA1-开天辟地的篇章-最简单的计算机" class="headerlink" title="PA1 - 开天辟地的篇章: 最简单的计算机"></a>PA1 - 开天辟地的篇章: 最简单的计算机</h1><blockquote>
<p><strong>世界诞生的故事 - 第一章</strong></p>
<p>先驱已经准备好了创造计算机世界的工具. 为了迈出第一步, 他运用了一些数字电路的知识, 就已经创造出了一个最小的计算机 – 图灵机. 让我们来看看其中的奥妙.</p>
</blockquote>
<h2 id="在开始愉快的PA之旅之前"><a href="#在开始愉快的PA之旅之前" class="headerlink" title="在开始愉快的PA之旅之前"></a>在开始愉快的PA之旅之前</h2><blockquote>
<p><strong>随时记录实验心得</strong>	</p>
<p>我们已经在你学长学姐的实验报告中多次看到类似的悔恨: 因为没有及时记录实验心得而在编写实验报告的时候忘记了自己经历趣事的细节. 为了和助教们分享你的各种实验经历, 我们建议你在实验过程中随时记录实验心得, 比如自己踩过的大坑, 或者是调了一周之后才发现的一个弱智bug, 等等.</p>
<p>我们相信, 当你做完PA回过头来阅读这些心得的时候, 就会发现这对你来说是一笔宝贵的财富.</p>
</blockquote>
<h2 id="开天辟地的篇章"><a href="#开天辟地的篇章" class="headerlink" title="开天辟地的篇章"></a>开天辟地的篇章</h2><h3 id="任务-尝试理解计算机如何计算"><a href="#任务-尝试理解计算机如何计算" class="headerlink" title="任务 尝试理解计算机如何计算"></a>任务 尝试理解计算机如何计算</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// PC: instruction    | // label: statement</span><br><span class="line">0: mov  r1, 0         |  pc0: r1 = 0;</span><br><span class="line">1: mov  r2, 0         |  pc1: r2 = 0;</span><br><span class="line">2: addi r2, r2, 1     |  pc2: r2 = r2 + 1;</span><br><span class="line">3: add  r1, r1, r2    |  pc3: r1 = r1 + r2;</span><br><span class="line">4: blt  r2, 100, 2    |  pc4: if (r2 &lt; 100) goto pc2;   // branch if less than</span><br><span class="line">5: jmp 5              |  pc5: goto pc5;</span><br></pre></td></tr></table></figure>

<p>在看到上述例子之前, 你可能会觉得指令是一个既神秘又难以理解的概念. 不过当你看到对应的C代码时, 你就会发现指令做的事情竟然这么简单! 而且看上去还有点蠢, 你随手写一个for循环都要比这段C代码看上去更高级.</p>
<p>不过你也不妨站在计算机的角度来理解一下, 计算机究竟是怎么通过这种既简单又笨拙的方式来计算<code>1+2+...+100</code>的. 这种理解会使你建立”程序如何在计算机上运行”的最初原的认识.</p>
</blockquote>
<p>​	我理解的计算机执行计算的方式是：不断的更新PC，读取对应地址，从中取出指令并执行。</p>
<h2 id="RTFSC"><a href="#RTFSC" class="headerlink" title="RTFSC"></a>RTFSC</h2><h3 id="代码框架初探"><a href="#代码框架初探" class="headerlink" title="代码框架初探"></a>代码框架初探</h3><blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ics2023</span><br><span class="line">├── abstract-machine   # 抽象计算机</span><br><span class="line">├── am-kernels         # 基于抽象计算机开发的应用程序</span><br><span class="line">├── fceux-am           # 红白机模拟器</span><br><span class="line">├── init.sh            # 初始化脚本</span><br><span class="line">├── Makefile           # 用于工程打包提交</span><br><span class="line">├── nemu               # NEMU</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure>

<p>​	目前只需要关心nemu目录下的代码：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">nemu</span><br><span class="line">├── configs                    # 预先提供的一些配置文件</span><br><span class="line">├── include                    # 存放全局使用的头文件</span><br><span class="line">│   ├── common.h               # 公用的头文件</span><br><span class="line">│   ├── config                 # 配置系统生成的头文件, 用于维护配置选项更新的时间戳</span><br><span class="line">│   ├── cpu</span><br><span class="line">│   │   ├── cpu.h</span><br><span class="line">│   │   ├── decode.h           # 译码相关</span><br><span class="line">│   │   ├── difftest.h</span><br><span class="line">│   │   └── ifetch.h           # 取指相关</span><br><span class="line">│   ├── debug.h                # 一些方便调试用的宏</span><br><span class="line">│   ├── device                 # 设备相关</span><br><span class="line">│   ├── difftest-def.h</span><br><span class="line">│   ├── generated</span><br><span class="line">│   │   └── autoconf.h         # 配置系统生成的头文件, 用于根据配置信息定义相关的宏</span><br><span class="line">│   ├── isa.h                  # ISA相关</span><br><span class="line">│   ├── macro.h                # 一些方便的宏定义</span><br><span class="line">│   ├── memory                 # 访问内存相关</span><br><span class="line">│   └── utils.h</span><br><span class="line">├── Kconfig                    # 配置信息管理的规则</span><br><span class="line">├── Makefile                   # Makefile构建脚本</span><br><span class="line">├── README.md</span><br><span class="line">├── resource                   # 一些辅助资源</span><br><span class="line">├── scripts                    # Makefile构建脚本</span><br><span class="line">│   ├── build.mk</span><br><span class="line">│   ├── config.mk</span><br><span class="line">│   ├── git.mk                 # git版本控制相关</span><br><span class="line">│   └── native.mk</span><br><span class="line">├── src                        # 源文件</span><br><span class="line">│   ├── cpu</span><br><span class="line">│   │   └── cpu-exec.c         # 指令执行的主循环</span><br><span class="line">│   ├── device                 # 设备相关</span><br><span class="line">│   ├── engine</span><br><span class="line">│   │   └── interpreter        # 解释器的实现</span><br><span class="line">│   ├── filelist.mk</span><br><span class="line">│   ├── isa                    # ISA相关的实现</span><br><span class="line">│   │   ├── mips32</span><br><span class="line">│   │   ├── riscv32</span><br><span class="line">│   │   ├── riscv64</span><br><span class="line">│   │   └── x86</span><br><span class="line">│   ├── memory                 # 内存访问的实现</span><br><span class="line">│   ├── monitor</span><br><span class="line">│   │   ├── monitor.c</span><br><span class="line">│   │   └── sdb                # 简易调试器</span><br><span class="line">│   │       ├── expr.c         # 表达式求值的实现</span><br><span class="line">│   │       ├── sdb.c          # 简易调试器的命令处理</span><br><span class="line">│   │       └── watchpoint.c   # 监视点的实现</span><br><span class="line">│   ├── nemu-main.c            # 你知道的...</span><br><span class="line">│   └── utils                  # 一些公共的功能</span><br><span class="line">│       ├── log.c              # 日志文件相关</span><br><span class="line">│       ├── rand.c</span><br><span class="line">│       ├── state.c</span><br><span class="line">│       └── timer.c</span><br><span class="line">└── tools                      # 一些工具</span><br><span class="line">    ├── fixdep                 # 依赖修复, 配合配置系统进行使用</span><br><span class="line">    ├── gen-expr</span><br><span class="line">    ├── kconfig                # 配置系统</span><br><span class="line">    ├── kvm-diff</span><br><span class="line">    ├── qemu-diff</span><br><span class="line">    └── spike-diff</span><br></pre></td></tr></table></figure>
</blockquote>
<p>提示：</p>
<ul>
<li><code>nemu/include/generated/autoconf.h</code>, 阅读C代码时使用</li>
<li><code>nemu/include/config/auto.conf</code>, 阅读Makefile时使用</li>
</ul>
<h4 id="准备第一个程序"><a href="#准备第一个程序" class="headerlink" title="准备第一个程序"></a>准备第一个程序</h4><blockquote>
<p>我们已经知道, NEMU是一个用来执行客户程序的程序, 但客户程序一开始并不存在于客户计算机中. 我们需要将客户程序读入到客户计算机中, 这件事是monitor来负责的. 于是NEMU在开始运行的时候, 首先会调用<code>init_monitor()</code>函数(在<code>nemu/src/monitor/monitor.c</code>中定义) 来进行一些和monitor相关的初始化工作.</p>
</blockquote>
<h4 id="运行第一个客户程序"><a href="#运行第一个客户程序" class="headerlink" title="运行第一个客户程序"></a>运行第一个客户程序</h4><blockquote>
<p>Monitor的初始化工作结束后, <code>main()</code>函数会继续调用<code>engine_start()</code>函数 (在<code>nemu/src/engine/interpreter/init.c</code>中定义). 代码会进入简易调试器(Simple Debugger)的主循环<code>sdb_mainloop()</code> (在<code>nemu/src/monitor/sdb/sdb.c</code>中定义), 并输出NEMU的命令提示符:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(nemu)</span><br></pre></td></tr></table></figure>

<p>简易调试器是monitor的核心功能, 我们可以在命令提示符中输入命令, 对客户计算机的运行状态进行监控和调试. 框架代码已经实现了几个简单的命令, 它们的功能和GDB是很类似的.</p>
<p>在命令提示符后键入<code>c</code>后, NEMU开始进入指令执行的主循环<code>cpu_exec()</code> (在<code>nemu/src/cpu/cpu-exec.c</code>中定义). <code>cpu_exec()</code>又会调用<code>execute()</code>, 后者模拟了CPU的工作方式: 不断执行指令. 具体地, 代码将在一个for循环中不断调用<code>exec_once()</code>函数, 这个函数的功能就是我们在上一小节中介绍的内容: 让CPU执行当前PC指向的一条指令, 然后更新PC.</p>
</blockquote>
<h4 id="任务：优美的退出"><a href="#任务：优美的退出" class="headerlink" title="任务：优美的退出"></a>任务：优美的退出</h4><blockquote>
<p>为了测试大家是否已经理解框架代码, 我们给大家设置一个练习: 如果在运行NEMU之后直接键入<code>q</code>退出, 你会发现终端输出了一些错误信息. 请分析这个错误信息是什么原因造成的, 然后尝试在NEMU中修复它.</p>
</blockquote>
<p>​	当我们执行任务中的流程后，终端显示错误信息，我们如何通过错误信息找到解决方法呢？</p>
<p><img src="/../images/PA1-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0%E7%9A%84%E7%AF%87%E7%AB%A0-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%88%AA%E5%B1%8F2023-09-21%2008.38.12-5256718.png" alt="截屏2023-09-21 08.38.12"></p>
<p>​	先试试阅读make显示的出错位置的信息，大概了解到在执行NEMU的时候出错，但笔者在漫长的查找下并没有找到出错的原因：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run: run-env</span><br><span class="line">	$(call git_commit, &quot;run NEMU&quot;)</span><br><span class="line">	$(NEMU_EXEC)</span><br></pre></td></tr></table></figure>

<p>​	换个思路：试一试神奇的GDB，首先我们通过<code>make menuconfig</code>命令，进入<code>config</code>页面，勾选<code>Build Options</code>中的<code>Enable debug information</code>，退出后执行<code>make clean</code>，<code>make gdb</code>进入gdb，通过执行gdb我们发现gdb输出<code>Inferior 1 (process 10465) exited with code 01</code>，RTFW后我们知道： “Exited with code N” just refers to the value returned from <code>main()</code>. 同时，<code>return is_exit_status_bad()</code> 暗示了<code>main</code>的返回值，<del>按照之前写代码的经验，main函数通常在最后返回的是0</del>。<img src="/../images/PA1-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0%E7%9A%84%E7%AF%87%E7%AB%A0-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%88%AA%E5%B1%8F2023-09-21%2009.09.15-5258561-5258563.png" alt="截屏2023-09-21 09.09.15"></p>
<p>​	现在明确目标，找到<code>is_exit_status_bad()</code>并弄清它做了什么。在linux中，我们使用grep命令在文件中查找：<img src="/../images/PA1-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0%E7%9A%84%E7%AF%87%E7%AB%A0-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%88%AA%E5%B1%8F2023-09-21%2009.16.40.png" alt="截屏2023-09-21 09.16.40"></p>
<p>​	查阅函数，在包含的头文件中弄清函数中的宏表示什么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// src/utils/state.c</span><br><span class="line"></span><br><span class="line">#include &lt;utils.h&gt;</span><br><span class="line"></span><br><span class="line">NEMUstate nemu_state = &#123; .state = NEMU_STOP&#125;</span><br><span class="line">int good = (nemu_state.state == NEMU_END &amp;&amp; nemu_state.alt_ret == 0) || (nemu_state.state == NEMU_QUIT);</span><br><span class="line"></span><br><span class="line">return !good;</span><br></pre></td></tr></table></figure>

<p>​	<code>utils.h</code>中<code>enum &#123;NEMU_RUNNING, NEMU_STOP, NEMU_END, NEMU_ABORT, NEMU_QUIT&#125;</code> 。</p>
<p>​	当退出状态是“好”的，<code>good == 1</code>，返回0，反之，返回1。</p>
<p>​	现在，使用gdb设置断点，打印信息，笔者发现，在从nemu_state声明后到程序执行结束时，nemu_state.state &#x3D;&#x3D; 1且nemu_state.halt_ret &#x3D;&#x3D; 0，明显，此时good被置为0。那么，但NEMU状态为stop时，也是一个可以退出的“好”状态，修改代码，完成优美地退出。<img src="/../images/PA1-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0%E7%9A%84%E7%AF%87%E7%AB%A0-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%88%AA%E5%B1%8F2023-09-21%2012.37.11-5271038.png" alt="截屏2023-09-21 12.37.11"></p>
<h2 id="基础设施-简易调试器"><a href="#基础设施-简易调试器" class="headerlink" title="基础设施: 简易调试器"></a>基础设施: 简易调试器</h2><p>后面的任务是要在monitor里面完成下图的功能：</p>
<blockquote>
<p><img src="/../images/PA1-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0%E7%9A%84%E7%AF%87%E7%AB%A0-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%88%AA%E5%B1%8F2023-10-10%2016.13.38-6925623.png" alt="截屏2023-10-10 16.13.38"></p>
</blockquote>
<h3 id="解析命令"><a href="#解析命令" class="headerlink" title="解析命令"></a>解析命令</h3><p>​	第一步是解析命令，其实就是处理字符串，等到下面实现操作的时候详细说明。</p>
<h3 id="单步执行"><a href="#单步执行" class="headerlink" title="单步执行"></a>单步执行</h3><blockquote>
<p>单步执行的功能十分简单, 而且框架代码中已经给出了模拟CPU执行方式的函数, 你只要使用相应的参数去调用它就可以了. 如果你仍然不知道要怎么做, RTFSC.</p>
</blockquote>
<h3 id="打印寄存器"><a href="#打印寄存器" class="headerlink" title="打印寄存器"></a>打印寄存器</h3><blockquote>
<p>打印寄存器就更简单了. 不过既然寄存器的结构是ISA相关的, 我们希望能为简易调试器屏蔽ISA的差异. 框架代码已经为大家准备了如下的API:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// nemu/src/isa/$ISA/reg.c</span><br><span class="line">void isa_reg_display(void);</span><br></pre></td></tr></table></figure>

<p>执行<code>info r</code>之后, 就调用<code>isa_reg_display()</code>, 在里面直接通过<code>printf()</code>输出所有寄存器的值即可. 如果你从来没有使用过<code>printf()</code>, 请RTFM或者STFW. 如果你不知道要输出什么, 你可以参考GDB中的输出.</p>
</blockquote>
<h3 id="扫描内存"><a href="#扫描内存" class="headerlink" title="扫描内存"></a>扫描内存</h3><blockquote>
<p>扫描内存的实现也不难, 对命令进行解析之后, 先求出表达式的值. 但你还没有实现表达式求值的功能, 现在可以先实现一个简单的版本: 规定表达式<code>EXPR</code>中只能是一个十六进制数, 例如</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x 10 0x80000000</span><br></pre></td></tr></table></figure>

<p>这样的简化可以让你暂时不必纠缠于表达式求值的细节. 解析出待扫描内存的起始地址之后, 就可以使用循环将指定长度的内存数据通过十六进制打印出来. 如果你不知道要怎么输出, 同样的, 你可以参考GDB中的输出. 问题是, 我们要如何访问客户计算机的内存数据呢? (答案早就说了喂)</p>
<p>实现了扫描内存的功能之后, 你可以打印<code>0x80000000</code>或者<code>0x100000</code>附近的内存, 你应该会看到程序的代码, 和内置客户程序的内容进行对比, 检查你的实现是否正确.</p>
</blockquote>
<h3 id="任务-实现单步执行-打印寄存器-扫描内存"><a href="#任务-实现单步执行-打印寄存器-扫描内存" class="headerlink" title="任务 实现单步执行, 打印寄存器, 扫描内存"></a>任务 实现单步执行, 打印寄存器, 扫描内存</h3><p>​	实现单步执行前，我们先看看程序是如何接收用户输入的。讲义给出相关代码在<code>nemu/src/monitor/sdb</code>下，观察nemu&#x2F;src&#x2F;monitor&#x2F;sdb&#x2F;sdb.c，首先看<code>main_loop</code>函数，该函数将用户的输入分解成了命令cmd和参数args，并通过便利cmd_table判断命令是否合法，然后通过handler传入参数并调用命令。在 cmd_table中添加命令，如下图所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">static struct &#123;</span><br><span class="line">  const char *name;</span><br><span class="line">  const char *description;</span><br><span class="line">  int (*handler) (char *);</span><br><span class="line">&#125; cmd_table [] = &#123;</span><br><span class="line">  &#123; &quot;help&quot;, &quot;Display information about all supported commands&quot;, cmd_help &#125;,</span><br><span class="line">  &#123; &quot;c&quot;, &quot;Continue the execution of the program&quot;, cmd_c &#125;,</span><br><span class="line">  &#123; &quot;q&quot;, &quot;Exit NEMU&quot;, cmd_q &#125;,</span><br><span class="line"></span><br><span class="line">  /* TODO: Add more commands */</span><br><span class="line">  &#123;&quot;si&quot;, &quot;Continue the excution of the program by 1 or N step&quot;, cmd_single_n_step&#125;,</span><br><span class="line">  &#123;&quot;info&quot;, &quot;Info r prints all registers, info w prints watchpoints&quot;, cmd_info_r_w&#125;,</span><br><span class="line">  &#123;&quot;x&quot;, &quot;X N EXPR scan memory at EXPR and Output N consecutive four byte numbers in hexadecimal&quot;, cmd_scan_mem&#125;,</span><br><span class="line">  &#123;&quot;p&quot;, &quot;p EXPR prints the value of EXPR&quot;, cmd_get_expr_val&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">void sdb_mainloop() &#123;</span><br><span class="line">  if (is_batch_mode) &#123;</span><br><span class="line">    cmd_c(NULL);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (char *str; (str = rl_gets()) != NULL; ) &#123;</span><br><span class="line">    char *str_end = str + strlen(str);</span><br><span class="line"></span><br><span class="line">    /* extract the first token as the command */</span><br><span class="line">    char *cmd = strtok(str, &quot; &quot;);</span><br><span class="line">    if (cmd == NULL) &#123; continue; &#125;</span><br><span class="line"></span><br><span class="line">    /* treat the remaining string as the arguments,</span><br><span class="line">     * which may need further parsing</span><br><span class="line">     */</span><br><span class="line">    char *args = cmd + strlen(cmd) + 1;</span><br><span class="line">    if (args &gt;= str_end) &#123;</span><br><span class="line">      args = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_DEVICE</span><br><span class="line">    extern void sdl_clear_event_queue();</span><br><span class="line">    sdl_clear_event_queue();</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; NR_CMD; i ++) &#123;</span><br><span class="line">      if (strcmp(cmd, cmd_table[i].name) == 0) &#123;</span><br><span class="line">        if (cmd_table[i].handler(args) &lt; 0) &#123; return; &#125;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (i == NR_CMD) &#123; printf(&quot;Unknown command &#x27;%s&#x27;\n&quot;, cmd); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	我们以单步打印为例，给出解析命令处理字符串的操作，程序已经帮我们分割了命令和参数，我们只需要处理参数即可，即 <code>si N</code>中的<code>N</code>。我们使用<code>strtok</code>处理字符串，分割空格。<code>argument</code>用来存储合法的变量。argc用来记录参数能被空格分割出多少字符。如果该参数大于1则说明输入错误并返回。如果等于1，则说明单步执行。如何找到单步执行的呢？在源码中我们发现，项目已经给出了继续执行程序需要用到的<code>cmd_c</code>，函数里调用了<code>cpu_exec</code> 然后通过grep查找该函数的实现，我们知道了这个函数就是用来实现单步&#x2F;多步打印的功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static int cmd_single_n_step(char* args ) &#123;</span><br><span class="line">	</span><br><span class="line">	// count how many arguments in args and store the number in argc</span><br><span class="line">	// store the arguments in vector argv</span><br><span class="line">	char * argument;</span><br><span class="line">	int argc = 0;</span><br><span class="line">	argument = strtok(args, &quot; &quot;);</span><br><span class="line">	if(argument != NULL) argc++;</span><br><span class="line">	char * arg = argument;</span><br><span class="line">	while(argument != NULL) &#123;</span><br><span class="line">		argument = strtok(NULL, &quot; &quot;);</span><br><span class="line">		if(argument != NULL) argc++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// if no arguments, execute 1 step</span><br><span class="line">	if(argc == 0) &#123;</span><br><span class="line">		cpu_exec(1);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if(argc &gt; 1) &#123;</span><br><span class="line">		printf(&quot;si N need only 1 argument\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i = 0; i &lt; strlen(arg); ++i) &#123;</span><br><span class="line">		if(!isdigit(arg[i])) &#123;</span><br><span class="line">			printf(&quot;arguments in si N should be a non-zero number\n&quot;);</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int step_num = atoi(arg);</span><br><span class="line">	cpu_exec(step_num);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	单&#x2F;多步打印的结果展示：</p>
<p><img src="/../images/PA1-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0%E7%9A%84%E7%AF%87%E7%AB%A0-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%88%AA%E5%B1%8F2023-10-11%2013.38.21.png" alt="截屏2023-10-11 13.38.21"></p>
<p>​	接下来实现打印寄存器，命令的解析过程就不再重复，打开<code>nemu/src/isa/riscv32/reg.c</code>,发现寄存器的名字已经给出了，我们需要找到寄存器的值存储在什么位置。寄存器是cpu的一个组成部分，通过grep命令检索cpu，发现其类型为<code>CPU_state</code>，接着检索<code>CPU_state</code>，在<code>include/isa.h</code>中发现他的定义，最终我们找到结构体的定义，数组<code>gpr</code>就是我们所需的寄存器的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  word_t gpr[MUXDEF(CONFIG_RVE, 16, 32)];</span><br><span class="line">  vaddr_t pc;</span><br><span class="line">&#125; MUXDEF(CONFIG_RV64, riscv64_CPU_state, riscv32_CPU_state);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	接着，实现简单的打印步骤就好。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;isa.h&gt;</span><br><span class="line">#include &quot;local-include/reg.h&quot;</span><br><span class="line"></span><br><span class="line">const char *regs[] = &#123;</span><br><span class="line">  &quot;$0&quot;, &quot;ra&quot;, &quot;sp&quot;, &quot;gp&quot;, &quot;tp&quot;, &quot;t0&quot;, &quot;t1&quot;, &quot;t2&quot;,</span><br><span class="line">  &quot;s0&quot;, &quot;s1&quot;, &quot;a0&quot;, &quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;, &quot;a4&quot;, &quot;a5&quot;,</span><br><span class="line">  &quot;a6&quot;, &quot;a7&quot;, &quot;s2&quot;, &quot;s3&quot;, &quot;s4&quot;, &quot;s5&quot;, &quot;s6&quot;, &quot;s7&quot;,</span><br><span class="line">  &quot;s8&quot;, &quot;s9&quot;, &quot;s10&quot;, &quot;s11&quot;, &quot;t3&quot;, &quot;t4&quot;, &quot;t5&quot;, &quot;t6&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void isa_reg_display() &#123;</span><br><span class="line">	for(int i = 0; i &lt; 32; ++i) &#123;</span><br><span class="line">		printf(&quot;reg:\t %s\t\t\t %x\n&quot;, regs[i], cpu.gpr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	打印寄存器的结果：<br>​	</p>
<p><img src="/../images/PA1-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0%E7%9A%84%E7%AF%87%E7%AB%A0-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%88%AA%E5%B1%8F2023-10-11%2013.39.41-7789397.png" alt="截屏2023-10-11 13.39.41"></p>
<p>​	实现扫描内存的关键在于如何访问计算机的内存数据，回顾<code>RTFSC</code>一节，内存相关代码在<code>nemu/src/memory</code>当中，那就继续阅读源码，尝试能否找到答案。我们知道<code>nemu</code>是一个运行在主机上的虚拟机，<code>host.h</code>用于判断物理机器的机器字长并修改虚拟机的相关字长。<code>paddr.c</code>的作用是对<code>NEMU</code>和主机上的内存进行映射。项目已经实现了读取内存的函数<code>vaddr_read()</code>和判断内存地址是否合法的函数<code>in_pmem()</code>，我们只需要传入对应的参数即可完成扫描内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static int cmd_scan_mem(char * args) &#123;</span><br><span class="line">	int argc = 0;</span><br><span class="line">	char * argv[2];</span><br><span class="line">	argv[argc] = strtok(args, &quot; &quot;);</span><br><span class="line">	if(argv[argc]) ++argc;</span><br><span class="line">	while(argv[argc] != NULL) &#123;</span><br><span class="line">		argv[argc] = strtok(NULL, &quot; &quot;);</span><br><span class="line">		if(argv[argc]) ++argc;</span><br><span class="line">	&#125;</span><br><span class="line">	if(argc == 0 || argc &gt; 2) &#123;</span><br><span class="line">		printf(&quot;command x N EXPR, needs 2 arguments\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i = 0; i &lt; strlen(argv[0]); ++i) &#123;</span><br><span class="line">		if(!isdigit(argv[0][i])) &#123;</span><br><span class="line">			printf(&quot;N in command x N EXPR must be digit\n&quot;);</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	paddr_t addr_val = 0;</span><br><span class="line">	if(!hexStr2Dec(argv[1], &amp;addr_val)) &#123;</span><br><span class="line">		printf(&quot;EXPR in command x N EXPR must be hex type\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	// printf(&quot;DEBUG hexStr2Val: argv[1]: %s\taddr_val: %x\n&quot;, argv[1], addr_val);</span><br><span class="line">	</span><br><span class="line">	// judge if addr is legal </span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	for(int i = 0; i &lt; atoi(argv[0]); ++i) &#123;</span><br><span class="line">		if(!in_pmem(addr_val + 4 * i)) &#123;</span><br><span class="line">			printf(&quot;addr_val: 0x%x is illegal\n&quot;, addr_val + 4 * i);</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		word_t mem_output = paddr_read(addr_val + 4 * i, 4);</span><br><span class="line">		printf(&quot;0x%8x:\t0x%8x\n&quot;, addr_val + 4 * i, mem_output);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	内存扫描的结果：</p>
<p><img src="/../images/PA1-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0%E7%9A%84%E7%AF%87%E7%AB%A0-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%88%AA%E5%B1%8F2023-10-11%2013.41.22-7002890.png" alt="截屏2023-10-11 13.41.22"></p>
<h2 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h2><h3 id="任务-实现算术表达式的词法分析"><a href="#任务-实现算术表达式的词法分析" class="headerlink" title="任务 实现算术表达式的词法分析"></a>任务 实现算术表达式的词法分析</h3><blockquote>
<p>你需要完成以下的内容:</p>
<ul>
<li>为算术表达式中的各种token类型添加规则, 你需要注意C语言字符串中转义字符的存在和正则表达式中元字符的功能.</li>
<li>在成功识别出token后, 将token的信息依次记录到<code>tokens</code>数组中.</li>
</ul>
</blockquote>
<p>​	这个比较简单，把常用的一些字符按照正则表达式的形式写入<code>enmu</code>和<code>rules</code>就好了，其实这里注意<code>enum</code>中的变量名需要和下文<code>switch</code>中的变量名保持一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">  TK_NOTYPE = 256, </span><br><span class="line">  TK_ADD, </span><br><span class="line">  TK_EQ,</span><br><span class="line"></span><br><span class="line">  /* TODO: Add more token types */</span><br><span class="line">  TK_SUB, </span><br><span class="line">  TK_MUL, </span><br><span class="line">  TK_LB, </span><br><span class="line">  TK_RB, </span><br><span class="line">  TK_DEC,</span><br><span class="line">  TK_DIV,</span><br><span class="line">  TK_NEG,</span><br><span class="line">  TK_POINT, // 指针解引用 *p</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct rule &#123;</span><br><span class="line">  const char *regex;</span><br><span class="line">  int token_type;</span><br><span class="line">&#125; rules[] = &#123;</span><br><span class="line"></span><br><span class="line">  /* TODO: Add more rules.</span><br><span class="line">   * Pay attention to the precedence level of different rules.</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  &#123;&quot; +&quot;, TK_NOTYPE&#125;,    // spaces</span><br><span class="line">  &#123;&quot;\\+&quot;, TK_ADD&#125;,         // plus</span><br><span class="line">  &#123;&quot;==&quot;, TK_EQ&#125;,        // equal</span><br><span class="line">  &#123;&quot;-&quot;, TK_SUB&#125;,	// sub</span><br><span class="line">  &#123;&quot;\\*&quot;, TK_MUL&#125;,	// multiply</span><br><span class="line">  &#123;&quot;/&quot;, TK_DIV&#125;,		// divide</span><br><span class="line">  &#123;&quot;\\(&quot;, TK_LB&#125;,		// left bracket</span><br><span class="line">  &#123;&quot;\\)&quot;, TK_RB&#125;,		// right bracket</span><br><span class="line">  &#123;&quot;[0-9]+&quot;, TK_DEC&#125;, // decimal number</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="任务-实现算术表达式的递归求值"><a href="#任务-实现算术表达式的递归求值" class="headerlink" title="任务 实现算术表达式的递归求值"></a>任务 实现算术表达式的递归求值</h3><p>​	这算一个比较难得步骤，我们要实现<code>eval(p,q)</code>和<code>check_parentheses()</code>函数。讲义给出了<code>eval</code>的框架。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">eval(p, q) &#123;</span><br><span class="line">  if (p &gt; q) &#123;</span><br><span class="line">    /* Bad expression */</span><br><span class="line">  &#125;</span><br><span class="line">  else if (p == q) &#123;</span><br><span class="line">    /* Single token.</span><br><span class="line">     * For now this token should be a number.</span><br><span class="line">     * Return the value of the number.</span><br><span class="line">     */</span><br><span class="line">  &#125;</span><br><span class="line">  else if (check_parentheses(p, q) == true) &#123;</span><br><span class="line">    /* The expression is surrounded by a matched pair of parentheses.</span><br><span class="line">     * If that is the case, just throw away the parentheses.</span><br><span class="line">     */</span><br><span class="line">    return eval(p + 1, q - 1);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    /* We should do more things here. */</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	第一二种情况就不再赘述。从第三种情况开始，我们先实现括号匹配函数<code>check_parentheses()</code>，大概思路就是判断位置<code>p</code>的括号是否和位置<code>q</code>的括号相匹配。我们用一个栈来实现，不过需要注意的是，不同于处理字符串的括号匹配算法，我们需要将括号<code>p</code>的位置也存入栈中，以便将来出栈时判断和左括号<code>p</code>匹配的右括号是否为<code>q</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool check_parentheses(int p, int q) &#123;</span><br><span class="line">	if(tokens[p].type != TK_LB || tokens[q].type != TK_RB) return false;</span><br><span class="line">	SqStack *S = (SqStack*)malloc(sizeof(SqStack));</span><br><span class="line">	initStack(S);</span><br><span class="line"></span><br><span class="line">	for(int i = p; i &lt;= q; ++i) &#123;</span><br><span class="line">		if(tokens[i].type == TK_LB) &#123;</span><br><span class="line">			push(S, &#x27;(&#x27;, i);</span><br><span class="line">		&#125; else if(tokens[i].type == TK_RB) &#123;</span><br><span class="line">			char* x = (char*)malloc(sizeof(char));</span><br><span class="line">			int* pos = (int*)malloc(sizeof(int));</span><br><span class="line">			if(!pop(S, x, pos)) &#123; return false; &#125; </span><br><span class="line">			if( *pos == p &amp;&amp; i == q) return true;</span><br><span class="line">			else if(*pos == p || i == q) return false;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	if(!isEmpty(S)) return false;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	如果匹配成功，则丢掉这两个匹配的括号继续递归求值。</p>
<p>​	<code>else</code>中的内容是笔者借鉴的，确实没有想出来如何找到主元素。</p>
<blockquote>
<p>​	上面的框架已经考虑了BNF中算术表达式的开头两种定义, 接下来我们来考虑剩下的情况(即上述伪代码中最后一个<code>else</code>中的内容). 一个问题是, 给出一个最左边和最右边不同时是括号的长表达式, 我们要怎么正确地将它分裂成两个子表达式? 我们定义”主运算符”为表达式人工求值时, 最后一步进行运行的运算符, 它指示了表达式的类型(例如当一个表达式的最后一步是减法运算时, 它本质上是一个减法表达式). 要正确地对一个长表达式进行分裂, 就是要找到它的主运算符. </p>
<p>…</p>
<p>…</p>
<p>通过上面这个简单的例子, 我们就可以总结出如何在一个token表达式中寻找主运算符了:</p>
<ul>
<li>非运算符的token不是主运算符.</li>
<li>出现在一对括号中的token不是主运算符. 注意到这里不会出现有括号包围整个表达式的情况, 因为这种情况已经在<code>check_parentheses()</code>相应的<code>if</code>块中被处理了.</li>
<li>主运算符的优先级在表达式中是最低的. 这是因为主运算符是最后一步才进行的运算符.</li>
<li>当有多个运算符的优先级都是最低时, 根据结合性, 最后被结合的运算符才是主运算符. 一个例子是<code>1 + 2 + 3</code>, 它的主运算符应该是右边的<code>+</code>.</li>
</ul>
</blockquote>
<p>​	照着讲义的思路，给出以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/* find the position of main operator in token expression using recursion */</span><br><span class="line">		int op = 0;	// 主元素的位置</span><br><span class="line">		int minPriority = 5;	// 初始时最小优先级设为 5</span><br><span class="line">		int curPriority = 0;  // 当前优先级为 0</span><br><span class="line">		int brackets = 0; 		// 记录括号，因为在括号中的运算符优先级最高，而我们的目的是找到最小优先级，故当存在括号时，当前操作符的优先级被设为最高 5</span><br><span class="line">		/* 以下考虑 ‘+ - * / ==’ */</span><br><span class="line">		</span><br><span class="line">		for (int i = p; i &lt;= q; ++i) &#123;</span><br><span class="line">			if (tokens[i].type == TK_MUL || tokens[i].type == TK_DIV) &#123;</span><br><span class="line">				if (brackets == 0) &#123; curPriority = 4; &#125;	// 乘除法的优先级为 4</span><br><span class="line">				else &#123; curPriority = 5; &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (tokens[i].type == TK_ADD || tokens[i].type == TK_SUB) &#123;</span><br><span class="line">				if (brackets == 0) &#123; curPriority = 3; &#125;	// 加减法优先级为 3</span><br><span class="line">				else &#123; curPriority = 5; &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (tokens[i].type == TK_EQ) &#123;</span><br><span class="line">				if (brackets == 0) &#123; curPriority = 2; &#125;	// 等号优先级为 2</span><br><span class="line">				else &#123; curPriority = 5; &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (tokens[i].type == TK_LB) &#123;</span><br><span class="line">				++brackets;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (tokens[i].type == TK_RB) &#123;</span><br><span class="line">				--brackets;</span><br><span class="line">				continue;</span><br><span class="line">			&#125; else &#123; continue; &#125;</span><br><span class="line">			/* 	如果当前操作符优先级 &lt;= 最小优先级(取等号的原因是最后被结合的运算符才是主运算符) </span><br><span class="line">			 *	则替换主操作符位置</span><br><span class="line">			*/</span><br><span class="line">			if(curPriority &lt;= minPriority) &#123;</span><br><span class="line">				minPriority = curPriority;</span><br><span class="line">				op = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		/* 找到主操作符后，分割并递归求值 */</span><br><span class="line">		uint32_t val1 = eval(p, op -1, flag);</span><br><span class="line">		uint32_t val2 = eval(op + 1, q, flag);</span><br><span class="line">		/* 执行操作后返回值 */</span><br><span class="line">		switch(tokens[op].type) &#123;</span><br><span class="line">			case TK_ADD: </span><br><span class="line">				return val1 + val2;</span><br><span class="line">			case TK_SUB: </span><br><span class="line">				return val1 - val2;</span><br><span class="line">			case TK_MUL:</span><br><span class="line">				return val1 * val2;</span><br><span class="line">			case TK_EQ:</span><br><span class="line">				return val1 == val2;</span><br><span class="line">			case TK_DIV:</span><br><span class="line">				return val1 / val2;</span><br><span class="line">			default:</span><br><span class="line">				printf(&quot;func eval switch bad type\n&quot;);</span><br><span class="line">				assert(0);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>​	接着完善<code>expr()</code>函数，该函数先识别字符串并存储到<code>tokens</code>数组中去，接着便利所有规则，对负数，接触引用等具有特殊含义的token进行重新标记，以便后续<code>eval()</code>函数识别并处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">word_t expr(char *e, bool *success) &#123;</span><br><span class="line">  // 如果不在给定的token之中，则返回0，并置为false</span><br><span class="line">  if (!make_token(e)) &#123;</span><br><span class="line">    *success = false;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  /* TODO: Insert codes to evaluate the expression. */</span><br><span class="line">  // TODO();</span><br><span class="line">  // 遍历所有规则</span><br><span class="line">  for(int i = 0; i &lt; nr_token; ++i) &#123;</span><br><span class="line">	  // if the type is &#x27;-&#x27; and it is the first symbol of the expr, it is a negtive flag</span><br><span class="line">	  if( tokens[i].type == TK_SUB) &#123;</span><br><span class="line">		  if (i == 0) &#123; tokens[i].type = TK_NEG; &#125;</span><br><span class="line">		  else if(tokens[i - 1].type == TK_ADD </span><br><span class="line">			|| tokens[i - 1].type == TK_SUB</span><br><span class="line">			|| tokens[i - 1].type == TK_MUL</span><br><span class="line">			|| tokens[i - 1].type == TK_DIV</span><br><span class="line">			|| tokens[i - 1].type == TK_LB</span><br><span class="line">			|| tokens[i - 1].type == TK_NEG</span><br><span class="line">			|| tokens[i - 1].type == TK_POINT) &#123;</span><br><span class="line">		 // in this condition, the - will be a negtive flag</span><br><span class="line">		 tokens[i].type = TK_NEG;</span><br><span class="line">	  	&#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	  else if(tokens[i].type == TK_MUL) &#123;</span><br><span class="line">		// in this condition, * will be a get value symbol</span><br><span class="line">	  	if (i == 0) &#123;</span><br><span class="line">			tokens[i].type = TK_POINT;</span><br><span class="line">		&#125; else if (i == nr_token - 1) &#123;</span><br><span class="line">			*success = false;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125; else if (tokens[i - 1].type == TK_ADD </span><br><span class="line">				|| tokens[i - 1].type == TK_SUB</span><br><span class="line">				|| tokens[i - 1].type == TK_MUL</span><br><span class="line">				|| tokens[i - 1].type == TK_DIV</span><br><span class="line">				|| tokens[i - 1].type == TK_LB</span><br><span class="line">				|| tokens[i - 1].type == TK_NEG</span><br><span class="line">				|| tokens[i - 1].type == TK_POINT) &#123;</span><br><span class="line">			tokens[i].type = TK_POINT;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *success = true;</span><br><span class="line">  return eval(0, nr_token - 1, success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	效果如下图所示：</p>
<p>​	<img src="/../images/PA1-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0%E7%9A%84%E7%AF%87%E7%AB%A0-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%88%AA%E5%B1%8F2023-10-11%2014.13.58-7004844.png" alt="截屏2023-10-11 14.13.58"></p>
<h3 id="任务-实现表达式生成器"><a href="#任务-实现表达式生成器" class="headerlink" title="任务  实现表达式生成器"></a>任务  实现表达式生成器</h3><blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gen_rand_expr</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (choose(<span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: gen_num(); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: gen(<span class="string">&#x27;(&#x27;</span>); gen_rand_expr(); gen(<span class="string">&#x27;)&#x27;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: gen_rand_expr(); gen_rand_op(); gen_rand_expr(); <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上文内容, 实现表达式生成器. 实现后, 就可以用来生成表达式求值的测试用例了.</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gen-expr 10000 &gt; input</span><br></pre></td></tr></table></figure>

<p>将会生成10000个测试用例到<code>input</code>文件中, 其中每行为一个测试用例, 其格式为</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果 表达式</span><br></pre></td></tr></table></figure>

<p>再稍微改造一下NEMU的<code>main()</code>函数, 让其读入<code>input</code>文件中的测试表达式后, 直接调用<code>expr()</code>, 并与结果进行比较. 为了容纳长表达式的求值, 你还需要对<code>tokens</code>数组的大小进行修改.</p>
<p>随着你的程序通过越来越多的测试, 你会对你的代码越来越有信心.</p>
</blockquote>
<p>​	这里就直接把代码贴出来了，生成的错误表达式将直接被程序抛弃，这个功能<code>NEMU</code>已经实现了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">int index_buf = 0;</span><br><span class="line"></span><br><span class="line">int choose(int n)&#123;</span><br><span class="line">    int flag = rand() % 3 ; // 0 1 2</span><br><span class="line">	printf(&quot;index = %d, flag = %d. \n&quot;,index_buf, flag);</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br><span class="line">void gen_num()&#123;</span><br><span class="line">    int num = rand()% 100;</span><br><span class="line">    int num_size = 0, num_tmp = num;</span><br><span class="line">    while(num_tmp)&#123;</span><br><span class="line">	num_tmp /= 10;</span><br><span class="line">	num_size ++;</span><br><span class="line">    &#125;</span><br><span class="line">    int x = 1;</span><br><span class="line">    while(num_size)</span><br><span class="line">    &#123;</span><br><span class="line">	x *= 10;</span><br><span class="line">	num_size -- ;</span><br><span class="line">    &#125;</span><br><span class="line">    x /= 10;</span><br><span class="line">    while(num)</span><br><span class="line">    &#123;</span><br><span class="line">	char c = num / x + &#x27;0&#x27;;</span><br><span class="line">	num %= x;</span><br><span class="line">	x /= 10;</span><br><span class="line">	buf[index_buf ++] = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void gen(char c)&#123;</span><br><span class="line">    buf[index_buf ++] = c;</span><br><span class="line">&#125;</span><br><span class="line">void gen_rand_op()&#123;</span><br><span class="line">    char op[4] = &#123;&#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27;, &#x27;/&#x27;&#125;;</span><br><span class="line">    int op_position = rand() % 4;</span><br><span class="line">    buf[index_buf ++] = op[op_position];</span><br><span class="line">&#125;</span><br><span class="line">static void gen_rand_expr() &#123;</span><br><span class="line">  //  buf[0] = &#x27;\0&#x27;;</span><br><span class="line">  /*</span><br><span class="line">   * switch (choose(3)) &#123;</span><br><span class="line">   *	case 0: gen_num(); break;</span><br><span class="line">   *	case 1: gen(&#x27;(&#x27;); gen_rand_expr(); gen(&#x27;)&#x27;); break;</span><br><span class="line">   *	default: gen_rand_expr(); gen_rand_op(); gen_rand_expr(); break;</span><br><span class="line">   * &#125;</span><br><span class="line">   * */</span><br><span class="line">	switch(choose(3)) &#123;</span><br><span class="line">		case 0: </span><br><span class="line">			gen_num();</span><br><span class="line">			break;</span><br><span class="line">		case 1: gen(&#x27;(&#x27;);</span><br><span class="line">			gen_rand_expr();</span><br><span class="line">			gen(&#x27;)&#x27;);</span><br><span class="line">			break;</span><br><span class="line">		default:</span><br><span class="line">			gen_rand_expr();</span><br><span class="line">			gen_rand_op();</span><br><span class="line">			gen_rand_expr();</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/22/dlco-nju/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/22/dlco-nju/" class="post-title-link" itemprop="url">dlco_nju</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-22 15:13:02" itemprop="dateCreated datePublished" datetime="2023-08-22T15:13:02+08:00">2023-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-13 17:26:26" itemprop="dateModified" datetime="2023-09-13T17:26:26+08:00">2023-09-13</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="南京大学-计算机科学与技术系-数字逻辑与计算机组成-课程实验"><a href="#南京大学-计算机科学与技术系-数字逻辑与计算机组成-课程实验" class="headerlink" title="南京大学 计算机科学与技术系 数字逻辑与计算机组成 课程实验"></a><a target="_blank" rel="noopener" href="https://nju-projectn.github.io/dlco-lecture-note/index.html">南京大学 计算机科学与技术系 数字逻辑与计算机组成 课程实验</a></h2><h2 id="实验一-选择器"><a href="#实验一-选择器" class="headerlink" title="实验一 选择器"></a>实验一 选择器</h2><h3 id="任务：1-上板实验-二位四选一选择器；2-实现一个简单的二位四选一选择器。"><a href="#任务：1-上板实验-二位四选一选择器；2-实现一个简单的二位四选一选择器。" class="headerlink" title="任务：1.上板实验: 二位四选一选择器；2.实现一个简单的二位四选一选择器。"></a>任务：1.<strong>上板实验: 二位四选一选择器</strong>；2.实现一个简单的二位四选一选择器。</h3><blockquote>
<p>用选择器模板实现一个2位4选1的选择器，如下图所示，选择器有5个2位输入端，分别为X0, X1, X2, X3和Y，输出端为F；X0, X1, X2, X3是四个2位的输入变量。输出F端受控制端Y的控制，选择其中的一个X输出，当Y &#x3D; 00时，输出端输出X0，即F &#x3D; X0；当Y &#x3D; 01时，输出端输出X1，即F &#x3D; X1；以此类推。</p>
<p><img src="/../images/dlco-nju/%E6%88%AA%E5%B1%8F2023-08-22%2015.30.30.png" alt="截屏2023-08-22 15.30.30"></p>
<p>选择开发板上的SW0和SW1作为控制端Y，SW2—SW9作为四个两位数据输入端X0–X3，将两位的输出端F接到发光二极管LEDR0和LEDR1上显示输出，完成设计，对自己的设计进行功能仿真，并下载到开发板上验证电路性能。</p>
</blockquote>
<p>​	简单的二位四选一选择器实现比较简单，参照讲义上 <em>Listing 5</em> <em>4选1选择器case语句实现</em> 使用<code>case</code>语句实现即可。但是选择器模版应该如何使用呢？阅读并观察讲义中<em>Listing 8</em> <em>使用选择器模板实现选择器</em>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">module mux21e(a,b,s,y);</span><br><span class="line">  input   a,b,s;</span><br><span class="line">  output  y;</span><br><span class="line">  MuxKey #(2, 1, 1) i0 (y, s, &#123;</span><br><span class="line">    1&#x27;b0, a,</span><br><span class="line">    1&#x27;b1, b</span><br><span class="line">  &#125;);</span><br><span class="line">endmodule</span><br><span class="line"></span><br><span class="line">module mux41b(a,s,y);</span><br><span class="line">  input  [3:0] a;</span><br><span class="line">  input  [1:0] s;</span><br><span class="line">  output y;</span><br><span class="line">  MuxKeyWithDefault #(4, 2, 1) i0 (y, s, 1&#x27;b0, &#123;</span><br><span class="line">    2&#x27;b00, a[0],</span><br><span class="line">    2&#x27;b01, a[1],</span><br><span class="line">    2&#x27;b10, a[2],</span><br><span class="line">    2&#x27;b11, a[3]</span><br><span class="line">  &#125;);</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module MuxKey #(NR_KEY = 2, KEY_LEN = 1, DATA_LEN = 1) (</span><br><span class="line">  output [DATA_LEN-1:0] out,</span><br><span class="line">  input [KEY_LEN-1:0] key,</span><br><span class="line">  input [NR_KEY*(KEY_LEN + DATA_LEN)-1:0] lut</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>​	<code>MuxKey</code>接受6个参数，三个一组，<code>#(NR_KEY = 2, KEY_LEN = 1, DATA_LEN = 1)</code>前三个参数以#开始在()内，分别为键值对的数量，键值的位宽，数据的位宽 ，后三个参数为引脚名称，分别为输出引脚out，给定的键值和<code>(键值，数据)</code> 的列表 <code>lut</code>。</p>
<p>​	现在我们可以编写用选择器模板实现的一个2位4选1的选择器，键值对的数量为4，键值的位宽，数据的位宽均为2。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module top(X0, X1, X2, X3, Y, F);</span><br><span class="line">	input [1:0] X0, X1, X2, X3, Y;</span><br><span class="line">	output [1:0] F;</span><br><span class="line">	MuxKey #(4, 2, 2) i0 (F, Y, &#123;</span><br><span class="line">		2&#x27;b00, X0,</span><br><span class="line">		2&#x27;b01, X1,</span><br><span class="line">		2&#x27;b10, X2,</span><br><span class="line">		2&#x27;b11, X3	</span><br><span class="line">		&#125;);</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<p>​	此时编译未成功，提示缺少模块<code>MuxKey</code>。如何结构化模块？首先寻找示例代码中是否有相关的例子。观察到<code>nvboard/example/vsrc</code>中有多个<code>.v</code>文件，且<code>top.v</code>中有实例化模块的例子，这说明该示例使用了结构化模块，阅读<code>Makefile</code>文件发现，编译时使用–top-module指出顶层模块名。我们仿照示例编写<code>Makefile</code>文件，并在目录中添加<code>MuxKey.v</code>和<code>MuxKeyInternal.v</code>模块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(VERILATOR) $(VERILATOR_CFLAGS) \</span><br><span class="line">		--top-module $(TOPNAME) $^ \</span><br><span class="line">		$(addprefix -CFLAGS , $(CFLAGS)) $(addprefix -LDFLAGS , $(LDFLAGS)) \</span><br><span class="line">		--Mdir $(OBJ_DIR) --exe -o $(abspath $(BIN))</span><br></pre></td></tr></table></figure>

<p>​	通过前一节搭建verilator仿真环境，我们知道如何在<code>nvboard</code>上连接引脚进行测试。此处就不再赘述。实现效果如下：	 <img src="/../images/dlco-nju/%E6%88%AA%E5%B1%8F2023-08-22%2015.55.17-2690921.png" alt="截屏2023-08-22 15.55.17"></p>
<p>​	当使能端<code>Y = 10</code>时，选择器选择<code>X2 = 11</code>，<code>LED0，LED1</code>被点亮。而不会输出其他信号。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>​	不要使用行为建模方式设计电路，即Verilog不像C语言编程一样是在过程中发现错误并优化代码的。一定要在脑海或者图纸上先将电路画出来，再进行编码仿真。特别是当开发者心里没有电路但期望通过行为建模让综合器生成某种行为的电路，这就已经偏离“描述电路”的本质了。对于代码来说，多尝试总是没错的，尽量把自己脑海中想到的东西写下来验证，电脑永远是对的。</p>
<h3 id="遗留问题："><a href="#遗留问题：" class="headerlink" title="遗留问题："></a>遗留问题：</h3><blockquote>
<p>​	所以，直到大家掌握“描述电路”的思维而不被行为建模误导之前，我们强烈建议初学者远离行为建模方式，仅通过数据流建模和结构化建模方式直接描述电路。例如，上文关于if和always的说法从某种程度上来说是正确的，但下面的问题可以帮助大家测试自己是否已经掌握了Verilog的本质：</p>
<ul>
<li>在硬件描述语言中，“执行”的精确含义是什么？</li>
<li>是谁在执行Verilog的语句？ 是电路，综合器，还是其它的？</li>
<li>if的条件满足，就不执行else后的语句，这里的“不执行”又是什么意思？ 和描述电路有什么联系？</li>
<li>有“并发执行”，又有“顺序执行”，还有“任何一个变量发生变化就立即执行”，以及“在任何情况下都执行”，它们都是如何在设计出来的电路中体现的？</li>
</ul>
<p>​	如果你无法对这些问题作出明确的回答，我们强烈建议你不要使用行为建模方式。如果你真的想弄懂它们，你需要阅读 <a target="_blank" rel="noopener" href="https://nju-projectn.github.io/dlco-lecture-note/exp/inst.eecs.berkeley.edu/~cs150/fa06/Labs/verilog-ieee.pdf">Verilog标准手册</a> 。</p>
</blockquote>
<p>​		标准手册太长了，留着慢慢读。</p>
<h2 id="实验二-译码器和编码器"><a href="#实验二-译码器和编码器" class="headerlink" title="实验二 译码器和编码器"></a>实验二 译码器和编码器</h2><h3 id="任务：实现一个8-3优先编码器并在七段数码管上显示"><a href="#任务：实现一个8-3优先编码器并在七段数码管上显示" class="headerlink" title="任务：实现一个8-3优先编码器并在七段数码管上显示"></a>任务：<strong>实现一个8-3优先编码器并在七段数码管上显示</strong></h3><blockquote>
<p><strong>功能描述</strong></p>
<p>查找8-3优先编码器相关原理和实现方法，实现一个8-3编码器，完成8-3编码器的设计、功能仿真和硬件实现。</p>
<p>输入一个8位二进制数，对此8位二进制数进行高位优先编码成一个3位二进制值，并根据是否有输入增加一位输入指示位，即8个输入全0时指示位为0，有任何一个输入为1时指示位为1。编码器的使能端可选实现。将此编码结果及指示位以二进制形式显示在四个发光二极管LED上。再将此结果跟据七段数码管的显示进行译码，将二进制的优先编码结果以十进制的形式显示在数码管上。</p>
<p><strong>输入输出建议</strong></p>
<p>输入可以使用拨动开关SW7-SW0。使能端可以用SW8。输出为LED2-0，输出指示可以是LED4，数码管输出为HEX0。</p>
<p>例：我们从SW7—SW0输入00001110，因为我们设计的是一个高位优先的优先编码器，从左（高位）开始，第一位为1的是第3号位，那么优先编码器的编码二进制结果就为011，将这个值显示在发光二极管上，并且指示位也同时置为1。再对这个数值跟据七段数码管的显示进行译码，此时应显示为 <code>3</code> ，用HEX0显示，所以HEX0[6:0]应该译码为0110000（注意高低位顺序），那么在七段数码管上就会显示 <code>3</code> 这个字符。</p>
</blockquote>
<p>​	首先我们先在<code>vsrc</code>中新建文件<code>bcd7seg.v</code>实现七段数码管编码的模块。该模块在网上已经有很多实现方式了，这里需要注意一点，我们在<code>nvboard/board/N4</code>中能找到LED数码管每个管的名称，在组合显示数字时多尝试查看显示是否正确。接着实现顶层模块<code>top.v</code>，代码及注释如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">module top(x, en, y, f, led);</span><br><span class="line">	input [7:0] x;	//输入码</span><br><span class="line">	input en;	// 使能端</span><br><span class="line">	output reg [6:0] led; // 灯，数码管的引脚</span><br><span class="line">	output reg f;					// 输入指示位</span><br><span class="line">	output reg [2:0] y;		// 输出编码</span><br><span class="line">	integer i;</span><br><span class="line">	</span><br><span class="line">	// 实例化七段数码管编码模块</span><br><span class="line">	bcd7seg seg(</span><br><span class="line">		.b(&#123;1&#x27;b0, y&#125;), //接入引脚</span><br><span class="line">		.h(led)</span><br><span class="line">	);</span><br><span class="line">	</span><br><span class="line">	// 逻辑</span><br><span class="line">	always @(x or en) begin</span><br><span class="line">		f = 0;</span><br><span class="line">		if (en) begin</span><br><span class="line">			y = 0;</span><br><span class="line">			for(i = 0; i &lt;= 7; i = i + 1)</span><br><span class="line">				if(x[i] == 1) begin </span><br><span class="line">					y = i[2:0];	// 把十进制i转化为3位二进制数存入y中</span><br><span class="line">					f = 1&#x27;b1;</span><br><span class="line">				end</span><br><span class="line">			end</span><br><span class="line">		else y = 0;</span><br><span class="line">	end</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	<code>nvboard</code>的引脚接线和<code>Makefile</code>参照上一个实验即可。</p>
<p>​	最终效果如下图所示，<code>LED4</code>是输入指示位，<code>SW8</code>是使能端，当使能端为1时允许输出，输入端为<code>00010100</code>，由于是优先编码，最高位4对应的LED2被点亮，数码管显示4。</p>
<p><img src="/../images/dlco-nju/%E6%88%AA%E5%B1%8F2023-08-22%2016.41.08-2693675-2693707.png" alt="截屏2023-08-22 16.41.08"></p>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>​	在实例化时发现引脚数目不对，8-3优先编码器的输出端为3位而数码管的输入端为4位，用<code>&#123;&#125;</code>将输出扩展一位达到效果。</p>
<p>​	在数字电路设计与计算机组成一书中有提到电路中存在高阻态<code>Z</code>和不定值<code>X</code>，这类状态在<code>Verilog</code>中用<code>casez</code>和<code>casex</code>解决。首先要明确的是’?’代表的不是don’t care，而是’z’。再有就是case&#x2F;casez&#x2F;casex其实都是可综合的，这一点也要记住。</p>
<p> 区分：</p>
<ul>
<li><p>case语句的表达式的值有4中情况：0、1、z、x。4种是不同的，故表达式要严格的相等才可以操作分支语句。</p>
</li>
<li><p>casez语句中的表达式情况有三种：0、1、x。不用关心z，z可以和任何数值相等，即z &#x3D;0.z&#x3D; 1,z&#x3D;x;</p>
</li>
<li><p>casex语句的表达式情况有二种：0、1.不用关心x和z。即x&#x3D;z&#x3D;0,x&#x3D;z&#x3D;1<img src="/../images/dlco-nju/%E6%88%AA%E5%B1%8F2023-08-22%2017.02.57-2694983.png" alt="截屏2023-08-22 17.02.57"></p>
</li>
</ul>
<p>​		<code>casez </code>用<code>?</code>表示无关项；<code>casex</code>用<code>x</code>表示无关值。</p>
<h2 id="实验三-加法器与ALU"><a href="#实验三-加法器与ALU" class="headerlink" title="实验三 加法器与ALU"></a>实验三 加法器与ALU</h2><h3 id="任务：实现一个带有逻辑运算的简单ALU"><a href="#任务：实现一个带有逻辑运算的简单ALU" class="headerlink" title="任务：实现一个带有逻辑运算的简单ALU"></a>任务：<strong>实现一个带有逻辑运算的简单ALU</strong></h3><blockquote>
<p>设计一个能实现如下功能的4位带符号位的 <strong>补码</strong> ALU：</p>
<table>
<thead>
<tr>
<th>功能选择</th>
<th>功能</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>000</td>
<td>加法</td>
<td>A+B</td>
</tr>
<tr>
<td>001</td>
<td>减法</td>
<td>A-B</td>
</tr>
<tr>
<td>010</td>
<td>取反</td>
<td>Not A</td>
</tr>
<tr>
<td>011</td>
<td>与</td>
<td>A and B</td>
</tr>
<tr>
<td>100</td>
<td>或</td>
<td>A or B</td>
</tr>
<tr>
<td>101</td>
<td>异或</td>
<td>A xor B</td>
</tr>
<tr>
<td>110</td>
<td>比较大小</td>
<td>If A&lt;B then out&#x3D;1; else out&#x3D;0;</td>
</tr>
<tr>
<td>111</td>
<td>判断相等</td>
<td>If A&#x3D;&#x3D;B then out&#x3D;1; else out&#x3D;0;</td>
</tr>
</tbody></table>
<p>ALU进行加减运算时，需要能够判断结果是否为0，是否溢出，是否有进位等。这里，输入的操作数A和B都已经是补码。比较大小请按带符号数的方式设置。</p>
<p>执行逻辑操作时不需要考虑overflow和进位。</p>
<p>由于开发板上输入有限，可以使用SW作为数据输入，button作为选择端。</p>
</blockquote>
<p>​	实现四位ALU，我们首先实现模块接口，有3个输入：两个操作数A，B，一个选择操作数sel；4个输出，结果res，零标志位zero，溢出标志overflow，进位标志carry。下面给出每位的输出表达式：</p>
<ul>
<li><code>&#123; carry, res &#125; = a + b</code>，verilog语法自动扩展位得到carry bit。</li>
<li>溢出位的判断需要分类：<ul>
<li>在补码加法中：<code>overflow = (a[3] == b[3]) &amp;&amp; (res[3] != a[3]) </code>，如果两个操作数的符号位相同且均不同于结果的符号位，则说明产生溢出，因为正数加正数不会产生负数，对于两个负操作数同理。</li>
<li>在补码减法中：<code>overflow = (tmp_a[3] == 1 &amp;&amp; tmp_b[3] == 0 &amp;&amp; tmp_    res[3] == 0) || (tmp_a[3] == 0 &amp;&amp; tmp_b[3] == 1 &amp;&amp; tmp_res[3] == 1);</code>，正数-负数，结果为负数，称为上溢，负数-正数，结果为正数，称为下溢。</li>
</ul>
</li>
<li><code>zero = (res == 0) ? 1 :  0 </code>，直接比较就好。</li>
</ul>
<p>​	通过<code>case</code>语句实现选择操作。再连接到<code>nvboard</code>上进行验证即可。效果如下：</p>
<p><img src="/../images/dlco-nju/%E6%88%AA%E5%B1%8F2023-08-23%2014.06.59-2770822-2770823.png" alt="截屏2023-08-23 14.06.59"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">top=top</span><br><span class="line">a (SW7, SW6, SW5, SW4)		// 操作数a连接 SW7-4</span><br><span class="line">b (SW11, SW10, SW9, SW8)	// 操作数b连接 SW11-8</span><br><span class="line">res (LD3, LD2, LD1, LD0)	// 结果显示在 LED灯3-0 上</span><br><span class="line">zero LD15									// LED15 显示标志零</span><br><span class="line">carry LD14								// LED14 显示进位位</span><br><span class="line">overflow LD13							// LED13 显示溢出位</span><br><span class="line">sel (SW2, SW1, SW0)				// SW2-0 控制操作符</span><br></pre></td></tr></table></figure>

<p>​	如图：<code>0001b - 1000b = 0001b + 0001b + 0111b = 1001b</code> 产生上溢，LED13被点亮。其余功能不再一一展示。</p>
<h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h3><p>​	在写<code>top.v</code>文件中的always语句块时，会用到之前的<code>always @ (*)</code>来省略敏感事件，但在实际操作时有些情况编译会不通过。如<img src="/../images/dlco-nju/%E6%88%AA%E5%B1%8F2023-08-23%2014.25.03-2772159.png" alt="截屏2023-08-23 14.25.03"></p>
<p>​	箭头所指的地方解释了编译失败的原因，因为我们将<code>tmp_res</code>作为敏感事件，这导致<code>always</code>语句中为<code>tmp_res</code>赋值时会唤醒敏感事件，在组合电路中产生环路，这是不允许的。</p>
<p>​	编译时出现的另一个问题时在电路中会产生latches，我遇到的情况是<strong>原信号赋值或者判断</strong>，即在取反时直接使用以下语句<code>b = ~b</code>。更多避免latch的方法请阅读菜鸟教程**<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/verilog-latch.html">Verilog 避免 Latch</a>**。</p>
<p>​	总之，在使用<code>always</code>语法块的时候要时刻注意模拟的电路是否正确，更好的办法是将电路图先画下来，这样更方便debug。</p>
<h3 id="疑问："><a href="#疑问：" class="headerlink" title="疑问："></a>疑问：</h3><p>​	既然ALU有那么多功能，那我们把每个功能模块化后再在顶层模块实例化并使用他们可以吗？不过出现的问题是，实例化无法在always语句中使用，这样我们只能在电路中实例化每一个模块，那引脚该怎么连呢？需要使用多个引线<code>(wire)</code>先接入引脚，再在每个<code>case</code>语句判断后接入输入输出吗？既然采用模块化，case也可以被替代为选择器模块？又该怎么实现仿真？</p>
<h3 id="一些Linux系统问题："><a href="#一些Linux系统问题：" class="headerlink" title="一些Linux系统问题："></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/yjk13703623757/article/details/81055980">一些Linux系统问题</a>：</h3><h4 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dev/sda1: Inodes that were part of a corrupted orphan linked list found.</span><br><span class="line">/dev/sda1: UNEXPECTED INCONSISTENCY:; RUN fsck MANUALLY</span><br><span class="line">        (i.e., without -a or -p options)</span><br><span class="line">fsck exited with status code 4</span><br><span class="line">The root filesystem on /dev/sda3 requires a manual fsck</span><br><span class="line">modprobe: module ehci-orion not found in modules.dep</span><br><span class="line"></span><br><span class="line">BusyBox v1.22.1 (Debian 1:1.22.0-9+deb8u1) built-in shell (ash)</span><br><span class="line">Enter &#x27;help&#x27; for a list of built-in commands.</span><br><span class="line"></span><br><span class="line">/bin/sh: can&#x27;t access tty; job control turned off</span><br><span class="line">(initramfs) _</span><br></pre></td></tr></table></figure>

<p>出错原因：磁盘检测不能通过，可能是因为系统突然断电或其它未正常关闭系统导致。</p>
<h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsck /dev/sda1   *// 修复对象取决于出错的对象，可以是一块磁盘或者一个VG*</span><br></pre></td></tr></table></figure>

<p>然后系统会问你一些问题，稍作调整后，重启系统。</p>
<h2 id="一些verilator语法："><a href="#一些verilator语法：" class="headerlink" title="一些verilator语法："></a>一些verilator语法：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For synthesizing hardware, two types of always blocks are relevant:</span><br><span class="line">Combinational: always @(*)</span><br><span class="line">Clocked: always @(posedge clk)</span><br></pre></td></tr></table></figure>

<p>​	组合块·<code>always @(*)</code>等价于赋值语句<code>assign</code>，因此总是有一种方法可以双向表达组合电路。在使用哪种语法之间的选择主要是哪种语法更方便的问题。过程块内部代码的语法与外部代码的语法不同。过程块有一组更丰富的语句（例如，if-then，case），不能包含连续赋值*，但也引入了许多新的非直观的出错方式。</p>
<p>​	<code>Clocked: always @(posedge clk)</code>建一个组合逻辑块，就像组合总是块一样，但也在组合逻辑块的输出端创建一组触发器（或“寄存器”）。逻辑块的输出不是立即可见的，而是仅在下一个（posedge-clk）之后才可见的。</p>
<h3 id="Blocking-vs-Non-Blocking-Assignment"><a href="#Blocking-vs-Non-Blocking-Assignment" class="headerlink" title="Blocking vs. Non-Blocking Assignment"></a>Blocking vs. Non-Blocking Assignment</h3><p>There are three types of assignments in Verilog:</p>
<ul>
<li><strong>Continuous</strong> assignments (<code>assign x = y;</code>). Can only be used when <strong>not</strong> inside a procedure (“always block”).</li>
<li>Procedural <strong>blocking</strong> assignment: (<code>x = y;</code>). Can only be used inside a procedure.</li>
<li>Procedural <strong>non-blocking</strong> assignment: (<code>x &lt;= y;</code>). Can only be used inside a procedure.</li>
</ul>
<p>​	在<code>combinational always block</code>中，使用<code>blocking assignments</code>。在<code>clocked always block</code>中，使用非块分配。充分理解为什么对硬件设计不是特别有用，需要充分理解Verilog模拟器如何跟踪事件。不遵循这一规则会导致极难发现的错误，这些错误既不具有确定性，又在模拟硬件和合成硬件之间有所不同。</p>
<p>​	在组合逻辑中使用<code>=</code>赋值，在时序逻辑中使用<code>&lt;=</code>赋值：</p>
<p>举个例子：初始化<code>m=1，n=2，p=3</code>；分别执行以下语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、begin </span><br><span class="line">  m=n；n=p；p=m；</span><br><span class="line">  end</span><br><span class="line">  </span><br><span class="line">2、begin</span><br><span class="line">  m&lt;=n; n&lt;=p; p&lt;=m;</span><br><span class="line">  end</span><br></pre></td></tr></table></figure>

<p>​	结果分别是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、m=2,n=3,p=2;（在给p赋值时m=2已经生效） </span><br><span class="line"></span><br><span class="line">2、m=2,n=3,p=1;(在begin-end过程中，m=2一直无效而是在整体执行完后才生效）</span><br></pre></td></tr></table></figure>

<p>​	这两种赋值“&#x3D;”用于阻塞式赋值；“&lt;&#x3D;”用于非阻塞式赋值中。</p>
<p>​	阻塞赋值：阻塞赋值语句是在这句之后所有语句执行之前执行的，即后边的语句必须在这句执行完毕才能执行，所以称为阻塞，实际上就是顺序执行。</p>
<p>​	非阻塞赋值：非阻塞赋值就是与后边相关语句同时执行，即就是并行执行。</p>
<p>​	所以一般时序电路使用非阻塞赋值，assign语句一般使用&#x3D;阻塞赋值；</p>
<h3 id="verilog-同步复位与异步复位"><a href="#verilog-同步复位与异步复位" class="headerlink" title="verilog-同步复位与异步复位"></a>verilog-同步复位与异步复位</h3><p><img src="/../images/dlco-nju/%E6%88%AA%E5%B1%8F2023-09-09%2016.00.42-4246445.png" alt="截屏2023-09-09 16.00.42"></p>
<h2 id="实验四-计数器和时钟"><a href="#实验四-计数器和时钟" class="headerlink" title="实验四 计数器和时钟"></a>实验四 计数器和时钟</h2><h3 id="任务：在nvboard开发板上实现一个计数器，在七段数码管上直接以十进制显示"><a href="#任务：在nvboard开发板上实现一个计数器，在七段数码管上直接以十进制显示" class="headerlink" title="任务：在nvboard开发板上实现一个计数器，在七段数码管上直接以十进制显示"></a>任务：在nvboard开发板上实现一个计数器，在七段数码管上直接以十进制显示</h3><blockquote>
<p>利用开发板上的频率为50MHz的时钟，请先设计一个分频器，其输入为50MHz的时钟，输出为一个频率为1Hz，周期为1秒的时钟信号。再用这个新的频率为1Hz的时钟信号作为你设计的时钟信号，进行计数。</p>
<p>要求此计时器有开始、暂停和清零功能，要求从00计数到99，计数值到99后重新从零开始计数。在数码管上用两位数字显示。</p>
<p>可以在计时结束的时候让某一个发光二极管闪烁一个时钟周期，提示计时结束。</p>
</blockquote>
<p>​	这涉及到时序逻辑电路问题。回想原来做过的实验，我们在配置nvboard的时候曾经写过一个<code>flow_light</code>流水灯，流水灯的实现和这次计数器的实验大同小异。如何控制始终周期呢？<code>flow_light</code>代码使用一个32位寄存器<code>led</code>作为计数器，在大于5000000时置0并更新流水灯。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module top(</span><br><span class="line">	input clk,</span><br><span class="line">	input rst,</span><br><span class="line">	output reg [15:0] led</span><br><span class="line">);</span><br><span class="line">	reg [31:0] count;</span><br><span class="line">	always @(posedge clk) begin</span><br><span class="line">		if (rst) begin led &lt;= 1; count &lt;= 0; end</span><br><span class="line">		else begin</span><br><span class="line">			if (count == 0) led &lt;= &#123;led[14:0], led[15]&#125;;</span><br><span class="line">			count &lt;= (count &gt;= 5000000 ? 32&#x27;b0 : count + 1);</span><br><span class="line">		end</span><br><span class="line">	end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<p>​	同时，讲义 Listing 16 给出了一秒钟生成代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">always @(posedge clk)</span><br><span class="line">  if(count_clk==24999999)</span><br><span class="line">  begin</span><br><span class="line">    count_clk &lt;=0;</span><br><span class="line">    clk_1s &lt;= ~clk_1s;</span><br><span class="line">  end</span><br><span class="line">  else</span><br><span class="line">    count_clk &lt;= count_clk+1;</span><br></pre></td></tr></table></figure>

<p>​	其中，为满足要求，变量<code>count_clk</code>的宽度应为26位。</p>
<p>​	现在开始设计计数器，首先规定输入输出，按照实验要求，设置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module top(</span><br><span class="line">	input clk, // 时钟</span><br><span class="line">	input rst, // 复位位</span><br><span class="line">	output reg [3:0] b0, // 连接7位数码管</span><br><span class="line">	output reg [3:0] b1, // </span><br><span class="line">	output reg [6:0] h0, //</span><br><span class="line">  output reg [6:0] h1, // 同上</span><br><span class="line">	input en // 使能位，暂停位	</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>​	接着设置必要的模块内导线，其中设置暂存器的原因是<code>verilator</code>不支持不同位的导线相连，如<code>b0 = (count % 10) is not allowed</code>，尝试使用<code>b0 = ( count % 10)[3:0]</code>，仍然报错，可能是语法原因。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reg [25:0] count_clk = 0; // 计时器，用于1秒的更新</span><br><span class="line">reg [6:0] count = 0;			// 计数器，从0更新到99</span><br><span class="line">reg [6:0] count_tmp1;			// 暂存器1，存储个位</span><br><span class="line">reg [6:0] count_tmp2;			// 暂存器2，存储十位</span><br></pre></td></tr></table></figure>

<p>​	实例化七位数码管，七位数码管的代码已封装到<code>bcd7seg.v</code>中：</p>
<pre><code>bcd7seg seg0(.b(b0), .h(h0));
bcd7seg seg1(.b(b1), .h(h1));
</code></pre>
<p>​	最后展示代码实现：</p>
<pre><code>always @(posedge clk or posedge rst) begin
    if(en) begin
        if (rst || count == 100) begin
            count_clk &lt;= 0;
            count &lt;= 0;
       		end
        else if(count_clk == 9999999) begin
            count_clk &lt;= 26&#39;b0;
            count_clk &lt;= ~count_clk;
            count &lt;= count + 1;
            count_tmp1 &lt;= count % 10;
            b0 &lt;= count_tmp1[3:0];
            count_tmp2 &lt;= ((count - count % 10) / 10);
            b1 &lt;= count_tmp2[3:0];
        end
        else begin
            count_clk &lt;= count_clk + 1;
        end
    end
    else begin
        count &lt;= count;
        b0 &lt;= b0;
        b1 &lt;= b1;
    end
end
</code></pre>
<p>简单展示实验结果：</p>
<p>​	将<code>SW0</code>设置为使能位，点击变为绿色时计数开始，数码管开始变化：</p>
<p><img src="/../images/dlco-nju/%E6%88%AA%E5%B1%8F2023-09-11%2010.18.29.png" alt="截屏2023-09-11 10.18.29">	</p>
<p>​	再次点击<code>SW0</code> 置 <code>en = 0</code>使得计数器暂停，<code>PBC</code>为复位位，点击后置位为0，因为笔者还没学会在markdown中插入动态图片，展示略过。</p>
<p><img src="/../images/dlco-nju/%E6%88%AA%E5%B1%8F2023-09-11%2010.19.00-4398757.png" alt="截屏2023-09-11 10.19.00"></p>
<h3 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h3><p>​	计数器的实现涉及到时序逻辑电路的知识，简单归纳几点：</p>
<ul>
<li>时序逻辑电路使用<code>always @ (posedge clk)</code>，<code>clk</code>为<code>input</code>，在nvboard上自动更新；<code>posedge</code>指明时序逻辑块内的电路变化发生在时钟上沿，同理<code>negedge</code>指明变化发生在时钟下沿。</li>
<li>在时序逻辑电路中，即<code>always @ (posedge clk)</code>块中，使用非阻塞声明<code>x &lt;= y</code>，这表明整个时序逻辑块内的电路是并行的。而在组合逻辑电路中，使用阻塞声明<code>x = y</code>。他们的区别在上文中有提到。</li>
<li>遇到的问题：无法通过 <code>b0 = (count % 10)</code> 将26位宽的类型通过截断放入4位宽的b0中，笔者的解决方法是新声明一个暂存寄存器存储值后使用verilator语法<code>b0 = count_tmp1[3:0]</code>赋值，是否还有更好的办法？</li>
</ul>
<h2 id="实验五-寄存器组及存储器"><a href="#实验五-寄存器组及存储器" class="headerlink" title="实验五 寄存器组及存储器"></a>实验五 寄存器组及存储器</h2><h3 id="任务-请在一个工程中完成如下的寄存器堆和RAM。寄存器堆和RAM的大小均为-，即都有16个存储单元，每个存储单元都是8位的，均可以进行读写。"><a href="#任务-请在一个工程中完成如下的寄存器堆和RAM。寄存器堆和RAM的大小均为-，即都有16个存储单元，每个存储单元都是8位的，均可以进行读写。" class="headerlink" title="任务 请在一个工程中完成如下的寄存器堆和RAM。寄存器堆和RAM的大小均为 ，即都有16个存储单元，每个存储单元都是8位的，均可以进行读写。"></a>任务 请在一个工程中完成如下的寄存器堆和RAM。寄存器堆和RAM的大小均为 ，即都有16个存储单元，每个存储单元都是8位的，均可以进行读写。</h3><blockquote>
<h3 id="实现寄存器堆："><a href="#实现寄存器堆：" class="headerlink" title="实现寄存器堆："></a>实现寄存器堆：</h3><p>​	读取时不需要时钟控制，即读地址有效后，直接输出数据。写入时通过时钟上升沿进行控制。</p>
<p>​	此时可用以下方式输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assign out = ram[addr];</span><br></pre></td></tr></table></figure>

<p>​	采用下面的方式进行初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">initial</span><br><span class="line">begin</span><br><span class="line">  $readmemh(&quot;D:/digital_logic/mem1.txt&quot;, ram, 0, 15);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>​	初始化数值为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@0 00</span><br><span class="line">@1 01</span><br><span class="line">@2 02</span><br><span class="line">@3 03</span><br><span class="line">@4 04</span><br><span class="line">@5 05</span><br><span class="line">@6 06</span><br><span class="line">@7 07</span><br><span class="line">@8 08</span><br><span class="line">@9 09</span><br><span class="line">@a 0a</span><br><span class="line">@b 0b</span><br><span class="line">@c 0c</span><br><span class="line">@d 0d</span><br><span class="line">@e 0e</span><br><span class="line">@f 0f</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="存储器的行为和FPGA的RAM模块"><a href="#存储器的行为和FPGA的RAM模块" class="headerlink" title="存储器的行为和FPGA的RAM模块"></a><strong>存储器的行为和FPGA的RAM模块</strong></h3><blockquote>
<p>​	以下存储器综合时，综合器是否会用FPGA的RAM模块来实现这个模块？</p>
<p>​	Listing 19 存储器实现代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">module ram #(</span><br><span class="line">  parameter RAM_WIDTH = 32,</span><br><span class="line">  parameter RAM_ADDR_WIDTH = 10</span><br><span class="line">)(</span><br><span class="line">    input clk,</span><br><span class="line">    input we,</span><br><span class="line">    input [RAM_WIDTH-1:0] din,</span><br><span class="line">    input [RAM_ADDR_WIDTH-1:0] inaddr,</span><br><span class="line">    input [RAM_ADDR_WIDTH-1:0] outaddr,</span><br><span class="line">    output [RAM_WIDTH-1:0] dout</span><br><span class="line">);</span><br><span class="line">  reg [RAM_WIDTH-1:0] ram [(2**RAM_ADDR_WIDTH)-1:0];</span><br><span class="line">  always @(posedge clk)</span><br><span class="line">      if (we)</span><br><span class="line">        ram[inaddr] &lt;= din;</span><br><span class="line">  assign dout = ram[outaddr];</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<p>​	如果将表 Listing 19中存储器实现部分改为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">always @(posedge clk)</span><br><span class="line">  if (we)</span><br><span class="line">    ram[inaddr] &lt;= din;</span><br><span class="line">  else</span><br><span class="line">    dout &lt;= ram[outaddr];</span><br></pre></td></tr></table></figure>

<p>该存储器的行为是否会发生变化？</p>
</blockquote>
<p>​	原代码<code>assign dout = ram[outaddr]</code>书写格式为组合逻辑电路格式，该读取数据不受时钟控制，只要输出地址有效，就会读取数据。而修改后的代码将<code>dout &lt;= ram[outaddr]</code>写入时序逻辑电路中，这样一来，读取数据将受到时钟信号控制，在时钟信号上沿且使能端为1时读取数据。</p>
<h3 id="实验思路："><a href="#实验思路：" class="headerlink" title="实验思路："></a>实验思路：</h3><p>​	<em><strong>Listing 20</strong></em> 给出了存储器实例代码，我们只需要在此基础上稍加修改，就可以得到一个16 * 8 的存储器。</p>
<pre><code>module top(clk, we, inaddr, outaddr, din, dout, rst);
input clk; 
input we;
input rst;
input [3:0] inaddr;
input [3:0] outaddr;
input [7:0] din;
output reg [7:0] dout;
reg [7:0] ram [15:0];

initial
begin
    $readmemh(&quot;/home/thelonging/verilator/dlco-nju/lab05/v_rams_16/mem/mem1.txt&quot;, ram, 0, 15);
end

always @ (posedge clk)
begin
    if (we)
        ram[inaddr] &lt;= din;
end

assign dout = ram[outaddr];
endmodule
</code></pre>
<h3 id="实验结果："><a href="#实验结果：" class="headerlink" title="实验结果："></a>实验结果：</h3><p>​	通过nvboard观察实验结果，我们置<code>SW15-SW12</code>为读地址，<code>SW11-SW8</code>为写地址，<code>SW7-SW0</code>为输入数据，<code>LED7-LED0</code>显示读出的数据，<code>PBC</code>为写使能位。</p>
<p>​	当前读取存储地址位为<code>0001</code>的数据，结果显示为1，如下图所示</p>
<p><img src="/../images/dlco-nju/%E6%88%AA%E5%B1%8F2023-09-11%2015.12.10-4416337.png"></p>
<p>​	现在我们尝试在地址为0的地方写入<code>00000111</code>，点击<code>PBC</code>使读使能位有效写入数据，结果如下图所示：</p>
<h3 id=""><a href="#" class="headerlink" title=""></a><img src="/../images/dlco-nju/%E6%88%AA%E5%B1%8F2023-09-11%2015.18.01-4416688.png"></h3><h3 id="总结：-4"><a href="#总结：-4" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><p><code>verilator</code>语句中的<code>initial</code>语句块完成在RAM的初始化，该语句在一个verilator中只能使用一次。</p>
</li>
<li><p>当需要初始化的RAM数据量较大的时候，可以使用文件来在系统启动时直接装入RAM数据。 Verilog提供了以下语句来将文件中的数据导入到RAM中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">initial</span><br><span class="line">begin</span><br><span class="line">  $readmemh(&quot;D:/digital_logic/mem1.txt&quot;, ram, 0, 7);</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="实验六-移位寄存器及桶形移位器"><a href="#实验六-移位寄存器及桶形移位器" class="headerlink" title="实验六 移位寄存器及桶形移位器"></a>实验六 移位寄存器及桶形移位器</h2><h3 id="任务-利用移位寄存器实现随机数发生器"><a href="#任务-利用移位寄存器实现随机数发生器" class="headerlink" title="任务 利用移位寄存器实现随机数发生器"></a>任务 <strong>利用移位寄存器实现随机数发生器</strong></h3><blockquote>
<p>我们可以利用8位移位寄存器来实现一个简单的随机数发生器。 经典的LFSR（线性反馈移位寄存器， <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register">Linear-feedback shift register</a> ）可以使用n位移位寄存器生成长度为 的二进制循环序列。 这类序列的片段在表观上是随机的，所以被广泛用于通信中的随机序列生成。例如，在CDMA通信中的长码的长度就是 <code>2^42 - 1</code>的伪随机序列。</p>
<p>具体实现时，可以用一个8位右移移位寄存器，从左到右的比特以<br>$$<br>x_7x_6x_5x_4x_3x_2x_1x_0<br>$$<br>表示。每个时钟周期右移一位<code>x0</code>被移出，最左边移入的位按照上一周期的值计算 <a target="_blank" rel="noopener" href="https://nju-projectn.github.io/dlco-lecture-note/exp/06.html#f1">1</a> ：<br>$$<br>x_8 &#x3D; x_4⊕x_3⊕x_2⊕x_0<br>$$<br>例如，初始二进制值为00000001时，移位寄存器的状态将按 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000 0001 -&gt; 1000 0000 -&gt; 0100 0000 -&gt; 0010 0000 -&gt; 1000 1000 ...</span><br></pre></td></tr></table></figure>

<p>变化。 该序列的周期为255。 当然，当初始值为全零时，系统将一直停留在全零状态，所以需要对全零状态进行特殊处理。</p>
<p>请实现一个8位的周期为255的伪随机序列，以按钮为时钟信号，并请将8位二进制数以十六进制显示在数码管上，在DE10-Standard开发板上观察生成的随机数序列。</p>
</blockquote>
<p>​	关键步骤的实现讲义已经给出了，我们只需要在开发板上实现它就可以了。具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">module top(</span><br><span class="line">	input clk,	// 时钟</span><br><span class="line">	output reg [3:0] b0,	// 存储高四位</span><br><span class="line">	output reg [3:0] b1,	// 存储低四位</span><br><span class="line">	output reg [6:0] h0,	// 数码管上显示低四位</span><br><span class="line">  output reg [6:0] h1,	// 数码管上显示高四位</span><br><span class="line">	output reg [7:0] show,	// 存储八位二进制</span><br><span class="line">	output reg [7:0] led	// 用于同步显示八位二进制</span><br><span class="line">);</span><br><span class="line">	reg [31:0] count;	//计时器</span><br><span class="line">	reg x8;						// 更新位</span><br><span class="line">	reg [7:0] start;	// 初始值</span><br><span class="line">	bcd7seg seg0 (.b(b0), .h(h0));	// 实例化灯0</span><br><span class="line">	bcd7seg seg1 (.b(b1), .h(h1));	// 实例化灯1</span><br><span class="line"></span><br><span class="line">	// 初始化</span><br><span class="line">	initial </span><br><span class="line">	begin</span><br><span class="line">		start = 8&#x27;b00000001;</span><br><span class="line">		count = 0;</span><br><span class="line">		show = start;</span><br><span class="line">	end</span><br><span class="line">	</span><br><span class="line">	// 时序逻辑块，按时钟上沿变化</span><br><span class="line">	always @ (posedge clk)</span><br><span class="line">	begin</span><br><span class="line">		// 当计数器为0时，更新数据</span><br><span class="line">		if(count == 0) begin</span><br><span class="line">			x8 &lt;= show[4] ^ show[3] ^ show[2] ^ show[0];</span><br><span class="line">			show &lt;= &#123;x8, show[7:1]&#125;;</span><br><span class="line">			b1 &lt;= show[7:4];</span><br><span class="line">			b0 &lt;= show[3:0];</span><br><span class="line">			led &lt;= show;</span><br><span class="line">			count &lt;= count + 1;</span><br><span class="line">		end</span><br><span class="line">		else begin</span><br><span class="line">			// 计数</span><br><span class="line">			count &lt;= (count &gt;= 25000000 ? 32&#x27;b0 : count + 1);</span><br><span class="line">		end</span><br><span class="line">	end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<p>​	同时，因为此任务中需要在数码管上显示16进制数，我们需要更新七位数码管的模块代码，给出每个灯管对应字母，具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">		a</span><br><span class="line">		_</span><br><span class="line">f	| 	| b</span><br><span class="line">		-			g</span><br><span class="line">e	|		| c</span><br><span class="line">		-</span><br><span class="line">		d</span><br><span class="line">module bcd7seg(</span><br><span class="line">	input [3:0] b,</span><br><span class="line">	output reg [6:0] h</span><br><span class="line">);</span><br><span class="line">	always @ (*)</span><br><span class="line">		case (b)</span><br><span class="line">			//	   abcdefg</span><br><span class="line">			0: h =  7&#x27;b0000001;</span><br><span class="line">			1: h =  7&#x27;b1001111;</span><br><span class="line">			2: h =  7&#x27;b0010010; </span><br><span class="line">			3: h =  7&#x27;b0000110;</span><br><span class="line">			4: h =  7&#x27;b1001100;</span><br><span class="line">			5: h =  7&#x27;b0100100;</span><br><span class="line">			6: h =  7&#x27;b0100000;</span><br><span class="line">			7: h =  7&#x27;b0001111;</span><br><span class="line">			8: h =  7&#x27;b0000000; </span><br><span class="line">			9: h =  7&#x27;b0001100;</span><br><span class="line">			10: h = 7&#x27;b0001000; </span><br><span class="line">			11: h = 7&#x27;b1100000;</span><br><span class="line">			12: h = 7&#x27;b0110001;</span><br><span class="line">			13: h = 7&#x27;b1000010;</span><br><span class="line">			14: h = 7&#x27;b0110000;</span><br><span class="line">			15: h = 7&#x27;b0111000;</span><br><span class="line">		endcase</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<h3 id="实验展示"><a href="#实验展示" class="headerlink" title="实验展示"></a>实验展示</h3><p>​	下图截取了随机数发生器工作时的片段，<code>SEG0</code>和<code>SEG1</code>显示<code>LED7-LED0</code>所表示的八位二进制位，显示结果按十六进制给出，当前现实为 <code>7:0</code>，对应<code>0111 0000</code>。</p>
<p><img src="/../images/dlco-nju/%E6%88%AA%E5%B1%8F2023-09-12%2011.50.44-4495909-4495915.png" alt="截屏2023-09-12 11.50.44"></p>
<h3 id="总结：-5"><a href="#总结：-5" class="headerlink" title="总结："></a>总结：</h3><p>​	这次实验卡住笔者的地方是使七位数码管显示的结果与LED灯小时的结果保持一致。在verilator代码中，如果直接使用<code>show</code>连接LED灯，LED灯显示的数据会比数码管显示的数据快一个周期。这说明<code>show</code>的更新比 <code>b0 、b1</code>更快，观察代码，<u>这可能是因为需要把show的数据更新完之后，才能将数据输入到<code>b0</code>和<code>b1</code>中去？</u><strong>此问题笔者尚未解决，但是增加一个<code>led</code>作为新的输出后倒实现了同步的效果。</strong></p>
<h2 id="实验七-状态机及键盘输入"><a href="#实验七-状态机及键盘输入" class="headerlink" title="实验七 状态机及键盘输入"></a>实验七 状态机及键盘输入</h2><h3 id="任务-实现单个按键的ASCII码显示"><a href="#任务-实现单个按键的ASCII码显示" class="headerlink" title="任务 实现单个按键的ASCII码显示"></a>任务 <strong>实现单个按键的ASCII码显示</strong></h3><blockquote>
<ul>
<li>七段数码管低两位显示当前按键的键码，中间两位显示对应的ASCII码（转换可以考虑自行设计一个ROM并初始化）。只需完成字符和数字键的输入，不需要实现组合键和小键盘。</li>
<li>当按键松开时，七段数码管的低四位全灭。</li>
<li>七段数码管的高两位显示按键的总次数。按住不放只算一次按键。只考虑顺序按下和放开的情况，不考虑同时按多个键的情况。</li>
</ul>
</blockquote>
<p>​	要解决的问题：</p>
<pre><code> 1. 如何判断按键是否松开
 2. 如何判断按键按住不放	
 3. 如何记录总按键次数
 4. 如何初始化一个ROM
</code></pre>
<p>​	既然要实现的功能这么多，我们不妨先把大体的框架搭好，回顾之前搭建nvboard实验平台，在example里面已经实现了如何接收按键并输出的模块，在文件<code>nvboard/example/vsrc/ps2_board.v</code>中，我们看懂了直接拿过来用就可以了，不过最终的版本要做一些修改，下面给出修改后的<code>ps2_board.v</code>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">module ps2_keyboard(clk,resetn,ps2_clk,ps2_data, out0, out1);</span><br><span class="line">    input clk,resetn,ps2_clk,ps2_data;</span><br><span class="line">    output reg [3:0] out0[2:0], out1[2:0];</span><br><span class="line"></span><br><span class="line">    reg [9:0] buffer;        	// ps2_data bits</span><br><span class="line">    reg [3:0] count;  				// count ps2_data bits</span><br><span class="line">    reg [2:0] ps2_clk_sync;		</span><br><span class="line"></span><br><span class="line">    always @(posedge clk) begin</span><br><span class="line">        ps2_clk_sync &lt;=  &#123;ps2_clk_sync[1:0],ps2_clk&#125;;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    wire sampling = ps2_clk_sync[2] &amp; ~ps2_clk_sync[1];</span><br><span class="line"></span><br><span class="line">    always @(posedge clk) begin</span><br><span class="line">        if (resetn == 0) begin // reset</span><br><span class="line">            count &lt;= 0;</span><br><span class="line">        end</span><br><span class="line">        else begin</span><br><span class="line">            if (sampling) begin</span><br><span class="line">              if (count == 4&#x27;d10) begin</span><br><span class="line">                if ((buffer[0] == 0) &amp;&amp;  // start bit</span><br><span class="line">                    (ps2_data)       &amp;&amp;  // stop bit</span><br><span class="line">                    (^buffer[9:1])) begin      // odd  parity</span><br><span class="line">                    $display(&quot;receive %x&quot;, buffer[8:1]);</span><br><span class="line">		    out0 &lt;= &#123;out0[1], out0[0], buffer[4:1]&#125;;</span><br><span class="line">		    out1 &lt;= &#123;out1[1], out1[0], buffer[8:5]&#125;;</span><br><span class="line">                end</span><br><span class="line">                count &lt;= 0;     // for next</span><br><span class="line">              end else begin</span><br><span class="line">                buffer[count] &lt;= ps2_data;  // store ps2_data</span><br><span class="line">                count &lt;= count + 3&#x27;b1;</span><br><span class="line">              end</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<p>​	讲义中解释了大部分参数，笔者在下面贴上讲义内容，在此着重介绍笔者修改的部分，添加了<code>output reg [3:0] out1[2:0], out[2:0]</code>用于记录三个时钟周期内的键盘输出变化，<code>out1</code>和<code>out0</code>分别记录高四位和低四位，这两个参数将在顶层模块用于解决上述提到的<strong>问题1</strong>和<strong>问题2</strong>，实现方法为每个时钟周期向左位移一次，抛弃最高位并更新最低位。</p>
<blockquote>
<p>​	代码首先通过ps2_clk_sync记录PS2时钟信号的历史信息，并检测时钟的下降沿，当发现下降沿时将sampling置一。然后开始逐位接收数据并放入缓冲区fifo队列,收集完11个bit后将缓冲区转移至数据队列fifo。</p>
<p>​	键盘控制器模块设置了一个8字节的fifo队列，以防止键盘数据发送过快，处理模块来不及取走数据而丢失。这类fifo队列在数字系统中很常见，它主要用于在两个处理速度不同的模块之间传递数据。 上游模块负责在队列中添加数据，下游模块负责取出数据进行处理。fifo队列的缓冲作用可以在下游处理模块来不及处理数据时临时存放数据。 fifo是一个先进先出的队列，配有写指针和读指针。当队列不空时，送出ready信号，表示此时有数据要处理； 当队列溢出时，送出overflow信号。按键处理系统调用该模块时，需要在键盘控制器ready信号为1的情况下读取键盘数据，确认读取完毕后将nextdata_n置零 <strong>一个周期</strong> 。 这时，键盘控制器模块收到确认读取完毕的信号，将读指针前移，准备提供下一数据。请读者自行考虑处理模块与本模块的配合时序，避免漏键或者重复读取。当然，也可自行设计两个模块交互的时序。</p>
</blockquote>
<p>​	接着我们考虑如何实现七位数码管全熄灭，很显然我们需要修改七位数码管代码<code>bcd7seg.v</code>，笔者的想法是增加一位控制位<code>en</code>，<code>en = 1</code>时，灯亮，<code>en = 0</code>时灯灭，控制明暗的逻辑模块将放在顶层模块<code>top.v</code>中，由于实现简单这里将不给出代码的具体实现。</p>
<p>​	最后我们要在顶层模块中实现实验要求，笔者的实现思路是从最简单的<strong>1.显示当前按键的键码开始，2.接着实现按键松开时数码管全灭，3.七段数码管的高两位显示按键的总次数，4.最后实现初始化ROM并输出对应ASCII码</strong>，本文将不再赘述具体细节。</p>
<p>​	重点讲一讲上述问题的解决：</p>
<ol>
<li>通过记录三个周期内的键码变化，我们可以判断当前按键是否已松开，并更新使能位</li>
<li>通过记录两个周期内使能位的变化，我们可以判断按键按下了多少次，相邻周期内使能位高低电平变化代表按键按下一次</li>
<li>初始化ROM的方法在存储器一章已经给出具体实现，在本节中，我们通过<code>（通码，ASCII码）</code>的方式存储，其中通码为地址，ASCII码为值，这种方法会浪费大量的存储空间，但是实现简单。</li>
</ol>
<p>​	下面将给出代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">module top (</span><br><span class="line">	input clk,	// 时钟</span><br><span class="line">	input rst,	// 复位位</span><br><span class="line">	input ps2_clk,	// 键盘时钟</span><br><span class="line">	input ps2_data,	// 接收键值</span><br><span class="line">	output reg [3:0] b0,	// 用于显示键值低四位</span><br><span class="line">	output reg [3:0] b1,	// 用于显示键值高四位</span><br><span class="line">	output reg [6:0] h0,	</span><br><span class="line">	output reg [6:0] h1,</span><br><span class="line">	output reg [6:0] light6, light5, light4, light3, light2, light1,</span><br><span class="line">	output reg en,	// 用于控制灯管明暗</span><br><span class="line">	output reg [7:0] count,	// 记录按键的总次数</span><br><span class="line">	output reg [7:0] d1,	// 显示ASCII码的十位</span><br><span class="line">	output reg [7:0] d0		// 显示ASCII码的个位</span><br><span class="line">);</span><br><span class="line">	</span><br><span class="line">	reg [7:0] rom [255:0];	//	只读存储器，存储按键对应的ASCII码</span><br><span class="line">	reg [3:0] out0_clk_sync [2:0];	// 记录三个周期的键码低四位</span><br><span class="line">	reg [3:0] out1_clk_sync [2:0];	// 记录三个周期的键码高四位</span><br><span class="line">	reg [1:0] en_clk_sync;	// 记录两个周期内使能位的变化</span><br><span class="line">	reg [3:0] r1, r0;	// 临时寄存器</span><br><span class="line"></span><br><span class="line">	// 初始化</span><br><span class="line">	initial begin </span><br><span class="line">		count = 0;</span><br><span class="line">		en_clk_sync[1] = 0;</span><br><span class="line">		en_clk_sync[0] = 0;</span><br><span class="line">		$readmemh(&quot;/home/thelonging/verilator/dlco-nju/lab07/keyboard/mem/mem1.txt&quot;, rom);</span><br><span class="line">	end</span><br><span class="line">	</span><br><span class="line">	// 将最新的键值存储到显示中去</span><br><span class="line">	assign b0 = out0_clk_sync[0];</span><br><span class="line">	assign b1 = out1_clk_sync[0];</span><br><span class="line"></span><br><span class="line">	always @ (posedge clk) </span><br><span class="line">	// 用于判断按键是否松开，并更新数据</span><br><span class="line">	begin</span><br><span class="line">		if((out1_clk_sync[2] == out1_clk_sync[0]) &amp;&amp;</span><br><span class="line">			(out0_clk_sync[2] == out0_clk_sync[0]) &amp;&amp;</span><br><span class="line">			(out1_clk_sync[1] == 4&#x27;hf) &amp;&amp;</span><br><span class="line">			(out0_clk_sync[1] == 4&#x27;h0)</span><br><span class="line">		) begin</span><br><span class="line">			en &lt;= 0;</span><br><span class="line">		end else begin</span><br><span class="line">		       en &lt;= 1;</span><br><span class="line">		       &#123;r1, r0&#125; &lt;= rom[&#123;out1_clk_sync[0], out0_clk_sync[0]&#125;];</span><br><span class="line">		      d0 &lt;= &#123;r1, r0&#125; % 10;</span><br><span class="line">		      d1 &lt;= ((&#123;r1, r0&#125; - &#123;r1, r0&#125; % 10) / 10);</span><br><span class="line">	       	end</span><br><span class="line">	end</span><br><span class="line"></span><br><span class="line">	// 记录两个周期的使能位</span><br><span class="line">	always @ (posedge clk)</span><br><span class="line">	begin</span><br><span class="line">		en_clk_sync &lt;= &#123;en_clk_sync[1], en&#125;;</span><br><span class="line">	end</span><br><span class="line">	</span><br><span class="line">	// 记录按下的次数</span><br><span class="line">	always @ (en_clk_sync)</span><br><span class="line">	begin</span><br><span class="line">		if(en_clk_sync[1] != en_clk_sync[0]) begin</span><br><span class="line">			count = count + 1;</span><br><span class="line">		end else begin</span><br><span class="line">			count = (count == 8&#x27;b11111111) ? 0 : count;</span><br><span class="line">		end</span><br><span class="line">	end</span><br><span class="line"></span><br><span class="line">	// 实例化七位数码管并连线</span><br><span class="line">	bcd7seg seg0(.b(b0), .h(h0), .en(en));</span><br><span class="line">	bcd7seg seg1(.b(b1), .h(h1), .en(en));</span><br><span class="line">	</span><br><span class="line">	bcd7seg seg2(.b(d0[3:0]), .h(light1), .en(en));</span><br><span class="line">	bcd7seg seg3(.b(d1[3:0]), .h(light2), .en(en));</span><br><span class="line">	</span><br><span class="line">	bcd7seg seg6(.b(count[3:0]), .h(light5), .en(1));</span><br><span class="line">	bcd7seg seg7(.b(count[7:4]), .h(light6), .en(1));</span><br><span class="line"></span><br><span class="line">	// 实例化键盘并连线</span><br><span class="line">	ps2_keyboard my_keyboard(</span><br><span class="line">		.clk(clk),</span><br><span class="line">		.resetn(~rst),</span><br><span class="line">		.ps2_clk(ps2_clk),</span><br><span class="line">		.ps2_data(ps2_data),</span><br><span class="line">		.out0(out0_clk_sync),</span><br><span class="line">		.out1(out1_clk_sync)</span><br><span class="line">	);</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<h3 id="实验展示："><a href="#实验展示：" class="headerlink" title="实验展示："></a>实验展示：</h3><p>​	这个图比较难截，这里放一张简单说一下，因为mac截图时按下的是<code>shift</code>键，对应键值显示在SEG1、SEG0中，为12，<code>shift</code>的ASCII码为16，显示在SEG3，SEG2中，高两位数码管显示按下13次，<code>LED0</code>亮是因为这里接了使能位。</p>
<p><img src="/../images/dlco-nju/%E6%88%AA%E5%B1%8F2023-09-13%2016.31.06-4593884.png" alt="截屏2023-09-13 16.31.06"></p>
<h3 id="总结：-6"><a href="#总结：-6" class="headerlink" title="总结："></a>总结：</h3><p>​	verilator的一些语法问题笔者还没有充分理解：</p>
<ol>
<li><p>当声明<code>output reg [3:0] out0[2:0]</code>时，不能通过<code>out0 &lt;= &#123;out0[1：0], buffer[4:1]&#125;;</code>代码实现左移操作而必须通过拆开<code>out0[1],out0[0]</code>才能实现位移操作 <code>out0 &lt;= &#123;out0[1], out0[0], buffer[4:1]&#125;;</code></p>
</li>
<li><p>在记录按下次数时不能写位时序逻辑电路而必须写为组合逻辑电路，以下是错误写法，问题就是虽然是沿时钟上沿变化，但是里面的判断并未和时钟有关系，为什么这样写了之后数据会变化且无规律。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 记录按下的次数 错误版</span><br><span class="line">	always @ (posedge clk)</span><br><span class="line">	begin</span><br><span class="line">		if(en_clk_sync[1] != en_clk_sync[0]) begin</span><br><span class="line">			count = count + 1;</span><br><span class="line">		end else begin</span><br><span class="line">			count = (count == 8&#x27;b11111111) ? 0 : count;</span><br><span class="line">		end</span><br><span class="line">	end</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="评估电路综合后的时序"><a href="#评估电路综合后的时序" class="headerlink" title="评估电路综合后的时序:"></a>评估电路综合后的时序:</h2><blockquote>
<p>​	我们提供了一个基于开源EDA的综合后时序评估项目. 这个项目通过<a target="_blank" rel="noopener" href="https://yosyshq.net/yosys">开源RTL综合器yosys</a>对RTL设计进行综合, 并映射到一个45nm的<a target="_blank" rel="noopener" href="https://mflowgen.readthedocs.io/en/latest/stdlib-freepdk45.html">开源工艺库nangate45</a>, 然后将综合得到的网表文件和工艺库中的标准单元信息文件输入到<a target="_blank" rel="noopener" href="https://github.com/OSCC-Project/iEDA/tree/master/src/operation/iSTA">开源静态时序分析工具iSTA</a>中, iSTA将快速评估RTL设计中的时序路径, 并给出时序余量最少的若干条路径, 供RTL设计者参考. 通过上述方式, RTL设计者可快速得知RTL设计的时序情况, 并对RTL设计进行快速迭代.</p>
<p>你可以通过以下命令克隆该项目, 具体操作方式请阅读项目中的README.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:OSCPU/yosys-sta.git</span><br></pre></td></tr></table></figure>

<p>尝试用上述项目评估你的数字电路实验.</p>
</blockquote>
<p>​	下载之后，会有个叫yosys-sta的文件，笔者目前找到的使用方法就是把之前verilator项目中的vsrc复制粘贴到该文件目录下，改名为exmaple，然后运行命令<code>make sta</code>，评估结果会存储在<code>result</code>目录中。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>​	笔者断断续续一个月把讲义要求的数字电路必做部分实验做完了，剩下的实验就先放着，去做PA1去，说实做到现在感觉也只学到了皮毛，感觉只会写代码，对于实际如何连线肯定还是存在很大困难，不知道在这个地方偷的懒后面会不会需要补回来，<del>遗留的问题也不想解决。</del></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/21/%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/21/%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/" class="post-title-link" itemprop="url">搭建verilator仿真环境</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-21 13:21:14 / 修改时间：17:04:57" itemprop="dateCreated datePublished" datetime="2023-08-21T13:21:14+08:00">2023-08-21</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="搭建verilator仿真环境"><a href="#搭建verilator仿真环境" class="headerlink" title="搭建verilator仿真环境"></a>搭建verilator仿真环境</h1><blockquote>
<p>verilator是一款开源的verilog仿真工具, 在”一生一芯”项目中, 你将会使用它来进行RTL功能仿真, 从而验证你编写的RTL代码.</p>
<p>框架代码默认提供了一个<code>npc</code>目录, 这里的<code>npc</code>是<code>New Processor Core</code>的含义, 将来大家就会在这个目录下设计自己的处理器. 不过为了设置一个环境变量<code>NPC_HOME</code>, 你需要运行如下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ysyx-workbench</span><br><span class="line">bash init.sh npc</span><br></pre></td></tr></table></figure>

<p>这个环境变量会在将来使用. <code>npc</code>目录下有一些简单的文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ysyx-workbench/npc</span><br><span class="line">├── csrc</span><br><span class="line">│   └── main.cpp</span><br><span class="line">├── Makefile</span><br><span class="line">└── vsrc</span><br><span class="line">    └── example.v</span><br></pre></td></tr></table></figure>

<p>目前这三个文件几乎都是空文件, 在这一小节中, 我们将会引导大家搭建verilator仿真环境, 并编写两个简单的数字电路模块来进行仿真.</p>
</blockquote>
<h2 id="任务：认识verilator"><a href="#任务：认识verilator" class="headerlink" title="任务：认识verilator"></a>任务：认识verilator</h2><blockquote>
<p>你很可能是第一次听说过verilator这个工具, 这是很正常的. 然后你就会想进一步了解verilator的各种信息, 这也是很正常的. 但如果你的第一反应是去问人, 这就不恰当了. 事实上, verilator这个工具在仿真领域已经非常有名, 以至于你可以很容易在互联网上搜索到它的相关信息. 你需要通过STFW找到它的官方网站, 然后阅读一下相关的介绍.</p>
</blockquote>
<p>​	verilator是一个用作仿真电路的软件，将Verilog或者SystemVerilog文件转换为c或者c++文件，然后可以通过自己编辑的testbench测试用例观察电路是否正确。</p>
<h2 id="任务：安装verilator"><a href="#任务：安装verilator" class="headerlink" title="任务：安装verilator"></a>任务：安装verilator</h2><blockquote>
<p>在官网中找到安装verilator的步骤, 然后按照从git安装的相应步骤进行操作. 我们之所以不采用<code>apt-get</code>安装, 是因为其版本较老. 此外, 为了统一版本, 你需要通过git安装<code>5.008</code>的版本. 为此, 你还需要进行一些简单的git操作, 如果你对此感到生疏, 你可能需要寻找一些git教程来学习. 另外, 你最好在<code>ysyx-workbench/</code>之外的目录进行这一操作, 否则git将会追踪到verilator的源代码, 从而占用不必要的磁盘空间.</p>
<p>安装成功后, 运行以下命令来检查安装是否成功，以及版本是否正确</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verilator --version</span><br></pre></td></tr></table></figure>
</blockquote>
<p>​	找到verilator官网的<a target="_blank" rel="noopener" href="https://verilator.org/guide/latest/install.html">install部分</a>，跟着官网步骤一步一步来就可以了，注意切换版本时使用git checkout的地方。</p>
<h2 id="任务：运行示例"><a href="#任务：运行示例" class="headerlink" title="任务：运行示例"></a>任务：运行示例</h2><blockquote>
<p>verilator手册中包含一个C++的示例, 你需要在手册中找到这个示例, 然后按照示例的步骤进行操作.</p>
</blockquote>
<p>​	也是照着<a target="_blank" rel="noopener" href="https://verilator.org/guide/latest/example_cc.html#example-c-execution">官网的步骤</a>，注意：verilog代码文件名必须与模块名一致，如our.v的模块名必须命名<code>module our</code>。</p>
<p><img src="/../images/%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/%E6%88%AA%E5%B1%8F2023-08-21%2013.47.39-2596869.png" alt="截屏2023-08-21 13.47.39"></p>
<h2 id="示例：双控开关"><a href="#示例：双控开关" class="headerlink" title="示例：双控开关"></a>示例：双控开关</h2><blockquote>
<p>手册中的示例非常简单, 甚至算不上是一个真正的电路模块. 接下来我们编写一个真正的电路模块, 双控开关, 来进行测试. 编写如下的verilog代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module top(</span><br><span class="line">  input a,</span><br><span class="line">  input b,</span><br><span class="line">  output f</span><br><span class="line">);</span><br><span class="line">  assign f = a ^ b;</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<p>双控开关的一个应用是通过两个开关(<code>a</code>和<code>b</code>)联合控制同一盏灯的亮灭(<code>f</code>). 和手册中的示例不同, 这个模块有输入输出端口. 为了驱动输入端口, 并从输出端口获得结果, 我们需要对C++文件中的<code>while</code>循环进行修改:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 以下为伪代码</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">while (???) &#123;</span><br><span class="line">  int a = rand() &amp; 1;</span><br><span class="line">  int b = rand() &amp; 1;</span><br><span class="line">  top-&gt;a = a;</span><br><span class="line">  top-&gt;b = b;</span><br><span class="line">  top-&gt;eval();</span><br><span class="line">  printf(&quot;a = %d, b = %d, f = %d\n&quot;, a, b, top-&gt;f);</span><br><span class="line">  assert(top-&gt;f == (a ^ b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一次循环中, 代码将会随机生成两个1比特信号, 用来驱动两个输入端口, 然后通过<code>eval()</code>函数更新电路的状态, 这样我们就可以读取输出端口的值并打印. 为了自动检查结果是否正确, 我们通过<code>assert()</code>语句对输出结果进行检查.</p>
</blockquote>
<h2 id="任务：对双控开关模块进行仿真"><a href="#任务：对双控开关模块进行仿真" class="headerlink" title="任务：对双控开关模块进行仿真"></a>任务：对双控开关模块进行仿真</h2><blockquote>
<p>尝试在verilator中对双控开关模块进行仿真. 由于顶层模块名与手册中的示例有所不同, 你还需要对C++文件进行一些相应的修改. 此外, 这个项目没有指示仿真结束的语句, 为了退出仿真, 你需要键入<code>Ctrl+C</code>.</p>
</blockquote>
<p>​	verilog代码不做更改，但需要将它存放在<code>top.v</code>中，接着编辑C++文件，观察<strong>任务：运行示例</strong>中的C++代码。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mkdir test_our</span><br><span class="line">cd test_our</span><br><span class="line"></span><br><span class="line">cat &gt;our.v &lt;&lt;&#x27;EOF&#x27;</span><br><span class="line">  module our;</span><br><span class="line">     initial begin $display(&quot;Hello World&quot;); $finish; end</span><br><span class="line">  endmodule</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &gt;sim_main.cpp &lt;&lt;&#x27;EOF&#x27;</span><br><span class="line">  #include &quot;Vour.h&quot;</span><br><span class="line">  #include &quot;verilated.h&quot;</span><br><span class="line">  int main(int argc, char** argv) &#123;</span><br><span class="line">      VerilatedContext* contextp = new VerilatedContext;</span><br><span class="line">      contextp-&gt;commandArgs(argc, argv);</span><br><span class="line">      Vour* top = new Vour&#123;contextp&#125;;</span><br><span class="line">      while (!contextp-&gt;gotFinish()) &#123; top-&gt;eval(); &#125;</span><br><span class="line">      delete top;</span><br><span class="line">      delete contextp;</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</blockquote>
<p>​	<code>#include &quot;Vour.h&quot;</code>和<code>#include &quot;verilated.h&quot;</code> 第一个头文件是verilator将our.v转换为的c++头文件，这样我们可以在C++文件中构建一个our模块的实例<code>Vour* top = new Vour&#123;contextp&#125;;</code> <code>top-&gt;eval();</code>用来更新模拟状态。</p>
<p>​	<strong>以下是个人的理解！！不一定对！！</strong></p>
<ul>
<li><code>contextp</code>是一个指向<code>VerilatedContext</code>(Verilated 上下文)的指针 。<code>contextp-&gt;commandArgs(argc, argv);</code>将verilator上下文与命令行参数联系在一起。<code>Vour* top = new Vour&#123;contextp&#125;;</code> 将实例与上下文联系在一起。<code>contextp-&gt;gotFinish()</code>是用来判断verilator是否接收到终止指令。</li>
</ul>
<p>​	现在我们编写双控开关的C++文件，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Vtop.h&quot;</span><br><span class="line">#include &quot;verilated.h&quot;</span><br><span class="line">int main(int argc, char ** argv) &#123;</span><br><span class="line">	VerilatedContext* contextp = new VerilatedContext;</span><br><span class="line">	contextp-&gt;commandArgs(argc, argv);</span><br><span class="line">	Vtop* top = new Vtop&#123;contextp&#125;;</span><br><span class="line">	while (!contextp-&gt;gotFinish()) &#123;</span><br><span class="line">		int a = rand() &amp; 1;</span><br><span class="line">		int b = rand() &amp; 1;</span><br><span class="line">		top-&gt;a = a;</span><br><span class="line">		top-&gt;b = b;</span><br><span class="line">		top-&gt;eval();</span><br><span class="line">		printf(&quot;a = %d, b = %d, f = %d\n&quot;, a, b, top-&gt;f);</span><br><span class="line">		assert(top-&gt;f == (a ^ b));</span><br><span class="line">	&#125;</span><br><span class="line">	delete top;</span><br><span class="line">	delete contextp;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="任务：理解RTL仿真的行为"><a href="#任务：理解RTL仿真的行为" class="headerlink" title="任务：理解RTL仿真的行为"></a>任务：理解RTL仿真的行为</h2><blockquote>
<p>阅读verilator编译出的C++代码, 然后结合verilog代码, 尝试理解仿真器进行仿真的时候都发生了什么。</p>
</blockquote>
<p>​	将verilog的模块作为一个类实现。并且结合C++testbench文件实现了仿真功能。</p>
<h2 id="打印并查看波形"><a href="#打印并查看波形" class="headerlink" title="打印并查看波形"></a>打印并查看波形</h2><blockquote>
<p>查看波形文件是RTL调试的常用手段之一. verilator支持波形的生成, 你可以通过开源的波形查看工具GTKWave来查看波形.</p>
</blockquote>
<h2 id="任务：生成波形并查看"><a href="#任务：生成波形并查看" class="headerlink" title="任务：生成波形并查看"></a>任务：生成波形并查看</h2><blockquote>
<p>verilator手册中已经介绍了波形生成的方法, 你需要阅读手册找到相关内容, 然后按照手册中的步骤生成波形文件, 并通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install gtkwave</span><br></pre></td></tr></table></figure>

<p>安装GTKWave来查看波形.</p>
</blockquote>
<p>​	下载手册后用<code>ctrl+f</code>搜索<code>gtkwave</code>找到<code>Install GTKWave</code>，跟着步骤一步一步来就装好了。装好之后怎么用呢？提示说verilator中有答案，但是我们在手册里面没有搜到有关教程。回到代码里看一看，我们知道一般代码包里都会有example，打开example发现有如下文件。</p>
<p><img src="/../images/%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/%E6%88%AA%E5%B1%8F2023-08-21%2014.44.20-2600269.png" alt="截屏2023-08-21 14.44.20"></p>
<p>​	<del>之前有说-c是C++文件-SC是systemC文件，我们用的是Makefile，tracing后缀用来追踪波形，那就打开<code>make_tracing_sc</code>文件看看Makefile写了些什么。(笔者好像是在网上搜索了一下博客发现的，有点忘记了)。</del></p>
<p>​	这部分是在南京大学数字逻辑与计算机组成课程实验里找到答案的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Make waveforms</span><br><span class="line">VERILATOR_FLAGS += --trace</span><br></pre></td></tr></table></figure>

<p>​	现在我们知道要得到波形文件需要添加<code>--trace</code>，由于波形文件一般会占用较多的磁盘空间, 长时间生成波形可能会导致磁盘空间耗尽, 从而导致系统崩溃。所以适当修改testbench。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &quot;Vtop.h&quot;</span><br><span class="line">#include &quot;verilated.h&quot;</span><br><span class="line">+++</span><br><span class="line">#include &quot;verilated_vcd_c.h&quot;</span><br><span class="line">+++</span><br><span class="line">int main(int argc, char** argv, char** env) &#123;</span><br><span class="line">	VerilatedContext* contextp = new VerilatedContext;</span><br><span class="line">	contextp-&gt;commandArgs(argc, argv);</span><br><span class="line">	Vtop* top = new Vtop&#123;contextp&#125;;</span><br><span class="line"></span><br><span class="line">+++</span><br><span class="line">	VerilatedVcdC* tfp = new VerilatedVcdC; // initialize VDC pointer</span><br><span class="line">	contextp-&gt;traceEverOn(true); // turn on the tracing mode</span><br><span class="line">	top-&gt;trace(tfp, 0);</span><br><span class="line">	tfp-&gt;open(&quot;wave.vcd&quot;); // set the output file wave.vcd</span><br><span class="line">+++</span><br><span class="line"></span><br><span class="line">	// while(!contextp-&gt;gotFinish()) &#123;</span><br><span class="line">	for(int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">		int a = rand() &amp; 1;</span><br><span class="line">		int b = rand() &amp; 1;</span><br><span class="line">		top-&gt;a = a;</span><br><span class="line">		top-&gt;b = b;</span><br><span class="line">		top-&gt;eval();</span><br><span class="line">		printf(&quot;a = %d, b = %d, f= %d\n&quot;, a, b , top-&gt;f);</span><br><span class="line">+++</span><br><span class="line">		tfp-&gt;dump(contextp-&gt;time()); // dump wave</span><br><span class="line">		contextp-&gt;timeInc(1); // push simulate time                      +++                   </span><br><span class="line">		assert(top-&gt;f == (a ^ b));</span><br><span class="line">	&#125;</span><br><span class="line">	delete top;</span><br><span class="line">	tfp-&gt;close();</span><br><span class="line">	delete contextp;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	大概是这样的写法，波形文件如下图所示：符合 <code>f = a ^ b </code></p>
<p><img src="/../images/%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/%E6%88%AA%E5%B1%8F2023-08-21%2015.11.15-2601879-2601886-2601889-2601914.png" alt="截屏2023-08-21 15.11.15"></p>
<h2 id="任务：一键仿真"><a href="#任务：一键仿真" class="headerlink" title="任务：一键仿真"></a>任务：一键仿真</h2><blockquote>
<p>反复键入编译运行的命令是很不方便的, 尝试为<code>npc/Makefile</code>编写规则<code>sim</code>, 实现一键仿真, 如键入<code>make sim</code>即可进行上述仿真.</p>
</blockquote>
<p>​	这部分是关于Makefile的学习，推荐看<a target="_blank" rel="noopener" href="https://www.itsembedded.com/dhd/vivado_sim_3/">itsembedded的教程</a>进行学习。笔者将自己的简易实现放在这里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">all:</span><br><span class="line">	@echo &quot;Write this Makefile by your self.&quot;</span><br><span class="line">sim:</span><br><span class="line">	$(call git_commit, &quot;sim RTL&quot;) # DO NOT REMOVE THIS LINE!!!</span><br><span class="line">	@echo &quot;Write this Makefile by your self.&quot;</span><br><span class="line">	verilator -Wall csrc/main.cpp vsrc/example.v --cc --trace --exe --build</span><br><span class="line">include ../Makefile</span><br></pre></td></tr></table></figure>

<h2 id="接入NVBOARD"><a href="#接入NVBOARD" class="headerlink" title="接入NVBOARD"></a>接入NVBOARD</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/NJU-ProjectN/nvboard.git">NVBoard</a>(NJU Virtual Board)是南京大学开发的, 用于教学的虚拟FPGA板卡项目, 可以在RTL仿真环境中提供一个虚拟板卡的界面, 支持拨码开关, LED灯, VGA显示等功能, 在速度要求不高的场景下可完全替代真实的FPGA板卡(毕竟不是每人身边都有一块FPGA). 通过以下命令获取NVBoard的代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ysyx-workbench</span><br><span class="line">bash init.sh nvboard</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="任务：运行NVBoard示例"><a href="#任务：运行NVBoard示例" class="headerlink" title="任务：运行NVBoard示例"></a>任务：运行NVBoard示例</h2><blockquote>
<p>阅读NVBoard项目的介绍, 尝试运行NVBoard项目中提供的示例.</p>
</blockquote>
<p>​	浏览器可以直接搜到nvboard的github，阅读readme，并运行example里的实例</p>
<h2 id="任务：在NVBoard上实现双控开关"><a href="#任务：在NVBoard上实现双控开关" class="headerlink" title="任务：在NVBoard上实现双控开关"></a>任务：在NVBoard上实现双控开关</h2><blockquote>
<p>阅读NVBoard项目的说明, 然后仿照该示例下的C++文件和Makefile, 修改你的C++文件, 为双控开关的输入输出分配引脚, 并修改<code>npc/Makefile</code>使其接入NVBoard.</p>
</blockquote>
<p>​	双控开关的verilog 文件不需要更改，仿照<code>NVboard/example</code>的testbench文件修改C++文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;nvboard.h&gt;</span><br><span class="line">#include &quot;Vtop.h&quot;</span><br><span class="line">static TOP_NAME dut;</span><br><span class="line">void nvboard_bind_all_pins(Vtop* top);</span><br><span class="line">int main() &#123;</span><br><span class="line">	nvboard_bind_all_pins(&amp;dut);</span><br><span class="line">	nvboard_init();</span><br><span class="line">	while(1) &#123;</span><br><span class="line">		dut.eval();</span><br><span class="line">		nvboard_update();</span><br><span class="line">	&#125;</span><br><span class="line">	nvboard_quit();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	TOP_NAME 实例化一个top模块dut，<code>nvboard_bind_all_pins(Vtop* top);</code>将模块上的引脚按照<code>constr/top.nxdc</code>中描述的方式连接。<code>nvboard_init();</code>初始化nvboard，通过<code>while(1)</code>循环等待鼠标事件发生。<code>dut.eval() nvboard_update();</code>用于更新模块和nvboard。<code>nvboard_quit();</code>退出nvboard。</p>
<p>​	NVBoard的引脚名字在<code>nvboard/board/N4</code>中。top.nxdc文件中给出连接方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">top=top</span><br><span class="line"></span><br><span class="line">a SW0</span><br><span class="line">b SW1</span><br><span class="line">f LD0</span><br></pre></td></tr></table></figure>

<p>​	top &#x3D; top_modulename, 顶层模块名，<code>a SW0</code>表示a 连接到SW0上。makefile文件仿照nvboard示例即可。 效果如下：</p>
<p><img src="/../images/%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/%E6%88%AA%E5%B1%8F2023-08-21%2016.47.47-2607672.png" alt="截屏2023-08-21 16.47.47"></p>
<h2 id="示例：流水灯"><a href="#示例：流水灯" class="headerlink" title="示例：流水灯"></a>示例：流水灯</h2><h2 id="任务：将流水灯接入NVBoard"><a href="#任务：将流水灯接入NVBoard" class="headerlink" title="任务：将流水灯接入NVBoard"></a>任务：将流水灯接入NVBoard</h2><blockquote>
<p>编写流水灯模块, 然后接入NVBoard并分配引脚. 如果你的实现正确, 你将看到灯从右端往左端依次亮起并熄灭.</p>
</blockquote>
<p>​	理解了如何接入NVBoard后，这个任务非常的简单。Makefile保持不变，要注意的地方就是C++文件和nxdc文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;nvboard.h&gt;</span><br><span class="line">#include &quot;Vtop.h&quot;</span><br><span class="line"></span><br><span class="line">static TOP_NAME dut;</span><br><span class="line"></span><br><span class="line">void nvboard_bind_all_pins(Vtop* top);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void single_cycle() &#123;</span><br><span class="line">	dut.clk = 0; dut.eval();</span><br><span class="line">	dut.clk = 1; dut.eval();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void reset(int n) &#123;</span><br><span class="line">	dut.rst = 1;</span><br><span class="line">	while(n-- &gt; 0) single_cycle();</span><br><span class="line">	dut.rst = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	nvboard_bind_all_pins(&amp;dut);</span><br><span class="line">	nvboard_init();</span><br><span class="line">	reset(10);</span><br><span class="line"></span><br><span class="line">	while(1) &#123;</span><br><span class="line">		nvboard_update();</span><br><span class="line">		single_cycle();</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">top=top</span><br><span class="line"></span><br><span class="line">led (LD15, LD14, LD13, LD12, LD11, LD10, LD9, LD8, LD7, LD6, LD5, LD4, LD3, LD2, LD1, LD0)</span><br><span class="line"></span><br><span class="line">clk PS2_CLK</span><br><span class="line">rst BTNC </span><br></pre></td></tr></table></figure>

<p>​	效果如下，等会一个一个的点亮，但是在连接reset的时候没有找到RST，改到PB_C成功实现reset功能。<img src="/../images/%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/%E6%88%AA%E5%B1%8F2023-08-21%2016.37.47-2607075.png" alt="截屏2023-08-21 16.37.47"></p>
<h2 id="任务：理解RTL仿真的行为-2"><a href="#任务：理解RTL仿真的行为-2" class="headerlink" title="任务：理解RTL仿真的行为(2)"></a>任务：理解RTL仿真的行为(2)</h2><blockquote>
<p>阅读verilator编译出的C++代码, 然后结合verilog代码, 尝试理解仿真器是如何对时序逻辑电路进行仿真的.</p>
</blockquote>
<p>​	对时序逻辑电路的仿真主要是要维护一个时钟，在时钟上沿改变电路的状态。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>​	搭建verilator仿真环境这一章耗费了笔者大约一周的时间，掌握一个新的工具困难在于对未知的恐惧，特别是在学习verilator和nvboard的过程中，由于网络上只有很少的中文博客，导致STFW无法很好的解决问题，只能通过RTFM和RTFSC来学习verilator如何使用。幸运的是几乎所有的README都写的详细并且附带示例，读者只需要在阅读完之后加以模仿，就可以完成讲义里的任务，RTFM的好处在于可以更全面的了解整个程序是如何工作的，一定要动手写代码并运行，观察报错信息并改正它。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/17/Itsembedded/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/17/Itsembedded/" class="post-title-link" itemprop="url">Itsembedded</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-17 13:25:10" itemprop="dateCreated datePublished" datetime="2023-08-17T13:25:10+08:00">2023-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-18 10:16:08" itemprop="dateModified" datetime="2023-08-18T10:16:08+08:00">2023-08-18</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Verilator教程"><a href="#Verilator教程" class="headerlink" title="Verilator教程"></a>Verilator教程</h1><p>详情见<a target="_blank" rel="noopener" href="https://itsembedded.com/dhd/verilator_1/">itsembedded.com</a></p>
<h2 id="Verilator-Pt-1"><a href="#Verilator-Pt-1" class="headerlink" title="Verilator Pt.1"></a>Verilator Pt.1</h2><p>在开始Pt.1之前，请先自学数字电路并且具备一些c&#x2F;c++基础</p>
<ol>
<li><p>在GitHub上下载源码，切换到分支pt1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/n-kremeris/verilator_basics</span><br><span class="line">git checkout verilator_pt1</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了检测verilator是如何工作的，我们需要一种 DUT (device under test)，观察目录下的alu.sv文件。</p>
<ol>
<li>开始定义了一个枚举类声明operation_t，包含add, sub, nop操作。</li>
<li>定义alu模块，包含6个输入和2个输出。</li>
<li>在always语法块中，左边的变量需要用logic或者register</li>
<li>当 clk，rst中任意一个发生改变时，对输入进行更改。</li>
<li>计算结果，用case判读需要进行的操作</li>
<li>输出结果。</li>
</ol>
</li>
<li><p>Verilator 通过c++进行测试，但是无法将SystemVerilog ALU文件加载到C++，testbench中，因此我们要先通过verilator把systemVerilgo ALU 转换为C++文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verilator --cc alu.sv</span><br></pre></td></tr></table></figure>

<p><code>--cc</code>告诉verilator转换为c++，<code>--sc</code>则转换为c。转换后的结果存放在<code>obj_dir</code>中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l obj_dir/</span><br><span class="line">Valu___024unit.cpp  Valu___024unit__Slow.cpp  Valu.cpp  Valu.mk</span><br><span class="line">Valu__Syms.cpp  Valu__ver.d Valu___024unit.h    Valu_classes.mk</span><br><span class="line">Valu.h    Valu__Slow.cpp  Valu__Syms.h    Valu__verFiles.dat</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>.mk</code>文件就被<code>Make</code>命令使用来构造一个模拟可执行文件 。<code>.h</code>和<code>.cpp</code>文件包含执行源码。</p>
<blockquote>
<p>The two files we’re most interested right now are <code>Valu.h</code> and <code>Valu___024unit.h</code>:</p>
<ul>
<li><code>Valu.h</code> - This is the primary design header which  contains the converted “ALU” class definition - this is what we will  “instantiate” in our C++ testbench as the DUT.</li>
<li><code>Valu___024unit.h</code> - This is an internal header for the “ALU” class, and it contains our <code>operation_t</code> type definition.</li>
</ul>
</blockquote>
</li>
<li><p>设计一个c++测试文件，下载的目录里面有一个叫<code>tb_alu.cpp</code>的文件，这就是我们的测试文件。打开并观察它。</p>
<ol>
<li><p>包含一些头文件，<code>&lt;verilated.h&gt;</code>和<code>&lt;verilated_vcd_c.h&gt;</code>有我们需要用到的verilator功能。<code>Valu.h</code>包含了ALU模组的类<code>Valu___024unit.h</code>包含了自定义的声明。</p>
</li>
<li><p><code>sim_time</code>表示模拟时间</p>
</li>
<li><p><code>Valu * dut = new Valu</code>声明了一个ALU模组实例。创建<code>m_trace</code>用于追踪<code>dut</code>,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char** argv, char** env) &#123;</span><br><span class="line">    Valu *dut = new Valu;</span><br><span class="line"></span><br><span class="line">    Verilated::traceEverOn(true);</span><br><span class="line">    VerilatedVcdC *m_trace = new VerilatedVcdC;</span><br><span class="line">    dut-&gt;trace(m_trace, 5);</span><br><span class="line">    m_trace-&gt;open(&quot;waveform.vcd&quot;);</span><br><span class="line"></span><br><span class="line">    /* &lt;...&gt; */</span><br><span class="line"></span><br><span class="line">    m_trace-&gt;close();</span><br><span class="line">    delete dut;</span><br><span class="line">    exit(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>这段代码用于更新模拟时间，<code>dut-&gt;eval();</code>评估所有信号，<code>m_trace-&gt;dump(sim_time);</code>将追踪的信号写入波形转储文件(waveform dump file)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while (sim_time &lt; MAX_SIM_TIME) &#123;</span><br><span class="line">    dut-&gt;clk ^= 1;</span><br><span class="line">    dut-&gt;eval();</span><br><span class="line">    m_trace-&gt;dump(sim_time);</span><br><span class="line">    sim_time++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>构建可执行模拟文件</p>
<ol>
<li><p>再次运行verilator产生包含c++测试文件的<code>.mk</code>文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verilator -Wall --trace -cc alu.sv --exe tb_alu.cpp</span><br></pre></td></tr></table></figure>

<ul>
<li><code>--trace</code> 打开波形追踪</li>
</ul>
</li>
<li><p>构建可执行文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -C obj_dir -f Valu.mk Valu</span><br></pre></td></tr></table></figure>

<p><code>-C obj_dir</code>告诉<code>make</code>在<code>obj_dir</code>目录下工作。<code>-f Valu.mk</code>是makfie文件，Valu可执行文件的名字。构造完成后在<code>obj_dir</code>中会找到<code>Valu</code>二进制可执行文件。</p>
</li>
<li><p>执行<code>./obj_dir/Valu</code>后会出现<code>waveform.vcd</code>，通过命令<code>gtkwave waveform.vcd</code>观察波形文件</p>
</li>
</ol>
</li>
</ol>
<h2 id="在开始Pt2前先学一点Makefile的知识"><a href="#在开始Pt2前先学一点Makefile的知识" class="headerlink" title="在开始Pt2前先学一点Makefile的知识"></a>在开始Pt2前先学一点Makefile的知识</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target_name : dependency_1 dependency_2 dependency_3</span><br><span class="line">    bash_command_that_generates_the_target &lt;parameters&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>make</code>    &lt;-build the first target that appears in the Makefile</li>
<li><code>make target_name</code>    &lt;- build the target with the name <code>target_name</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: waves</span><br><span class="line">waves : adder_tb_snapshot.wdb</span><br><span class="line">    @echo &quot;### OPENING WAVES ###&quot;</span><br><span class="line">    xsim --gui adder_tb_snapshot.wdb</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.PHONY: wave</code> marks the <code>waves</code> target as not generating any output files.</li>
<li>The part <code>: adder_tb_snapshot.wdb</code> tells waves that this file is a required dependency for this target.</li>
<li>“@” character before <code>echo</code> prevents printout of the actual <code>echo</code> command.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TB_TOP := tb</span><br><span class="line"></span><br><span class="line">.PHONY : waves</span><br><span class="line">waves : $(TB_TOP).wdb</span><br><span class="line">        @echo</span><br><span class="line">        @echo &quot;### OPENING WAVES ###&quot;</span><br><span class="line">        xsim --gui $(TB_TOP)_snapshot.wdb</span><br></pre></td></tr></table></figure>

<ul>
<li>store tb as a variable.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ifeq ($(SOURCES),)</span><br><span class="line">some_target :</span><br><span class="line">    @echo &quot;Print message saying that step was skipped&quot;</span><br><span class="line">else</span><br><span class="line">some_target : $(SOURCES)</span><br><span class="line">    run_build_command $(SOURCES)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<ul>
<li>to check if the corresponding source variable is set with <code>make</code>‘s <code>ifeq</code> command</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    rm -rf *.jou *.log *.pb *.wdb xsim.dir      # This deletes all files generated by Vivado</span><br><span class="line">    rm -rf .*.timestamp                         # This deletes all our timestamps</span><br></pre></td></tr></table></figure>

<ul>
<li>删除文件操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SUB ?= VHDL</span><br><span class="line">ifeq ($(SUB), VHDL)</span><br><span class="line">  $(info Building with VHDL subtractor)</span><br><span class="line">  DEFINES_SV := $(DEFINES_SV) -d SUBTRACTOR_VHDL</span><br><span class="line">else ifeq ($(SUB), SV)</span><br><span class="line">  $(info Building with SYSTEMVERILOG subtractor)</span><br><span class="line">  DEFINES_SV := $(DEFINES_SV) -d SUBTRACTOR_SV</span><br><span class="line">else</span><br><span class="line">  $(info )</span><br><span class="line">  $(info BAD SUBTRACTOR TYPE)</span><br><span class="line">  $(info Available options:)</span><br><span class="line">  $(info make SUB=VHDL &lt;target&gt;)</span><br><span class="line">  $(info make SUB=SV &lt;target&gt;)</span><br><span class="line">  $(error )</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<ul>
<li>第一行将SUB设置为变量，如果没有SUB默认为VHDL，<code>make SUB=SV</code>命令将SUB赋值为SV</li>
</ul>
<h2 id="Verilator-Pt-2"><a href="#Verilator-Pt-2" class="headerlink" title="Verilator Pt.2"></a>Verilator Pt.2</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/15/digital-design-and-computer-architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/15/digital-design-and-computer-architecture/" class="post-title-link" itemprop="url">digital design and computer architecture</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-15 13:41:34" itemprop="dateCreated datePublished" datetime="2023-08-15T13:41:34+08:00">2023-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-22 15:20:12" itemprop="dateModified" datetime="2023-08-22T15:20:12+08:00">2023-08-22</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数字设计和计算机体系结构"><a href="#数字设计和计算机体系结构" class="headerlink" title="数字设计和计算机体系结构"></a>数字设计和计算机体系结构</h1><h2 id="第二章-组合逻辑设计"><a href="#第二章-组合逻辑设计" class="headerlink" title="第二章 组合逻辑设计"></a>第二章 组合逻辑设计</h2><ul>
<li><p>与或范式</p>
</li>
<li><p>或与范式</p>
</li>
<li><p>等式化简，展开一个蕴含式:</p>
<p><img src="/../images/digital-design-and-computer-architecture/%E6%88%AA%E5%B1%8F2023-08-15%2014.27.49-2080877-2089511.png" alt="截屏2023-08-15 14.27.49-2080877-2089511"></p>
</li>
<li><p>原理图</p>
<ul>
<li>两条线交叉地方有个点表示之间有连接</li>
<li>两条线交叉地方没有点表示没有连接</li>
</ul>
</li>
<li><p>用符号<code>X</code>表示不需要考虑的输入</p>
</li>
<li><p>推气泡</p>
<ol>
<li>从电路的输出端开始向输入方向推。</li>
<li>将气泡从最后的输出端向输入端推，可以读出输出<code>(Y)</code>的布尔表达式，而非输出的补<code>(^Y)</code>。</li>
<li>继续向后推，以消除每个门的气泡。如果当前的门有一个输入的气泡，则在前面门的输出加上气泡。如果当前的门不带输入气泡，前面的门也不带输出气泡。</li>
<li>气泡式串联删除的，可以忽略中间门的输出气泡和最右边门的输入气泡。</li>
</ol>
</li>
</ul>
<p><img src="/../images/digital-design-and-computer-architecture/%E6%88%AA%E5%B1%8F2023-08-15%2015.00.08-2082815-2089536-2688523.png" alt="截屏2023-08-15 15.00.08-2082815-2089536"></p>
<ul>
<li><code>X</code>和<code>Z</code>：布尔代数局限于0和1.然而，真实的电路中会出现非法值和浮空现象，分别用<code>X</code>和<code>Z</code>表示。<ul>
<li>一个典型的误解是将浮空或者未被驱动的节点和逻辑0等同。事实上浮空节点可能是0或1或之间的电压。</li>
</ul>
</li>
<li>三态缓冲器：<ul>
<li>三种可能输出：高电平<code>(1)</code>，低电平<code>(0)</code>，浮空<code>(Z)</code><ul>
<li>使能端<code>E</code>，高电平有效，作为一个简单的缓冲器，低电平无效，输出被置为高电阻<code>(Z)</code>。2-41反之。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/../images/digital-design-and-computer-architecture/%E6%88%AA%E5%B1%8F2023-08-15%2015.13.21-2083606-2089571-2688548.png" alt="截屏2023-08-15 15.13.21-2083606-2089571"></p>
<ul>
<li><p>卡诺图：一个图形化的化简布尔表达式方法</p>
<ol>
<li>用最少的圈来圈住全部所有的1；</li>
<li>圈中的所有方格必须都为1；</li>
<li>每个圈必须是矩形，其每边长必须是2的整数次幂（1，2，4）；</li>
<li>每个圈必须尽可能大；</li>
<li>圈可以环绕卡诺图的边界；</li>
<li>如果可以使用更少数量的圈，卡诺图中一个为1的方格可以被多次圈住；</li>
<li>如0果可以用较少和较大的圈覆盖1，这些无关项也可以被圈起来。<br><img src="/../images/digital-design-and-computer-architecture/%E6%88%AA%E5%B1%8F2023-08-15%2015.35.01-2084907-2089594-2688805.png" alt="截屏2023-08-15 15.35.01-2084907-2089594"></li>
</ol>
</li>
<li><p>多路选择器，可用于实现逻辑，真值表中的每一行和多路选择器的一个输入相对应。</p>
</li>
<li><p>时序</p>
<ul>
<li>传输延迟<code>(propagation delay)</code>和最小延迟<code>(contamination delay)</code></li>
<li>关键路径和最短路径</li>
<li>传输延迟是关键路径上每个元件的传输延迟之和</li>
<li>最小延迟是在最短路径上每个元件的最小延迟之和</li>
</ul>
</li>
<li><p>毛刺：<img src="/../images/digital-design-and-computer-architecture/%E6%88%AA%E5%B1%8F2023-08-15%2016.25.58.png" alt="截屏2023-08-15 16.25.58"></p>
<ul>
<li>只要读取输出之前的等待时间和传输延迟一样长，出现毛刺是不会有问题的，这是因为输出最终将稳定在正确的值。</li>
</ul>
</li>
</ul>
<h2 id="第三章-时序逻辑设计"><a href="#第三章-时序逻辑设计" class="headerlink" title="第三章 时序逻辑设计"></a>第三章 时序逻辑设计</h2><ul>
<li>锁存器和触发器<ul>
<li>SR锁存器</li>
<li>D锁存器，电平敏感的</li>
<li>D触发器，边沿触发的</li>
<li>寄存器</li>
<li>带使能端的触发器，<code>EN = 0</code> 时将忽略时钟，保持原来的状态不变。</li>
<li>带复位功能的触发器，<code>RESET = 1</code>，带复位功能的触发器忽略<code>D</code>并且将输出Q复位为0。同步复位的触发器仅仅在时钟上升沿时进行复位，异步复位只需要<code>RESET = 1</code>时就可以复位</li>
<li>同步时序电路<ul>
<li>每一个电路元件是寄存器或组合电路</li>
<li>至少有一个电路元件是寄存器</li>
<li>所有寄存器接收同一个时钟信号</li>
<li>每一个环路至少包含一个寄存器</li>
</ul>
</li>
<li>时序逻辑电路的时序</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="theLonging"
      src="/images/touxiang.JPG">
  <p class="site-author-name" itemprop="name">theLonging</p>
  <div class="site-description" itemprop="description">不捨晝夜。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/chantchanH7" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chantchanH7" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/562879980@qq.com" title="E-Mail → 562879980@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-07 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">theLonging</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">250k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:48</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
