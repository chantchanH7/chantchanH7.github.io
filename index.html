<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="不捨晝夜。">
<meta property="og:type" content="website">
<meta property="og:title" content="talk is cheap, show me the code.">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="talk is cheap, show me the code.">
<meta property="og:description" content="不捨晝夜。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="theLonging">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>talk is cheap, show me the code.</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">talk is cheap, show me the code.</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/22/HOT-COLD-DATA-SEPARATION-POLICIES/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/22/HOT-COLD-DATA-SEPARATION-POLICIES/" class="post-title-link" itemprop="url">HOT/COLD DATA SEPARATION POLICIES</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-22 15:50:49" itemprop="dateCreated datePublished" datetime="2024-01-22T15:50:49+08:00">2024-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-23 09:44:27" itemprop="dateModified" datetime="2024-01-23T09:44:27+08:00">2024-01-23</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SSD中冷热数据分类策略的总结"><a href="#SSD中冷热数据分类策略的总结" class="headerlink" title="SSD中冷热数据分类策略的总结"></a>SSD中冷热数据分类策略的总结</h1><h2 id="2-Level-LRU"><a href="#2-Level-LRU" class="headerlink" title="2-Level LRU"></a>2-Level LRU</h2><p>两级<code>LRU</code>策略使用了两种<code>LRU-based</code>列表：热列表<code>(hot list)</code>和候选列表<code>(candidate list)</code>。每个列表包含逻辑页号<code>(LPNs) Logic Page Number</code>。基本上，只有存储在<code>hot list</code>上的逻辑页号才被当作热数据。在这个策略下，当一个写操作被接收时，<code>FTL</code>在两个列表中寻找相关的<code>LPN</code>，如果逻辑页号在<code>host list</code>中，它被提升到<code>host list</code>的首位，以减少被驱逐的机会。如果<code>LPN</code>在<code>candidate list</code>上，将其从<code>candidate list</code>中移除并放入<code>hot list</code>中。如果两个<code>list</code>中都没有该<code>LPN</code>，则将其放到<code>candidate list</code>中。每个<code>list</code>的大小是固定的。如果<code>hot list</code>满了，<code>candidate list</code>中的最后一个<code>LPN</code>会被丢弃。</p>
<p>该策略简单但有问题。固定大小的<code>hot list</code>意味着它无法适应热数据量超过热列表大小的各种工作负载。另一个问题是基于<code>LRU list</code>的查找操作因为线性查找会消耗大量时间。</p>
<h2 id="Multiple-Bloom-Filter"><a href="#Multiple-Bloom-Filter" class="headerlink" title="Multiple Bloom Filter"></a>Multiple Bloom Filter</h2><p><code>MBF</code>策略使用<code>bloom filters (BF)</code>测试当前<code>LPN</code>是否属于热数据集<code>set of hot data</code>。<code>BF</code>由一个位数组组成，其大小是<code>BLOOM_FILTER_SIZE</code>（即位数）。每个逻辑页号<code>(LPN)</code>通过多个不同的哈希函数进行哈希处理，根据每个<code>LPN</code>的哈希结果，BF中相应的位被设置为1。这意味着每个LPN的哈希结果会影响BF中特定位的状态。这个策略通过将<code>LPN</code>映射到BF的特定位来跟踪哪些<code>LPN</code>属于热数据集。如果一个LPN的哈希结果对应的位在BF中已经被设置为1，那么这个<code>LPN</code>被认为是热数据的一部分。这种方法用于快速检测和过滤热数据，优化数据存储和访问效率。</p>
<p>为了最小化错误地将一些非热数据错误分类为热数据的假阳性错误，多重布隆过滤器（MBF）策略利用了多个布隆过滤器（BF）。BF（数字过滤器）的实际数量是可配置的，建议至少有四个BF。在某一点上，其中一个布隆过滤器被指定为当前过滤器<code>cur_filter</code>。对于每个写请求，如果当前过滤器中相应的位已经被设置为<code>1</code>，<code>MBF</code>策略会尝试以循环方式在下一个布隆过滤器的相同位置设置该位。在每个衰减周期之后，当前过滤器被设置为最长时间间隔内未被选中的布隆过滤器，并且该布隆过滤器中的所有位都被清除，以去除旧信息。在<code>MBF</code>策略下，通过使用相同的哈希函数对<code>LPN</code>进行哈希处理，然后计算所有布隆过滤器中对应位位置的置<code>1</code>位数，来估计<code>LPN</code>的热度。如果所有哈希位置的计数超过预定义的阈值，该LPN被分类为热数据。</p>
<p><code>MBF</code>的优点之一是它只消耗很少的内存空间。然而<code>MBF</code>的性能很大程度上依赖于哈希函数的选择，过滤器的数量，过滤器的规模，阈值等。</p>
<blockquote>
<p>什么是布隆过滤器</p>
<p><strong>数据结构：</strong>它实际上是一个很长的二进制向量和一系列随机映射函数。以Redis中的布隆过滤器实现为例，Redis中的布隆过滤器底层是</p>
<ul>
<li><strong>一个大型位数组（二进制数组）</strong></li>
<li><strong>多个无偏hash函数：</strong>无偏hash函数就是能把元素的hash值计算的比较均匀的hash函数，能使得计算后的元素下标比较均匀的映射到位数组中。</li>
</ul>
<p><strong>空间计算：</strong>在布隆过滤器增加元素之前，首先需要初始化布隆过滤器的空间，也就是上面说的二进制数组，除此之外还需要计算无偏hash函数的个数。布隆过滤器提供了两个参数，分别是预计加入元素的大小n，运行的错误率f。布隆过滤器中有算法根据这两个参数会计算出二进制数组的大小l，以及无偏hash函数的个数k。<br>它们之间的关系比较简单：</p>
<ul>
<li>错误率越低，位数组越长，控件占用较大</li>
<li>错误率越低，无偏hash函数越多，计算耗时较长</li>
</ul>
</blockquote>
<h2 id="Dynamic-dAta-Clustering"><a href="#Dynamic-dAta-Clustering" class="headerlink" title="Dynamic dAta Clustering"></a>Dynamic dAta Clustering</h2><p>在<code>LRU</code>和<code>MBF</code>策略中，数据被简单的分为冷热两种。然而，<code>DAC</code>策略通过<code>regions</code>提供更细粒度的数据分类。所有的逻辑页<code>LPN</code>一开始被放在<code>region 0 (coldest)</code>中接着会被慢慢的提升到更高的区域当对同一个逻辑页号有连续的写操作时。另一方面，当一个块被选为垃圾回收对象时，该块中的所有有效页会被降级到更低的<code>region</code>中。</p>
<p><code>DAC</code>中的<code>region</code>数量通常来说被置为4或者更多，当通常是根据工作负载而改变的。此外，由于每个分区都分配了单独的更新块，当干净块的数量紧张时，<code>DAC</code>策略可能表现不佳。</p>
<h2 id="A-New-LSM-style-Garbage-Collection-Scheme-for-ZNS-SSDs中的方法"><a href="#A-New-LSM-style-Garbage-Collection-Scheme-for-ZNS-SSDs中的方法" class="headerlink" title="A New LSM-style Garbage Collection Scheme for ZNS SSDs中的方法"></a>A New LSM-style Garbage Collection Scheme for ZNS SSDs中的方法</h2><p>基于我们的观察，具有类似寿命的数据表现出强烈的空间局部性。例如，在键值存储中，每个层级显示不同的寿命，而同一层级中的<code>SSTables</code>是以批量方式写入的，这一点在之前的研究中也有观察到。</p>
<blockquote>
<ol>
<li><strong>CAO, Z., DONG, S., VEMURI, S., AND DU, D. H. Characteriz- ing, modeling, and benchmarking rocksdb key-value workloads at facebook. In <em>USENIX FAST</em> (2020).</strong></li>
<li><strong>KIM, T., HONG, D., HAHN, S. S., CHUN, M., LEE, S., HWANG, J., LEE, J., AND KIM, J. Fully automatic stream management for multi-streamed ssds using program contexts. In <em>FAST</em> (2019).</strong></li>
</ol>
</blockquote>
<p><img src="/../images/HOT-COLD-DATA-SEPARATION-POLICIES/%E6%88%AA%E5%B1%8F2024-01-22%2019.06.46.png" alt="截屏2024-01-22 19.06.46"></p>
<p>为了分别冷热数据并将它们分到不同的区域中，我们定义四种状态的区域，<code>C0_Zone</code>，<code>C1C_Zone</code>，<code>C1H_Zone</code>和<code>C2_Zone</code>。新到的数据顺序写入<code>C0_zone</code>，删除的数据从图中的状态中删除。</p>
<p>假设<code>LSM_ZGC</code>选择一个状态为<code>C0_zone</code>的候选区域。它读取区域中所有的段并尝试识别冷热数据。我们定义当段的利用率大于阈值<code>thresholdcold</code>时被称为冷。被识别为冷的段中有效块被合并和写入状态为<code>C1C_zone</code>的区域中。其他段中的有效块被合并和写入状态为<code>C1H_zone</code>中。</p>
<p>当候选区域是C1C区域或C1H区域时，LSM ZGC会读取所有段，并将所有有效块视为冷数据。这是因为这些有效块在两次垃圾收集尝试后仍然存在。它们被合并并写入到状态为C2区域的区域中。我们可以进一步扩展，例如C3区域等，但在这项研究中，我们在此停止，并将从C2区域存活下来的有效块写入另一个C2区域。我们期望这种机制能够将冷数据与其他数据隔离开来，这将增加在垃圾收集期间找到利用率较低的候选区域的机会。</p>
<h2 id="Dynamic-Hot-Data-Identification-Using-a-Stack-Distance-Approximation"><a href="#Dynamic-Hot-Data-Identification-Using-a-Stack-Distance-Approximation" class="headerlink" title="Dynamic Hot Data Identification Using a Stack Distance Approximation"></a>Dynamic Hot Data Identification Using a Stack Distance <strong>Approximation</strong></h2><p>热数据的鉴别需要同时考虑最近性<code>(recency)</code>和频率<code>(frequency)</code>。</p>
<p>本文提出一种利用堆栈距离近似的动态热数据鉴别策略。包含三部分：工作负载分析器，负载分配器，冷热数据鉴别器。</p>
<p>我们提议的热&#x2F;冷数据标识符还采用了多个<code>bloom filter</code>和多个<code>hash function</code>。多个<code>bloom filter</code>可以捕获最近性和频率。然而，我们的动态方案和MBF之间的主要区别在于<code>bloom filter</code>选择机制。我们提议的方案明智地选择了其中一个<code>bloom filter</code>，并由我们的<code>workload analyzer</code>和<code>weight allocator</code>协助。</p>
<p>工作负载分析仪通过采用堆栈距离来提供工作负载特征分析。栈距离<code>stack distance</code>是指两次连续访问同一对象之间访问的不同对象的数量。对于时间局部访问模式<code>temporally localized access patterns</code>来说，最近性<code>recency</code>是一个更有价值的因素，堆栈距离是衡量这种时间位置的良好指标。因此，所有引用的平均堆栈距离小，表明时间局部性良好，这意味着堆栈距离较小的工作负载应将最近因素<code>recency</code>视为更重要的因素。栈距离可用于测量最近性，但同时需要高计算复杂度和高空间消耗。因此一个高效的栈距离计算方法是该设计的关键。它只使用一个哈希表，为每个桶维护简单的信息，并通过非常简单的计算生成近似的堆栈距离。因此，拟议的近似机制大大减少了开销，并以非常高的精度表现出显著的性能。</p>
<p>根据工作负载分析，权重分配器通过智能地（而不仅仅是顺序地）选择每个布隆过滤器，动态地赋予最近性或频率更多的权重。此外，与MBF不同，我们的初步工作[1]采用了一个线性递减的最近性权重函数，而我们选择了一个指数递减的权重函数，以更真实地为每个布隆过滤器分配最近性权重。因此，这种动态方案更有效地捕捉了最近性以及频率。</p>
<p><strong>A dynamic hot data identification scheme:</strong> 当工作负载有小的栈距离时，通过选择存储数据最新的重置<code>bloom filter</code>给最近性<code>recency</code>分配更多的权重。当工作负载变现出更大的栈距离时，通过选择相邻的下一个<code>bloom filter</code>分配更多的权重给频率。</p>
<p><strong>A stack distance approximation algorithm:</strong> 它采用了一个哈希表，该哈希表维护简单信息并执行非常简单的计算（即简单的两个值的平均值），从而大幅度降低计算复杂度（O(1)）。权重分配基本上基于这个近似算法。广泛的评估表明，它表现出极高的精确性和优异的性能。</p>
<p><strong>A novel baseline scheme:</strong> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/18/Improving-Flash-Write-Performance-by-Using-Update-Frequency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/18/Improving-Flash-Write-Performance-by-Using-Update-Frequency/" class="post-title-link" itemprop="url">Improving Flash Write Performance by Using Update Frequency</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-18 14:18:15" itemprop="dateCreated datePublished" datetime="2024-01-18T14:18:15+08:00">2024-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-22 11:51:27" itemprop="dateModified" datetime="2024-01-22T11:51:27+08:00">2024-01-22</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Improving-Flash-Write-Performance-by-Using-Update-Frequency"><a href="#Improving-Flash-Write-Performance-by-Using-Update-Frequency" class="headerlink" title="Improving Flash Write Performance by Using Update Frequency"></a>Improving Flash Write Performance by Using Update Frequency</h1><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>由于擦除块的规尺寸很大，有效数据和无效数据通常会被拼接在一起，导致回收空间需要高昂的数据移动。经验表明<code>FTL</code>通常很难”正确”，这是因为闪存清洁开销复杂的依赖性：</p>
<ul>
<li><code>I/O</code>负载性。</li>
<li>多种<code>FTL</code>设计选择，例如空间过度配置，数据放置算法，数据清理策略。</li>
</ul>
<p>尽管有大量的研究工作，但最终结果是低且不可预测的<code>SSD</code>写性能。特别对于产生小而分散的数据库<code>I/O</code>写入密集型工作负载。</p>
<h3 id="这片文章回答的问题：通过利用写斜来指导数据放置，我们可以在多大程度上减少FTL的写入开销？"><a href="#这片文章回答的问题：通过利用写斜来指导数据放置，我们可以在多大程度上减少FTL的写入开销？" class="headerlink" title="这片文章回答的问题：通过利用写斜来指导数据放置，我们可以在多大程度上减少FTL的写入开销？"></a>这片文章回答的问题：通过利用写斜来指导数据放置，我们可以在多大程度上减少FTL的写入开销？</h3><p>我们用一组基本的<code>I/O</code>写入模式（k模态更新分布）、数据放置策略和清理策略的清理开销进行分析建模。基于分析结果，我们提出了一种新的数据放置算法，利用更新频率来减少<code>FTL</code>清理开销，从而提高写入性能和设备寿命。</p>
<h2 id="贡献："><a href="#贡献：" class="headerlink" title="贡献："></a>贡献：</h2><ul>
<li>模拟了空间过度配置、写入频率、数据放置策略和垃圾收集策略对FTL清理开销的影响。该模型对于验证和指导<code>FTL</code>的数据放置算法的设计很有用。通过详细的模拟来验证分析结果。</li>
<li>我们在误差范围内估算出任何给定 I&#x2F;O 工作负载可实现的最小清理开销，这使我们能够量化减少任何 FTL 清理开销的空间。</li>
<li>基于建模结果，提出了一种数据放置算法，该算法以原则性的方式利用更新频率，并且能够动态适应 I&#x2F;O 写入模式，而不依赖于特定于工作负载的参数。 新的数据放置算法可以集成到现有的混合或页面级映射 FTL 中（正如我们在 2.4 节中讨论的）。 实验结果表明，与从标准 DBMS 基准（例如 TPC-C）收集的各种微基准和 I&#x2F;O 跟踪的最先进技术相比，我们的算法将清理开销减少了 20%-75% [24] 或 TATP [19]。</li>
</ul>
<h2 id="相关工作："><a href="#相关工作：" class="headerlink" title="相关工作："></a>相关工作：</h2><h3 id="一些数据放置算法："><a href="#一些数据放置算法：" class="headerlink" title="一些数据放置算法："></a>一些数据放置算法：</h3><p>我们强调了异地更新的数据放置算法的演变，并深入了解为什么一种新方法可以降低FTL清洁开销。事实上，所有<code>FTL</code>数据放置建议都尝试根据数据的更新频率对数据进行分组。</p>
<h3 id="数据放置挑战："><a href="#数据放置挑战：" class="headerlink" title="数据放置挑战："></a>数据放置挑战：</h3><p>在两个区域间移动数据的两个挑战。</p>
<ul>
<li>第一、一个区域<code>(region)</code>的占用率与其清洁成本<code>(cleaning cost)</code>之间存在高度非线性的关系。</li>
<li>第二、各区域<code>(region)</code>清理成本的增加或减少不能立即评估，而在很长一段时间后才能感受到（评估到）。</li>
</ul>
<p>例如，考虑两个分区，第一个分区与第二个分区相比，其占用率和清理成本异常高。显然我们需要将一些数据从第一个分区移动到第二个分区：然而，移动多少数据以及哪些数据并不明确。一个静态的数据提升策略（例如，尝试平衡两个分区之间的清理成本，或者简单的始终提升&#x2F;降级策略）会导致由区域占用率的变化而非工作负载偏差的变化触发的数据移动波动。页面最初从第一个分区向德格清理成本较低的分区移动。在某个点上，清理频率和&#x2F;或清理成本变得相似，页面迁移就停止了。不幸的是，到了这个时候，已经有太多页面被移动，第二个分区的清理成本继续增加。最终，迁移过程反向进行。</p>
<p>在这篇论文中，我们通过对清理成本与数据放置决策之间关系的原理性理解，解决了以往数据放置方法的局限性。我们为足够通用的更新分布建立了清理成本的分析模型，这使我们能够推理出任何给定<code>I/O</code>工作负载的基本清理开销。基于分析模型的发现，我们提出了一个原理性的数据放置算法，该算法在一定误差范围内解决最优解&#x2F;我们的数据放置算法与以往的提议有以下不同之处：</p>
<ul>
<li>没有可调参数。以前的提案依赖于工作负载特点的可变参数。例如区域的数量，从一个区域迁移到下一个区域的时间阈值，经验概率模型。</li>
<li>区域大小与页面更新频率之间没有不匹配。之前的方法建议固定大小的区域，可能导致将更新频率非常不同的页面放在一起；我们的数据提案在运行时确定最优的区域数量（即日志结构）及其最优大小。</li>
<li>准确的页面提升&#x2F;降级。<code>strawman strategy</code>总是将更新的页面提升到热区域， 将擦除的页面降级为冷区域。这样的策略会导致次优性能。清理时，我们可以区分页面是否因区域占用而被清理，还是因为它确实具有较低的更新频率。更新时，当页面足够热以证明将其推广到更热的区域时，我们可以识别精确的阈值。</li>
</ul>
<h2 id="符号和假设"><a href="#符号和假设" class="headerlink" title="符号和假设"></a>符号和假设</h2><ul>
<li><code>α</code>: 过度配置：用户空间和额外空间的比例。</li>
<li><code>μ</code>: 设备利用率：用户空间和总空间。</li>
</ul>
<p>清理块（又称垃圾收集）的开销由有效且需要在擦除块之前重新定位的页面分数给出。表示为<code>Pgc</code>：可解释为百分比或概率，块中的有效页数 &#x2F; 块的总页数。</p>
<p>清理开销 &#x3D; 需要重新定位的有效页面数量 &#x2F; 块中的总页面数量<br>$$<br>P_{gc}&#x3D;\frac{P_{valid}}{P_{total}}<br>$$<br>擦除操作带来的好处，即回收的可用空间量，是块的容量减去页面迁移所消耗的空间。因此，我们定义写放大的概念，即每次用户写入时<code>FTL</code>写入的额外物理空间。<br>$$<br>WA&#x3D;1+\frac{P_{gc}}{1-P_{gc}}&#x3D;1+\frac{P_{valid}}{P_{total}-P_{valid}}<br>$$<br>其中，<code>1</code>代表了存储新写入的用户数据所需的物理写入，只能通过压缩或去重才能避免。第二项代表了由于非原地写入而产生的实际清理开销。我们同样把第二项称为<code>GC (Garbage Collection)</code>。</p>
<p> <strong><code>I/O</code>工作负载：</strong>这篇文章对<code>k-model I/O</code>工作负载的变体进行建模。<code>k-model I/O</code>工作负载代表一种更新分布，其中任何页面的更新频率只能有<code>k</code>个可能的离散值<code>(fi,...,fk)</code>。我们将具有给定更新频率的所有页面称为一个更新集。每个更新集都有一个相关的大小，定义为总用户数据的一部分<code>si</code>，并接收到总更新的一部分<code>fsi</code>。</p>
<p><code>k-model</code>工作负载有两个优势：</p>
<ul>
<li>建模简单。</li>
<li>足够通用，可以近似模拟真实的<code>I/O</code>工作负载。通过将具有相似更新频率的页面”分箱”组合在一起，可以通过<code>k</code>模态工作负载来抽象一般的<code>I/O</code>工作负载。正如我们将看到，页面可以安全地分组到具有指数级增常更新频率的箱中。</li>
</ul>
<h3 id="模型假设"><a href="#模型假设" class="headerlink" title="模型假设"></a>模型假设</h3><p>建模清理开销时，做出如下假设：</p>
<ul>
<li>我们排除了顺序写入。利用顺序写入模式是一个正交的主题，相对容易实现，例如通过检测顺序写入模式并将更新存储在同一个擦除块中。如果同样的页面再次顺序写入，该块被置为无效，并且可以在不进行任何数据移动的情况下被擦除。然而，我们的模型支持任何偏斜的<code>I/O</code>工作负载。</li>
<li>我们只建模长期<code>FTL</code>擦除开销。新格式化的<code>SSD</code>没有立即的清理开销，因为所有闪存块都被擦除并可用于写入，这导致好的但是短暂的写入性能。</li>
</ul>
<h2 id="FTL清理策略"><a href="#FTL清理策略" class="headerlink" title="FTL清理策略"></a><code>FTL</code>清理策略</h2><h3 id="随机更新-1-Modal-Distribution"><a href="#随机更新-1-Modal-Distribution" class="headerlink" title="随机更新(1-Modal Distribution)"></a>随机更新<code>(1-Modal Distribution)</code></h3><p>假设一个由单页更新组成的随机更新工作负载。所有页面拥有相同的更新概率，因此，数据放置并不重要，例如，将任何页面存储在一起没有任何好处，清除成本只依赖于块选择策略。</p>
<p>贪婪策略：选择具有最少有效页的块进行更新。由于所有页面的更新频率相同，并且更新不相关，因此贪婪政策是最佳的。</p>
<p>我们首先对<code>LRU</code>和<code>Greedy policy</code>进行建模，表明<code>LRU</code>清洁政策接近最佳是实际重要性的。</p>
<p>闪存设备可以考虑为圆形日志结构，其中更新附加到尾部，每当需要空间时，清理总是从日志头开始，写入最古老的块。</p>
<p>在完整的日志循环中，写入操作要么是由页面迁移引起的，要么是由实际用户更新引起的。</p>
<p>在每次用户更新时，一个给定页面不会被置为无效的概率是，其中<code>N</code>是页面的总数：<br>$$<br>1-\frac{1}{N}<br>$$<br>而清理过程不会产生无效化（一旦有效页面被重新定位，一个块就会立即被擦除）。因此，一个给定页面在整个日志循环期间保持有效的概率是它在一次更新中避免无效化的概率的总用户更新次数的幂。</p>
<p>假设总共有<code>(1 + α) * N</code>个物理页，<code>Pgc</code>的一部分会因为擦除过程中的重新分配被”浪费”，而<code>(1 - Pgc)</code>的物理页面事实上存储新的用户数据。因此，我们可以通过方程的极限推导出<code>Pgc</code>。<br>$$<br>P_{gc}&#x3D;(1-\frac{1}{N})^{N(1+α)(1-p_{gc})}<br>$$<br>当<code>N</code>足够大的时候，我们应用欧拉极限<code>Euler&#39;s limit</code> :<br>$$<br>P_{gc}&#x3D;e^{-(1+α)(1-p_{gc})}<br>$$<br>它接受解析解：<br>$$<br>P_{gc}&#x3D;-\frac{W(-(1+α)e^{-(1+α)})}{1+α}<br>$$<br>上面公式中的<code>W</code>是<code>Lambert-W</code>函数，即:<br>$$<br>z&#x3D;W(z)e^{W(z)}<br>$$<br>的解。<code>W</code>不能表示为代数函数的组合。然而，<code>W</code>可以进行数值计算（例如通过泰勒展开），尽管从实际角度来看，这相当繁琐。</p>
<p>因此我们提出一种简单的近似方法。注意到：<br>$$<br>-(1+α)e^{-α}⊂(-e^{-1},0)\quadα ∈ R^+<br>$$<br>因此我们需要在一个相当小的范围内近似<code>W</code>。最终得到代数近似：<br>$$<br>P_{gc}\approx\frac{e^{-0.9\alpha}}{1+\alpha}<br>$$<br>方程<code>(9)</code>提供了在分配额外容量和清理性能之间的定量权衡，它表明，随着超额配置的增加，<code>Pgc</code>的减少速度略快于指数级。</p>
<h4 id="贪婪清除策略Greedy-cleaning-policy"><a href="#贪婪清除策略Greedy-cleaning-policy" class="headerlink" title="贪婪清除策略Greedy cleaning policy"></a>贪婪清除策略<code>Greedy cleaning policy</code></h4><p>为了量化贪婪清洁政策的好处，我们需要考虑超过方程4给出的平均pgc值：我们还需要对有效页面在擦除块上的分布进行建模。</p>
<p>对于<code>LRU</code>和<code>Greedy</code>策略：无论何时我们需要回收空间时，我们选择具有最少有效页数量的最老写入的<code>B</code>个块。当<code>B = 1</code>时，清除策略变为<code>LRU</code>；当<code>B = (1 + α) N / C</code>时变为贪婪策略。建模时考虑如下：</p>
<ul>
<li><p>概率分布函数<code>Pgc</code>，简称为<code>(PDF)</code>，是关于<code>α</code>过量配置的函数。</p>
<p>块中的有效页数量遵循二项分布，块中任何两个页拥有相等且无关的<code>Pgc</code>概率是有效的。因此，一个块有<code>k</code>个有效页面的概率是：<br>$$<br>p(k)&#x3D;\begin{pmatrix}<br>C\<br>k\<br>\end{pmatrix}\cdot {P_{pc}}^k \cdot (1-p_{gc})^{C-k}<br>$$<br>请注意，<code>Pgc(α)</code>由方程4给出，概率分布函数<code>PDF(Pgc)</code>是一个向量：<br>$$<br>PDF(p_{gc})&#x3D;\begin{bmatrix}p(C) &amp; p(C - 1) &amp; … &amp; p(0)\end{bmatrix}<br>$$<br>标准差为：<br>$$<br>stddev&#x3D;\sqrt{C\cdot p_{gc}\cdot (1-p_{gc})}<br>$$</p>
</li>
<li></li>
<li><p>PDF更改为块在清洁窗口中位置的函数。</p>
<p>使页面失效的过程可以用以下马尔可夫链过渡矩阵表示：<br>$$<br>M&#x3D;\begin{bmatrix}<br>\frac{N-C}{N} &amp; \frac{C}{N} &amp; … &amp; 0 \<br>. &amp; . &amp; . &amp; \<br>&amp; &amp; \frac{1}{N} &amp; \frac{C-1}{N}\<br>0 &amp; 0 &amp; 0 &amp; 1\<br>\end{bmatrix}<br>$$<br><code>M(i, i)</code> 代表一个块在更新时所有页面避免无效化的概率，并且该块保持有<code> C - i</code> 个有效页面的同一状态。<code>M(i, i + 1)</code> 代表迁移到下一个状态的概率，这个状态定义为有 <code>C - i - 1</code> 个有效页面。在 <code>n</code> 次更新后的 <code>PDF</code> 变化简单地表示为<br>$$<br>PDF_{new} &#x3D; PDF_{old} · M^n<br>$$<br>而更新的次数 n 反过来由块在清理窗口中的位置决定。</p>
</li>
<li><p>如何计算通过增加<code>B</code>窗口获得的收益。</p>
<p>我们无法推断出分析公式来给出<code>Pgc</code>和窗口大小<code>B</code>之间的简明关系，但是，<code>Pgc</code>减少可以计算为：<br>$$<br>Benefit&#x3D;\sum_{i&#x3D;2}^{B}(PDF_{old}-PDF_i)\cdot \begin{bmatrix}<br>C &amp; C-1 &amp;…&amp; 1 &amp; 0\end{bmatrix}’<br>$$<br>“Benefit” 指的是通过设置大小为 B 的清理窗口，从而节省的平均有效页面数量，这些页面不需要重新定位。请注意，所有的术语都是向量，而且最后一个元素代表马尔可夫链模型状态的有效页面数量。</p>
<p>最终结果表明窗口贪婪策略只有很少的好处。</p>
<p>于是我们总结<code>Greedy</code>和<code>Window-Greedy</code>策略对于随机更新来说不是必须的。</p>
</li>
</ul>
<h3 id="2-modal-Distribution"><a href="#2-modal-Distribution" class="headerlink" title="2-modal Distribution"></a>2-modal Distribution</h3><p>我们模拟两种不同情况下双模态工作负载（页面要么是热的，要么是冷的）的清理开销：a) 当页面是随机共置的，b) 当页面根据它们的更新频率分开存储时。</p>
<h4 id="随机数据放置"><a href="#随机数据放置" class="headerlink" title="随机数据放置"></a>随机数据放置</h4><p>页面更新的频率只有<code>f1</code>和<code>f2</code>两种情况，两种集合的大小为<code>s1</code>和<code>s2</code>，并让<code>fr = f1 / f2</code>为两个更新集之间的相对页面更新频率。我们假设页面是随机配置的，并且使用LRU策略（即日志结构化数据放置）清理块。</p>
<p>设<code>Pgc1</code>、<code>Pgc2</code>为更新集1和更新集2的页面分别在垃圾收集中有效的概率，并设<code>Pavg</code>为随机选择的页面有效的概率。<code>Pgc1</code>、<code>Pgc2</code>可以使用与第4.1节类似的逻辑表示，经过一系列操作后我们得到：<br>$$<br>\frac{log(p_{gc1})}{log(p_{gc2})}&#x3D;f_r ⇔ p_{gc1}&#x3D;p_{gc2}^{f_r}<br>$$<br>公式(16)总结了两组的有效页面概率之间的关系，并表明在垃圾收集中必须重新放置较冷的页面的概率与<code>fr-th</code>根向1增长。例如，如果集合2是冷<code>cold</code>则<code>fr &gt; 1</code>且<br>$$<br>P_{gc2}&#x3D;\sqrt[fr]{p_{gc1}}<br>$$<br><code>Pavg</code>和<code>pgc1</code>,<code>pgc2</code>之间的关系是从以下条件下推导出的，即总清洁开销等于与每个更新集相关的部分清洁开销的总和。也即：<br>$$<br>p_{avg}&#x3D;1-\frac{(1-p_{gc1})(1-p_{gc2})}{f_{s1}(1-p_{gc2})+f_{s2}(1-p_{gc1})}<br>$$<br><strong>解析近似：</strong>为了便于理解清理开销，我们还提出了一个封闭公式近似，用于<code>Pavg</code>，<code>Pgc1</code>，<code>Pgc2</code>。该近似基于对每个更新集的页面数量计数。如果我们在某一时刻抓取日志结构<code>log-structure</code>中的所有页面，会发现有<br>$$<br>\frac{s_1+s_2}{1+\alpha}<br>$$<br>比例的页面包含集合1和集合2的有效用户页。</p>
<h4 id="基于频率的数据放置策略"><a href="#基于频率的数据放置策略" class="headerlink" title="基于频率的数据放置策略"></a>基于频率的数据放置策略</h4><p>直观上，根据更新频率，可以通过分页减少清洁开销，正如之前的工作所观察到的那样。在第4.2.1节中，我们确定了热数据和冷数据之间的相对差异，根据更新频率来分离页面是合理的。<strong>接下来，我们将展示如何优化分离数据并计算最低清洁开销。</strong></p>
<p>规定<br>$$<br>\beta \cdot N \quad (\beta &lt; \alpha)<br>$$<br>为分配给第一个日志结构的过度配置页数。剩余的过度配置分配给第二个日志结构。</p>
<p>由于每个页面有单一的更新频率，新的页面更新概率可以用方程<code>(9)</code>来计算。</p>
<p>全局清洁开销，<code>GCavg</code>，是每个区域的单个清洁开销的总和，按区域的更新频率加权：<br>$$<br>GC_{tot}&#x3D;f_{s1}\frac{p_{gc1}}{1-p_{gc1}}+f_{s2}\frac{p_{gc2}}{1-p_{gc2}}<br>$$<br>由于<code>Pgc1</code>，<code>Pgc2</code>依赖于额外的空间分配，剩余的挑战是如何将额外的容量预算最优地分配给每个更新集合。即如何选择β以减小<code>GCtot</code>。</p>
<p>通过对方程10求导，我们找到了使 <code>GC(β)</code> 达到全局最小值的 <code>β</code> （<code>GC(β)</code> 是一个凸函数）。将方程3代入方程10之后，我们将导数表示为：<br>$$<br>\frac{\partial GC_{tot}}{\partial \beta} &#x3D; \frac{f_{s1} W_1}{s_1(W_1 + 1)(W_1 + z_1)} - \frac{f_{s2} W_2}{s_2(W_2 + 1)(W_2 + z_2)}<br>$$<br>使用简化符号：<br>$$<br>z_1&#x3D;1+\frac{\beta}{s_1};\<br>z_2&#x3D;1+\frac{\alpha-\beta}{s_2};\<br>W_i&#x3D;W(-z_ie^{z_i});\<br>$$<br>最优点<code>β</code>是导数为0的点，也即当：<br>$$<br>f_r&#x3D;\frac{W_1}{(W_1+1)(W_1+z_1)}&#x3D;\frac{W_2}{(W_2+1)(W_2+z_2)}<br>$$<br>影响最优点<code>β</code>的参数有三个：</p>
<ul>
<li>过度配置<code>α</code></li>
<li>相对更新频率<code>fr</code></li>
<li>更新集合的大小<code>si</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/17/SSD-based-Workload-Characteristics-and-Their-Performance-Implications/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/17/SSD-based-Workload-Characteristics-and-Their-Performance-Implications/" class="post-title-link" itemprop="url">SSD-based Workload Characteristics and Their Performance Implications</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-17 11:11:02" itemprop="dateCreated datePublished" datetime="2024-01-17T11:11:02+08:00">2024-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-27 19:49:15" itemprop="dateModified" datetime="2024-01-27T19:49:15+08:00">2024-01-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SSD-based-Workload-Characteristics-and-Their-Performance-Implications"><a href="#SSD-based-Workload-Characteristics-and-Their-Performance-Implications" class="headerlink" title="SSD-based Workload Characteristics and Their Performance Implications"></a>SSD-based Workload Characteristics and Their Performance Implications</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction:"></a>Introduction:</h2><h3 id="SSD的优化目标与硬盘不同："><a href="#SSD的优化目标与硬盘不同：" class="headerlink" title="SSD的优化目标与硬盘不同："></a>SSD的优化目标与硬盘不同：</h3><ul>
<li>SSD上组织数据，目标是最大化并行性和最小化垃圾收集开销。</li>
<li>SSD优化以数据移动为目标，而不是数据放置。</li>
<li>允许进行复杂的优化并快速调整工作负载的变化。</li>
</ul>
<h3 id="与SSD设计和性能相关的特征："><a href="#与SSD设计和性能相关的特征：" class="headerlink" title="与SSD设计和性能相关的特征："></a>与SSD设计和性能相关的特征：</h3><ul>
<li>温度范围。</li>
<li>逻辑局部性（概括了简单的空间局部性和顺序性）。</li>
<li>增加SSD页面大小的敏感性。</li>
</ul>
<h3 id="将上述特征与SSD性能相关联："><a href="#将上述特征与SSD性能相关联：" class="headerlink" title="将上述特征与SSD性能相关联："></a>将上述特征与SSD性能相关联：</h3><ul>
<li>写放大：设备上写入的数据量与应用程序写入的数据量之间的比率与高尾延迟和降低的耐用性相关。</li>
<li>读放大：从SSD读取的数据量与应用程序请求的数据量之间的比率。</li>
<li>闪存读取成本：包括从闪存介质读取数据并将其传输到控制器的低级延迟。</li>
</ul>
<h3 id="发现证实了建议的特征与SSD设计和优化的相关性："><a href="#发现证实了建议的特征与SSD设计和优化的相关性：" class="headerlink" title="发现证实了建议的特征与SSD设计和优化的相关性："></a>发现证实了建议的特征与SSD设计和优化的相关性：</h3><ul>
<li>增加 SSD 内逻辑分区的数量可减少写入放大。 然而，这需要大量的开销并且带来收益递减。 最佳分区数量小于以前研究中建议的数量。</li>
<li>读取放大随着页面大小的增加而增加，并且主要取决于请求大小的分布。 然而，对地址范围的重复访问会显着降低读取放大。 这种减少的程度可以通过逻辑空间局部性来估计。</li>
<li>通过有选择地从大页中读取部分字节范围，可以有效降低闪存读取成本。 我们简单的贪婪算法足以达到此目的，展示了向主机导出“部分读取”接口的潜在好处。</li>
</ul>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background:"></a>Background:</h2><h3 id="工作负载"><a href="#工作负载" class="headerlink" title="工作负载"></a>工作负载</h3><ul>
<li>the University of Massachusetts (SPC traces) </li>
<li>Microsoft Research at Cambridge</li>
<li>Microsoft production servers</li>
<li>Florida International University</li>
</ul>
<p>我们关注这些工作负载上的普遍属性</p>
<ul>
<li>Request arrival time (relative to the beginning of the trace) 请求到达时间，与trace的开始相关。</li>
<li>Volume number 存储体编号</li>
<li>Request size (in byte) 请求大小</li>
<li>I&#x2F;O operation I&#x2F;O操作（读或写）</li>
</ul>
<h3 id="温度范围"><a href="#温度范围" class="headerlink" title="温度范围"></a>温度范围</h3><p>工作负载偏斜传统上被用来通过使用缓存来优化性能。如果缓存足够大能存储应用程序的工作集，则大部分请求不需要访问底层设备。在这种情况下，常用的经验法则，比如80-20法则——它指出80%的请求访问了20%的数据——经常被用来估计工作负载所需的缓存大小。因此，传统的分析通过评估工作集大小或热数据（频繁访问的数据）的数量来描述工作负载的偏斜程度。虽然这些对于优化硬盘和缓存性能是足够的，但对于固态硬盘（SSD）的优化，更详细的分析可能会带来更多的好处。</p>
<p>在闪存层的设计中，通过分离冷热数据到不同的逻辑分区中可以减小写放大，垃圾回收开销，和单元磨损。这样的分类同样也可以优化磨损均衡和页面重用。因此，许多闪存将数据分类到两个区域。</p>
<p>Stoica和Ailamaki的研究表明，只要每个分区内的访问偏斜足够小，就可以将几种不同的温度级别的数据分组到同一个分区中，而不会增加写放大的现象。我们基于这一分析，根据工作负载所需的最小分区数量来进行特征描述。然后我们量化了在最佳数量过高时分配较少分区的成本。我们特别感兴趣的是常见的两个分区情况，用于热数据和冷数据。</p>
<h4 id="表征温度范围"><a href="#表征温度范围" class="headerlink" title="表征温度范围"></a>表征温度范围</h4><p>​	当一个逻辑页被写入SSD时，FTL将原来的物理地址标记为无效的然后选择芯片和平面，根据条带和负载均匀策略将一页写入。然后将页写入平面中的一个活跃块（一个已经被擦除但还没有完全写满的块）。将数据分别放入N个逻辑分区需要每个平面有N个活跃块。</p>
<p>​	根据<code>Stoica 和 Ailamaki</code>的定义，<code>fi</code>表示页面<code>i</code>的更新频率。理想的情况下，每个分区将包含具有相同更新频率的页面。这显然是不切实际的，因为现代芯片每个平面只有512个块。相反，具有多个访问频率的逻辑页面被分组到每个分区（读者认为这里的一个分区<code>partition</code>就是一个块<code>block</code>）中。<code>fr(p)</code>表示分区<code>p</code>中的更新频率比，这是存储在<code>p</code>中的页面的最大和最小更新频率之间的比率。<code>fr</code>表示所有分区的最大比率。参考[57]中的理论分析表明，确保<code>fr ≤ 2</code>足以最小化垃圾回收开销。然而，这个结果没有考虑到维护所需分区数量的开销。</p>
<p>​	为了确定在现代芯片组织下这种优化是否现实，我们计算了确保<code>fr ≤ 2</code>所需的最小分区数量。我们根据更新的频率对每个工作负载中的逻辑扇区进行排名，并贪婪的将他们分配给不同的分区：：我们从第一个分区开始，分配给它更新频率最高的页面<code>i</code>以及所有满足<code>fj ≥ fi /2</code>的页面<code>&#123;j&#125;</code>。然后我们将下一个页面分配给第二个分区，以此类推。我们在分析基于硬件驱动器<code>(HDD)</code>的迹象和基于固态硬盘<code>SSD</code>的<code>RocksDB</code>迹象时，分别使用了512字节和4KB的扇区大小，以反映这些迹象中观察到的访问粒度。我们将在第4节中更详细地讨论访问粒度。</p>
<p>​	我们的结果显示，所需的最少分区数量在2到16之间变化，并且在不同类别之间有所不同。图<code>1(a)</code>展示了每个类别的第25、50和第75百分位数，垂直线显示了每个类别所需的最小和最大分区数量（键值类别包括单个RocksDB迹象，因此用一个小圆圈表示）。例如，对于75%的数据库管理系统（DBMS）工作负载和键值工作负载，9个分区就足够了，而75%的邮件服务器工作负载至少需要14个分区。我们在不同限制下的<code>fr</code>上重复了这个实验。不出所料，位了维持更低的比例，需要更多的分区。所需最少分区数量从3到26不等，用于<code>fr ≤ 1.5</code>，当<code>fr ≤ 3</code>时，需要2到11个分区。</p>
<p>​	<strong>发现一：</strong>实现写入放大的理论下限需要大量的分区。</p>
<p>​	为了理解这些结果的影响，考虑最先进的企业<code>SSD</code>，每个平面有521个块和<code>28%</code>的过度配置空间。每个平面将有400个可用的逻辑块。因此为了维持<code>16</code>个分区，<code>4%</code>的块需要作为活跃块，平均<code>2%</code>的逻辑容量将无法利用。除了这种开销外，还必须考虑在<code>SSD</code>的<code>RAM</code>中将页面维护和分类为几个分区的成本。</p>
<p>​	SSD设计可能会限制分区数量，以利用专用硬件，或最大限度地减少分区开销。为了评估次优分区的影响，我们重复上述过程以穷尽地找到<code>fmin(N)</code>–贪婪分区方案导致N个预定数量的分区时的最低比率。图<code>1(c)</code>展示了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/11/Lab-page-tables/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/11/Lab-page-tables/" class="post-title-link" itemprop="url">Lab: page tables</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-11 20:03:25" itemprop="dateCreated datePublished" datetime="2024-01-11T20:03:25+08:00">2024-01-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-26 13:31:59" itemprop="dateModified" datetime="2024-01-26T13:31:59+08:00">2024-01-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>26k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>24 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab-page-tables"><a href="#Lab-page-tables" class="headerlink" title="Lab: page tables"></a>Lab: page tables</h1><p>准备工作：</p>
<ol>
<li>阅读<code>book-riscv-rev1</code>第三章</li>
<li>阅读<code>memlayout.h</code></li>
<li>阅读<code>vm.c</code></li>
<li>阅读<code>riscv.h</code></li>
<li>阅读<code>kalloc.c</code></li>
<li>阅读<code>exec.c</code></li>
</ol>
<h2 id="从main-c开始："><a href="#从main-c开始：" class="headerlink" title="从main.c开始："></a>从<code>main.c</code>开始：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start() jumps here in supervisor mode on all CPUs.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">    kinit();         <span class="comment">// physical page allocator</span></span><br><span class="line">    kvminit();       <span class="comment">// create kernel page table</span></span><br><span class="line">    kvminithart();   <span class="comment">// turn on paging</span></span><br><span class="line">    procinit();      <span class="comment">// process table</span></span><br><span class="line">    trapinit();      <span class="comment">// trap vectors</span></span><br><span class="line">    trapinithart();  <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinit();      <span class="comment">// set up interrupt controller</span></span><br><span class="line">    plicinithart();  <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">    binit();         <span class="comment">// buffer cache</span></span><br><span class="line">    iinit();         <span class="comment">// inode table</span></span><br><span class="line">    fileinit();      <span class="comment">// file table</span></span><br><span class="line">    virtio_disk_init(); <span class="comment">// emulated hard disk</span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(started == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hart %d starting\n&quot;</span>, cpuid());</span><br><span class="line">    kvminithart();    <span class="comment">// turn on paging</span></span><br><span class="line">    trapinithart();   <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinithart();   <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">  &#125;</span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kinit-函数分配物理页面physical-page-allocator"><a href="#kinit-函数分配物理页面physical-page-allocator" class="headerlink" title="kinit()函数分配物理页面physical page allocator:"></a><code>kinit()</code>函数分配物理页面<code>physical page allocator:</code></h3><p>其中<code>end</code>指向内核代码后的第一个地址，也即<code>kernel data</code>结束的地方，现在我们知道，<code>freerange()</code>函数将图中<code>Free memory</code>的部分全部清空，并以页面对齐的形式存入<code>freelist</code>中。</p>
<p><img src="/../images/Lab-page-tables/%E6%88%AA%E5%B1%8F2024-01-16%2011.02.46.png" alt="截屏2024-01-16 11.02.46"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kinit</span><span class="params">()</span> &#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>); <span class="comment">// kinit 初始化保护 kmem 的自旋锁</span></span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP); <span class="comment">// freerange 对 end 到 PHYSTOP 之间的每一页调用 kfree 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="freerange-函数"><a href="#freerange-函数" class="headerlink" title="freerange()函数:"></a><code>freerange()</code>函数:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);	<span class="comment">// 将起始地址按页对齐</span></span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="kfree-函数"><a href="#kfree-函数" class="headerlink" title="kfree()函数:"></a><code>kfree()</code>函数:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free the page of physical memory pointed at by pa,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP) <span class="comment">// 判断物理地址是否规范</span></span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">  <span class="comment">// 将该页填充垃圾数据</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line">  acquire(&amp;kmem.lock);	<span class="comment">// 请求锁</span></span><br><span class="line">  r-&gt;next = kmem.freelist;	<span class="comment">// 头插法插入空闲页列表</span></span><br><span class="line">  kmem.freelist = r;	</span><br><span class="line">  release(&amp;kmem.lock);	<span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kvminit-函数创建内核页表："><a href="#kvminit-函数创建内核页表：" class="headerlink" title="kvminit()函数创建内核页表："></a><code>kvminit()</code>函数创建内核页表：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the one kernel_pagetable</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvminit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  kernel_pagetable = kvmmake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="kvmmake-为内核制作一个直接映射的页表："><a href="#kvmmake-为内核制作一个直接映射的页表：" class="headerlink" title="kvmmake()为内核制作一个直接映射的页表："></a><code>kvmmake()</code>为内核制作一个直接映射的页表：</h4><p>其中<code>etext</code>指向内核代码结束的地方，即<code>kernel text</code>结束的地方。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Make a direct-map page table for the kernel.</span></span><br><span class="line"><span class="type">pagetable_t</span> <span class="title function_">kvmmake</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">pagetable_t</span> kpgtbl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建内核页表</span></span><br><span class="line">  kpgtbl = (<span class="type">pagetable_t</span>) kalloc();	<span class="comment">// kalloc()函数从freelist中取出一页并返回</span></span><br><span class="line">  <span class="built_in">memset</span>(kpgtbl, <span class="number">0</span>, PGSIZE);	<span class="comment">// 将内核页表填充空</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W); <span class="comment">// 直接映射 uart 寄存器的 虚拟地址 到 物理地址</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W); <span class="comment">// 直接映射 virtio disk 接口的 虚拟地址 到 物理地址</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  kvmmap(kpgtbl, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W); <span class="comment">// 直接映射 PLIC 的 虚拟地址 到 物理地址，大小为 0x400000</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// kernel text 在 内核代码结束的地方往下增长一个 KERNBASE 大小</span></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将内核数据和物理内存映射</span></span><br><span class="line">  <span class="comment">// 接着上面映射，将kernel data 和 free memory 映射到 从 etext 到 PHYSTOP 的物理地址空间中</span></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 映射 负责 trap entry/exit 的 trampoline</span></span><br><span class="line">  <span class="comment">// trampoline 是在 内核虚拟地址的最高处</span></span><br><span class="line">  <span class="comment">// 即从最大的虚拟地址向下分配一页给 trampoline</span></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为每一个进程分配和映射 内核栈</span></span><br><span class="line">  <span class="comment">// allocate and map a kernel stack for each process.</span></span><br><span class="line">  proc_mapstacks(kpgtbl);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> kpgtbl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="proc-mapstacks-函数为进程分配一页内核栈："><a href="#proc-mapstacks-函数为进程分配一页内核栈：" class="headerlink" title="proc_mapstacks()函数为进程分配一页内核栈："></a><code>proc_mapstacks()</code>函数为进程分配一页内核栈：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map kernel stacks beneath the trampoline,</span></span><br><span class="line"><span class="comment">// each surrounded by invalid guard pages.</span></span><br><span class="line"><span class="comment">// 内核栈映射到 trampoline 的下方，每一个内核栈页紧跟一个保护页</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACK(p) (TRAMPOLINE - (p)*2*PGSIZE - 3*PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a page for each process&#x27;s kernel stack.</span></span><br><span class="line"><span class="comment">// Map it high in memory, followed by an invalid guard page.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">proc_mapstacks</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="comment">// 遍历所有进程，为每一个进程分配一页内核栈</span></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="type">char</span> *pa = kalloc();	<span class="comment">// 分配物理页面</span></span><br><span class="line">    <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">    uint64 va = KSTACK((<span class="type">int</span>) (p - proc));	<span class="comment">// 映射后返回虚拟地址</span></span><br><span class="line">    kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);	<span class="comment">// 将虚拟地址 映射到 物理地址上</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kvminithart-函数启用分页："><a href="#kvminithart-函数启用分页：" class="headerlink" title="kvminithart()函数启用分页："></a><code>kvminithart()</code>函数启用分页：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Switch h/w page table register to the kernel&#x27;s page table, and enable paging.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvminithart</span><span class="params">()</span>	<span class="comment">// 将硬件页表寄存器切换到内核的页表，并启用分页</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// wait for any previous writes to the page table memory to finish.</span></span><br><span class="line">  sfence_vma();</span><br><span class="line">  <span class="comment">// install the kernel page table</span></span><br><span class="line">  <span class="comment">// writes the physical page address of the root page-table page into the register satp</span></span><br><span class="line">  <span class="comment">// after this the CPU will translate addresses using the kernel page table</span></span><br><span class="line">  <span class="comment">// 加载内核页表</span></span><br><span class="line">  <span class="comment">// 将 根页表页的物理页地址写入 寄存器satp 中</span></span><br><span class="line">  <span class="comment">// 然后 cpu 可以通过 内核页表 翻译地址</span></span><br><span class="line">  w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line">  <span class="comment">// flush stale entries from the TLB.</span></span><br><span class="line">  sfence_vma();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use riscv&#x27;s sv39 page table scheme.</span></span><br><span class="line"><span class="comment">// 使用 riscv&#x27;s sv39 页表标准</span></span><br><span class="line"><span class="comment">// SV39是一种支持39位虚拟地址的页表模式。将8L左移60位，是为了将模式设置位放置在`satp`寄存器的最高位，因为在SV39模式中，`satp`寄存器的 [63:60] 位用于指定页表模式。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP_SV39 (8L &lt;&lt; 60)</span></span><br><span class="line"><span class="comment">// 右移12位是因为RISC-V中的页表基地址是按4KB对齐的，所以低12位应该是0。右移操作删除了这些对齐位。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAKE_SATP(pagetable) (SATP_SV39 | (((uint64)pagetable) &gt;&gt; 12))</span></span><br></pre></td></tr></table></figure>

<h3 id="procinit-初始化进程表："><a href="#procinit-初始化进程表：" class="headerlink" title="procinit()初始化进程表："></a><code>procinit()</code>初始化进程表：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize the proc table.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">procinit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  initlock(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);</span><br><span class="line">  initlock(&amp;wait_lock, <span class="string">&quot;wait_lock&quot;</span>);</span><br><span class="line">  <span class="comment">// 开始时 p = proc，p 的位置是数组 proc[NPROC] 的起始位置</span></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      initlock(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line">      p-&gt;state = UNUSED;</span><br><span class="line">      p-&gt;kstack = KSTACK((<span class="type">int</span>) (p - proc));</span><br><span class="line">      <span class="comment">// 指针相减就是地址相减，获取当前进程p和proc数组最开始位置的偏移量</span></span><br><span class="line">      <span class="comment">// 比如第一次 p - proc = 0，则p-&gt;kstack = TRAMPOLINE - 3 * PGSIZE</span></span><br><span class="line">      <span class="comment">// 3 个 pagesize 分别是</span></span><br><span class="line">      <span class="comment">// trampolie</span></span><br><span class="line">      <span class="comment">// guard page 占一个 pagesize</span></span><br><span class="line">      <span class="comment">// kstack0    占一个 pagesize</span></span><br><span class="line">      <span class="comment">// guard page 占一个 pagesize</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="memlayout-h头文件描述了物理内存的布局"><a href="#memlayout-h头文件描述了物理内存的布局" class="headerlink" title="memlayout.h头文件描述了物理内存的布局"></a><code>memlayout.h</code>头文件描述了物理内存的布局</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Physical memory layout</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu -machine virt is set up like this,</span></span><br><span class="line"><span class="comment">// based on qemu&#x27;s hw/riscv/virt.c:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 00001000 -- boot ROM, provided by qemu</span></span><br><span class="line"><span class="comment">// 02000000 -- CLINT</span></span><br><span class="line"><span class="comment">// 0C000000 -- PLIC</span></span><br><span class="line"><span class="comment">// 10000000 -- uart0 </span></span><br><span class="line"><span class="comment">// 10001000 -- virtio disk </span></span><br><span class="line"><span class="comment">// 80000000 -- boot ROM jumps here in machine mode</span></span><br><span class="line"><span class="comment">//             -kernel loads the kernel here</span></span><br><span class="line"><span class="comment">// unused RAM after 80000000.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the kernel uses physical memory thus:</span></span><br><span class="line"><span class="comment">// 80000000 -- entry.S, then kernel text and data</span></span><br><span class="line"><span class="comment">// end -- start of kernel page allocation area</span></span><br><span class="line"><span class="comment">// PHYSTOP -- end RAM used by the kernel</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu puts UART registers here in physical memory.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0 0x10000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0_IRQ 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// virtio mmio interface</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO0 0x10001000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO0_IRQ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_NET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_IRQ 33</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// core local interruptor (CLINT), which contains the timer.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT 0x2000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT_MTIMECMP(hartid) (CLINT + 0x4000 + 8*(hartid))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT_MTIME (CLINT + 0xBFF8) <span class="comment">// cycles since boot.</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu puts platform-level interrupt controller (PLIC) here.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC 0x0c000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_PRIORITY (PLIC + 0x0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_PENDING (PLIC + 0x1000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_MENABLE(hart) (PLIC + 0x2000 + (hart)*0x100)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SENABLE(hart) (PLIC + 0x2080 + (hart)*0x100)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_MPRIORITY(hart) (PLIC + 0x200000 + (hart)*0x2000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SPRIORITY(hart) (PLIC + 0x201000 + (hart)*0x2000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_MCLAIM(hart) (PLIC + 0x200004 + (hart)*0x2000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SCLAIM(hart) (PLIC + 0x201004 + (hart)*0x2000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the kernel expects there to be RAM</span></span><br><span class="line"><span class="comment">// for use by the kernel and user pages</span></span><br><span class="line"><span class="comment">// from physical address 0x80000000 to PHYSTOP.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNBASE 0x80000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHYSTOP (KERNBASE + 128*1024*1024)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map the trampoline page to the highest address,</span></span><br><span class="line"><span class="comment">// in both user and kernel space.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAMPOLINE (MAXVA - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map kernel stacks beneath the trampoline,</span></span><br><span class="line"><span class="comment">// each surrounded by invalid guard pages.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACK(p) (TRAMPOLINE - (p)*2*PGSIZE - 3*PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// User memory layout.</span></span><br><span class="line"><span class="comment">// Address zero first:</span></span><br><span class="line"><span class="comment">//   text</span></span><br><span class="line"><span class="comment">//   original data and bss</span></span><br><span class="line"><span class="comment">//   fixed-size stack</span></span><br><span class="line"><span class="comment">//   expandable heap</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   USYSCALL (shared with kernel)</span></span><br><span class="line"><span class="comment">//   TRAPFRAME (p-&gt;trapframe, used by the trampoline)</span></span><br><span class="line"><span class="comment">//   TRAMPOLINE (the same page as in the kernel)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE)  <span class="comment">// 将 USYSCALL 映射到 TRAPFRAME 地址空间后的一页</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> pid;  <span class="comment">// Process ID</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="vm-c描述了内核地址和用户地址的处理："><a href="#vm-c描述了内核地址和用户地址的处理：" class="headerlink" title="vm.c描述了内核地址和用户地址的处理："></a><code>vm.c</code>描述了内核地址和用户地址的处理：</h2><h3 id="pte-t-walk-pagetable-t-pagetable-uint64-va-int-alloc-函数返回虚拟地址va对应的页表项"><a href="#pte-t-walk-pagetable-t-pagetable-uint64-va-int-alloc-函数返回虚拟地址va对应的页表项" class="headerlink" title="pte_t *walk(pagetable_t pagetable, uint64 va, int alloc)函数返回虚拟地址va对应的页表项"></a><code>pte_t *walk(pagetable_t pagetable, uint64 va, int alloc)</code>函数返回虚拟地址va对应的页表项</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the address of the PTE in page table pagetable</span></span><br><span class="line"><span class="comment">// that corresponds to virtual address va. If alloc!=0,</span></span><br><span class="line"><span class="comment">// create any required page-table pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The risc-v Sv39 scheme has three levels of page-table</span></span><br><span class="line"><span class="comment">// pages. A page-table page contains 512 64-bit PTEs.</span></span><br><span class="line"><span class="comment">// A 64-bit virtual address is split into five fields:</span></span><br><span class="line"><span class="comment">//   39..63 -- must be zero.</span></span><br><span class="line"><span class="comment">//   30..38 -- 9 bits of level-2 index.</span></span><br><span class="line"><span class="comment">//   21..29 -- 9 bits of level-1 index.</span></span><br><span class="line"><span class="comment">//   12..20 -- 9 bits of level-0 index.</span></span><br><span class="line"><span class="comment">//    0..11 -- 12 bits of byte offset within the page.</span></span><br><span class="line"><span class="comment">// walk函数为给定va找到其对应的PTE</span></span><br><span class="line"><span class="type">pte_t</span> *<span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)   <span class="comment">// 给定va不能大于最大虚拟地址</span></span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">    <span class="comment">// 根据当前level，对va进行移位和掩码操作，得到当前level页表的中对应PTE</span></span><br><span class="line">    <span class="comment">// 当 level = 2 时，向右移出 12 + 2 * 9 = 30, 经掩码后得到9位level=2页表的PTE编号</span></span><br><span class="line">    <span class="comment">// 当 level = 1 时，向右移出 12 + 1 * 9 = 21, 经掩码后得到9位level=1页表的PTE编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;  <span class="comment">// 判断有效位</span></span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">      <span class="comment">// 提取物理地址，对应一个页的首地址</span></span><br><span class="line">      <span class="comment">// PTE2PA 函数将最右10位标志位移出，补充12位全0偏移位（12位对应offset），原44位 PPN 保留，得到指向下一层页表的物理地址</span></span><br><span class="line">      <span class="comment">// level = 2 时，pagetable 指向 level = 1 的页表</span></span><br><span class="line">      <span class="comment">// level = 1 时，pagetable 指向 level = 0 的页表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 对应PTE不存在，且alloc被置位，则为该PTE指向的下一层页表分配一页</span></span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 一切清0，新分配的下一级页表的所有PTE也是无效的</span></span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      <span class="comment">// 更新PTE，将56位物理地址右移12位去掉偏移位，移进10位标志位，同时将PTE_V置1</span></span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 跳出循环，此时 pagetable 指向level = 0 的页表</span></span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">  <span class="comment">// level=0，向右移出12位，经掩码后得到9位level=0页表的PTE编号</span></span><br><span class="line">  <span class="comment">// 返回va对应的level=0页表中的对应PTE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uint64-walkaddr-pagetable-t-pagetable-uint64-va-返回虚拟地址va对应的物理地址："><a href="#uint64-walkaddr-pagetable-t-pagetable-uint64-va-返回虚拟地址va对应的物理地址：" class="headerlink" title="uint64 walkaddr(pagetable_t pagetable, uint64 va)返回虚拟地址va对应的物理地址："></a><code>uint64 walkaddr(pagetable_t pagetable, uint64 va)</code>返回虚拟地址<code>va</code>对应的物理地址：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look up a virtual address, return the physical address,</span></span><br><span class="line"><span class="comment">// or 0 if not mapped.</span></span><br><span class="line"><span class="comment">// Can only be used to look up user pages.</span></span><br><span class="line">uint64 <span class="title function_">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> &#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  pa = PTE2PA(*pte);	<span class="comment">// 通过PTE寻找PA</span></span><br><span class="line">  <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kvmmap-为内核页表添加映射："><a href="#kvmmap-为内核页表添加映射：" class="headerlink" title="kvmmap()为内核页表添加映射："></a><code>kvmmap()</code>为内核页表添加映射：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a mapping to the kernel page table.</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvmmap</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kpgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-mappages-pagetable-t-pagetable-uint64-va-uint64-size-uint64-pa-int-perm"><a href="#int-mappages-pagetable-t-pagetable-uint64-va-uint64-size-uint64-pa-int-perm" class="headerlink" title="int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)"></a><code>int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)</code></h3><p>该函数为虚拟地址<code>va</code>设置到物理地址<code>pa</code>的页表项，<code>va</code>和<code>size</code>必须是按页对齐的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class="line"><span class="comment">// physical addresses starting at pa.</span></span><br><span class="line"><span class="comment">// va and size MUST be page-aligned.</span></span><br><span class="line"><span class="comment">// Returns 0 on success, -1 if walk() couldn&#x27;t</span></span><br><span class="line"><span class="comment">// allocate a needed page-table page.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span> &#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;   <span class="comment">// 指向将要分配的 page table entry</span></span><br><span class="line">  <span class="comment">// 判断是否按页对齐</span></span><br><span class="line">  <span class="keyword">if</span>((va % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: va not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((size % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: size not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: size&quot;</span>);</span><br><span class="line">  <span class="comment">// a 是 va的起始地址</span></span><br><span class="line">  a = va;</span><br><span class="line">  <span class="comment">// last 是 va 的终止地址，按页对齐</span></span><br><span class="line">  last = va + size - PGSIZE;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;mappages: remap&quot;</span>); <span class="comment">// 该 pte 已经被分配，其 PTE_V 位 有效</span></span><br><span class="line">    <span class="comment">// 将物理地址的 PPN 取出来，加上标志位信息 prem 和 有效位 PTE_V</span></span><br><span class="line">    <span class="comment">// 然后将该有效位 放入 pte 中</span></span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="keyword">if</span>(a == last)   <span class="comment">// 分配到了足够的页数就跳出循环</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">    <span class="comment">// 已经分配了一页，虚拟地址的起始位置和物理地址的起始位置都增加一页</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-uvmunmap"><a href="#void-uvmunmap" class="headerlink" title="void uvmunmap()"></a><code>void uvmunmap()</code></h3><p>从虚拟地址<code>va</code>开始，移除 <code>npages</code> 个映射。<code>va</code>必须是页对齐的。这些映射必须是存在的。且可选的释放物理内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remove npages of mappings starting from va. va must be</span></span><br><span class="line"><span class="comment">// page-aligned. The mappings must exist.</span></span><br><span class="line"><span class="comment">// Optionally free the physical memory.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  <span class="keyword">if</span>((va % PGSIZE) != <span class="number">0</span>)	<span class="comment">// 虚拟地址必须是页对齐的</span></span><br><span class="line">    panic(<span class="string">&quot;uvmunmap: not aligned&quot;</span>);</span><br><span class="line">  <span class="comment">/* 循环遍历从 va 开始的 n 个页 */</span></span><br><span class="line">  <span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)	<span class="comment">// walk函数找到a对应的PTE</span></span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: walk&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)	<span class="comment">// 检查该 PTE 是否有效</span></span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: not mapped&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(PTE_FLAGS(*pte) == PTE_V) <span class="comment">// 检查是否为叶子页表条目</span></span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(do_free)&#123;	<span class="comment">// do_free 为真时，释放内存</span></span><br><span class="line">      uint64 pa = PTE2PA(*pte);	<span class="comment">// 通过 PTE2PA 获取物理地址 </span></span><br><span class="line">      kfree((<span class="type">void</span>*)pa);	<span class="comment">// 释放物理内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pagetable-t-uvmcreate-创建一个空用户页表并返回"><a href="#pagetable-t-uvmcreate-创建一个空用户页表并返回" class="headerlink" title="pagetable_t uvmcreate()创建一个空用户页表并返回"></a><code>pagetable_t uvmcreate()</code>创建一个空用户页表并返回</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create an empty user page table.</span></span><br><span class="line"><span class="comment">// returns 0 if out of memory.</span></span><br><span class="line"><span class="type">pagetable_t</span> <span class="title function_">uvmcreate</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line">  pagetable = (<span class="type">pagetable_t</span>) kalloc();	<span class="comment">// 分配一页</span></span><br><span class="line">  <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uint64-uvmalloc-为进程分配PTE和物理内存，以便增加进程的内存大小"><a href="#uint64-uvmalloc-为进程分配PTE和物理内存，以便增加进程的内存大小" class="headerlink" title="uint64 uvmalloc()为进程分配PTE和物理内存，以便增加进程的内存大小"></a><code>uint64 uvmalloc()</code>为进程分配<code>PTE</code>和物理内存，以便增加进程的内存大小</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">uvmalloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz, <span class="type">int</span> xperm)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line">  uint64 a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(newsz &lt; oldsz)</span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line"></span><br><span class="line">  oldsz = PGROUNDUP(oldsz);	<span class="comment">// 将 oldsz 上调到最近的页大小倍数</span></span><br><span class="line">  <span class="comment">// 按页大小循环</span></span><br><span class="line">  <span class="keyword">for</span>(a = oldsz; a &lt; newsz; a += PGSIZE)&#123;</span><br><span class="line">    mem = kalloc();	<span class="comment">// 分配一页</span></span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="comment">// 将虚拟地址 a 以页大小映射到 新分配的物理地址 mem 中</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != <span class="number">0</span>)&#123;</span><br><span class="line">      kfree(mem);</span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newsz;	<span class="comment">// 返回新大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uint64-uvmdealloc-减少进程的内存大小，即释放一部分用户空间内存。"><a href="#uint64-uvmdealloc-减少进程的内存大小，即释放一部分用户空间内存。" class="headerlink" title="uint64 uvmdealloc()减少进程的内存大小，即释放一部分用户空间内存。"></a><code>uint64 uvmdealloc()</code>减少进程的内存大小，即释放一部分用户空间内存。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Deallocate user pages to bring the process size from oldsz to</span></span><br><span class="line"><span class="comment">// newsz.  oldsz and newsz need not be page-aligned, nor does newsz</span></span><br><span class="line"><span class="comment">// need to be less than oldsz.  oldsz can be larger than the actual</span></span><br><span class="line"><span class="comment">// process size.  Returns the new process size.</span></span><br><span class="line">uint64 <span class="title function_">uvmdealloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(newsz &gt;= oldsz)	<span class="comment">// 新的大小必须小于旧的大小</span></span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line">	<span class="comment">// 将 newsz, oldsz 上调到最近的页大小倍数</span></span><br><span class="line">  <span class="keyword">if</span>(PGROUNDUP(newsz) &lt; PGROUNDUP(oldsz))&#123;</span><br><span class="line">    <span class="comment">// 计算出新旧大小间的页面数量</span></span><br><span class="line">    <span class="type">int</span> npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;</span><br><span class="line">    uvmunmap(pagetable, PGROUNDUP(newsz), npages, <span class="number">1</span>);	<span class="comment">// 取消从新的大小开始，到旧的大小之间的 n 页映射</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="freewalk-pagetable-t-pagetable-递归释放页表中的页面，所有的叶子映射必须被移除"><a href="#freewalk-pagetable-t-pagetable-递归释放页表中的页面，所有的叶子映射必须被移除" class="headerlink" title="freewalk(pagetable_t pagetable)递归释放页表中的页面，所有的叶子映射必须被移除"></a><code>freewalk(pagetable_t pagetable)</code>递归释放页表中的页面，所有的叶子映射必须被移除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recursively free page-table pages.</span></span><br><span class="line"><span class="comment">// All leaf mappings must already have been removed.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freewalk</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123; <span class="comment">// 检查条目是否有效且非叶子（即指向另一个页表）</span></span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      freewalk((<span class="type">pagetable_t</span>)child);</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      panic(<span class="string">&quot;freewalk: leaf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*)pagetable);	<span class="comment">// 释放当前页表所占用的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-uvmfree-释放用户空间页，然后释放页表页面"><a href="#void-uvmfree-释放用户空间页，然后释放页表页面" class="headerlink" title="void uvmfree()释放用户空间页，然后释放页表页面"></a><code>void uvmfree()</code>释放用户空间页，然后释放页表页面</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free user memory pages,</span></span><br><span class="line"><span class="comment">// then free page-table pages.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uvmfree</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(sz &gt; <span class="number">0</span>)</span><br><span class="line">    uvmunmap(pagetable, <span class="number">0</span>, PGROUNDUP(sz)/PGSIZE, <span class="number">1</span>); <span class="comment">// 先取消映射</span></span><br><span class="line">  freewalk(pagetable);	<span class="comment">// 然后释放页表中的所有页</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h2><p>一些操作系统通过共享用户空间和内核之间的仅读区域的数据加速某些系统调用。这消除了在执行这些系统调用时对内核交叉的需求。为了帮助你学习如何向页表中插入映射，你的第一个任务是为<code>xv6</code>的<code>getpid()</code>系统调用实现这种优化。</p>
<blockquote>
<p>当进程被创建时，在<code>USYSCALL</code>（一个在<code>memlayout.h</code>定义的虚拟地址）映射一个只读页面。在这个页面的开始，存储了一个<code>struct usyscall</code>，用于保存当前进程的<code>PID</code>。这个实验中，<code>ugetpid()</code>在用户空间中被提供并将会自动的使用<code>USYSCALL</code>映射。</p>
</blockquote>
<p>提示：</p>
<ul>
<li>选择合适的允许位使用户空间访问只读页面。</li>
<li>在新页面的生命周期中需要完成一些事情。为了获得灵感，请了解内核<code>kernel/proc.c</code>中的陷阱框架处理。</li>
</ul>
<p>结构体<code>usyscall</code>用于保存进程<code>ID</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> pid;  <span class="comment">// Process ID</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>函数<code>ugetpid()</code>，其中<code>USYSCALL</code>是一个全局变量，指向用户空间的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ugetpid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> *<span class="title">u</span> =</span> (<span class="keyword">struct</span> usyscall *)USYSCALL;</span><br><span class="line">  <span class="keyword">return</span> u-&gt;pid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>看一看<code>kernel/proc.c</code>中如何描述一个<code>page table</code>的生命周期的？</p>
<blockquote>
<p><code>trampoline (跳板)</code>：通常指的是一种用于实现不同函数或程序段之间跳转的技术，特别是在操作系统内核中用于系统调用和中断处理的上下文切换。</p>
<p><code>trampoline</code>在操作系统内核中的应用</p>
<p>1.系统调用和中断处理：</p>
<ul>
<li>在操作系统中，当程序执行1系统调用或当发生中断时，需要从用户模式<code>(user mode)</code>切换到内核模式<code>(kernel mode)</code>。</li>
<li>这种模式切换涉及到处理器状态的大量改变，如切换栈，改变权限级别等。</li>
</ul>
<p>2.上下文切换：</p>
<ul>
<li><code>Trampoline</code>通常用于这种上下文切换的过程。它提供了一个固定的、已知的内核空间地址，用户模式代码可以跳转到这个地址以执行系统调用或响应中断。</li>
<li>这个跳板代码负责保存当前的执行上下文（如寄存器状态），设置适当的内核栈，然后跳转到实际的系统调用或中断处理函数。</li>
</ul>
<p><code>trapframe (陷阱帧)</code>通常指的是一种数据结构，它用于在发生异常或中断（统称为“陷阱”）时保存进程或线程的状态。当操作系统必须处理这样的事件时，它会保存当前执行环境的关键信息到<code>trapframe</code>中，以便之后可以恢复并继续执行。</p>
<ol>
<li>保存上下文：<ul>
<li>当系统调用、中断或其他异常发生时，当前进程的状态（如CPU寄存器的值）会被保存到<code>trapframe</code>中。</li>
<li>这包含程序计数器（PC）、堆栈指针（SP）、状态寄存器和其他重要的寄存器。</li>
</ul>
</li>
<li>上下文切换</li>
</ol>
<ul>
<li><code>Trapframe</code>使得操作系统能够在处理完中断或异常后，准确地恢复到发生中断前的状态，继续执行进程。</li>
<li>这是多任务操作系统实现时间共享的关键机制之一。</li>
</ul>
<ol start="3">
<li>系统调用：<ul>
<li>对于系统调用，<code>trapframe</code>可以用来传递调用参数和返回值。</li>
</ul>
</li>
</ol>
<p><code>Trapframe page:</code></p>
<ul>
<li>特定内存页：<ul>
<li>在某些操作系统实现中，每个进程或线程的<code>trapframe</code>可能被存储在一个特定的内存页中，这个页称为<code>trapframe page</code>。</li>
<li>这个页面通常位于进程的用户空间内存中的一个固定位置。</li>
</ul>
</li>
<li>访问和管理：<ul>
<li>操作系统内核负责管理这些页面，并在需要时读写<code>trapframe</code>的内容。</li>
<li>这种方法为每个进程提供了一个独立的空间来存放其中断或异常的状态信息。</li>
</ul>
</li>
</ul>
</blockquote>
<p>在<code>kernel/proc.c</code>中，观察<code>fork</code>函数是如何创建一个进程的。</p>
<p><code>fork()</code>函数通过调用<code>allocproc()</code>创建一个新的进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new process, copying the parent.</span></span><br><span class="line"><span class="comment">// Sets up child kernel stack to return as if from fork() system call.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们看看<code>allocproc()</code>做了什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look in the process table for an UNUSED proc.</span></span><br><span class="line"><span class="comment">// If found, initialize state required to run in the kernel,</span></span><br><span class="line"><span class="comment">// and return with p-&gt;lock held.</span></span><br><span class="line"><span class="comment">// If there are no free procs, or a memory allocation fails, return 0.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc* <span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="comment">/* 遍历线程池，寻找未使用的线程 */</span></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = allocpid();	<span class="comment">// 分配 pid</span></span><br><span class="line">  p-&gt;state = USED;	<span class="comment">// 标记当前线程为已使用</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page. 通过 kalloc() 为 trapframe 分配一页</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to user space.</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空闲用户页表通过函数<code>proc_pagetable()</code>分配，让我们看看函数<code>proc_pagetable</code>做了什么</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a user page table for a given process, with no user memory,</span></span><br><span class="line"><span class="comment">// but with trampoline and trapframe pages.</span></span><br><span class="line"><span class="type">pagetable_t</span> <span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty page table.</span></span><br><span class="line">  pagetable = uvmcreate();	<span class="comment">// 分配一个空闲的用户页表</span></span><br><span class="line">  <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline code (for system call return)</span></span><br><span class="line">  <span class="comment">// at the highest user virtual address.</span></span><br><span class="line">  <span class="comment">// only the supervisor uses it, on the way</span></span><br><span class="line">  <span class="comment">// to/from user space, so not PTE_U.</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在 pagetable 中，创建一个PTE，从 TRAMPOLINE 映射到 trampoline，大小为 PGSIZE</span></span><br><span class="line"><span class="comment">   * 权限为 可读，可执行</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,</span><br><span class="line">              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trapframe page just below the trampoline page, for</span></span><br><span class="line">  <span class="comment">// trampoline.S.</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在 pagetable 中，创建一个PTE，从 TRAPFRAME 映射到 p-&gt;trapframe，大小为 PGSIZE</span></span><br><span class="line"><span class="comment">   * 权限为可读，可写</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们看看释放进程时函数<code>freeproc()</code>做了什么：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free a proc structure and the data hanging from it,</span></span><br><span class="line"><span class="comment">// including user pages.</span></span><br><span class="line"><span class="comment">// p-&gt;lock must be held.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)	</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;trapframe);	<span class="comment">// 释放 trapframe</span></span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);	<span class="comment">// 释放进程页表，但proc_freepagetable 函数没有定义</span></span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回头再看实验，要加速系统调用<code>getpid()</code>，首先我们要知道<code>getpid()</code>中的<code>pid</code>存放在什么地方，观察代码后发现<code>pid</code>存放在内核代码段<code>struct proc</code>中，因此要访问<code>pid</code>必须要进行用户态和内核态之间的切换。有什么办法能避免用户态和内核态的切换？我们知道操作系统为每个进程在用户态维护一个页表，如果我们把<code>pid</code>存储到进程页表中，则省去了切换到内核态的开销。下面讲讲怎么做。</p>
<p>在<code>memlayout.h</code>中发现，用户页表中的布局为：</p>
<p>我们发现<code>USYSCALL</code>页表已经布局到用户页表中了，并且是与内核共享的一段页面（注意，这是一个虚拟地址）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User memory layout.</span></span><br><span class="line"><span class="comment">// Address zero first:</span></span><br><span class="line"><span class="comment">//   text</span></span><br><span class="line"><span class="comment">//   original data and bss</span></span><br><span class="line"><span class="comment">//   fixed-size stack</span></span><br><span class="line"><span class="comment">//   expandable heap</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   USYSCALL (shared with kernel)</span></span><br><span class="line"><span class="comment">//   TRAPFRAME (p-&gt;trapframe, used by the trampoline)</span></span><br><span class="line"><span class="comment">//   TRAMPOLINE (the same page as in the kernel)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> pid;  <span class="comment">// Process ID</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>为了在进程中访问这段页面，我们需要在<code>struct proc</code>中添加一个新的指针，指向该段页面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line"> 	...</span><br><span class="line">	...</span><br><span class="line">  <span class="comment">// used to speed up system call</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> * <span class="title">usyscall</span>;</span>   <span class="comment">// 加速系统调用，指向共享的页的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们在创建一个进程的时候，同样要为<code>USYSCALL</code>页面分配物理地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look in the process table for an UNUSED proc.</span></span><br><span class="line"><span class="comment">// If found, initialize state required to run in the kernel,</span></span><br><span class="line"><span class="comment">// and return with p-&gt;lock held.</span></span><br><span class="line"><span class="comment">// If there are no free procs, or a memory allocation fails, return 0.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = allocpid();</span><br><span class="line">  p-&gt;state = USED;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// allocate a usyscall page using kalloc()</span></span><br><span class="line">  <span class="comment">// 使用 kalloc() 函数为 usyscall 分配一页物理页面</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;usyscall = (<span class="keyword">struct</span> usyscall * )kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">      freeproc(p);</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	p-&gt;usyscall-&gt;pid = p-&gt;pid;	<span class="comment">// 让 p-&gt;usyscall-&gt;pid 为 p-&gt;pid</span></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to user space.</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，在<code>proc_pagetable</code>中，我们要添加虚拟地址到物理地址的映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a user page table for a given process, with no user memory,</span></span><br><span class="line"><span class="comment">// but with trampoline and trapframe pages.</span></span><br><span class="line"><span class="type">pagetable_t</span> <span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty page table.</span></span><br><span class="line">  pagetable = uvmcreate();</span><br><span class="line">  <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 注意到在allocproc()中我们已经为p-&gt;usyscall分配了一个物理页面并且 p-&gt;usyscall 指针指向该物理页面的</span></span><br><span class="line">  <span class="comment">// 首地址，现在我们通过 mappages 在 页表中将虚拟地址 USYSCALL 映射到 p-&gt;usyscall 中。</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p-&gt;usyscall), PTE_R | PTE_U | PTE_W) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline code (for system call return)</span></span><br><span class="line">  <span class="comment">// at the highest user virtual address.</span></span><br><span class="line">  <span class="comment">// only the supervisor uses it, on the way</span></span><br><span class="line">  <span class="comment">// to/from user space, so not PTE_U.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,</span><br><span class="line">              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trapframe page just below the trampoline page, for</span></span><br><span class="line">  <span class="comment">// trampoline.S.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在创建进程的操作就结束了，要注意到的是，我们在释放进程的时候，同时也要把该页表项及映射释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free a proc structure and the data hanging from it,</span></span><br><span class="line"><span class="comment">// including user pages.</span></span><br><span class="line"><span class="comment">// p-&gt;lock must be held.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 kfree 函数将 p-&gt;usyscall 指向的一页物理地址释放掉</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;usyscall)</span><br><span class="line">      kfree((<span class="type">void</span>*)p-&gt;usyscall);</span><br><span class="line">  p-&gt;usyscall = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅仅释放掉物理地址还不够，我们还需要调用函数<code>proc_freepagetable()</code>取消页表中相应页表项的映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free a process&#x27;s page table, and free the</span></span><br><span class="line"><span class="comment">// physical memory it refers to.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);	<span class="comment">// 取消 pagetable 中映射到 TRAMPOLINE 的页表项</span></span><br><span class="line">    uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);	<span class="comment">// 取消 pagetable 中映射到 TRAPFRAME 的页表项</span></span><br><span class="line">    uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);	<span class="comment">// 取消 pagetable 中映射到 USYSCALL 的页表项</span></span><br><span class="line">    uvmfree(pagetable, sz);	<span class="comment">// 调用 uvmfree 释放整个页表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试通过。</p>
<p><img src="/../images/Lab-page-tables/%E6%88%AA%E5%B1%8F2024-01-25%2020.54.17-6187266-6187267.png" alt="截屏2024-01-25 20.54.17"></p>
<h3 id="Question-Which-other-xv6-system-call-s-could-be-made-faster-using-this-shared-page-Explain-how"><a href="#Question-Which-other-xv6-system-call-s-could-be-made-faster-using-this-shared-page-Explain-how" class="headerlink" title="Question: Which other xv6 system call(s) could be made faster using this shared page? Explain how."></a>Question: Which other xv6 system call(s) could be made faster using this shared page? Explain how.</h3><p>通过共享页面能加速的系统调用，首先要求不能是对共享页中的数据进行写操作，因为对内核页面的写操作需要切换到内核态，这违背了加速系统调用的初衷。于是我们推测：</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/27/confzns/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/27/confzns/" class="post-title-link" itemprop="url">confzns</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-27 14:08:58" itemprop="dateCreated datePublished" datetime="2023-12-27T14:08:58+08:00">2023-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-02 20:33:46" itemprop="dateModified" datetime="2024-01-02T20:33:46+08:00">2024-01-02</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ConfZNS学习记录"><a href="#ConfZNS学习记录" class="headerlink" title="ConfZNS学习记录"></a>ConfZNS学习记录</h1><h2 id="阅读confZNS论文"><a href="#阅读confZNS论文" class="headerlink" title="阅读confZNS论文"></a>阅读confZNS论文</h2><p><code>confzns</code>是一个基于<code>femu</code>的<code>zns ssd</code>模拟器。源码地址在 <a target="_blank" rel="noopener" href="https://github.com/DKU-StarLab/ConfZNS%E3%80%82">https://github.com/DKU-StarLab/ConfZNS。</a></p>
<p>论文地址在 <a target="_blank" rel="noopener" href="https://dl.acm.org/doi/abs/10.1145/3579370.3594772">https://dl.acm.org/doi/abs/10.1145/3579370.3594772</a></p>
<h3 id="解决的问题："><a href="#解决的问题：" class="headerlink" title="解决的问题："></a>解决的问题：</h3><p><code>ZNS SSD</code>的内部架构是如何影响使用这些设备的应用程序的并行性和隔离性的。</p>
<blockquote>
<p>例如，如果区域与多个通道和路径相关联，即使在与单个区域进行大请求大小交互时，应用程序也可以获得高内部并行性的好处。</p>
</blockquote>
<h3 id="ConfZNS的特性"><a href="#ConfZNS的特性" class="headerlink" title="ConfZNS的特性"></a><code>ConfZNS</code>的特性</h3><ol>
<li><code>ConfZNS</code>支持<code>zns ssd</code>多样化区域映射。</li>
<li><code>ConfZNS</code>模拟的时间是精确的。</li>
<li><code>ConfZNS</code>允许从内部设备结构到应用软件的全栈探索。</li>
</ol>
<h3 id="ConfZNS设计"><a href="#ConfZNS设计" class="headerlink" title="ConfZNS设计"></a><code>ConfZNS</code>设计</h3><ol>
<li><code>ZNS</code>架构</li>
<li>时间估算器</li>
<li>资源监视器</li>
<li><code>ZNS</code>配置器</li>
</ol>
<h3 id="ZNS架构"><a href="#ZNS架构" class="headerlink" title="ZNS架构"></a><code>ZNS</code>架构</h3><p>在<code>SSD</code>中，通道<code>(channels)</code>、路径<code>(ways)</code>、晶圆<code>(dies)</code>、平面<code>(planes)</code>等都可以称为并行单元。可以利用这样的并行单元来达到最大的吞吐量。</p>
<p>如图所示，同一区域可以分配给不同的并行单元。</p>
<p><img src="/../images/confzns/%E6%88%AA%E5%B1%8F2023-12-27%2016.11.11.png" alt="截屏2023-12-27 16.11.11"></p>
<h3 id="时间估算器"><a href="#时间估算器" class="headerlink" title="时间估算器"></a><code>时间估算器</code></h3><p>服务延迟和队列延迟是影响<code>SSD I/O</code>延迟的两个因素。</p>
<p>图3、图4展示了<code>confzns</code>如何估算读写请求的延迟。</p>
<p>其中<code>Logic Page Numbers</code>被暴露给主机，而<code>Physic Page Numbers</code>靠设备维护。</p>
<p>由于区域映射的方式不同，每个区域覆盖的<code>PPN</code>也不同。</p>
<p>通过使用两种时钟，全局时钟<code>gc</code>，本地时钟<code>lc</code>。</p>
<ul>
<li><p><code>gc</code>: 会在每一个<code>tick</code>是增加</p>
</li>
<li><p><code>lc</code>: 每个资源维护一个<code>lc</code>，<code>lc</code>表示该资源的下一次可用时间。</p>
<p><code>lc = max(gc, lc) + service_time</code>，表示该资源的下一次可用时间。</p>
</li>
<li><p>如果<code>local clock</code>小于或者等于<code>global clock</code>，这表示该<code>local clock</code>对应的资源当前是空闲的。</p>
</li>
</ul>
<p><img src="/../images/confzns/%E6%88%AA%E5%B1%8F2023-12-27%2016.49.23.png" alt="截屏2023-12-27 16.49.23"></p>
<p><img src="/../images/confzns/%E6%88%AA%E5%B1%8F2023-12-27%2016.49.37.png" alt="截屏2023-12-27 16.49.37"></p>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>**混合区域支持<code>Mixed zone support</code>**：<code>confzns</code>可以同时支持<code>Single Unit Zone</code>或者<code>Full Unit Zone</code>。这使得<code>ZNS SSD</code>的应用程序有两种控制方式。一种是传统的线程，通过创建不同数量的线程，它们可以控制并行性。第二个是不同的区域。通过分配不同的区域，它们可以控制SSD中可以使用多少并行单元。同时也支持每个鱼去使用不同类型的闪存。</p>
<p><strong>传统区域支持</strong>：<code>ConfZNS</code>同样支持传统区域。</p>
<p><strong>PCIe链接带宽延迟模型</strong>：在ConfZNS中，PCIe链接带宽和版本是可配置的。此外，ConfZNS可以调节I&#x2F;O请求以满足PCIe接口的最大带宽。带宽调节的时间模型是基于漏桶算法实现的。当PCIe链接带宽未饱和时，所有请求都可以无延迟转移，只有转移时间会应用于这些请求。然而，如果达到最大带宽（例如3.94GB&#x2F;s），剩余的请求必须等待直到它们可以被转移。随着带宽接近其极限，这个等待时间会增加，并且会应用于所有待处理的请求。</p>
<h2 id="运行ConfZNS："><a href="#运行ConfZNS：" class="headerlink" title="运行ConfZNS："></a>运行<code>ConfZNS</code>：</h2><p>拉取<code>ConfZNS</code>源码：<a target="_blank" rel="noopener" href="https://github.com/DKU-StarLab/ConfZNS">https://github.com/DKU-StarLab/ConfZNS</a></p>
<p>根据<code>README.md</code>运行</p>
<p>先安装必要的工具链</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Switch to the FEMU building directory</span></span><br><span class="line">cd build-femu</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">only Debian/Ubuntu based distribution supported</span></span><br><span class="line">sudo ./pkgdep.sh</span><br></pre></td></tr></table></figure>

<p>编译<code>FEMU</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./femu-compile.sh</span><br></pre></td></tr></table></figure>

<p>下载镜像，这里我们用到的是<code>FEMU</code>官网提供的镜像。填个问卷就可以获得了。</p>
<p>然后模拟运行<code>zns ssd</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run-zns.sh</span><br></pre></td></tr></table></figure>

<p>我在这里遇到了一些打印时结构体访问越界的错误问题，把那段代码注释后可以成功运行。</p>
<p>不过接着遇到的问题是<code>run-zns.sh</code>运行失败。这是因为在<code>confzns</code>的源码中<code>-device femu, devsz_mb = 4096, femu_mode = 1</code>，其中<code>femu_mode = 1</code>表示<code>ssd</code>类型为<code>black box</code>。修改后的<code>run-zns.sh</code>如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Huaicheng Li &lt;hcli@cmu.edu&gt;</span></span><br><span class="line"><span class="comment"># Run FEMU as Zoned-Namespace (ZNS) SSDs</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Image directory</span></span><br><span class="line">IMGDIR=/home/parallels/images</span><br><span class="line"><span class="comment"># Virtual machine disk image</span></span><br><span class="line">OSIMGF=<span class="variable">$IMGDIR</span>/u20s.qcow2</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ ! -e <span class="string">&quot;<span class="variable">$OSIMGF</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;VM disk image couldn&#x27;t be found ...&quot;</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Please prepare a usable VM image and place it as <span class="variable">$OSIMGF</span>&quot;</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Once VM disk image is ready, please rerun this script again&quot;</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">sudo x86_64-softmmu/qemu-system-x86_64 \</span><br><span class="line">    -name <span class="string">&quot;FEMU-ZNSSD-VM&quot;</span> \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -cpu host \</span><br><span class="line">    -smp $(<span class="built_in">nproc</span>) \ 虚拟机CPU数量等于宿主机的处理器数量</span><br><span class="line">    -m 4G \					为虚拟机分配4GB内存</span><br><span class="line">    -device virtio-scsi-pci,<span class="built_in">id</span>=scsi0 \	</span><br><span class="line">    -device scsi-hd,drive=hd0 \</span><br><span class="line">    -drive file=<span class="variable">$OSIMGF</span>,<span class="keyword">if</span>=none,aio=native,cache=none,format=qcow2,<span class="built_in">id</span>=hd0 \</span><br><span class="line">    -device femu,devsz_mb=4096,femu_mode=3 \	表示分配的FEMU设备的大小为4GB 模式为zns ssd</span><br><span class="line">    -net user,hostfwd=tcp::8080-:22 \	设置端口为 8080</span><br><span class="line">    -net nic,model=virtio \</span><br><span class="line">    -nographic \</span><br><span class="line">    -qmp unix:./qmp-sock,server,nowait 2&gt;&amp;1 | <span class="built_in">tee</span> <span class="built_in">log</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>ConfZNS</code>启动后，我们新建一个终端，通过命令<code>ssh -p 8080 femu@localhost</code>远程连接终端，输入密码后成功连接。</p>
<p>首先键入命令<code>nvme list</code>查看系统中所有的<code>NVMe</code>设备的概览。</p>
<ul>
<li><code>node</code>是设备节点。</li>
<li><code>SN</code>是设备序列号<code>serial number</code>的缩写，用于唯一标识硬件设备。</li>
<li><code>Model</code>: 这是NVMe设备的模型名称，由制造商指定。（比如这里是 FEMU模拟的ZNS SSD）</li>
<li><code>Namespace</code>这是NVMe设备上的命名空间编号，命名空间是NVMe存储的逻辑分区。</li>
<li><code>Usage</code>:显示当前命名空间已使用的存储空间以及总可用空间。</li>
<li><code>Format</code>：描述了该命名空间的数据格式，包括扇区大小。这里的<code>512B + 0B</code>表示扇区大小为<code>512</code>字节加上<code>0</code>字节的元数。</li>
<li><code>FW Rev</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ sudo nvme list</span><br><span class="line">Node          SN       Model                    Namespace   Usage              Format           FW Rev  </span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line">/dev/nvme0n1  vZNSSD0  FEMU ZNS-SSD Controller  1          4.29  GB / 4.29  GB  512   B +  0 B   1.0     </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输入命令<code>nvme zns help</code>查看命令的帮助。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ nvme zns help</span><br><span class="line">nvme-1.13.48.g33c6</span><br><span class="line">usage: nvme zns &lt;command&gt; [&lt;device&gt;] [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">The &#x27;&lt;device&gt;&#x27; may be either an NVMe character device (ex: /dev/nvme0) or an</span><br><span class="line">nvme block device (ex: /dev/nvme0n1).</span><br><span class="line"></span><br><span class="line">Zoned Namespace Command Set</span><br><span class="line"></span><br><span class="line">The following are all implemented sub-commands:</span><br><span class="line">  id-ctrl             Retrieve ZNS controller identification</span><br><span class="line">  id-ns               Retrieve ZNS namespace identification</span><br><span class="line">  zone-mgmt-recv      Sends the zone management receive command</span><br><span class="line">  zone-mgmt-send      Sends the zone management send command</span><br><span class="line">  report-zones        Retrieve the Report Zones report</span><br><span class="line">  close-zone          Closes one or more zones</span><br><span class="line">  finish-zone         Finishes one or more zones</span><br><span class="line">  open-zone           Opens one or more zones</span><br><span class="line">  reset-zone          Resets one or more zones</span><br><span class="line">  offline-zone        Offlines one or more zones</span><br><span class="line">  set-zone-desc       Attaches zone descriptor extension data</span><br><span class="line">  zone-append         Writes data and metadata (if applicable), appended to the end of the requested zone</span><br><span class="line">  changed-zone-list   Retrieves the changed zone list log</span><br><span class="line">  version             Shows the program version</span><br><span class="line">  help                Display this help</span><br><span class="line"></span><br><span class="line">See &#x27;nvme zns help &lt;command&gt;&#x27; for more information on a specific command</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>让我们一一解释这些命令的用法：</p>
<ul>
<li><p><code>nvme zns id-ctrl</code>: Send NVMe Zoned Command Set Identify Controller, return result and structure.下面给出一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ sudo nvme zns id-ctrl /dev/nvme0n1</span><br><span class="line">NVMe ZNS Identify Controller:</span><br><span class="line">zasl    : 5</span><br></pre></td></tr></table></figure>

<p><code>zone append size limit</code>是区域追加大小限制，这里指的区域追加大小限制应该是append命令的大小限制。</p>
<blockquote>
<p>分区命名空间命令集规范目前在命令集的识别控制器中只定义了一个字段：区域追加大小限制（ZASL）。区域追加大小限制（ZASL）编码了区域追加命令的最大命令大小。下面的例子返回的是‘5’，这对应于128千字节（在这个例子中可以追加的最大大小）。</p>
</blockquote>
</li>
<li><p><code>nvme zns id-ns</code> 获取 <code>ZNS namespace</code> 标识</p>
<p>人不可读的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ sudo nvme zns id-ns /dev/nvme0n1 </span><br><span class="line">ZNS Command Set Identify Namespace:</span><br><span class="line">zoc     : 0</span><br><span class="line">ozcs    : 1</span><br><span class="line">mar     : 0xffffffff</span><br><span class="line">mor     : 0xffffffff</span><br><span class="line">rrl     : 0</span><br><span class="line">frl     : 0</span><br><span class="line">lbafe  0: zsze:0x20000 zdes:0 (in use)</span><br><span class="line">lbafe  1: zsze:0x0 zdes:0</span><br><span class="line">lbafe  2: zsze:0x0 zdes:0</span><br><span class="line">lbafe  3: zsze:0x0 zdes:0</span><br><span class="line">lbafe  4: zsze:0x0 zdes:0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>人可读的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ sudo nvme zns id-ns /dev/nvme0n1 -H</span><br><span class="line">ZNS Command Set Identify Namespace:</span><br><span class="line">zoc     : 0	Zone Operation Characteristics</span><br><span class="line">  [1:1] : 0	  Zone Active Excursions: No</span><br><span class="line">  [0:0] : 0	  Variable Zone Capacity: No</span><br><span class="line"></span><br><span class="line">ozcs    : 1	Optional Zoned Command Support</span><br><span class="line">  [0:0] : 0x1	  Read Across Zone Boundaries: Yes</span><br><span class="line">mar     : No Active Resource Limit</span><br><span class="line">mor     : No Open Resource Limit</span><br><span class="line">rrl     : Not Reported</span><br><span class="line">frl     : Not Reported</span><br><span class="line">LBA Format Extension  0 : Zone Size: 0x20000 LBAs - Zone Descriptor Extension Size: 0 bytes (in use)</span><br><span class="line">LBA Format Extension  1 : Zone Size: 0x0 LBAs - Zone Descriptor Extension Size: 0 bytes</span><br><span class="line">LBA Format Extension  2 : Zone Size: 0x0 LBAs - Zone Descriptor Extension Size: 0 bytes</span><br><span class="line">LBA Format Extension  3 : Zone Size: 0x0 LBAs - Zone Descriptor Extension Size: 0 bytes</span><br><span class="line">LBA Format Extension  4 : Zone Size: 0x0 LBAs - Zone Descriptor Extension Size: 0 bytes</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>zoc</code>：区域活动波动<code>Zone Active Excursions</code>和可变区域容量<code>Variable Zone Capability</code>的特性都不支持。</li>
<li><code>Optional Zoned Command Support</code>：表示支持的可选分区命令。<code>1</code>表示跨区域边界读取是支持的。</li>
<li><code>mar</code> <code>Max Active Resources</code>：表示没有限制可以活动的资源数量。</li>
<li><code>mor</code> <code>Maximum Open Resources</code>：表示没有开放资源的限制。</li>
<li><code>rrl</code> <code>Read Recovery Levels</code>：未报告，意味着没有读取恢复级别的信息。</li>
<li><code>frl</code> <code>Finish Recovery Levels</code>：未报告，意味着没有提供关于完成恢复级别的信息。</li>
<li><code>LBA Format Extension</code>：这些是逻辑块地址格式扩展条目，描述了不同区域的大小和描述符扩展大小。‘<ul>
<li><code>Zone Size</code>的大小为：<code>0x20000</code>的逻辑块地址，区域描述符扩展大小为0字节，表示这个区域格式当前正在使用中。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>zone-mgmt-recv      Sends the zone management receive command</code> 不太明白咋用，一用内核就挂了。</strong></p>
</li>
<li><p><strong><code>zone-mgmt-send      Sends the zone management send command</code> 同上。</strong></p>
</li>
<li><p><code>report-zones</code>：获取分区的报告，以下是一部分输出。</p>
<ul>
<li><code>nr_zones</code>表示一共有64个分区。</li>
<li><code>SLBA</code>表示每个分区的起始逻辑块地址。</li>
<li><code>WP</code>表示每个分区的写指针指向的逻辑块地址。<ul>
<li><code>Cap</code>表示每个分区的<code>Zone capability</code>，大小为<code>0x20000</code>。</li>
<li><code>State</code>表示每个分区的类型，这里的类型是<code>EMPTY</code>。</li>
<li><code>Type</code>类型为<code>Unknown</code>或者<code>SEQWRITE_REQ</code>顺序写规定。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ sudo nvme zns report-zones /dev/nvme0n1 </span><br><span class="line">nr_zones: 64</span><br><span class="line">SLBA: 0x380000   WP: 0x380000   Cap: 0x20000    State: EMPTY        Type: Unknown        Attrs: 0x0</span><br><span class="line">SLBA: 0x3a0000   WP: 0x3a0000   Cap: 0x20000    State: EMPTY        Type: Unknown        Attrs: 0x0</span><br><span class="line">SLBA: 0x3c0000   WP: 0x3c0000   Cap: 0x20000    State: EMPTY        Type: Unknown        Attrs: 0x0</span><br><span class="line">SLBA: 0x3e0000   WP: 0x3e0000   Cap: 0x20000    State: EMPTY        Type: Unknown        Attrs: 0x0</span><br><span class="line">SLBA: 0x400000   WP: 0x400000   Cap: 0x20000    State: EMPTY        Type: SEQWRITE_REQ   Attrs: 0x0</span><br><span class="line">SLBA: 0x420000   WP: 0x420000   Cap: 0x20000    State: EMPTY        Type: SEQWRITE_REQ   Attrs: 0x0</span><br><span class="line">SLBA: 0x440000   WP: 0x440000   Cap: 0x20000    State: EMPTY        Type: SEQWRITE_REQ   Attrs: 0x0</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>open-zone</code>: 显示打开区域，<code>action:3</code>表示执行的具体操作；<code>zone:0</code>表示操作的是第0个区域；<code>nsid:1</code>表示操作的区域的命名空间标识符是1。<strong>区域需要先打开才能关闭，否则会出现错误。</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ sudo nvme zns open-zone /dev/nvme0n1</span><br><span class="line">zns-open-zone: Success, action:3 zone:0 nsid:1</span><br></pre></td></tr></table></figure>

<p>执行命令<code>sudo nvme zns report-zones /dev/nvme0n1</code>查看区域状态。我们可以发现区域的状态为<code>EXP_OPENED</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nr_zones: 64</span><br><span class="line">SLBA: 0x0        WP: 0x0        Cap: 0x20000    State: EXP_OPENED   Type: Unknown        Attrs: 0x0</span><br><span class="line">SLBA: 0x20000    WP: 0x20000    Cap: 0x20000    State: EMPTY        Type: Unknown        Attrs: 0x0</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>close-zone</code>关闭区域，关闭后再通过<code>report-zones</code>命令得到区域的报告。状态为关闭。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ sudo nvme zns close-zone /dev/nvme0n1</span><br><span class="line">zns-close-zone: Success, action:1 zone:0 nsid:1</span><br><span class="line">femu@fvm:~$ sudo nvme zns report-zones /dev/nvme0n1</span><br><span class="line">nr_zones: 64</span><br><span class="line">SLBA: 0x0        WP: 0x0        Cap: 0x20000    State: CLOSED       Type: Unknown        Attrs: 0x0</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>finish-zone</code>完成区域，即将该区域设置为满。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ sudo nvme zns finish-zone /dev/nvme0n1 </span><br><span class="line">zns-finish-zone: Success, action:2 zone:0 nsid:1</span><br><span class="line">femu@fvm:~$ sudo nvme zns report-zones /dev/nvme0n1 </span><br><span class="line">nr_zones: 64</span><br><span class="line">SLBA: 0x0        WP: 0xffffffffffffffff Cap: 0x20000    State: FULL         Type: Unknown        Attrs: 0x0</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>offline-zone</code>：将一个区域设置为离线会使该区域变得无法访问。在离线区域上的数据将无法访问，且在区域被重置之前，无法向该区域写入数据。运行此命令来将第一个区域设置为离线。</p>
<p><strong>对状态为空的区域关闭不行，对状态为显示打开的区域关闭也不行，对状态为满的区域关闭也不行。</strong></p>
</li>
<li><p><code>zone-append</code>和<code>read</code>命令，这里 <code>-z 512</code>代表追加操作追加的数据大小为<code>512B</code>。通过区域报告，我们可以知道每个逻辑块的大小为<code>512B</code>（因为我们发现读指针增加了1）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ echo &quot;Hello World&quot; | sudo nvme zns zone-append /dev/nvme0n1 -z 512</span><br><span class="line">Success appended data to LBA 0</span><br><span class="line">femu@fvm:~$ sudo nvme read /dev/nvme0n1 -z 512</span><br><span class="line">Hello World</span><br><span class="line">read: Success</span><br><span class="line">femu@fvm:~$ sudo nvme zns report-zones /dev/nvme0n1</span><br><span class="line">nr_zones: 64</span><br><span class="line">SLBA: 0x0        WP: 0x1        Cap: 0x20000    State: EXP_OPENED   Type: Unknown        Attrs: 0x0</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ echo &quot;Goodbye World&quot; | sudo nvme zns zone-append /dev/nvme0n1 -z 512</span><br><span class="line">Success appended data to LBA 1</span><br><span class="line">femu@fvm:~$ sudo nvme read /dev/nvme0n1 -z 512</span><br><span class="line">Hello World</span><br><span class="line">read: Success</span><br><span class="line">femu@fvm:~$ sudo nvme read /dev/nvme0n1 -z 1024</span><br><span class="line">Hello World</span><br><span class="line">read: Success</span><br><span class="line">femu@fvm:~$ sudo nvme read /dev/nvme0n1 -z 512 -s 1</span><br><span class="line">Goodbye World</span><br><span class="line">read: Success</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​	当我们再次使用<code>zone-append</code>命令写入数据时，我们无须指定逻辑块地址。但在读取数据的时候，我们需要通过<code>-s</code>选项指定逻辑块地址以实现随机读。</p>
<ul>
<li>为什么使用nvme-cli write 命令也可以？</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/16/Lab-system-calls-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/16/Lab-system-calls-1/" class="post-title-link" itemprop="url">Lab: system calls</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-16 11:16:19" itemprop="dateCreated datePublished" datetime="2023-12-16T11:16:19+08:00">2023-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-26 08:59:15" itemprop="dateModified" datetime="2023-12-26T08:59:15+08:00">2023-12-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab-system-calls"><a href="#Lab-system-calls" class="headerlink" title="Lab: system calls"></a>Lab: system calls</h1><p>决定重新开始捡起<code>xv6</code>的实验。</p>
<h2 id="1-Using-gdb"><a href="#1-Using-gdb" class="headerlink" title="1.Using gdb:"></a>1.Using gdb:</h2><p>这个就跟着教程一步一步来。简单说一下在<code>mac os</code>下如何使用<code>gdb</code>，打开两个终端窗口：</p>
<ul>
<li><p>在第一个窗口下：</p>
<ol>
<li><p>执行<code>cd xv6-labs-2023</code>，进入目标文件。</p>
</li>
<li><p>运行<code>make qemu-gdb</code>。</p>
</li>
<li><p>终端会输出当前窗口的tcp，例如<code>tcp::26000</code>。</p>
<blockquote>
<p>以远程调试模式连接到本地主机上的端口<code>26000</code></p>
</blockquote>
</li>
</ol>
<p>	</p>
</li>
<li><p>在第二个窗口下：</p>
<ol>
<li><p>执行<code>cd xv6-labs-2023</code>，进入目标文件。</p>
</li>
<li><p>执行<code>riscv64-unknown-elf-gdb</code>，运行<code>gdb</code>。</p>
</li>
<li><p>在<code>gdb</code>中执行<code>target remote localhost:26000</code>，链接第一个窗口。</p>
</li>
<li><p>然后在<code>gdb</code>窗口中执行<code>file kernel/kernel</code>，加载可执行文件<code>kernel</code>到调试器<code>gdb</code>中。</p>
<blockquote>
<p>这一步只是加载可执行文件，并没有运行该文件。</p>
</blockquote>
</li>
<li><p>在<code>gdb</code>窗口中，执行<code>b syscall</code>，这一步是在<code>syscall</code>函数处打断点。</p>
</li>
<li><p>在<code>gdb</code>窗口中，执行<code>c</code>，运行上文加载的<code>kernel/kernel</code>可执行文件，可执行文件会在第一个调用<code>syscall</code>处暂停。</p>
</li>
<li><p>通过在<code>gdb</code>窗口中执行<code>layout src</code>命令启动和显示源代码布局。</p>
</li>
<li><p>然后调用执行<code>backtrace</code>，用于显示当前线程的调用堆栈。</p>
</li>
</ol>
</li>
</ul>
<p>效果如图所示：</p>
<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-16%2014.12.00-2707131.png" alt="截屏2023-12-16 14.12.00"></p>
<h3 id="Question-Looking-at-the-backtrace-output-which-function-called-syscall"><a href="#Question-Looking-at-the-backtrace-output-which-function-called-syscall" class="headerlink" title="Question: Looking at the backtrace output, which function called syscall?"></a>Question: Looking at the backtrace output, which function called <code>syscall</code>?</h3><p>如图所示，我们发现是在<code>kernel/trap.c:67</code>行，即函数<code>usertrap()</code>中调用了<code>syscall()</code>。检查源码确实如此。</p>
<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-16%2014.16.15.png" alt="截屏2023-12-16 14.16.15"></p>
<p>键入<code>n</code>命令让程序执行过<code>struct proc *p = myproc();</code>，然后键入<code>p /x *p</code>，打印指针<code>p</code>指向的<code>struct pro</code>结构体内容。</p>
<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-16%2014.28.45.png" alt="截屏2023-12-16 14.28.45"></p>
<p>上图中显示了结构体<code>struct proc</code>中的大部分内容。</p>
<h3 id="Question-What-is-the-value-of-p-gt-trapframe-gt-a7-and-what-does-that-value-represent-Hint-look-user-initcode-S-the-first-user-program-xv6-starts"><a href="#Question-What-is-the-value-of-p-gt-trapframe-gt-a7-and-what-does-that-value-represent-Hint-look-user-initcode-S-the-first-user-program-xv6-starts" class="headerlink" title="Question: What is the value of p-&gt;trapframe-&gt;a7 and what does that value represent? (Hint: look user/initcode.S, the first user program xv6 starts.)"></a>Question: What is the value of <code>p-&gt;trapframe-&gt;a7</code> and what does that value represent? (Hint: look <code>user/initcode.S</code>, the first user program xv6 starts.)</h3><p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-16%2014.32.49.png" alt="截屏2023-12-16 14.32.49"></p>
<p>接着我们打印<code>p-&gt;trapframe-&gt;a7</code>，发现值为7。问题的提示让我们去看<code>user/initcode.S</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Initial process that execs /init.</span><br><span class="line"># This code runs in user space.</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line"># exec(init, argv)</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        la a0, init</span><br><span class="line">        la a1, argv</span><br><span class="line">        li a7, SYS_exec</span><br><span class="line">        ecall</span><br><span class="line"></span><br><span class="line"># for(;;) exit();</span><br><span class="line">exit:</span><br><span class="line">        li a7, SYS_exit</span><br><span class="line">        ecall</span><br><span class="line">        jal exit</span><br><span class="line"></span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">  .string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">  .long init</span><br><span class="line">  .long 0</span><br></pre></td></tr></table></figure>

<p>我们发现这段代码把<code>SYS_exec</code>的值加载到寄存器<code>a7</code>中，然后通过<code>ecall</code>执行<code>a7</code>中的系统调用。</p>
<p>处理器当前在内核模式下运行，我们可以打印特权寄存器<code>(privileged registers)</code>，例如<code>sstatus (supervisor Status Register)</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p /x $sstatus</span><br><span class="line">$3 = 0x200000022</span><br></pre></td></tr></table></figure>

<p>图4.1和图4.2展示了64位机器和32位机器下的<code>sstatus</code>每一位的含义。</p>
<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-17%2010.18.16.png" alt="截屏2023-12-17 10.18.16"></p>
<h3 id="Question-What-was-the-previous-mode-that-the-CPU-was-in"><a href="#Question-What-was-the-previous-mode-that-the-CPU-was-in" class="headerlink" title="Question: What was the previous mode that the CPU was in?"></a>Question: What was the previous mode that the CPU was in?</h3><p>如图所示，<code>SSP</code>在64位机器上的<code>sstatus</code>的第八位，得到值为<code>0</code>。现在我们知道，当<code>trap</code>发生前，硬件线程<code>hart</code>处于用户态<code>user mode</code>。</p>
<p>在接下来的实验中，一些编程错误会导致<code>xv6</code>内核崩溃。例如，替换<code>num = p-&gt;trapframe-&gt;a7</code>为<code>num = *(int *)0;</code>，然后执行<code>make qemu</code>，会看见：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 1 starting</span><br><span class="line">hart 2 starting</span><br><span class="line">scause 0x000000000000000d</span><br><span class="line">sepc=0x0000000080002054 stval=0x0000000000000000</span><br><span class="line">panic: kerneltrap</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sepc: When a trap occurs, RISC-V saves the program counter here (since the pc is then overwritten with the value in stvec). The sret (return from trap) instruction copies sepc to the pc. The kernel can write sepc to control where sret goes.</p>
</blockquote>
<p><code>sepc</code>中存储的值是发生<code>trap</code>时，程序计数器中存储的处理器即将执行的下一条指令在内存中的地址。</p>
<h3 id="Question-Write-down-the-assembly-instruction-the-kernel-is-panicing-at-Which-register-corresponds-to-the-variable-num"><a href="#Question-Write-down-the-assembly-instruction-the-kernel-is-panicing-at-Which-register-corresponds-to-the-variable-num" class="headerlink" title="Question: Write down the assembly instruction the kernel is panicing at. Which register corresponds to the variable num?"></a>Question: Write down the assembly instruction the kernel is panicing at. Which register corresponds to the variable <code>num</code>?</h3><p><code>kernel/kernel.asm</code>是通过编译器将<code>c语言</code>编译成的内核汇编语言源文件，包含了原代码的汇编语言表示。</p>
<p>我们在<code>kernel/kernel.asm</code>中找到<code>sepc=0x0000000080002054</code>地址对应的汇编指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = *(int*)0;</span><br><span class="line">80002054:	00002683          	lw	a3,0(zero) # 0 &lt;_entry-0x80000000&gt;</span><br></pre></td></tr></table></figure>

<p>该指令尝试从零地址加载一个字<code>load word</code>到<code>a3</code>寄存器中。这会产生错误：因为地址0在大多数操作系统中是不可访问的，在<code>xv6</code>系统中<code>0x0-0x80000000</code>地址用于<code>I/O</code>设备。并且我们发现，<code>num</code>的值存储在<code>a3</code>寄存器中。</p>
<blockquote>
<p>The loader loads the xv6 kernel into memory at physical address <code>0x80000000</code>. The reason it places the kernel at <code>0x80000000</code> rather than <code>0x0</code> is because the address range <code>0x0:0x80000000</code> contains I&#x2F;O devices.</p>
</blockquote>
<p>要在故障指令处检查处理器和内核的状态，请启动gdb，并在故障epc上设置断点，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x0000000080002054</span><br><span class="line">Breakpoint 1 at 0x80002054: file kernel/syscall.c, line 138</span><br><span class="line">(gdb) layout asm</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[Switching to Thread 1.2]</span><br><span class="line"></span><br><span class="line">Thread 2 hit Breakpoint 1, syscall () at kernel/syscall.c:138</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-17%2011.40.13.png" alt="截屏2023-12-17 11.40.13"></p>
<p><code>gdb</code>展示的结果和<code>sepc</code>的结果相同。</p>
<h3 id="Question-Why-does-the-kernel-crash-Hint-look-at-figure-3-3-in-the-text-is-address-0-mapped-in-the-kernel-address-space-Is-that-confirmed-by-the-value-in-scause-above-See-description-of-scause-in-RISC-V-privileged-instructions"><a href="#Question-Why-does-the-kernel-crash-Hint-look-at-figure-3-3-in-the-text-is-address-0-mapped-in-the-kernel-address-space-Is-that-confirmed-by-the-value-in-scause-above-See-description-of-scause-in-RISC-V-privileged-instructions" class="headerlink" title="Question: Why does the kernel crash? Hint: look at figure 3-3 in the text; is address 0 mapped in the kernel address space? Is that confirmed by the value in scause above? (See description of scause in RISC-V privileged instructions)"></a>Question: Why does the kernel crash? Hint: look at figure 3-3 in the text; is address 0 mapped in the kernel address space? Is that confirmed by the value in <code>scause</code> above? (See description of <code>scause</code> in <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2023/labs/n//github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">RISC-V privileged instructions</a>)</h3><p>首先我们要清楚，在<code>kernel/kernel.asm</code>中的地址为虚拟地址。然后找到图3.3。如图，我们可以发现，虚拟地址0并没有映射到任何一个物理地址上。检查<code>scause</code>寄存器的值<code>scause = 0x000000000000000d</code>，通过图4.2可知，<code>0xd=13</code>对应<code>Load Page Fault</code>。</p>
<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-17%2020.08.43.png" alt="截屏2023-12-17 20.08.43"></p>
<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-18%2018.53.43.png" alt="截屏2023-12-18 18.53.43"></p>
<p><code>scause</code>是被上面的<code>kernel panic</code>打印出来的，但是你通常需要额外的信息来追踪导致崩溃的问题。例如，找到崩溃时是哪个用户进程正在运行，可以通过<code>p p-&gt;name</code>命令打印进程的名字。</p>
<p><code>process name is &quot;initcode\000\000\000\000\000\000\000&quot;</code>，进程的<code>pid</code>是<code>1</code>。</p>
<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-18%2019.12.14.png" alt="截屏2023-12-18 19.12.14"></p>
<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-18%2019.16.08.png" alt="截屏2023-12-18 19.16.08"></p>
<h2 id="2-System-call-tracing"><a href="#2-System-call-tracing" class="headerlink" title="2. System call tracing"></a>2. System call tracing</h2><h3 id="In-this-assignment-you-will-add-a-system-call-tracing-feature-that-may-help-you-when-debugging-later-labs-You’ll-create-a-new-trace-system-call-that-will-control-tracing-It-should-take-one-argument-an-integer-“mask”-whose-bits-specify-which-system-calls-to-trace-For-example-to-trace-the-fork-system-call-a-program-calls-trace-1-lt-lt-SYS-fork-where-SYS-fork-is-a-syscall-number-from-kernel-syscall-h-You-have-to-modify-the-xv6-kernel-to-print-out-a-line-when-each-system-call-is-about-to-return-if-the-system-call’s-number-is-set-in-the-mask-The-line-should-contain-the-process-id-the-name-of-the-system-call-and-the-return-value-you-don’t-need-to-print-the-system-call-arguments-The-trace-system-call-should-enable-tracing-for-the-process-that-calls-it-and-any-children-that-it-subsequently-forks-but-should-not-affect-other-processes"><a href="#In-this-assignment-you-will-add-a-system-call-tracing-feature-that-may-help-you-when-debugging-later-labs-You’ll-create-a-new-trace-system-call-that-will-control-tracing-It-should-take-one-argument-an-integer-“mask”-whose-bits-specify-which-system-calls-to-trace-For-example-to-trace-the-fork-system-call-a-program-calls-trace-1-lt-lt-SYS-fork-where-SYS-fork-is-a-syscall-number-from-kernel-syscall-h-You-have-to-modify-the-xv6-kernel-to-print-out-a-line-when-each-system-call-is-about-to-return-if-the-system-call’s-number-is-set-in-the-mask-The-line-should-contain-the-process-id-the-name-of-the-system-call-and-the-return-value-you-don’t-need-to-print-the-system-call-arguments-The-trace-system-call-should-enable-tracing-for-the-process-that-calls-it-and-any-children-that-it-subsequently-forks-but-should-not-affect-other-processes" class="headerlink" title="In this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new trace system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls trace(1 &lt;&lt; SYS_fork), where SYS_fork is a syscall number from kernel/syscall.h. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The trace system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes."></a>In this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new <code>trace</code> system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls <code>trace(1 &lt;&lt; SYS_fork)</code>, where <code>SYS_fork</code> is a syscall number from <code>kernel/syscall.h</code>. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The <code>trace</code> system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</h3><blockquote>
<p>这个实验做着比较奇怪，感觉只是做出来了，但为啥是这样的？</p>
</blockquote>
<p>我们先跟着<code>hints</code>走一遍流程：</p>
<ul>
<li><p><strong>Add <code>$U/_trace</code> to UPROGS in Makefile</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in Makefile</span><br><span class="line">UPROGS=\</span><br><span class="line">		...</span><br><span class="line">		$U/_trace</span><br></pre></td></tr></table></figure>
</li>
<li><p>Run make qemu and you will see that the compiler cannot compile <code>user/trace.c</code>, because the user-space stubs for the system call don’t exist yet: add a prototype for the system call to <code>user/user.h</code>, a stub to <code>user/usys.pl</code>, and a syscall number to <code>kernel/syscall.h</code>. The Makefile invokes the perl script <code>user/usys.pl</code>, which produces <code>user/usys.S</code>, the actual system call stubs, which use the RISC-V <code>ecall</code> instruction to transition to the kernel. Once you fix the compilation issues, run trace 32 grep hello README; it will fail because you haven’t implemented the system call in the kernel yet.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*In user/user.h*/</span></span><br><span class="line"><span class="comment">// system calls</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In user/usys.pl</span></span><br><span class="line">entry(<span class="string">&quot;trace&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Add a <code>sys_trace()</code> function in <code>kernel/sysproc.c</code> that implements the new system call by remembering its argument in a new variable in the <code>proc</code> structure (see <code>kernel/proc.h</code>). The functions to retrieve system call arguments from user space are in <code>kernel/syscall.c</code>, and you can see examples of their use in <code>kernel/sysproc.c</code>.</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in the proc structure of kernel/pro.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="type">int</span> tracemask;            <span class="comment">// Used to store trace mask number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> maskval;</span><br><span class="line">    argint(<span class="number">0</span>, &amp;maskval);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * when we run trace 32 grep hello README</span></span><br><span class="line"><span class="comment">     * terminal outputs p-&gt;trapframe-&gt;a0 32</span></span><br><span class="line"><span class="comment">     * thus we know the first argument is stored on register a0</span></span><br><span class="line"><span class="comment">     * now we store the trace mask into the structure proc-&gt;tracemask</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">cp</span> =</span> myproc();</span><br><span class="line">    cp-&gt;tracemask = maskval;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Modify <code>fork()</code> (see <code>kernel/proc.c</code>) to copy the trace mask from the parent to the child process.</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* function fork() in kernel/proc.c */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  	...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   	* modified by theFutile</span></span><br><span class="line"><span class="comment">   	* copy trace mask from parent to child</span></span><br><span class="line"><span class="comment">   	*/</span></span><br><span class="line">  	np-&gt;tracemask = p-&gt;tracemask;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Modify the <code>syscall()</code> function in <code>kernel/syscall.c</code> to print the trace output. You will need to add an array of syscall names to index into.</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in kernel/syscall.c */</span></span><br><span class="line"><span class="comment">/* add a new array stored syscall name*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span>* syscallsInfo[<span class="number">23</span>] = &#123;</span><br><span class="line">  			<span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;fork&quot;</span>,</span><br><span class="line">  			...</span><br><span class="line">        <span class="string">&quot;trace&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* modified the syscall function */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">syscall(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    <span class="comment">// Use num to lookup the system call function for num, call it,</span></span><br><span class="line">    <span class="comment">// and store its return value in p-&gt;trapframe-&gt;a0</span></span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * judge the trace mask bit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;tracemask &amp; (<span class="number">1ULL</span> &lt;&lt; num)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscallsInfo[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意，在上述操作结束后，<code>trace</code>命令在不传入<code>mask</code>时仍会打印信息，这是因为在创建进程的时候并没有初始化<code>tracemask</code>的值。所以，我们要在初始化进程的时候将<code>tracemask</code>赋值为<code>0</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* function freeproc() in kernel/proc.c */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">  	...</span><br><span class="line">		<span class="comment">/* free trace mask bits */</span></span><br><span class="line">  	p-&gt;tracemask = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阅读<code>syscall()</code>函数我们知道，系统调用的返回值被存储在<code>p-&gt;trapframe-&gt;a0</code>寄存器中，</p>
<p>在操作系统内核中，我们可以定义一个函数指针数组来映射系统调用编号到它们的处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">    [SYS_fork] = sys_fork,</span><br><span class="line">    [SYS_exit] = sys_exit,</span><br><span class="line">    [SYS_read] = sys_read,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-Sysinfo"><a href="#3-Sysinfo" class="headerlink" title="3. Sysinfo"></a>3. Sysinfo</h2><h3 id="In-this-assignment-you-will-add-a-system-call-sysinfo-that-collects-information-about-the-running-system-The-system-call-takes-one-argument-a-pointer-to-a-struct-sysinfo-see-kernel-sysinfo-h-The-kernel-should-fill-out-the-fields-of-this-struct-the-freemem-field-should-be-set-to-the-number-of-bytes-of-free-memory-and-the-nproc-field-should-be-set-to-the-number-of-processes-whose-state-is-not-UNUSED-We-provide-a-test-program-sysinfotest-you-pass-this-assignment-if-it-prints-“sysinfotest-OK”"><a href="#In-this-assignment-you-will-add-a-system-call-sysinfo-that-collects-information-about-the-running-system-The-system-call-takes-one-argument-a-pointer-to-a-struct-sysinfo-see-kernel-sysinfo-h-The-kernel-should-fill-out-the-fields-of-this-struct-the-freemem-field-should-be-set-to-the-number-of-bytes-of-free-memory-and-the-nproc-field-should-be-set-to-the-number-of-processes-whose-state-is-not-UNUSED-We-provide-a-test-program-sysinfotest-you-pass-this-assignment-if-it-prints-“sysinfotest-OK”" class="headerlink" title="In this assignment you will add a system call, sysinfo, that collects information about the running system. The system call takes one argument: a pointer to a struct sysinfo (see kernel/sysinfo.h). The kernel should fill out the fields of this struct: the freemem field should be set to the number of bytes of free memory, and the nproc field should be set to the number of processes whose state is not UNUSED. We provide a test program sysinfotest; you pass this assignment if it prints “sysinfotest: OK”."></a>In this assignment you will add a system call, <code>sysinfo</code>, that collects information about the running system. The system call takes one argument: a pointer to a <code>struct sysinfo</code> (see <code>kernel/sysinfo.h</code>). The kernel should fill out the fields of this struct: the <code>freemem</code> field should be set to the number of bytes of free memory, and the <code>nproc</code> field should be set to the number of processes whose <code>state</code> is not <code>UNUSED</code>. We provide a test program <code>sysinfotest</code>; you pass this assignment if it prints “sysinfotest: OK”.</h3><p>还是跟着<code>hints</code>走一遍流程：</p>
<ul>
<li><p><strong>Add <code>$U/_sysinfotest</code> to UPROGS in Makefile</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in Makefile</span><br><span class="line">UPROGS=\</span><br><span class="line">		...</span><br><span class="line">		$U/_trace</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Run make qemu; <code>user/sysinfotest.c</code> will fail to compile. Add the system call sysinfo, following the same steps as in the previous assignment. To declare the prototype for sysinfo() <code>in user/user.h</code> you need predeclare the existence of <code>struct sysinfo</code></strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*In user/user.h*/</span></span><br><span class="line"><span class="comment">// declare prototype</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span>;</span></span><br><span class="line"><span class="comment">// system calls</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo*)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In user/usys.pl</span></span><br><span class="line">entry(<span class="string">&quot;sysinfo&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>sysinfo needs to copy a <code>struct sysinfo</code> back to user space; see <code>sys_fstat()</code> (<code>kernel/sysfile.c</code>) and <code>filestat()</code> (<code>kernel/file.c</code>) for examples of how to do that using <code>copyout()</code>.</strong></p>
<p>我们知道，<code>sys_sysinfo()</code>函数是在内核代码部分声明的，但我们观察到用于测试<code>sysinfo()</code>的代码是在用户态中运行的。所以在用户态中运行的代码需要和在内核态中运行的代码进行交互。观察<code>sys_fstat()</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_fstat</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  uint64 st; <span class="comment">// user pointer to struct stat</span></span><br><span class="line">  argaddr(<span class="number">1</span>, &amp;st); <span class="comment">// store p-&gt;trapframe-&gt;a1 into st</span></span><br><span class="line">  <span class="keyword">if</span>(argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> filestat(f, st);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数将进程<code>p</code>中<code>trapframe-&gt;a1</code>中存储的地址赋值给<code>st</code>，该地址是从用户态中的代码传到内核空间中的。然后函数进一步将该地址传递到函数<code>filestat()</code>中，现在我们观察<code>filestat()</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get metadata about file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address, pointing to a struct stat.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">filestat</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_INODE || f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    stati(f-&gt;ip, &amp;st);</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">    <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;st, <span class="keyword">sizeof</span>(st)) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，该函数声明一个<code>struct stat</code>，然后将数据存储到当前的<code>stat</code>中，再调用<code>copyout()</code>函数，观察<code>copyout()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy from kernel to user.</span></span><br><span class="line"><span class="comment">// Copy len bytes from src to virtual address dstva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    <span class="keyword">if</span>(va0 &gt;= MAXVA)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    pte = walk(pagetable, va0, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span> || (*pte &amp; PTE_U) == <span class="number">0</span> ||</span><br><span class="line">       (*pte &amp; PTE_W) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    pa0 = PTE2PA(*pte);</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过注释，我们知道该函数从内核中拷贝数据到用户态中，其中，<code>pagetable</code>是<code>dstva</code>所在的页表中。该函数将内核空间中指针<code>src</code>指向的地址，拷贝<code>len</code>个字节，到虚拟地址<code>dstva</code>中，这个虚拟地址也即用户态空间中的位置。现在我们大致明白数据是如何从内核空间拷贝到用户空间。</p>
</li>
<li><p><strong>To collect the amount of free memory, add a function to <code>kernel/kalloc.c</code></strong></p>
<p>在结构体<code>struct sysinfo</code>中，我们要填写两个成员，<code>freemem</code>和<code>nproc</code>。其中<code>freemem</code>是存储空闲内存的数量的。观察<code>kernel/kalloc.c</code>代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>

<p>两个结构体<code>kmem</code>表示内核中的内存空间，其中 <code>lock</code>是一个自旋锁，在分配空间时需要加锁，<code>freelist</code>是一个指向空闲空间的链表，换句话说，空闲空间通过链表的形式存储。观察函数<code>kalloc()</code>的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现在分配物理空间的时候，首先通过<code>acquire(&amp;kmem.lock)</code>请求锁，然后获取当前内存的<code>freelist</code>，如果有空闲的内存，我们将内存取出并释放锁，然后将指针指向的空闲内存填充一些垃圾并返回该指针。并且，我们可以从上述代码中知道，每个<code>struct run</code>只想一个大小为<code>PGSIZE</code>的空间，也即<code>4096</code>比特。</p>
<p>现在我们尝试实现<code>collect_free_memory</code>。该函数首先获取<code>kmem</code>的空闲链表，然后请求锁，这保证了在计算空闲空间的时候内存不会被改变。然后每有一个空闲节点，<code>mem_byte</code>增加一个<code>PAGESIZE = 4096</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">count_free_mem</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> * <span class="title">r</span> =</span> kmem.freelist;</span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    uint64 mem_byte = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r) &#123;</span><br><span class="line">        mem_byte += PGSIZE;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">    <span class="keyword">return</span> mem_byte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>To collect the number of processes, add a function to <code>kernel/proc.c</code></strong></p>
<p>我们需要统计当前系统中状态不为<code>UNUSED</code>的进程数量，然后存储到<code>nproc</code>中，观察<code>kernel/proc.c</code>中函数<code>wakeup()</code>的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wake up all processes sleeping on chan.</span></span><br><span class="line"><span class="comment">// Must be called without any p-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p != myproc())&#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">        p-&gt;state = RUNNABLE;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道了内核代码遍历所有进程的方法，进程是在进程池中的，<code>NPROC</code>表示了进程的数量，于是我们实现<code>collect the number of processes</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">collect_process_num</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; ++p) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;state != UNUSED) &#123;</span><br><span class="line">            ++num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意，我们需要在<code>kernel/defs.h</code>中声明这些函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in kernel/defs.h */</span></span><br><span class="line"><span class="comment">// kalloc.c</span></span><br><span class="line">uint64          <span class="title function_">count_free_mem</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// proc.c</span></span><br><span class="line"><span class="type">int</span> 						<span class="title function_">collect_process_num</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>同时，要在<code>kernel/sysproc.c</code>中添加头文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/sysinfo.h&quot;</span></span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/05/ZNSLiterature02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/05/ZNSLiterature02/" class="post-title-link" itemprop="url">ZNSLiterature02</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-05 08:50:51" itemprop="dateCreated datePublished" datetime="2023-12-05T08:50:51+08:00">2023-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-12 15:52:33" itemprop="dateModified" datetime="2023-12-12T15:52:33+08:00">2023-12-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是第三周2023.12.4-2023.12.10的论文阅读笔记</p>
<h1 id="Performance-Characterization-of-NVMe-Flash-Devices-with-Zoned-Namespaces-ZNS"><a href="#Performance-Characterization-of-NVMe-Flash-Devices-with-Zoned-Namespaces-ZNS" class="headerlink" title="Performance Characterization of NVMe Flash Devices with Zoned Namespaces (ZNS)"></a>Performance Characterization of NVMe Flash Devices with Zoned Namespaces (ZNS)</h1><p>这篇文章大概讲了具有分区命名空间的闪存的性能分析。</p>
<p>本文的贡献:</p>
<ul>
<li><p>系统地描述了一款商业可用的 NVMe ZNS 设备的性能特性（即延迟、带宽和并行管理），包括其追加、读取、写入和区域管理操作（即完成和重置）。</p>
</li>
<li><p>我们分析了 ZNS 独特的重置和追加操作对读取、写入和追加 I&#x2F;O 性能的干扰影响。</p>
</li>
<li><p>我们揭示了最新 ZNS 模拟器性能模型的局限性，并讨论了解决这些问题的建议。</p>
</li>
<li><p>我们根据我们的特性分析，为 ZNS 应用开发者分享了关键建议。</p>
</li>
<li><p>我们在 <a target="_blank" rel="noopener" href="https://github.com/stonet-research/NVMeBenchmarks">https://github.com/stonet-research/NVMeBenchmarks</a> 上发布了我们的基准测试软件和数据集，以鼓励可复现的研究。</p>
</li>
</ul>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem:"></a>Problem:</h2><p>​	缺乏对 ZNS SSD（带有分区命名空间的固态硬盘）的广泛特性分析严重限制了在大数据工作负载中使用和应用 ZNS 设备的能力。这篇文章通过展示一款商业可用的 NVMe ZNS 设备的性能特性来弥补这一差距。</p>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background:"></a>Background:</h2><p>本文中提到的关于闪存的一些背景又和之前了解的概念有些偏差，在此记录下来：</p>
<ul>
<li><p>页<code>(page)</code>需要被顺序写入块中<code>(block)</code>，因此不允许数据随机写入。</p>
</li>
<li><p><code>It is also prone to read-write disturbs that occur when many reads are issued to the same blocks—they cause data loss. </code> </p>
<blockquote>
<p>读写干扰<code>(read-write distrubs)</code>是由于NAND闪存在频繁读取过程中对特定块施加重复电压引起的，这可能导致存储在邻近页中的数据不稳定，进而引发数据丢失或损坏。</p>
</blockquote>
<p>这也是为什么<code>ZNS SSD</code>中同时活跃的区域的数量有限制的原因<code>active zone limits</code>。</p>
<p>同样导致活跃区域的数量限制的原因还有：</p>
<blockquote>
<p>Since each zone operation (e.g., read, write, and append) consumes SSD resources (e.g., internal buffers), there are limits on the number of zones that can be concurrently opened and used.</p>
<p>由于每个区域操作（例如读取、写入和附加）都会消耗SSD资源（例如内部缓冲区），因此可以同时打开和使用的区域数量受到限制。</p>
</blockquote>
</li>
<li><p>追加操作<code>append</code>，类似于<code>nameless write</code>。</p>
<blockquote>
<p>这里追加操作没有固定写入的地址，而是在设备完成写入后返回给主机写入的地址。</p>
<p>即，不像写指令<code>write</code>，接收一个目标块地址。</p>
<p>追加指令<code>append</code>接收一个区域起始逻辑块地址<code>zone starting LBA (ZSLBA)</code>，当<code>append</code>完成后，逻辑块地址<code>LBA</code>返回给应用程序。这使得程序可以对同一个区域发送多个<code>append</code>命令。</p>
</blockquote>
</li>
<li><p>重置操作，显示通知设备某个区域中的数据可以被回收，但不一定是实时的。重置操作可以限制为 FTL（闪存翻译层）元数据映射操作，这会向设备指示该块稍后可以被擦除。</p>
</li>
</ul>
<h2 id="EXPERIMENTS"><a href="#EXPERIMENTS" class="headerlink" title="EXPERIMENTS:"></a>EXPERIMENTS:</h2><h3 id="Benchmarking-setup"><a href="#Benchmarking-setup" class="headerlink" title="Benchmarking setup:"></a><em>Benchmarking setup:</em></h3><ul>
<li><p><code>fio</code>，用来生成工作负载和基准测试。</p>
<blockquote>
<p><code>fio</code> 是一个流行的、灵活的开源工具，全称为 Flexible I&#x2F;O Tester。它被广泛用于执行和分析存储系统的性能和基准测试。<code>fio</code> 可以产生一定的I&#x2F;O负载，并以一种可控制和可预测的方式执行这些负载，使其成为评估和测试存储设备（如硬盘驱动器、固态硬盘、存储区域网络）性能的理想工具。</p>
</blockquote>
</li>
<li><p><code>SPDK</code>，（Storage Performance Development Kit）是一个高性能、用户态的存储开发工具包。它是由英特尔开发的开源项目，旨在提高存储设备，尤其是固态硬盘在数据中心中的性能和效率。SPDK 实现了一系列优化，使得存储操作可以绕过传统的内核栈，直接在用户空间运行，从而显著降低延迟并提高吞吐量。</p>
<blockquote>
<p>The <em>SPDK</em> stack, in contrast, is a bare-bones storage stack without any I&#x2F;O scheduler.</p>
</blockquote>
</li>
<li><p><code>mq-deadline</code> 是一种 I&#x2F;O 调度器，用于管理 Linux 操作系统中的块设备（如硬盘驱动器和固态硬盘）的请求队列。<code>mq-deadline</code> 是对原有 <code>deadline</code> 调度器的改进，专门为支持多队列 (Multi-Queue) 存储接口设计。这种调度器旨在平衡 I&#x2F;O 请求的延迟和吞吐量，特别是在高负载情况下。</p>
<blockquote>
<p>The Linux block layer ships with the <em>mq-deadline</em> scheduler, which buffers multiple write operations to a single zone, merges writes to contiguous LBAs into one or multiple (larger) writes, and sequentially issues the merged requests. Applications can, hence, issue multiple write operations to a single zone.</p>
</blockquote>
</li>
<li><p><code>io_uring</code> 是 Linux 内核中的一个比较新的异步I&#x2F;O接口。它为用户空间程序提供了一种高效的方式来提交和完成I&#x2F;O操作，尤其是在处理大量I&#x2F;O请求时。</p>
</li>
</ul>
<h3 id="Performance-metrics"><a href="#Performance-metrics" class="headerlink" title="Performance metrics:"></a><em>Performance metrics:</em></h3><ul>
<li><code>throughput</code>吞吐量</li>
<li><code>latency</code>延时</li>
</ul>
<h2 id="Observation"><a href="#Observation" class="headerlink" title="Observation:"></a>Observation:</h2><ol>
<li><p><em>The LBA format can have significant impact on both</em> write <em>and</em> append <em>latencies.</em></p>
<blockquote>
<p>导致这一现象的原因主要是硬件可能没有对于小的<code>IO</code>请求进行优化。</p>
</blockquote>
</li>
<li><p><em>Using the SPDK storage stack results in the lowest latencies.</em></p>
<blockquote>
<p>这是因为<code>SPDK</code>绕过内核直接与<code>SSD</code>设备交互。</p>
</blockquote>
</li>
<li><p>Write <em>and</em> append <em>throughput depends on the request size.</em></p>
<blockquote>
<ol>
<li><strong>请求大小与吞吐量的关系</strong>：<ul>
<li>实验显示，写入操作在 4 KiB 和 8 KiB 的请求大小时，IOPS（每秒输入&#x2F;输出操作数）吞吐量最高，达到约 85K IOPS。</li>
<li>而追加操作的性能随着请求大小的增加略有提升，从 66K IOPS 增至 69K IOPS。</li>
</ul>
</li>
<li><strong>字节吞吐量</strong>：<ul>
<li>以字节&#x2F;秒计算的吞吐量在大型请求（例如大于或等于 32 KiB）时最高，这是通过请求大小乘以 IOPS 计算得出的。（虽然每秒的<code>I\O</code>操作的次数减少了，但是每次<code>I\O</code>处理的字节数量提高了）。</li>
</ul>
</li>
<li><strong>请求方式的影响</strong>：<ul>
<li>由于请求是同步发出的，因此吞吐量是请求延迟的倒数。这意味着请求大小对性能的影响因写入和追加操作而异。</li>
</ul>
</li>
<li><strong>追加与写入性能差异</strong>：<ul>
<li>追加操作的吞吐量低于写入操作，并非 ZNS 设计固有的，而是取决于固件。预计新型 ZNS 设备的追加吞吐量会有所提高。</li>
</ul>
</li>
<li><strong>区域并行性的影响</strong>：<ul>
<li>请求大小的影响可能是由于区域并行性（即区域映射到多个闪存通道）造成的，类似于在文献 [44] 中观察到的情况。</li>
</ul>
</li>
<li><strong>最大吞吐量的建议</strong>：<ul>
<li>为了获得最大吞吐量，建议发出大型请求；在评估中使用的 ZNS 设备上，写入和追加操作分别在 4 KiB 和 8 KiB 请求大小时观察到最大的 IOPS 吞吐量，而对于大于 32 KiB 的请求观察到最大的字节吞吐量。</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li><p>write <em>operations have lower I&#x2F;O latencies than</em> append <em>operations.</em></p>
</li>
<li><p>对比了区域内并行<code>(intra-zone)</code>和区域间<code>(inter-zone)</code>并行</p>
<ol>
<li><p>在测试<code>write</code>和<code>read</code>操作时我们发现，区域内并行对比区域间并行，能达到更高的<code>IOPS</code>。</p>
<blockquote>
<p>如果程序需要比同时可打开区域数量更高的可扩展性，更推荐使用区域内并行。</p>
</blockquote>
</li>
<li><p>然而对于<code>append</code>操作来说，区域内和区域间请求并不敏感。</p>
<blockquote>
<p>推测这是由于<code>ZNS</code>设备的限制，而非<code>ZNS</code>设备设计的原因。</p>
</blockquote>
</li>
<li><p>对于大型（即 &gt;&#x3D;8KiB）I&#x2F;O请求，区域内追加和区域间写入操作的性能达到设备极限，并且在不同并发级别下以类似的方式扩展。</p>
</li>
</ol>
</li>
<li><p>区域状态机的转移开销</p>
<ol>
<li>区域的利用率对<code>reset</code>和<code>finish</code>操作有重要的影响。</li>
</ol>
</li>
<li><p><code>I/O</code>干扰：<code>write</code>，<code>append</code>和<code>read</code>的干扰</p>
<ol>
<li>ZNS设备在并发写入触发垃圾收集的情况下提供比普通<code>NVMe device</code>更稳定的读写性能。</li>
<li></li>
</ol>
</li>
</ol>
<h2 id="Recommendation"><a href="#Recommendation" class="headerlink" title="Recommendation:"></a>Recommendation:</h2><ol>
<li>对于低<code>I/O</code>延迟，使用<code>write</code>而不是<code>append</code>操作，并且使用<code>SPDK</code>存储堆栈，因为<code>SPDK</code>提供最低的<code>I/O</code>延迟。</li>
<li>相比于区域间并行性，更推荐使用区域内并行性；前者适用于追加和读取操作，而后者更适合写入操作。使用大型请求尺寸（即 &gt;&#x3D;8KiB，接近内部块大小）发起I&#x2F;O，因为更大的请求在更高并发级别下扩展性更好。</li>
<li>避免使用<code>finish</code>，特别是对于部分写入的区域。最小化需要<code>finish</code>的区域数量，</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/22/ZNSLiterature01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/22/ZNSLiterature01/" class="post-title-link" itemprop="url">ZNSLiterature01</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-22 15:56:24" itemprop="dateCreated datePublished" datetime="2023-11-22T15:56:24+08:00">2023-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-26 11:22:52" itemprop="dateModified" datetime="2023-11-26T11:22:52+08:00">2023-11-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是第二周2023.11.20-2023.11.26的论文阅读笔记</p>
<h1 id="ZNS-Avoiding-the-Block-Interface-Tax-for-Flash-based-SSDs"><a href="#ZNS-Avoiding-the-Block-Interface-Tax-for-Flash-based-SSDs" class="headerlink" title="ZNS: Avoiding the Block Interface Tax for Flash-based SSDs"></a>ZNS: Avoiding the Block Interface Tax for Flash-based SSDs</h1><p><a target="_blank" rel="noopener" href="https://www.usenix.org/conference/atc21/presentation/bjorling">https://www.usenix.org/conference/atc21/presentation/bjorling</a></p>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem:"></a>Problem:</h2><p>传统的<code>SSD</code>的问题：</p>
<ul>
<li><p>额外配置<code>(over-provision)</code>：这是为了在物理地址之间移动数据。</p>
</li>
<li><p>额外的<code>DRAM</code>：为了维护逻辑地址和物理地址之间的不稳定映射，这两个问题被称为<code>Block Interface Tax</code>。</p>
<blockquote>
<p>指使用块接口存储设备时所面临的性能和操作成本的问题。</p>
</blockquote>
</li>
</ul>
<h2 id="Previous-approach"><a href="#Previous-approach" class="headerlink" title="Previous approach:"></a>Previous approach:</h2><ul>
<li><p><code>Stream SSD</code>：主机会在写命令上添加标记<code>hint</code>。<code>Stream SSD</code>会通过这些标记将不同的数据放入不同的擦除块中。</p>
<blockquote>
<p>存在的问题：</p>
<ul>
<li>如果主机不添加标记，则和传统的<code>SSD</code> <code>(black box ssd)</code>没有区别。</li>
<li><code>SSD</code>仍然需要维护资源来管理这些标记的数据，所以不会降低额外配置<code>over provision</code>和额外<code>DRAM</code></li>
</ul>
</blockquote>
</li>
<li><p><code>open channel SSD</code>：主机和<code>SSD</code>共同管理一组连续的逻辑块簇<code>a set of contiguous LBA chunks</code>。这些连续的块簇<code>chunks</code>和物理擦除块<code>physical erased blocks</code>对齐。这样的对齐消除了设备垃圾回收开销<code>GC</code>，额外配置和<code>DRAM</code>。</p>
<blockquote>
<p>存在的问题：</p>
<ul>
<li>增加了主机的工作负担。</li>
<li>需要主机来管理不同<code>SSD</code>实现间的差异性。</li>
<li>需要持续的软件维护来保证其功能。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="Approach"><a href="#Approach" class="headerlink" title="Approach:"></a>Approach:</h2><p>提出了<code>ZNS</code>接口 <code>(Zone Namespace interface)</code>：</p>
<ul>
<li>兼容性：<code>ZNS</code>利用并兼容<code>ZAC/ZBC (Zoned ATA Command / Zoned Block Command)</code>规范中定义的分区存储模型。</li>
<li>增加了可以充分利用闪存特性的功能。</li>
<li>消除了<code>SSD</code>介质和设备接口之间的不匹配。</li>
<li>提供了一个不直接管理特定介质特性的下一代存储接口，这避免了像<code>OCSSD</code>那样直接处理介质特有特性的需要。</li>
</ul>
<p>一种<code>Tax-free Storage with zones</code>：</p>
<ul>
<li><code>zone state</code></li>
<li><code>zone write pointer</code></li>
</ul>
<p>提出上述的两个<code>ZNS</code>的特性，消除了主机软件需要跟踪每个区域最后写入的<code>LBA</code>的需求，简化了在例如不当关机后的恢复过程。</p>
<p><code>ZNS</code>接口在遵循区域存储规范的同时，也给出了两个对应闪存特性的新概念：</p>
<ul>
<li><p><code>writeable zone capability</code>：允许将区域内的<code>LBA</code>分为可写和不可写两部分，允许区域有比区域大小<code>zone size</code>更小的<code>writeable capability</code>。</p>
<blockquote>
<p>目的：使得<code>ZNS SSD</code>的区域大小可以与<code>SMR HDD</code>引入的2的幂次方大小行业标准对齐。</p>
</blockquote>
</li>
<li><p><code>active zone limit</code>：对处于打开或者关闭的区域的数量进行限制了限制。</p>
<blockquote>
<p>原因：基于闪存的介质<code>flash-based media</code>对这一数量有限制。</p>
<p>程序干扰（Program Disturb）是闪存（特别是NAND型闪存）中的一个现象，它对ZNS（区域命名空间）固态硬盘（SSD）的活动区域数量产生限制的方式是比较复杂的。我将为您详细解释这个过程。</p>
<h3 id="程序干扰（Program-Disturb）"><a href="#程序干扰（Program-Disturb）" class="headerlink" title="程序干扰（Program Disturb）"></a>程序干扰（Program Disturb）</h3><ol>
<li><strong>定义与影响</strong>：<ul>
<li>程序干扰是指在对NAND闪存的某个区域进行写操作（编程）时，可能无意中影响到相邻单元的现象。</li>
<li>这种干扰可能导致数据损坏或存储单元性能下降。</li>
</ul>
</li>
<li><strong>发生原因</strong>：<ul>
<li>NAND闪存中的存储单元（单元格）非常紧密排列。</li>
<li>当对一个单元进行写操作（注入电荷）时，相邻单元可能会因电场干扰而受到影响，尤其是在重复写入的情况下。</li>
</ul>
</li>
</ol>
<h3 id="对ZNS-SSD的影响"><a href="#对ZNS-SSD的影响" class="headerlink" title="对ZNS SSD的影响"></a>对ZNS SSD的影响</h3><ol>
<li><strong>ZNS SSD结构</strong>：<ul>
<li>ZNS SSD通过将存储空间划分为多个区域（zones）来优化数据管理和写入效率。</li>
<li>这些区域可独立管理，减少了写入放大（Write Amplification）和垃圾收集（Garbage Collection）的需要。</li>
</ul>
</li>
<li><strong>活动区域限制的必要性</strong>：<ul>
<li>由于程序干扰的存在，如果太多区域同时保持在可写状态（尤其是在高密度存储条件下），可能会增加数据损坏的风险。</li>
<li>限制同时处于打开或关闭状态的活动区域数量，可以减少相邻区域间的干扰，从而降低数据损坏的风险。</li>
</ul>
</li>
<li><strong>管理策略</strong>：<ul>
<li>ZNS SSDs通过限制同时可写的区域数量，从而降低程序干扰的风险。</li>
<li>这种限制有助于提高数据的可靠性和存储介质的寿命。</li>
</ul>
</li>
</ol>
<p>总的来说，程序干扰是一个物理现象，它限制了ZNS SSD中可以同时处于活动（即可写）状态的区域数量，这是为了减少数据损坏的风险并提高整体存储系统的稳定性和可靠性。</p>
<p><em>*<em>更深入的解释参考：Yu Cai, Onur Mutlu, Erich F Haratsch, and Ken Mai. Program Interference in MLC NAND Flash Memory: Characterization, Modeling, and Mitigation. In <em>2013 IEEE 31st International Conference on Computer De- sign (ICCD)</em>, pages 123–130. IEEE, 2013.</em>*</em></p>
</blockquote>
</li>
</ul>
<p>尽管ZNS接口增加了主机软件的责任，我们仍然使用一些方法减轻主机的这种负担。</p>
<h3 id="Evoloving-towards-ZNS"><a href="#Evoloving-towards-ZNS" class="headerlink" title="Evoloving towards ZNS:"></a>Evoloving towards ZNS:</h3><h4 id="对硬件的影响："><a href="#对硬件的影响：" class="headerlink" title="对硬件的影响："></a>对硬件的影响：</h4><p><code>ZNS</code>接口可以将区域的顺序写入转换到不同的擦除块中，从而消灭了接口和媒介之间的不匹配。</p>
<ul>
<li>数据放置在区域的粒度上被管理，这意味着负责在擦除块之间移动有效数据（以释放可写容量）的SSD垃圾收集例程将成为主机的责任。</li>
<li>这意味着设备上的写放大现象被消除，从而消除了对容量过剩配置的需求，同时也提升了介质的整体性能和使用寿命。</li>
</ul>
<blockquote>
<h3 id="ZNS-SSD的核心设计"><a href="#ZNS-SSD的核心设计" class="headerlink" title="ZNS SSD的核心设计"></a>ZNS SSD的核心设计</h3><ol>
<li><strong>顺序区域写入</strong>:<ul>
<li>ZNS SSD将存储空间分割成多个区域（zones），每个区域在一次写入操作中只允许顺序写入。</li>
<li>这种方式与传统的随机写入相比，更加适合NAND闪存的物理特性。</li>
</ul>
</li>
<li><strong>区域与擦除块的对应关系</strong>:<ul>
<li>在ZNS SSD中，顺序写入的区域直接对应于闪存的擦除块。</li>
<li>这样，每个区域的写入操作都直接映射到一个特定的擦除块上，减少了因随机写入造成的额外擦写循环。</li>
</ul>
</li>
</ol>
<h3 id="消除接口-介质不匹配"><a href="#消除接口-介质不匹配" class="headerlink" title="消除接口-介质不匹配"></a>消除接口-介质不匹配</h3><ol>
<li><strong>简化的闪存翻译层（FTL）</strong>:<ul>
<li>传统SSD中的FTL负责管理随机写入和数据在擦除块间的移动。</li>
<li>在ZNS SSD中，由于不支持随机写入，FTL的复杂性大大降低，这意味着更少的数据移动和管理开销。</li>
</ul>
</li>
<li><strong>由主机管理数据放置</strong>:<ul>
<li>在ZNS SSD中，数据的放置和擦除块的重置由主机（而非设备）显式管理。</li>
<li>这种设计使得数据存储更加高效，减少了写放大（Write Amplification）现象。</li>
</ul>
</li>
</ol>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><ul>
<li>减少写放大：由于写操作更加高效，ZNS SSD减少了写放大现象，这直接影响到设备的性能和寿命。</li>
<li>无需容量过剩配备：减少写放大也意味着不再需要为了补偿性能损耗而过度配备存储容量。</li>
<li>提升性能和寿命：整体上，ZNS SSD通过这种设计，提高了性能，并延长了存储介质的使用寿命。</li>
</ul>
<p>总之，ZNS SSD通过其对区域的顺序写入方式和简化的数据管理，有效地消除了传统接口与NAND闪存介质之间的不匹配问题，从而提高了存储效率和设备的整体性能。</p>
</blockquote>
<p><strong>Zone Sizing</strong>：区域写容量<code>zone write capability</code>和<code>SSD</code>的擦除块大小有直接的联系。</p>
<ul>
<li><p>在以块为接口的<code>SSD</code>中，擦除块中的数据是跨越了多个闪存晶圆<code>(flash dies)</code>的。 </p>
<blockquote>
<p>既为了获得更高的读写性能，也为了通过每条带（stripe）的奇偶校验来防止芯片级别和其他介质故障。</p>
</blockquote>
</li>
</ul>
<p><strong>Mapping Table</strong>：传统的<code>SSD</code>中，<code>FTL</code>维护了一个逻辑块到物理块的映射表，这样的映射表在提高垃圾回收效率的同时也占用了很大的空间。</p>
<p>而<code>ZNS SSD</code>的顺序写限制，可以使这种全相连的映射在擦除块级别或者以某种混合方式维护的粗粒度映射。这样做可以显著减少甚至完全消除<code>DRAM</code>（映射表需要提前存放在<code>SSD</code>的<code>DRAM</code>中）。</p>
<p><strong>Device Resources</strong>：部分写入的擦除块会关联一组资源。</p>
<blockquote>
<p>这一套装备包括硬件资源，如异或（XOR）引擎，内存资源，如静态随机存取内存（SRAM）或动态随机存取内存（DRAM），以及用于在断电后保持奇偶校验数据的电源电容器。</p>
</blockquote>
<p>数据和奇偶校验的大小可以从数百千字节到数兆字节不等，例如，这可能是由于两步编程所致。</p>
<blockquote>
<p>在NAND闪存技术中，”Two-Step Programming”（两步编程）是一种数据写入方法。这种方法在写入数据到NAND闪存单元时分为两个阶段进行，以提高数据的可靠性和减少错误。以下是两步编程的主要步骤和特点：</p>
<h3 id="第一步：初步写入"><a href="#第一步：初步写入" class="headerlink" title="第一步：初步写入"></a>第一步：初步写入</h3><ul>
<li>在这一步中，数据首先被写入到闪存单元，但并不是以最终的形态。这个阶段的目的是将数据大致定位到所需的状态。</li>
</ul>
<h3 id="第二步：精细调整"><a href="#第二步：精细调整" class="headerlink" title="第二步：精细调整"></a>第二步：精细调整</h3><ul>
<li>第二步涉及对之前写入的数据进行精细调整。这个阶段确保数据准确地达到其目标状态，从而减少写入错误。</li>
<li>这种方法特别适用于多级单元（MLC）和三级单元（TLC）NAND闪存，其中每个单元存储多个位的数据。</li>
</ul>
<h3 id="为什么使用两步编程"><a href="#为什么使用两步编程" class="headerlink" title="为什么使用两步编程"></a>为什么使用两步编程</h3><ol>
<li><p><strong>提高精确度</strong>：</p>
<ul>
<li>由于NAND闪存单元在存储多个数据位时容易受到干扰，两步编程通过分阶段精细调整来提高写入数据的准确度。</li>
</ul>
</li>
<li><p><strong>减少错误</strong>：</p>
<ul>
<li>分步骤写入减少了数据写入错误的可能性，特别是在高密度存储技术（如MLC和TLC）中。</li>
</ul>
</li>
<li><p><strong>提升可靠性</strong>：</p>
<ul>
<li>通过减少写入错误，两步编程提高了存储的可靠性，这对于保持数据完整性和延长设备寿命非常重要。</li>
</ul>
</li>
</ol>
<p>总体来说，两步编程是NAND闪存中一种重要的数据写入方法，特别是在那些要求高数据密度和可靠性的应用中。通过这种方法，可以有效地减少写入错误，提高整体存储介质的性能和可靠性。</p>
</blockquote>
<p>由于这些要求和相关成本，预计ZNS固态硬盘将拥有8到32个活动区域。尽管通过增加额外的电源电容器、使用动态随机存取内存（DRAM）进行数据移动、减少奇偶校验要求，或部署一种写回缓存的形式，可以进一步增加活动区域的数量。 </p>
<h4 id="Host-Software-Adoption-主机软件的采用情况"><a href="#Host-Software-Adoption-主机软件的采用情况" class="headerlink" title="Host Software Adoption 主机软件的采用情况"></a>Host Software Adoption 主机软件的采用情况</h4><p>三种让主机软件适配<code>ZNS</code>接口的方式。</p>
<p>采用顺序写特性的软件能更好的适配<code>ZNS</code>接口，比如<code>Log Structure Merge (LSM) tree-based database</code>。主要执行原地更新<code>in-place update</code>的应用程序在不对核心数据结构进行根本性修改的情况下，更难以支持。</p>
<ul>
<li><code>Host-side FTL (HFTL)</code>：一种在<code>ZNS SSD</code>写语法和使用随机写和就地更新的程序之间的媒介，类似于<code>SSD</code>的<code>FTL</code>层。</li>
</ul>
<p>  但只负责<code>translation mapping</code>和<code>Garbage collection</code></p>
<blockquote>
<p><strong>缺点：</strong><code>HFTL</code>需要占用<code>CPU</code>和<code>DRAM</code>。</p>
<p><strong>优点：</strong>使集成主机端的信息更加简单，增加了对数据放置和垃圾回收的控制，同时将<code>ZNS SSD</code>当作<code>conventional SSD</code>暴露给应用程序。</p>
</blockquote>
<ul>
<li><p><code>FTL System</code>：更高层次的存储接口允许多个应用程序通过常见的文件语法访问存储系统。</p>
<p>即：将区域与存储堆栈的更高层次集成，以确保顺序写入。</p>
</li>
<li><p><code>End-to-end Data placement</code>端到端数据放置：理想情况下，区域写语法讲与应用程序的现有数据结构保持一致。这将通过允许应用程序管理数据放置来提供最高程度的自由度，同时消除了来自文件系统和翻译层的间接开销。</p>
<blockquote>
<p>虽然端到端的数据放置使应用程序与ZNS固态硬盘之间的协作成为可能，并有潜力实现最佳的写放大、吞吐量和延迟改进，但它就像与原始块设备交互一样令人生畏。</p>
</blockquote>
</li>
</ul>
<h3 id="Implementation-我们已经向四个主要软件项目增加了支持，以评估ZNS的好处。"><a href="#Implementation-我们已经向四个主要软件项目增加了支持，以评估ZNS的好处。" class="headerlink" title="Implementation: 我们已经向四个主要软件项目增加了支持，以评估ZNS的好处。"></a>Implementation: 我们已经向四个主要软件项目增加了支持，以评估ZNS的好处。</h3><ul>
<li>更改<code>Linux</code>内核以支持<code>ZNS SSD</code></li>
<li>更改<code>f2fs file system</code></li>
<li>更改<code>fio benchmark</code>：这是为了测试和评估支持<code>ZNS</code>的存储设备性能</li>
<li>提出<code>ZenFS</code>：一个针对<code>RockDB</code>的新型存储后端，它通过分区来控制设备用以评估端到端集成对分区存储的好处</li>
</ul>
<h4 id="General-Linux-support"><a href="#General-Linux-support" class="headerlink" title="General Linux support"></a>General Linux support</h4><p><strong>Zone Capability:</strong></p>
<p><code>fio</code>和<code>f2fs</code>支持<code>Zone capability</code>，<code>fio</code>只保证不超过<code>zone capability</code>，<code>f2fs</code>管理段，段大小为<code>2MB</code>，多个段位一个区<code>section</code>，一个区<code>section</code>的大小和一个域<code>zone</code>的大小相同。</p>
<p><strong>limiting active zones 打开区域数量限制:</strong></p>
<p><code>fio</code>要求用户遵守打开区域数量这一限制。</p>
<p>对于<code>f2fs</code>来说，这种限制体现在打开的段的数量上。</p>
<h4 id="RocksDB-Zone-Support"><a href="#RocksDB-Zone-Support" class="headerlink" title="RocksDB Zone Support:"></a>RocksDB Zone Support:</h4><p>调整键值数据库<code>RocksBD</code>，使其能够通过使用<code>ZenFS</code>存储后端，将数据端到端地放置到分区存储设备上。<code>ZenFS</code>利用了<code>RocksDB</code>的日志结构合并<code>(LSM)</code>数数据结构，这是<code>RocksDB</code>用来存储和维护其数据的，并且还利用了其相关的不可变的仅限顺序的压缩过程。</p>
<p><code>LSM tree</code>：</p>
<p>最上层的数据是热数据，冷数据会被一直下放到最底层。</p>
<p><img src="/../images/ZNSLiterature01/%E6%88%AA%E5%B1%8F2023-11-25%2018.16.52.png" alt="截屏2023-11-25 18.16.52"></p>
<p><strong>ZenFS Architecture</strong>：</p>
<p><code>ZenFS</code>存储后端实现了一种最小的磁盘上文件系统，并使用<code>RocksDB</code>的文件包装<code>API</code>对其进行集成。</p>
<p><img src="/../images/ZNSLiterature01/%E6%88%AA%E5%B1%8F2023-11-25%2018.35.12.png" alt="截屏2023-11-25 18.35.12"></p>
<p><strong>Journaling and data</strong>：</p>
<ul>
<li>journal：日志区域用于恢复文件系统的状态，维护超级块数据结构，并将写前日志（WAL）和数据文件映射到区域。</li>
<li>data：数据区域存储文件内容。</li>
</ul>
<p><strong>Extents</strong>：</p>
<ul>
<li><code>RocksDB</code>的数据文件被映射并存储到一系列内容<code>a set of content</code>中。</li>
<li><code>content</code>是大小可变，块对齐的。</li>
<li><code>Extents</code>按顺序写入一个数据区域。</li>
<li>包含与特定标识符相关联的数据。</li>
</ul>
<p>每个区域包含很多<code>extents</code>，但是<code>extents</code>不能扩大<code>zone</code>的大小。</p>
<blockquote>
<p>区段的分配和释放事件被记录在内存数据结构中，并在关闭文件或通过<code>fsync</code>调用要求<code>RocksDB</code>持久化数据时写入日志。内存数据结构跟踪区段到区域的映射，一旦一个区域中分配了区段的所有文件都被删除，该区域就可以被重置并重用。</p>
</blockquote>
<p><strong>superblock 超级块</strong>：</p>
<p><strong>Journal 日志</strong>：</p>
<p><strong>Writeable Capacity in Data Zones 数据区域的可写容量</strong>：</p>
<p><strong>Data Zone Selection</strong>：ZenFS采用了一种尽最大努力的算法来选择最佳区域存储RocksDB数据文件。</p>
<blockquote>
<p> A match is only valid if the lifetime of the file is less than the oldest data stored in the zone to avoid prolonging the life of the data in the zone.</p>
<p>目的是为了确保不因为新添加的文件而不必要地延长存储区域中旧数据的存储时间，从而有效管理数据的生命周期和存储区域的使用效率。</p>
</blockquote>
<p><strong>Active Zone limit</strong></p>
<blockquote>
<p>活动区域限制。ZenFS必须遵守分区块设备指定的活动区域限制。要运行ZenFS，至少需要三个活动区域，它们分别被分配给日志、写前日志（WAL）和压缩过程。为了提高性能，用户可以控制并发压缩的数量。我们的实验表明，通过限制并发压缩的数量，RocksDB可以在写性能受限的情况下，只使用最少6个活动区域工作，而超过12个活动区域并不会带来任何显著的性能好处。</p>
</blockquote>
<p><strong>Direct I&#x2F;O and Buffered Writes</strong></p>
<blockquote>
<p>直接I&#x2F;O和缓冲写入。ZenFS利用了写入SST文件是顺序的和不可变的这一事实，并对SST文件执行直接I&#x2F;O写入，绕过了内核页面缓存。对于其他文件，如写前日志（WAL），ZenFS在内存中缓冲写入，并在缓冲区满、文件关闭或RocksDB请求刷新时刷新缓冲区。如果请求了刷新，缓冲区将被填充到下一个块边界，并且一个带有有效字节数的区段将被存储在日志中。这种填充导致了少量的写入放大，但这并非ZenFS独有，传统文件系统中也有类似的做法。</p>
</blockquote>
<h2 id="Regular-data-write-vs-zone-append-data-write"><a href="#Regular-data-write-vs-zone-append-data-write" class="headerlink" title="Regular data write .vs zone append data write"></a>Regular data write .vs zone append data write</h2><h3 id="zone-append-data-write-的优点"><a href="#zone-append-data-write-的优点" class="headerlink" title="zone append data write 的优点"></a>zone append data write 的优点</h3><ol>
<li><strong>锁定和资源分配</strong>：<ul>
<li>在Zone Append Write中，不需要在提交写操作之前分配存储空间（即延迟分配），也不需要锁定块组。这简化了I&#x2F;O提交过程，减少了延迟和开销，因为不需要等待资源的分配和锁定。</li>
<li>相反，Regular Write需要在写操作之前分配和锁定相应的块组，这会增加写操作的复杂性和时间成本。</li>
</ul>
</li>
<li><strong>写入操作的顺序</strong>：<ul>
<li>Zone Append Write不关心BIO（Block I&#x2F;O）的顺序，因为所有写入都是追加到区域末尾的。这允许利用异步校验和，而且无需等待特定的写入顺序，提高了效率。</li>
<li>Regular Write则需要保持写入顺序，因为块的位置是预先确定的。这可能需要对写入操作进行排序和同步，从而增加了复杂性和可能的延迟。</li>
</ul>
</li>
<li><strong>并行性和性能</strong>：<ul>
<li>Zone Append Write由于其简单性，允许更高的并行操作，可以在不同的队列中异步处理校验和计算。</li>
<li>而Regular Write的并行性受到锁定机制和同步需求的限制，对于每个文件范围，必须保持写操作的原子性，这可能限制了性能。</li>
</ul>
</li>
<li><strong>系统复杂性和可靠性</strong>：<ul>
<li>Zone Append Write简化了I&#x2F;O路径，减少了需要管理的元数据数量。在写入完成后，使用的块可以直接从end_bio()回调中检索，简化了块分配元数据的更新。</li>
<li>Regular Write通常涉及更多的系统调用和层次，每个步骤都增加了出错的可能性，也增加了系统资源的使用。</li>
</ul>
</li>
</ol>
<p>总结来说，Zone Append Write的设计减少了I&#x2F;O操作的复杂性，通过简化写入过程、减少锁定和资源分配的需求，以及提高写入操作的并行性来提高效率。这使得Zone Append Write特别适合于现代存储系统，这些系统通常优化了顺序写入操作并能够从这种简化的I&#x2F;O提交过程中受益。</p>
<h3 id="zone-append-data-write-的缺点"><a href="#zone-append-data-write-的缺点" class="headerlink" title="zone append data write 的缺点"></a>zone append data write 的缺点</h3><ol>
<li><p><strong>不支持RAID级别</strong>：</p>
<ul>
<li>Zone Append Writes 是为单个区域化设备设计的，这意味着它们在设计上用于向单个存储区域追加数据。当涉及到RAID（独立磁盘冗余阵列）时，数据通常跨越多个磁盘分布以提供冗余和性能提升。Zone Append Write无法处理发送到不同区域&#x2F;设备的两个写入操作，因为在RAID配置中，这可能导致不一致的逻辑块地址（LBA）位置返回，从而破坏数据的连续性和完整性。</li>
</ul>
</li>
<li><p><strong>仍然使用专用写入路径</strong>：</p>
<ul>
<li>该系统仍然需要专用的写入路径来处理全部延迟分配范围的写入。这是因为正常写入路径可能会跳过某些数据的写入，例如在<code>fdatasync()</code>调用范围之外的数据，导致数据丢失或不完整。在使用正常写入路径时，需要在提交写操作（bio）之前拆分现有的文件范围，这增加了处理复杂性。</li>
</ul>
</li>
<li><p><strong>文件范围的碎片化</strong>：</p>
<ul>
<li>每个I&#x2F;O操作限制在<code>zone_append_max_bytes</code>（例如512KB）这样的最大字节大小，意味着如果文件范围超过这个限制，它需要被拆分成多个I&#x2F;O操作。这导致同一文件的多个范围被创建，增加了文件系统的碎片化。因此，与常规的文件系统（如btrfs）相比，文件范围数量增多，可能导致性能下降和管理上的复杂性。</li>
</ul>
</li>
</ol>
<p>总的来说，虽然Zone Append Write在顺序数据写入方面具有效率优势，但它在一些特定的系统配置和操作上存在限制。这些限制主要是由于Zone Append Write设计的固有特性，它们在多设备（如RAID配置）、需要维护数据完整性和减少碎片化的环境中可能不是最佳选择。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/13/ZNSSSDliterature/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/13/ZNSSSDliterature/" class="post-title-link" itemprop="url">ZNSSSDliterature</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-13 19:38:51" itemprop="dateCreated datePublished" datetime="2023-11-13T19:38:51+08:00">2023-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-21 14:38:20" itemprop="dateModified" datetime="2023-11-21T14:38:20+08:00">2023-11-21</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Critical-Thinking-Reading"><a href="#Critical-Thinking-Reading" class="headerlink" title="Critical Thinking - Reading"></a>Critical Thinking - Reading</h1><h2 id="Read-a-paper-and-consider"><a href="#Read-a-paper-and-consider" class="headerlink" title="Read a paper and consider:"></a>Read a paper and consider:</h2><h3 id="Do-I-like-it-Hate-it-opinion"><a href="#Do-I-like-it-Hate-it-opinion" class="headerlink" title="Do I like it? Hate it? (opinion)"></a>Do I like it? Hate it? (opinion)</h3><h3 id="What-problem-is-it-trying-to-solve"><a href="#What-problem-is-it-trying-to-solve" class="headerlink" title="What problem is it trying to solve"></a>What problem is it trying to solve</h3><h3 id="How-does-their-approach-differ-from-previous-ones"><a href="#How-does-their-approach-differ-from-previous-ones" class="headerlink" title="How does their approach differ from previous ones"></a>How does their approach differ from previous ones</h3><h3 id="how-much-previous-work-do-I-know-about-read-it-reference-chaining"><a href="#how-much-previous-work-do-I-know-about-read-it-reference-chaining" class="headerlink" title="(how much previous work do I know about - read it! (reference chaining))"></a>(how much previous work do I know about - read it! (reference chaining))</h3><h3 id="Does-it-work"><a href="#Does-it-work" class="headerlink" title="Does it work?"></a>Does it work?</h3><h3 id="What-could-be-improved"><a href="#What-could-be-improved" class="headerlink" title="What could be improved"></a>What could be improved</h3><h1 id="Optimizing-Data-Migration-for-Garbage-Collection-in-ZNS-SSDs"><a href="#Optimizing-Data-Migration-for-Garbage-Collection-in-ZNS-SSDs" class="headerlink" title="Optimizing Data Migration for Garbage Collection in ZNS SSDs"></a>Optimizing Data Migration for Garbage Collection in ZNS SSDs</h1><h2 id="Problem-to-be-solved"><a href="#Problem-to-be-solved" class="headerlink" title="Problem to be solved"></a>Problem to be solved</h2><p>在<code>zns ssd</code>中，程序被允许以一种高效的数据放置方法连续的写入不同的区域<code>zone</code>中。然而，在一个区域<code>zone</code>中的<strong>无效数据<code>invalid data</code>只有在整个区域的数据被擦除时才能被释放</strong>，这导致了空间低利用率。</p>
<p>现阶段的研究集中在降低数据迁移的次数，但是他们的数据迁移方式并不高效。</p>
<p>一方面，<code>ZNS SSD</code>中的数据迁移会导致不必要的端到端开销。</p>
<blockquote>
<p>这是因为在<code>ZNS SSD</code>的数据迁移由<code>host</code>管理，迁移时要先将数据读取到内存中，再由主机指定写入对应的区域<code>zone</code>中去。</p>
</blockquote>
<p>另一方面，两个区域<code>zone</code>之间，进行块到块<code>block-to-block</code>的数据迁移的开销也很大，会导致巨大的重写开销。</p>
<p><strong>一种理想的方法是</strong>，将受害区域<code>victim zone</code>中的包含有效数据的块<code>blocks with valid data</code>重新映射到目标区域中<code>target zone</code>（通过这种映射，我们只需要擦除受害区域<code>victim zone</code>中的<code>blocks with invalid data </code>擦除，然后在目标区域<code>target zone</code>中开辟新的<code>block</code>并写入<code>blocks with invalid data</code>块中的有效数据即可）。</p>
<p>仍然，<code>ZNS SSD</code>中的区域和块之间的映射基于芯片间的并行提前被定义好了。</p>
<h2 id="Approaches"><a href="#Approaches" class="headerlink" title="Approaches"></a>Approaches</h2><p>提出一种新的<code>ZNS SSD</code>垃圾回收方式，<code>IS_AR</code>：</p>
<ul>
<li><h3 id="Zone-MD：提出的新ZNS命令，用于实现存储内部数据迁移in-storage-data-migration，以避免端到端的传输开销。"><a href="#Zone-MD：提出的新ZNS命令，用于实现存储内部数据迁移in-storage-data-migration，以避免端到端的传输开销。" class="headerlink" title="Zone_MD：提出的新ZNS命令，用于实现存储内部数据迁移in-storage data migration，以避免端到端的传输开销。"></a><code>Zone_MD</code>：提出的新<code>ZNS</code>命令，用于实现存储内部数据迁移<code>in-storage data migration</code>，以避免端到端的传输开销。</h3><p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-13%2020.27.34.png" alt="截屏2023-11-13 20.27.34"></p>
<p>如图所示，函数<code>Zone_MD(Src, Dst, Size)</code>接收三个参数：</p>
<ul>
<li><code>Src</code>：表示受害区域<code>victim zone</code>中的有效数据<code>valid data</code>的逻辑起始地址<code>starting logic address</code>。</li>
<li><code>Dst</code>：表示目标区域<code>target zone</code>的写指针<code>write pointer</code>地址。</li>
<li><code>Size</code>：表示要迁移的连续有效数据<code>continuous valid data</code>的大小。</li>
</ul>
<p>整个存储内数据迁移<code>in-storage data migration</code>在存储的内部通道<code>internal channel</code>的帮助下完成，避免了端到端传输。</p>
<blockquote>
<p><code>internal channel</code>是指固态硬盘（SSD）内部用于数据传输的通道。这个通道在硬盘的控制器内部进行操作，而不是通过主机的数据总线。这意味着数据迁移是在SSD设备内部完成的，而不需要数据经过主机（即计算机的CPU和主内存）。</p>
<p>这种内部数据迁移通道通常由SSD的固件和控制器逻辑来管理。它能够直接访问闪存存储单元，执行读取、传输和写入操作。使用这样的通道，可以有效地将数据从一个区域（源区域，Src）移动到另一个区域（目标区域，Dst），而不必通过外部接口传输数据，这样可以极大地减少数据迁移的延迟和带宽消耗。</p>
</blockquote>
</li>
<li><h3 id="AR：一种重映射策略remapping-strategy，该策略基于并行物理块，以减少block-to-block重写的开销。"><a href="#AR：一种重映射策略remapping-strategy，该策略基于并行物理块，以减少block-to-block重写的开销。" class="headerlink" title="AR：一种重映射策略remapping strategy，该策略基于并行物理块，以减少block-to-block重写的开销。"></a><code>AR</code>：一种重映射策略<code>remapping strategy</code>，该策略基于并行物理块，以减少<code>block-to-block</code>重写的开销。</h3></li>
</ul>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-13%2020.39.07.png" alt="截屏2023-11-13 20.39.07"></p>
<p>为保证对一个区域<code>zone</code>的并行写操作<code>parallelism of writing</code>，提出了一种基于并行块组<code>parallel block groups (PBGs)</code>动态的区域映射方法。</p>
<blockquote>
<p>上文中的每个block不是指NAND闪存内部的物理块，而是一个逻辑上的映射单元，它可能跨越多个芯片（chip）。</p>
</blockquote>
<ul>
<li>首先将<code>SSD</code>中的芯片分组，形成多个并行芯片组<code>mutiple parallel chip groups (PCG)</code>。通过<code>PCG</code>，读写操作可以并行的执行。</li>
<li>在每个并行芯片组<code>PCG</code>中，拥有相同偏移量<code>offset</code>的块被分到相同的并行块组中<code>PBG</code>，同样并行块组中的读写操作也能被并行的执行。</li>
<li>我们把并行块组<code>(PBG)</code>作为最小的重映射单位，并保证了区域内的并行性。</li>
<li>当一个区域被分配时，我们动态的将<code>PBGs</code>映射到区域上。</li>
</ul>
<p>现在我们讨论重映射策略。</p>
<p>在受害区域<code>victim zone</code>中，有两种<code>PBG</code>区域需要被迁移：</p>
<ul>
<li><code>V1</code>：整个并行块组<code>PBG</code>都是合法数据。</li>
<li><code>V2</code>：并行块组<code>PBG</code>的一部分是合法数据。</li>
</ul>
<p>在目标区域<code>target zone</code>，并行块组也分为两类：</p>
<ul>
<li><code>T1</code>：并行块组的所有部分均会被写入。</li>
<li><code>T2</code>：并行块组只有一部分会被写入。</li>
</ul>
<p>两辆组合，产生四种重映射方法：</p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-14%2008.44.24.png" alt="截屏2023-11-14 08.44.24"></p>
<ul>
<li><p><code>Fig.3.(1),(2)</code>：<code>V1</code>被重映射到包含<code>T1</code>或<code>T2</code>的区域<code>zone</code>。</p>
<ul>
<li><p><code>V1-&gt;T1</code>：<code>V1</code>的逻辑地址和物理地址直接重映射（这里的关键是没有提到数据从物理上的一个位置被复制到另一个位置，而是提到了逻辑空间（LS）到物理空间（PS）的映射直接重映射到目标区域，这通常涉及更新映射表（MT）而不是实际的数据移动。）到目标区域。同时，<code>Write Point</code>移动到<code>WP* = (WP + V1_Size)</code>，并在映射表<code>Mapping Table</code>上更新物理地址和逻辑地址。</p>
</li>
<li><p><code>V1-&gt;T2</code>：为了提高<code>T2</code>的空间利用率，<code>P1-P2</code>这段未被使用的空间的物理地址将被重映射到逻辑地址中去，其位置会在写指针<code>WP*</code>后面的<code>CW</code>处，长度不变。</p>
<blockquote>
<p><code>RT (Remapping Table)</code>：为了保持正确的索引关系，添加了一个新的重新映射表（RT），以记录逻辑地址与范围内的物理地址的偏移量（即具有相同偏移量相同的LS的连续段）粒度。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>Fig.3.(3),(4)</code>：<code>V2</code>被重映射到包含<code>T1</code>或<code>T2</code>的区域<code>zone</code>。</p>
<ul>
<li><p><code>V2</code>的整个物理地址直接被重映射到目标区域的物理地址中。然而，只有<code>V2</code>中的有效数据的逻辑地址被重映射到目标区域，因为目标区域只需要有效数据。</p>
<blockquote>
<p>V2中的无效数据空间被保留，直到目标区域重置（即部分无效空间被目标区域暂时占据）。</p>
</blockquote>
<p>因此，我们使用<code>ZNS SSD</code>的当前空间占用率<code>current space utilization (su)</code>作为基准<code>benchmark</code>。</p>
<p>如果<code>V2</code>中的有效数据的百分占比大于<code>su</code>，我们执行重映射。</p>
<p>否则我们直接重写<code>V2</code>中的所有有效数据。</p>
</li>
</ul>
</li>
</ul>
<p>​	通过上述方法，我们平衡了空间利用率和性能。</p>
<h2 id="Does-it-work-1"><a href="#Does-it-work-1" class="headerlink" title="Does it work?"></a>Does it work?</h2><p>将<code>IS-AR</code>和传统的数据迁移策略<code>Trad-DM</code>（没有实现数据内迁移和重映射）进行比较。具体的实验参数如下：</p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-14%2010.00.17.png" alt="截屏2023-11-14 10.00.17"></p>
<p>表格上看，数据迁移的延迟确实降低了，而且提高了<code>ZNS SSD</code>的寿命。</p>
<h2 id="What-could-be-improved？"><a href="#What-could-be-improved？" class="headerlink" title="What could be improved？"></a>What could be improved？</h2><p>论文中提到的<code>current space utilization</code>是如何选择的。</p>
<h1 id="A-New-LSM-style-Garbage-Collection-Scheme-for-ZNS-SSDs"><a href="#A-New-LSM-style-Garbage-Collection-Scheme-for-ZNS-SSDs" class="headerlink" title="A New LSM-style Garbage Collection Scheme for ZNS SSDs"></a>A New LSM-style Garbage Collection Scheme for ZNS SSDs</h1><h2 id="Problem-to-be-solved-1"><a href="#Problem-to-be-solved-1" class="headerlink" title="Problem to be solved"></a>Problem to be solved</h2><p><code>ZNS SSD</code>的两面性：</p>
<ul>
<li>Pro：通过将不同的工作负载分类到不同的区域中减少写放大<code>WAF</code></li>
<li>Cons：主机需要直接管理ZNS SSD，例如区域重置，并且它们具有顺序写入约束。</li>
</ul>
<p>简单的垃圾回收策略：</p>
<ul>
<li><code>LFS (log-structured File System)</code>：日志结构文件系统使用的段清理。</li>
<li><code>FTL (Flash Transition Layer)</code>：闪存层使用的垃圾回收策略</li>
</ul>
<p>上述策略的区别是将垃圾回收应用在区域<code>zone</code>还是段<code>segment</code>中。然而，这种简单的垃圾回收策略会因为区域的大小而导致更长的延迟，相比段大小而言。</p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><ul>
<li>如下图所示，要解决的问题还是：区域间的垃圾回收策略导致的时间开销过大。并且，最好选择利用利用率低的区域作为垃圾回收的区域。</li>
</ul>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-14%2015.11.12.png" alt="截屏2023-11-14 15.11.12"></p>
<ul>
<li><p>另一个观察是，在读取一个区域时，对块进行单独读取的耗时比对块进行组读取的模式的耗时更高。</p>
<blockquote>
<p>结果显示，以组的方式访问比单独访问要快得多。这是因为它不仅可以减少请求的数量，而且还可以利用ZNS固态硬盘内部的并行性。一般来说，ZNS固态硬盘中的一个区域会分布在多个通道上，这使得可以并行处理连续块的请求，就像开放通道固态硬盘（OCSSDs）那样。这一观察激励我们设计我们的LSM风格垃圾收集方案。</p>
</blockquote>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-14%2015.20.00.png" alt="截屏2023-11-14 15.20.00"></p>
</li>
</ul>
<h2 id="Approaches-1"><a href="#Approaches-1" class="headerlink" title="Approaches"></a>Approaches</h2><p>为了应对上文中提到的问题，提出了一个新的垃圾回收策略<code>LSM_ZGC</code>：</p>
<ul>
<li><code>LSM_ZGC</code>将区域分割为多个段，并分别管理这些段的信息。</li>
<li>以<code>LSM</code>的风格进行垃圾回收，读取候选区域的所有数据，识别冷数据，将它们合并到一个区域，同时将剩余数据合并到另一个区域。</li>
</ul>
<p>以下是<code>LSM_ZGC</code>的优点：</p>
<ul>
<li>采用基于段<code>segment</code>（而不是基于区域<code>zone</code>）的方式，有利于冷热数据分割，并可以用流水线的方式实现策略。</li>
<li>读取段中所有有效和无效的数据，可以通过利用区域中的内部并行性来减少垃圾收集开销。</li>
<li>将冷热数据放入不同的区域，可以增加找到利用率较低的区域的机会。</li>
</ul>
<p>在<code>ZNS SSD</code>的垃圾回收策略中，最简单的方式<code>Basic_ZGC</code>是：</p>
<ul>
<li>选择一个利用率最低的区域。</li>
<li>读取该区域中有效数据块并将它们写入新的区域中去。</li>
<li>最后通过<code>reset command</code>重置选择的块。</li>
</ul>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-14%2015.26.30.png" alt="截屏2023-11-14 15.26.30"></p>
<p>而<code>LSM_ZGC</code>的策略有三个不同之处：</p>
<ul>
<li><p>对于一个区域<code>zone</code>的垃圾回收会在段<code>segment</code>上实现。此外，它允许使用细粒度段单元执行区域垃圾收集，其中可以以管道方式读取、合并和写入段。</p>
</li>
<li><p>在垃圾回收阶段，它以<code>128KB</code>大小<code>IO</code>，不仅读取有效块，也读取无效块，而<code>Basic_ZGC</code>只读取有效块。</p>
<blockquote>
<p>读取所有快的原因是，我们在Figure 2中观察到，<code>in group manner</code>利用芯片的并行性提高读取速度。</p>
<p>因此当块数量大于16时，我们采取全部读取的方式。（由于16个128KB大小的请求可以覆盖整个2MB的段数据，它会读取所有块。）</p>
</blockquote>
</li>
<li><p><code>LSM_ZGC</code>通过鉴别冷数据<code>cold data</code>，并将冷数据合并到一个单独的区域中。</p>
<p>为了到达这个目的，我们定义四种区域的状态：</p>
<ul>
<li><p><code>C0_zone</code></p>
</li>
<li><p><code>C1C_zone</code>：</p>
<blockquote>
<p>我们将利用率高于阈值的段（称为门槛冷）定义为冷。这一决定基于我们的观察，即具有相似寿命的数据显示出强大的空间局部性。<br>可能的原因：段中大部分空间被占用通常意味着其中的数据已经稳定下来，且变动不大。</p>
</blockquote>
</li>
<li><p><code>C1H_zone</code></p>
</li>
<li><p><code>C2_zone</code></p>
</li>
</ul>
<p>新到达的数据按顺序写入状态为<code>C0</code>区域的区域，删除的数据将离开图中所示的状态。</p>
<ul>
<li><p>将冷数据写入<code>C1C_zone</code>。</p>
</li>
<li><p>将其他数据写入<code>C1H_zone</code>中。</p>
</li>
</ul>
<p>而当要回收的区域状态是<code>C1C_zone</code>或者<code>C1H_zone</code>时，<code>LSM_ZGC</code>将读取所有段，并把所有有效块看作冷数据。这是因为这些有效块在连续两次垃圾回收操作后都被保留了。最后这些块中的数据会被写入<code>C2_zone</code>中。</p>
<p>我们预计这种机制能够将冷数据与其他数据隔离开来，从而增加在垃圾收集期间找到利用率较低的候选区的机会。</p>
</li>
</ul>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-14%2015.42.42.png" alt="截屏2023-11-14 15.42.42"></p>
<h1 id="InDeF-An-Advanced-Defragmenter-Supporting-Migration-Offloading-on-ZNS-SSD"><a href="#InDeF-An-Advanced-Defragmenter-Supporting-Migration-Offloading-on-ZNS-SSD" class="headerlink" title="InDeF: An Advanced Defragmenter Supporting Migration Offloading on ZNS SSD"></a>InDeF: An Advanced Defragmenter Supporting Migration Offloading on ZNS SSD</h1><h2 id="Problem-to-be-solved-2"><a href="#Problem-to-be-solved-2" class="headerlink" title="Problem to be solved"></a>Problem to be solved</h2><p><code>ZNS SSD</code>由于其不恰当的更新和应用程序的多线程写作行为，它脆弱地能够碎片化。</p>
<blockquote>
<p>碎片化是指<code>SSD</code>中的数据不是连续存储在<code>SSD</code>上的，而是分散到不同的区域。</p>
</blockquote>
<p>由于碎片化，<code>I/O</code>请求会被分割（要读取不同的区域，所以将一个<code>I/O</code>分割成多个的<code>I/O</code>）。</p>
<blockquote>
<p>为什么说<code>ZNS SSD</code>更容易碎片化？</p>
<p>由于<code>ZNS SSD</code>的顺序写特性，访存需要使用一种<code>log-structured file system (LFS)</code>，如<code>F2FS</code>。</p>
</blockquote>
<p>传统的<code>Defragmentation tool</code>有如下缺点：</p>
<ul>
<li><p>由于大多数<code>Defragmentation tool</code>是为传统<code>SSD</code>设计的，它们无法处理物理碎片（这是因为传统SSD不会将物理地址暴露给主机）。而<code>ZNS SSD</code>将逻辑地址组织成一个个区域，且区域与物理介质的边界对齐。因此，我们可以通过这种特性在主机端判断物理碎片化。</p>
</li>
<li><p>传统的碎片整理工具<code>defragmentation tool</code>，如<code>defrag.f2fs</code>，在整理碎片时的开销很大。</p>
<blockquote>
<p>这是因为<code>defrag.f2fs</code>会把底层设备的所有内容读入主机内存中去，然后再将数据写入设备中的连续空间。这会导致大量的<code>I/O</code>开销。</p>
</blockquote>
</li>
<li><p>并且对于不熟悉系统编程的用户来说，使用这样的工具<code>defrag.f2fs</code>是困难的。</p>
</li>
<li><p>闪存设备的擦除次数有限，过多的数据迁移会降低<code>ZNS SSD</code>的寿命。</p>
</li>
<li><p>碎片整理会消耗大量的时间，且会降低前端应用的性能（由于额外的<code>I/O</code>操作）</p>
</li>
</ul>
<h2 id="How-to-find-these-problems"><a href="#How-to-find-these-problems" class="headerlink" title="How to find these problems?"></a>How to find these problems?</h2><ul>
<li><p><strong>在多线程模式的工作负荷下，数据读取的吞吐量显著降低，如图1所示：</strong></p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2010.19.07.png" alt="截屏2023-11-15 10.19.07"></p>
<ul>
<li><p><strong>I&#x2F;O请求碎片化的定义:</strong><br>由于文件系统的碎片化和闪存<code>SSD</code>的内部操作，一部分访存数据的分布变得更加随机，导致内部资源的冲突。</p>
<p>我们定义<code>I/O</code>请求的逻辑碎片<code>logical fragmentation</code>和物理碎片<code>physical fragmentation</code>，如图2所示：</p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2010.27.43.png" alt="截屏2023-11-15 10.27.43"></p>
</li>
</ul>
</li>
<li><p>**<code>Request splitting</code>**：由于碎片数据的逻辑地址不连续，向碎片数据发出的大型顺序I&#x2F;O被拆分为多个小型随机I&#x2F;O。</p>
</li>
<li><p>**<code>DoLF</code>**：<code>degree of logical fragmentation</code>，一个<code>I/O</code>范围中的逻辑碎片的数量。</p>
</li>
<li><p>**<code>DoPF</code>**：<code>degree of physical fragmentation</code>， 我们通过I&#x2F;O范围内的数据在闪存并行单元之间的均匀分布来衡量I&#x2F;O请求的物理碎片程度。</p>
<blockquote>
<p>这是因为在<code>SSD</code>中，物理碎片的定义和在磁盘上的不同（物理地址上连续），这是因为<code>SSD</code>上的芯片可以被并行的访问。如图2所示，我们把具有相同偏移量（即只能被同一芯片顺序访问的地址定义为物理碎片）。</p>
</blockquote>
<p>$$<br>DoPF &#x3D; \frac{\sum_{i&#x3D;1}^{L} \left(N_i - \frac{M}{L}\right)^2}{L}<br>$$</p>
<ul>
<li><code>M</code>：<code>I/O</code>请求访问的数据块的数量</li>
<li><code>L</code>：闪存的并行芯片数量</li>
<li><code>N_i</code>：<code>N</code>表示位于<code>i</code>平行单元（平行芯片）的数据块数量</li>
</ul>
<p>综上，较大的<code>DoPF</code>表明物理碎片程度较高，<code>I/O</code>并行程度较低。</p>
</li>
<li><p><strong>物理碎片和逻辑碎片对<code>I/O</code>性能的影响</strong></p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2011.03.09.png" alt="截屏2023-11-15 11.03.09"></p>
</li>
</ul>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2011.03.57.png" alt="截屏2023-11-15 11.03.57"></p>
<blockquote>
<p><strong>当芯片数量少于6个时，I&#x2F;O并行性对I&#x2F;O性能有显著影响，DoPF值显著增加，而I&#x2F;O性能大幅下降。然而，当DoPF值较小时，例如小于40，物理碎片化对I&#x2F;O性能的影响可以忽略不计。这是因为当I&#x2F;O的物理并行度超过一定程度时，软件开销主导了总的I&#x2F;O延迟。</strong></p>
</blockquote>
<ul>
<li><strong>如何寻找合适的碎片进行处理？</strong></li>
</ul>
<blockquote>
<p>碎片化程度低或很少访问的冷数据碎片整理数据几乎没有性能提升。</p>
</blockquote>
<p>​	<code>IODP</code>，<code>I/O data defragmentation priority</code>:<br>$$<br>IODP &#x3D; (\alpha \cdot DoLF + \beta \cdot DoPF) \times \text{readcount}<br>$$</p>
<ul>
<li><p><strong>传统固态硬盘碎片处理时的开销</strong></p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2011.20.51.png" alt="截屏2023-11-15 11.20.51"></p>
<ul>
<li><p>内存页面分配</p>
</li>
<li><p>读数据</p>
<blockquote>
<p>对内存的大量读取可能会导致主机内存使用量显著增加，并调用页面帧回收</p>
</blockquote>
</li>
<li><p>分配连续空间</p>
</li>
<li><p>写数据</p>
<blockquote>
<p>其次，在将所有目标数据读入页面缓存之前，defrag.f2fs分配一个连续的可用空间，并按顺序将所有数据写入SSD，从而导致SSD中的芯片空闲间隔很大。</p>
</blockquote>
</li>
<li><p>元数据<code>metadata</code>更新</p>
</li>
</ul>
</li>
</ul>
<h2 id="Approaches-2"><a href="#Approaches-2" class="headerlink" title="Approaches"></a>Approaches</h2><p><code>InDeF</code>的两个目标：</p>
<ul>
<li><p>一个是尽量减少用于碎片整理的迁移数据量，以减少底层设备的写入流量。</p>
</li>
<li><p>另一个是利用ZENS SSD的内部并行性来减少碎片整理的时间。</p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2011.34.18.png" alt="截屏2023-11-15 11.34.18"></p>
<ul>
<li><p><em>Fagmentation Information Management Module</em>：</p>
<ul>
<li><p>I&#x2F;O Monitor. 通过<code>I/O</code>访问的文件的<code>inode</code>确定文件块的范围</p>
</li>
<li><p>I&#x2F;O Information Management：</p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2017.08.59.png" alt="截屏2023-11-15 17.08.59"></p>
</li>
<li><p>Fagmentation Information Management.</p>
</li>
</ul>
</li>
<li><p><em>Fragmentation Calculation Module</em></p>
<ul>
<li><p>Zone Mapping in ZNS SSD</p>
<p><code>F2FS</code>通常使用<code>2MB</code>大小的段管理逻辑地址空间，图八中是区域映射到闪存块的例子：</p>
<p>图中<code>ZNS SSD</code>有四个并行芯片，一个逻辑块对应一个物理闪存页。</p>
<p>一个区域对应<code>F2FS</code>的两个连续的段。</p>
<p>根据区域大小，物理区域由一组分布在并行芯片中的块组成。</p>
<p>物理区域中的页面以交错的方式放置在不同的芯片中。</p>
<p>这样的方式能完全利用闪存操作的并行性。</p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2017.15.40.png" alt="截屏2023-11-15 17.15.40"></p>
</li>
<li><p>Calculating the degree of Fragmentation</p>
<p>首先将<code>I/O</code>范围内的文件块索引转换为文件的物理块地址。</p>
<p><code>DoLF</code>由逻辑块碎片计算。</p>
<p><code>DoPF</code>由物理块碎片计算。</p>
<p>图9是计算碎片化程度的一个例子</p>
<p>通过文件到存储的映射表，将文件<code>inode</code>中的索引号转换为文件系统的逻辑块地址。</p>
<ul>
<li><code>(32, 48, 3)</code>分别表示起始索引，结束索引，和读计数<code>read count</code></li>
<li><code>Inode# = 7</code>表示文件7</li>
</ul>
<p>索引对应了16个文件系统块。</p>
<p>我们会发现有在<code>File-system Block</code>，也就是所谓的逻辑块中，有6组碎片。所以<code>DoLF = 6</code></p>
<p>对于物理碎片，我们首先需要通过段号和段内偏移量获取闪存设备中每个逻辑块的位置。</p>
<p>例如，对于逻辑块<code>801</code>我们首先计算<code>In-segment offset = 801 - 800 = 1</code></p>
<p><code>1 mode 4 = 1</code>，现在我们知道逻辑块<code>801</code>会在芯片1上被处理。</p>
<p>最终，我们通过计算可以得到<code>DoPF</code>的值为2.5。</p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2018.52.28.png" alt="截屏2023-11-15 18.52.28"></p>
</li>
</ul>
</li>
<li><p>Defragmentation Module</p>
<p>选择需要迁移的数据过滤掉对<code>I/O</code>性能影响不大的碎片。</p>
<p>其次，毗连空间分配从该区域分配毗连的自由空间。</p>
<p>第三，主机的数据迁移任务被卸载到SSD。</p>
<p>最后，文件系统会保留迁移数据的元数据块。</p>
<p><img src="/../images/ZNSSSDliterature/%E6%88%AA%E5%B1%8F2023-11-15%2019.15.20.png" alt="截屏2023-11-15 19.15.20"></p>
<ul>
<li><p>Fragments filter.</p>
</li>
<li><p>Migration offloading.</p>
<ul>
<li><p>Command generating</p>
<p>InDeF将源数据分为两组，其中一组需要从主机内存传输到设备，另一组通过迁移卸载进行处理。</p>
<blockquote>
<p>这是因为：对于I&#x2F;O范围内的每个块，首先要检查它是否缓存在页面缓存中。如果它已经被缓存并且页面很脏，则需要将该块排除在迁移卸载之外，并从内存写入设备。如果缓存的页面干净或未缓存，则可以通过迁移卸载在内部复制。</p>
</blockquote>
</li>
<li><p>Command sending:</p>
<p> <code>In_Device_Defragment</code> 命令实现存储内数据迁移</p>
<blockquote>
<p>它包含一组源LBA和一组目标LBA。该命令非常高效，因为每个4KB逻辑块被两个4字节块地址替换。</p>
</blockquote>
</li>
<li><p>Command processing:</p>
<p>SSD内部控制器根据区域的写入策略处理迁移卸载和主机请求。</p>
<ul>
<li><p>如果源块和目标块属于同一芯片，则使用<code>copyback</code>命令在芯片内进行传输。</p>
</li>
<li><p>否则，先将数据块读入<code>SSD</code>中的<code>DRAM</code>，再写到目标位置。</p>
<blockquote>
<p>即使是对迁移卸载数据的读取请求，它们也可以通过SSD上的DRAM或闪存芯片正常处理。由于异地更新策略，对迁移卸载数据的写入请求不受影响。最后，文件系统会保留迁移到设备的数据的元数据块。F2FS实施检查点以提供一致的恢复点。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Slides"><a href="#Slides" class="headerlink" title="Slides:"></a>Slides:</h1><iframe src="../../../../pdf_file/ZNS00/ZNS_11.18.pdf" style="width:100%; height:800px;" frameborder="0"></iframe>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/11/ZNSLinuxKernelSupport/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/11/ZNSLinuxKernelSupport/" class="post-title-link" itemprop="url">ZNSLinuxKernelSupport</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-11 12:01:17" itemprop="dateCreated datePublished" datetime="2023-11-11T12:01:17+08:00">2023-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-16 13:16:53" itemprop="dateModified" datetime="2023-11-16T13:16:53+08:00">2023-11-16</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux-Zoned-Storage-Support-Overview"><a href="#Linux-Zoned-Storage-Support-Overview" class="headerlink" title="Linux Zoned Storage Support Overview"></a>Linux Zoned Storage Support Overview</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>​	应用程序开发者可以通过多种 I&#x2F;O 路径使用分区块设备，可以用不同的编程接口来控制它们，并且可以以不同的方式暴露分区块设备。下面的图表简单表示了各种访问路径。</p>
<blockquote>
<ul>
<li><code>POSIX</code>：<code>Portable Operating System Interface</code>，它是一系列 IEEE 标准，旨在确保不同操作系统之间的兼容性。</li>
</ul>
</blockquote>
<p><img src="/../images/ZNSLinuxKernelSupport/%E6%88%AA%E5%B1%8F2023-11-11%2013.15.44.png" alt="截屏2023-11-11 13.15.44"></p>
<ul>
<li><code>File Access Interface</code>：文件访问接口。上图中<code>Legacy Application</code>有两种文件访问方式：<ul>
<li><code>ZBD Compliant File System</code>：文件系统被修改，可以将随机写转换为适合<code>Zoned Block Devices</code>的顺序写。例如，<code>F2FS</code>。</li>
<li><code>Legacy File System</code>：文件系统未经修改，设备的顺序写入限制由一个设备映射器目标处理器<code>dm-zoned</code>处理。</li>
</ul>
</li>
<li><code>Raw Block Access Interface</code>：应用程序直接访问设备上的数据，该接口类似于<code>legacy File System</code>，使用<code>dm-zoned</code>设备映射器目标驱动实现的，以便对应用程序隐藏顺序写入的限制。</li>
</ul>
<p>​	为遵守分区块设备的顺序写入约束而编写或修改的应用程序可以使用三个额外的接口。这些接口直接将设备约束暴露给应用程序，这些应用程序必须确保数据使用从区域的写入指针位置开始的顺序流进行写入。</p>
<ul>
<li><code>File Access Interface</code>：该接口专门适配<a target="_blank" rel="noopener" href="https://zonedstorage.io/docs/linux/fs#zonefs"><code>zonefs</code></a>文件系统。该文件系统将<code>zoned block device</code>的每一个<code>zone</code>作为一个文件。但有所不同的是，设备中的顺序写不由<code>zonefs</code>管理，区域的顺序写应交给上层的应用程序负责。</li>
<li><code>Zoned Raw Block Access Interface</code>：该接口没有任何中间驱动来处理设备限制。应用程序可以直接打开分区块设备的设备文件来使用这个接口，以获取对区块信息和块层提供的管理操作的访问。</li>
<li><code>Passthrough Device Access Interface</code>：该接口由<code>SCSI</code>通用驱动<code>SG</code>和<code>NVMe</code>驱动提供，它允许应用程序直接向设备发送<code>SCSI</code>和<code>NVMe</code>命令。在这个接口中，内核对应用程序发送的命令干预非常小，这导致需要应用程序自己处理所有的设备限制（例如，逻辑和物理扇区大小，区域边界，命令超时，命令重试次数等）。如<code>libzbc</code>和<code>libnvme</code>这样的用户级库可以大大简化使用这个接口的应用程序的实现。</li>
</ul>
<h2 id="Kernel-Versions"><a href="#Kernel-Versions" class="headerlink" title="Kernel Versions"></a>Kernel Versions</h2><p><img src="/../images/ZNSLinuxKernelSupport/%E6%88%AA%E5%B1%8F2023-11-11%2014.07.43.png" alt="截屏2023-11-11 14.07.43"></p>
<ul>
<li><code>Passthrough Access Support (SG Access)</code>：内核支持通过<code>SCSI</code>通用<code>(SG)</code>接口访问主机管理的<code>ZBC/ZAC</code>硬盘。对于符合条件的 SCSI 硬盘或连接到兼容 SAS HBA 的 SATA 硬盘，用户可以通过 SG 驱动创建的节点文件来访问这些主机管理的磁盘。这允许用户通过 SG 接口与这些磁盘交互。</li>
<li><code>Zoned Block Device Access and F2FS Support</code>：4.10以后的内核支持主机以管理常规磁盘的方式将ZBC&#x2F;ZAC<code>磁盘当作block device files</code>管理。</li>
<li><code>Device Mapper and dm-zoned Support</code>：在内核4.13.0中，对分区块设备的支持被添加到了设备映射器基础架构中。这项支持允许在分区块设备之上使用 dm-linear 和 dm-flakey 设备映射器目标。此外，还添加了 dm-zoned 设备映射器目标驱动程序。</li>
<li><code>Block multi-queue and SCSI multi-queue Support</code>：支持块多队列和SCSI多队列。</li>
<li><code>zonefs</code>：支持<code>zonefs file system</code>，将分区块设备的区域作为常规文件暴露出来，支持所有类型的分区块设备。</li>
<li><code>Zone Append Operation Support</code>：追加写操作。</li>
<li><code>NVM Express Zoned Namespaces</code>：支持<code>NVMe ZNS</code>命令集。</li>
</ul>
<h1 id="Kernel-Configuration"><a href="#Kernel-Configuration" class="headerlink" title="Kernel Configuration"></a>Kernel Configuration</h1><p>内核中一些关于zoned block device 的配置</p>
<h2 id="Block-Layer"><a href="#Block-Layer" class="headerlink" title="Block Layer"></a>Block Layer</h2><h3 id="Zoned-Block-Devices-Core-Support"><a href="#Zoned-Block-Devices-Core-Support" class="headerlink" title="Zoned Block Devices Core Support"></a>Zoned Block Devices Core Support</h3><p>通过make menuconfig 打开Linux配置菜单，选择 <code>Zoned block device support</code>。</p>
<h3 id="Write-Ordering-Control"><a href="#Write-Ordering-Control" class="headerlink" title="Write Ordering Control"></a>Write Ordering Control</h3><p>​	写入顺序控制通过<code>deadline</code>（遗留的单队列块I&#x2F;O路径）和mq-deadkine（多队列块I&#x2F;O路径）块 I&#x2F;O 调度器实现的（见写入顺序控制）。如果设置了 CONFIG_BLK_DEV_ZONED 配置选项，则自动启用 deadline 和 mq-deadline 分区块设备支持。</p>
<p>​	对于分区块设备，启用这个调度器是必须的。配置选项 CONFIG_MQ_IOSCHED_DEADLINE 启用 mq-deadline 调度器。配置选项 CONFIG_IOSCHED_DEADLINE 启用 deadline 调度器。这两个选项都可以从 IO 调度器顶级菜单中选择。</p>
<p>​	不过在后续的版本中，<code>CONFIG_MQ_IOSCHED_DEADLINE</code>会随着<code>CONFIG_BLK_DEV_ZONED</code>配置而配置。</p>
<h2 id="Device-Drivers-Configuration"><a href="#Device-Drivers-Configuration" class="headerlink" title="Device Drivers Configuration"></a>Device Drivers Configuration</h2><ul>
<li><code>null_blk</code> Logic Device</li>
<li><code>ZBC</code> and &#96;ZAC Hard-Disks Support</li>
<li><code>NVMe Zoned Namespace Solid State Disks Support</code></li>
</ul>
<h2 id="Device-Mapper"><a href="#Device-Mapper" class="headerlink" title="Device Mapper"></a>Device Mapper</h2><p>设置了 CONFIG_BLK_DEV_ZONED 选项时，设备映射器子系统对分区块设备的支持会自动启用。这使得 dm-linear 和 dm-flakey 目标得到支持。请注意，必须启用 dm-zoned 设备映射器目标才能使用。</p>
<p>通过在菜单“设备驱动程序 –&gt; 多设备驱动支持（RAID 和 LVM）–&gt; 设备映射器支持 –&gt; 驱动管理的分区块设备目标支持”中选择 CONFIG_DM_ZONED 选项来启用 dm-zoned 目标。</p>
<h2 id="File-Systems"><a href="#File-Systems" class="headerlink" title="File Systems"></a>File Systems</h2><h3 id="F2fs"><a href="#F2fs" class="headerlink" title="F2fs"></a>F2fs</h3><p>当<code>CONFIG_BLK_DEV_ZONED</code>配置时，<code>f2fs file system</code>也自动被配置。</p>
<h3 id="zonefs"><a href="#zonefs" class="headerlink" title="zonefs"></a>zonefs</h3><p>这个要在 <code>menu File system -&gt; zonefs</code>中手动配置</p>
<h3 id="Kernel-Installation"><a href="#Kernel-Installation" class="headerlink" title="Kernel Installation"></a>Kernel Installation</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo make modules_install install</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo make headers_install</span><br></pre></td></tr></table></figure>

<h1 id="Zoned-Block-Device-user-Interface"><a href="#Zoned-Block-Device-user-Interface" class="headerlink" title="Zoned Block Device user Interface"></a>Zoned Block Device user Interface</h1><p>用户程序可以通过两种接口访问<code>zone information</code>和管理<code>zoned block device</code>中的<code>zones</code></p>
<ol>
<li><code>sysfs attribute files</code>：可以直接作为常规文件由应用程序访问，或者通过脚本语言访问。</li>
<li><code>ioctl() system call</code>：适用于从 C 程序或其他具有等效系统调用绑定的编程语言中使用。</li>
</ol>
<h2 id="Sysfs-Interface"><a href="#Sysfs-Interface" class="headerlink" title="Sysfs Interface"></a>Sysfs Interface</h2><table>
<thead>
<tr>
<th align="center">File</th>
<th>Kernel version</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x2F;sys&#x2F;block&#x2F;<em>dev name</em>&#x2F;queue&#x2F;zoned</td>
<td>4.10.0</td>
<td>Device zoned model</td>
</tr>
<tr>
<td align="center">&#x2F;sys&#x2F;block&#x2F;<em>dev name</em>&#x2F;queue&#x2F;chunk_sectors</td>
<td>4.10.0</td>
<td>Device zone size</td>
</tr>
<tr>
<td align="center">&#x2F;sys&#x2F;block&#x2F;<em>dev name</em>&#x2F;queue&#x2F;nr_zones</td>
<td>4.20.0</td>
<td>Total number of zones</td>
</tr>
<tr>
<td align="center">&#x2F;sys&#x2F;block&#x2F;<em>dev name</em>&#x2F;queue&#x2F;zone_append_max_bytes</td>
<td>5.8.0</td>
<td>Maximum size in bytes of a zone append write operation</td>
</tr>
<tr>
<td align="center">&#x2F;sys&#x2F;block&#x2F;<em>dev name</em>&#x2F;queue&#x2F;max_open_zones</td>
<td>5.9.0</td>
<td>Maximum number of open zones</td>
</tr>
<tr>
<td align="center">&#x2F;sys&#x2F;block&#x2F;<em>dev name</em>&#x2F;queue&#x2F;max_active_zones</td>
<td>5.9.0</td>
<td>Maximum number of active zones</td>
</tr>
</tbody></table>
<h3 id="Device-Zoned-Model"><a href="#Device-Zoned-Model" class="headerlink" title="Device Zoned Model"></a>Device Zoned Model</h3><p><code>zone model</code>（<code>host-managed</code>和<code>host-awared</code>）可以通过<code>zoned</code>设备队列 查看，例如，如果一个<code>zoned block device</code>叫做<code>sdb</code>，则通过命令查看模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /sys/block/sdb/queue/zoned</span></span><br><span class="line">host-managed</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>Regular block device, including drive-managed SMR disks</td>
</tr>
<tr>
<td>host-aware</td>
<td>Host-aware device model</td>
</tr>
<tr>
<td>host-managed</td>
<td>Host-managed device model</td>
</tr>
</tbody></table>
<h3 id="Zone-Size"><a href="#Zone-Size" class="headerlink" title="Zone Size"></a>Zone Size</h3><p>设备的区域大小<code>zone size</code>可以从<code>sysfs</code>队列属性文件读取，命令如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /sys/block/sdb/queue/chunk_sectors</span></span><br><span class="line">524288</span><br></pre></td></tr></table></figure>

<p>该值以512字节扇区的数量显示，不论设备的实际逻辑和物理大小如何。在上文中，设备分区的大小为<code>524288 * 512 = 256 MB</code></p>
<h3 id="Number-of-Zones"><a href="#Number-of-Zones" class="headerlink" title="Number of Zones"></a>Number of Zones</h3><p>同样，<code>zoned device</code>的<code>zones</code>的数量可以通过如下命令获取</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /sys/block/sdb/queue/nr_zones</span></span><br><span class="line">55880</span><br></pre></td></tr></table></figure>

<p>对于普通块设备，这个参数为0。</p>
<h3 id="Zone-Resources"><a href="#Zone-Resources" class="headerlink" title="Zone Resources"></a>Zone Resources</h3><p>设备区域资源可以从<code>sysfs queue</code>参数文件中读取，分别是<code>max_open_zones</code>和<code>max_active_zones</code>。</p>
<p>命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /sys/block/sdb/queue/max_open_zones</span></span><br><span class="line">128</span><br></pre></td></tr></table></figure>

<p>该命令给出了能被显示或者隐示打开的<code>zones</code>的数量为<code>128</code>。如果为0，则表示设备没有限制最大zones的打开数量。</p>
<p>接下来的命令给出了<code>zones</code>是<code>active</code>状态<code>(open or closed state)</code>的最大数量，同上，0表示没有限制：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /sys/block/sdb/queue/max_active_zones</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>当我们通过<code>null_blk</code>,<code>QEMU</code>,或者<code>tcmu-runner</code>模拟一个<code>zoned device</code>，以上参数是可以被人工设置的。</p>
<h2 id="ioctl-Application-Programming-Interface"><a href="#ioctl-Application-Programming-Interface" class="headerlink" title="ioctl() Application Programming Interface"></a><em>ioctl()</em> Application Programming Interface</h2><p>用户可以通过头文件<del>&#x2F;usr&#x2F;include&#x2F;linux&#x2F;blkzoned.h</del>，在kernel 5.10中，头文件在<code>include/uapi/linux/blkzone.h</code>，中定义的宏和数据结构获取<code>zoned block device</code>的信息并管理他们。</p>
<h3 id="Zone-Information-Data-Structures"><a href="#Zone-Information-Data-Structures" class="headerlink" title="Zone Information Data Structures"></a>Zone Information Data Structures</h3><p><code>struct blk_zone</code>定义了一个<code>zone-descriptor</code>结构，该结构包含了zone的所有描述。</p>
<ul>
<li><code>zone&#39;s location on device</code></li>
<li><code>zone type</code></li>
<li><code>zone state</code></li>
<li><code>position of zone write pointer</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct blk_zone - Zone descriptor for BLKREPORTZONE ioctl.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @start: Zone start in 512 B sector units </span></span><br><span class="line"><span class="comment"> * @len: Zone length in 512 B sector units</span></span><br><span class="line"><span class="comment"> * @wp: Zone write pointer location in 512 B sector units</span></span><br><span class="line"><span class="comment"> * @type: see enum blk_zone_type for possible values</span></span><br><span class="line"><span class="comment"> * @cond: see enum blk_zone_cond for possible values</span></span><br><span class="line"><span class="comment"> * @non_seq: Flag indicating that the zone is using non-sequential resources</span></span><br><span class="line"><span class="comment"> *           (for host-aware zoned block devices only).</span></span><br><span class="line"><span class="comment"> * @reset: Flag indicating that a zone reset is recommended.</span></span><br><span class="line"><span class="comment"> * @resv: Padding for 8B alignment.</span></span><br><span class="line"><span class="comment"> * @capacity: Zone usable capacity in 512 B sector units</span></span><br><span class="line"><span class="comment"> * @reserved: Padding to 64 B to match the ZBC, ZAC and ZNS defined zone</span></span><br><span class="line"><span class="comment"> *            descriptor size.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * start, len, capacity and wp use the regular 512 B sector unit, regardless</span></span><br><span class="line"><span class="comment"> * of the device logical block size. The overall structure size is 64 B to</span></span><br><span class="line"><span class="comment"> * match the ZBC, ZAC and ZNS defined zone descriptor and allow support for</span></span><br><span class="line"><span class="comment"> * future additional zone information.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_zone</span> &#123;</span></span><br><span class="line">	__u64	start;		<span class="comment">/* 分区的起始扇区。这是一个64位无符号整数，表示分区在存储设备上的起始位置，以512字节的扇区为单位计量。 */</span></span><br><span class="line">	__u64	len;		<span class="comment">/* 分区的长度，用扇区的数量表示。这同样是一个64位无符号整数，指示该分区包含多少个512字节的扇区。 */</span></span><br><span class="line">	__u64	wp;		<span class="comment">/* 分区的写入指针位置。这个值指示当前可写入数据的位置，在存储设备中也是以512字节扇区为单位表示。 */</span></span><br><span class="line">	__u8	type;		<span class="comment">/* 分区的类型。这是一个8位无符号整数，其值根据 enum blk_zone_type 中定义的类型来确定，比如常规分区、顺序写入分区等。 */</span></span><br><span class="line">	__u8	cond;		<span class="comment">/* 分区的状态。这个字段根据 enum blk_zone_cond 定义的值来确定分区的当前状态，例如空闲、满、只读等。*/</span></span><br><span class="line">	__u8	non_seq;	<span class="comment">/* 非顺序写入资源的标志。这是一个8位的标志位，用于指示该分区是否使用了非顺序写入资源，这通常仅适用于主动感知分区的块设备。 */</span></span><br><span class="line">	__u8	reset;		<span class="comment">/* 重置写入指针的推荐标志。这个字段表示是否推荐对该分区执行写入指针重置操作。 */</span></span><br><span class="line">	__u8	resv[<span class="number">4</span>];	<span class="comment">/*	 为了实现8字节对齐而设置的保留字段。	*/</span></span><br><span class="line">	__u64	capacity;	<span class="comment">/* 分区的可用容量，以512字节扇区为单位计量。*/</span></span><br><span class="line">	__u8	reserved[<span class="number">24</span>]; <span class="comment">/* 额外的保留字段，用来填充结构体大小，以确保整个结构体与 ZBC（Zoned Block Commands）、ZAC（Zoned ATA Commands）和 ZNS（Zoned Namespace）定义的分区描述符大小相匹配，即64字节。	*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	正如这个数据结构定义中的注释所指出的，用来表示（1）分区的起始位置、（2）分区的大小和（3）写入指针位置的单位是‘512字节的扇区大小’。这一点不受设备实际逻辑块大小的影响。即使是具有4KB逻辑扇区的设备，上述分区描述符字段也使用512字节扇区大小单位。”</p>
<h3 id="Zone-Type"><a href="#Zone-Type" class="headerlink" title="Zone Type"></a>Zone Type</h3><p>一个zone的discriptor只有一种类别：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * enum blk_zone_type - Types of zones allowed in a zoned device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_TYPE_CONVENTIONAL: The zone has no write pointer and can be writen</span></span><br><span class="line"><span class="comment"> *                              randomly. Zone reset has no effect on the zone.</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_TYPE_SEQWRITE_REQ: The zone must be written sequentially</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_TYPE_SEQWRITE_PREF: The zone can be written non-sequentially</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Any other value not defined is reserved and must be considered as invalid.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">blk_zone_type</span> &#123;</span></span><br><span class="line">	BLK_ZONE_TYPE_CONVENTIONAL	= <span class="number">0x1</span>,</span><br><span class="line">	BLK_ZONE_TYPE_SEQWRITE_REQ	= <span class="number">0x2</span>,</span><br><span class="line">	BLK_ZONE_TYPE_SEQWRITE_PREF	= <span class="number">0x3</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Zone-Condition"><a href="#Zone-Condition" class="headerlink" title="Zone Condition"></a>Zone Condition</h3><p>每个zone也只有一种状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * enum blk_zone_cond - Condition [state] of a zone in a zoned device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_COND_NOT_WP: The zone has no write pointer, it is conventional.</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_COND_EMPTY: The zone is empty.</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_COND_IMP_OPEN: The zone is open, but not explicitly opened.</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_COND_EXP_OPEN: The zones was explicitly opened by an</span></span><br><span class="line"><span class="comment"> *                          OPEN ZONE command.</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_COND_CLOSED: The zone was [explicitly] closed after writing.</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_COND_FULL: The zone is marked as full, possibly by a zone</span></span><br><span class="line"><span class="comment"> *                      FINISH ZONE command.</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_COND_READONLY: The zone is read-only.</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_COND_OFFLINE: The zone is offline (sectors cannot be read/written).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The Zone Condition state machine in the ZBC/ZAC standards maps the above</span></span><br><span class="line"><span class="comment"> * deinitions as:</span></span><br><span class="line"><span class="comment"> *   - ZC1: Empty         | BLK_ZONE_COND_EMPTY</span></span><br><span class="line"><span class="comment"> *   - ZC2: Implicit Open | BLK_ZONE_COND_IMP_OPEN</span></span><br><span class="line"><span class="comment"> *   - ZC3: Explicit Open | BLK_ZONE_COND_EXP_OPEN</span></span><br><span class="line"><span class="comment"> *   - ZC4: Closed        | BLK_ZONE_COND_CLOSED</span></span><br><span class="line"><span class="comment"> *   - ZC5: Full          | BLK_ZONE_COND_FULL</span></span><br><span class="line"><span class="comment"> *   - ZC6: Read Only     | BLK_ZONE_COND_READONLY</span></span><br><span class="line"><span class="comment"> *   - ZC7: Offline       | BLK_ZONE_COND_OFFLINE</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Conditions 0x5 to 0xC are reserved by the current ZBC/ZAC spec and should</span></span><br><span class="line"><span class="comment"> * be considered invalid.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">blk_zone_cond</span> &#123;</span></span><br><span class="line">	BLK_ZONE_COND_NOT_WP	= <span class="number">0x0</span>,</span><br><span class="line">	BLK_ZONE_COND_EMPTY	= <span class="number">0x1</span>,</span><br><span class="line">	BLK_ZONE_COND_IMP_OPEN	= <span class="number">0x2</span>,</span><br><span class="line">	BLK_ZONE_COND_EXP_OPEN	= <span class="number">0x3</span>,</span><br><span class="line">	BLK_ZONE_COND_CLOSED	= <span class="number">0x4</span>,</span><br><span class="line">	BLK_ZONE_COND_READONLY	= <span class="number">0xD</span>,</span><br><span class="line">	BLK_ZONE_COND_FULL	= <span class="number">0xE</span>,</span><br><span class="line">	BLK_ZONE_COND_OFFLINE	= <span class="number">0xF</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，<code>BLK_ZONE_COND_OFFLINE</code>和<code>BLK_ZONE_COND_READONLY</code>只能被设备本身设置，用来指示因硬件缺陷而能力受限的分区。</p>
<p>用户操作可能导致状态的转变。使用内核<code>ioctl()</code>接口的应用程序可以发出分区管理命令。</p>
<blockquote>
<p>The SCSI Zoned Block Command specification (ZBC), the ATA Zoned Device ATA Command Set specification (ZAC) and the NVM Express Zoned Namespace Command Set specification (ZNS) define a zone condition state machine that governs the possible transitions of a zone from one condition to another depending on the commands executed.</p>
</blockquote>
<h3 id="ioctl-Commands"><a href="#ioctl-Commands" class="headerlink" title="ioctl() Commands"></a>ioctl() Commands</h3><p>下面是 ioctl()命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Zoned block device ioctl&#x27;s:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @BLKREPORTZONE: Get zone information. Takes a zone report as argument.</span></span><br><span class="line"><span class="comment"> *                 The zone report will start from the zone containing the</span></span><br><span class="line"><span class="comment"> *                 sector specified in the report request structure.</span></span><br><span class="line"><span class="comment"> * @BLKRESETZONE: Reset the write pointer of the zones in the specified</span></span><br><span class="line"><span class="comment"> *                sector range. The sector range must be zone aligned.</span></span><br><span class="line"><span class="comment"> * @BLKGETZONESZ: Get the device zone size in number of 512 B sectors.</span></span><br><span class="line"><span class="comment"> * @BLKGETNRZONES: Get the total number of zones of the device.</span></span><br><span class="line"><span class="comment"> * @BLKOPENZONE: Open the zones in the specified sector range.</span></span><br><span class="line"><span class="comment"> *               The 512 B sector range must be zone aligned.</span></span><br><span class="line"><span class="comment"> * @BLKCLOSEZONE: Close the zones in the specified sector range.</span></span><br><span class="line"><span class="comment"> *                The 512 B sector range must be zone aligned.</span></span><br><span class="line"><span class="comment"> * @BLKFINISHZONE: Mark the zones as full in the specified sector range.</span></span><br><span class="line"><span class="comment"> *                 The 512 B sector range must be zone aligned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLKREPORTZONE	_IOWR(0x12, 130, struct blk_zone_report)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLKRESETZONE	_IOW(0x12, 131, struct blk_zone_range)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLKGETZONESZ	_IOR(0x12, 132, __u32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLKGETNRZONES	_IOR(0x12, 133, __u32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLKOPENZONE	_IOW(0x12, 134, struct blk_zone_range)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLKCLOSEZONE	_IOW(0x12, 135, struct blk_zone_range)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLKFINISHZONE	_IOW(0x12, 136, struct blk_zone_range)</span></span><br></pre></td></tr></table></figure>

<p>以下是内核支持的命令：</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Kernel version</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>BLKREPORTZONE</td>
<td>4.10.0</td>
<td>Get zone information</td>
</tr>
<tr>
<td>BLKRESETZONE</td>
<td>4.10.0</td>
<td>Reset a zone write pointer</td>
</tr>
<tr>
<td>BLKGETZONESZ</td>
<td>4.20.0</td>
<td>Get a device zone size</td>
</tr>
<tr>
<td>BLKGETNRZONES</td>
<td>4.20.0</td>
<td>Get the total number of zones of a device</td>
</tr>
<tr>
<td>BLKOPENZONE</td>
<td>5.5.0</td>
<td>Explicitly open a zone</td>
</tr>
<tr>
<td>BLKCLOSEZONE</td>
<td>5.5.0</td>
<td>Close a zone</td>
</tr>
<tr>
<td>BLKFINISHZONE</td>
<td>5.5.0</td>
<td>Finish a zone</td>
</tr>
</tbody></table>
<h3 id="Obtaining-Zone-Information"><a href="#Obtaining-Zone-Information" class="headerlink" title="Obtaining Zone Information"></a>Obtaining Zone Information</h3><p><code>BLKREPORTZONE</code>命令允许应用以分区描述符数组的形式获取设备的分区消息，<code>struct blk_zone_report</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct blk_zone_report - BLKREPORTZONE ioctl request/reply</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @sector: starting sector of report</span></span><br><span class="line"><span class="comment"> * @nr_zones: IN maximum / OUT actual</span></span><br><span class="line"><span class="comment"> * @flags: one or more flags as defined by enum blk_zone_report_flags.</span></span><br><span class="line"><span class="comment"> * @zones: Space to hold @nr_zones @zones entries on reply.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The array of at most @nr_zones must follow this structure in memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_zone_report</span> &#123;</span></span><br><span class="line">	__u64		sector;</span><br><span class="line">	__u32		nr_zones;</span><br><span class="line">	__u8    reserved[<span class="number">4</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blk_zone</span> <span class="title">zones</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sector</code>：代表报告的起始扇区。指定分区报告应该从哪个扇区开始。</li>
<li><code>nr_zones</code>：作为输入，指定调用者希望检索信息的最大分区数。作为输出，表示设备响应<code>BLKREPORTZONE</code>命令后报告的实际分区数。</li>
<li><code>zones[0]</code>：这是一个灵活数组成员（由<code>[0]</code>表示），用于存储分区描述符。此数组中的元素数量由<code>nr_zones</code>指定。这个数组将包含设备返回的实际分区信息。数组中的每个元素都是<code>struct blk_zone</code>类型，其中包含了关于单个分区的详细信息。</li>
</ul>
<p>下面是一个简单的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/blkzoned.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> start_sector = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_zone_report</span> *<span class="title">hdr</span>;</span></span><br><span class="line"><span class="type">size_t</span> hdr_len;</span><br><span class="line"><span class="type">int</span> nr_zones = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 	文件头的长度 	*/</span></span><br><span class="line">hdr_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> blk_zone_report) + nr_zones * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> blkzone);</span><br><span class="line"><span class="comment">/* 	为文件头分配空间	 */</span></span><br><span class="line">hdr = <span class="built_in">malloc</span>(hdr_len);</span><br><span class="line"><span class="comment">/*	检查是否分配成功	*/</span></span><br><span class="line"><span class="keyword">if</span> (!hdr)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">/*	文件头的起始扇区	*/</span></span><br><span class="line">    hdr-&gt;sector = start_sector;</span><br><span class="line">    <span class="comment">/*	最大分区数	*/</span></span><br><span class="line">    hdr-&gt;nr_zones = nr_zones;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*	通过`ioctl`调用，使用BLKREPORTZONE命令获取分区信息	*/</span></span><br><span class="line">    ret = ioctl(fd, BLKREPORTZONE, hdr);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*	如果没有报告任何分区，结束	*/</span></span><br><span class="line">    <span class="keyword">if</span> (!hdr-&gt;nr_zones) &#123;</span><br><span class="line">        <span class="comment">/* Done */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got %u zone descriptors\n&quot;</span>, hdr-&gt;nr_zones);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The next report must start after the last zone reported */</span></span><br><span class="line">    <span class="comment">/*	更新 start_sector 以便下一次报告从上一次报告的最后一个分区之后的扇区开始	*/</span></span><br><span class="line">    start_sector = hdr-&gt;zones[hdr-&gt;nr_zones - <span class="number">1</span>].start +</span><br><span class="line">               hdr-&gt;zones[hdr-&gt;nr_zones - <span class="number">1</span>].len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>zone</code>描述符的数量存储在结构体<code>blk_zone_report</code>中的<code>nr_zones</code>并返回。 </p>
<p>在5.9内核中，定义有所不同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * enum blk_zone_report_flags - Feature flags of reported zone descriptors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @BLK_ZONE_REP_CAPACITY: Zone descriptor has capacity field.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">blk_zone_report_flags</span> &#123;</span></span><br><span class="line">	BLK_ZONE_REP_CAPACITY	= (<span class="number">1</span> &lt;&lt; <span class="number">0</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct blk_zone_report - BLKREPORTZONE ioctl request/reply</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @sector: starting sector of report</span></span><br><span class="line"><span class="comment"> * @nr_zones: IN maximum / OUT actual</span></span><br><span class="line"><span class="comment"> * @flags: one or more flags as defined by enum blk_zone_report_flags.</span></span><br><span class="line"><span class="comment"> * @zones: Space to hold @nr_zones @zones entries on reply.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The array of at most @nr_zones must follow this structure in memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_zone_report</span> &#123;</span></span><br><span class="line">    __u64       sector;</span><br><span class="line">    __u32       nr_zones;</span><br><span class="line">    __u32       flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_zone</span> <span class="title">zones</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>flags</code>：包含一个或者多个<code>blk_zone_report_flags</code>的枚举类，枚举量为<code>BLK_ZONE_REP_CAPACITY</code>，</p>
<p>如果该值为1，则<code>zone</code>描述符结构<code>blk_zone</code>体会设置<code>capacity</code>域可用。否则忽略该成员。</p>
<p>下面的代码实例展示应用程序如何通过<code>autotool</code>构建环境中检查特定头文件和结构体成员的存在：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># less configure.ac</span><br><span class="line">...</span><br><span class="line">AC_CHECK_HEADER(linux/blkzoned.h, [],</span><br><span class="line">                [AC_MSG_ERROR([Couldn&#x27;t find linux/blkzoned.h. Kernel too old ?])],</span><br><span class="line">                [[#include &lt;linux/blkzoned.h&gt;]])</span><br><span class="line"></span><br><span class="line">AC_CHECK_MEMBER([struct blk_zone.capacity],</span><br><span class="line">                [AC_DEFINE(HAVE_BLK_ZONE_REP_V2, [1], [report zones includes zone capacity])],</span><br><span class="line">                [], [[#include &lt;linux/blkzoned.h&gt;]])</span><br></pre></td></tr></table></figure>

<p>在一些较新的Linux内核版本中，特别是从5.9版本开始，增加了对分区容量信息的支持。这意味着内核可以提供每个分区的容量信息。对于这些内核，宏<code>HAVE_BLK_ZONE_REP_V2</code>被定义，它的应用如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Handle kernel zone capacity support</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HAVE_BLK_ZONE_REP_V2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLK_ZONE_REP_CAPACITY   (1 &lt;&lt; 0)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_zone_v2</span> &#123;</span></span><br><span class="line">        __u64   start;          <span class="comment">/* Zone start sector */</span></span><br><span class="line">        __u64   len;            <span class="comment">/* Zone length in number of sectors */</span></span><br><span class="line">        __u64   wp;             <span class="comment">/* Zone write pointer position */</span></span><br><span class="line">        __u8    type;           <span class="comment">/* Zone type */</span></span><br><span class="line">        __u8    cond;           <span class="comment">/* Zone condition */</span></span><br><span class="line">        __u8    non_seq;        <span class="comment">/* Non-sequential write resources active */</span></span><br><span class="line">        __u8    reset;          <span class="comment">/* Reset write pointer recommended */</span></span><br><span class="line">        __u8    resv[<span class="number">4</span>];</span><br><span class="line">        __u64   capacity;       <span class="comment">/* Zone capacity in number of sectors */</span></span><br><span class="line">        __u8    reserved[<span class="number">24</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> blk_zone blk_zone_v2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_zone_report_v2</span> &#123;</span></span><br><span class="line">        __u64   sector;</span><br><span class="line">        __u32   nr_zones;</span><br><span class="line">        __u32   flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_zone</span> <span class="title">zones</span>[0];</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> blk_zone_report blk_zone_report_v2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* HAVE_BLK_ZONE_REP_V2 */</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>对于不支持报告分区容量的内核，通过上述代码重新定义<code>blk_zone</code>。</p>
<p>再次以libzbd库的源代码为例，分区报告回复的分区描述符可以按照以下方式处理。我们在上文中提到，结构体<code>struct blk_zone</code>内的成员的长度，都是以<code>512B</code>扇区计数的。而在函数<code>zbd_parse_zone</code>中，我们通过将<code>blk_zone</code>内的成员左移9位（即乘以512）得到对应的字节数量，并存储到对应的<code>struct zbd_zone * zone</code>中。</p>
<p>这是因为，在内核层面，分区的起始位置、长度、容量和写入指针通常以扇区为单位进行存储和报告，而在许多高级应用和系统调用中，使用字节作为更通用和精确的度量单位更为常见。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * zbd_parse_zone - Fill a zone descriptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*	</span></span><br><span class="line"><span class="comment"> 	*	zbd_zone 	用于存储解析后的分区信息</span></span><br><span class="line"><span class="comment"> 	*	blk_zone	指向原始从内核获取的分区信息</span></span><br><span class="line"><span class="comment"> 	*	blk_zone_report 指向分区报告的结构体指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">zbd_parse_zone</span><span class="params">(<span class="keyword">struct</span> zbd_zone *zone, <span class="keyword">struct</span> blk_zone *blkz,</span></span><br><span class="line"><span class="params">                                  <span class="keyword">struct</span> blk_zone_report *rep)</span></span><br><span class="line">&#123;</span><br><span class="line">				<span class="comment">/*	将分区的起始扇区转换为字节单位存储在 zbd_zone	中	*/</span></span><br><span class="line">        zone-&gt;start = blkz-&gt;start &lt;&lt; SECTOR_SHIFT;</span><br><span class="line">        <span class="comment">/*	将分区的长度(以扇区为单位)转换为以字节为单位	SECTOR_SHIFT = 9，扇区大小为512B	*/</span></span><br><span class="line">        zone-&gt;len = blkz-&gt;len &lt;&lt; SECTOR_SHIFT;</span><br><span class="line">        <span class="comment">/*	判断capacity	*/</span></span><br><span class="line">        <span class="keyword">if</span> (rep-&gt;flags &amp; BLK_ZONE_REP_CAPACITY)</span><br><span class="line">                zone-&gt;capacity = blkz-&gt;capacity &lt;&lt; SECTOR_SHIFT;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                zone-&gt;capacity = zone-&gt;len;</span><br><span class="line">        </span><br><span class="line">        zone-&gt;wp = blkz-&gt;wp &lt;&lt; SECTOR_SHIFT;</span><br><span class="line"></span><br><span class="line">        zone-&gt;type = blkz-&gt;type;</span><br><span class="line">        zone-&gt;cond = blkz-&gt;cond;</span><br><span class="line">        zone-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (blkz-&gt;reset)</span><br><span class="line">                zone-&gt;flags |= ZBD_ZONE_RWP_RECOMMENDED;</span><br><span class="line">        <span class="keyword">if</span> (blkz-&gt;non_seq)</span><br><span class="line">                zone-&gt;flags |= ZBD_ZONE_NON_SEQ_RESOURCES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命令行工具blkzone，作为util-linux项目的一部分，使用BLKREPORTZONE命令来实现其报告功能。其代码类似于上述方法进行了修改，以确保无论使用的是哪个版本的内核，都能正确编译和执行。</p>
<h3 id="Resetting-a-Zone-Write-Pointer"><a href="#Resetting-a-Zone-Write-Pointer" class="headerlink" title="Resetting a Zone Write Pointer"></a>Resetting a Zone Write Pointer</h3><p>一个或多个连续写区域的写指针可以通过命令<code>BLKRESETZONE</code>重置，在重置一个写指针的时候，区域的状态同样会被更改为<code>BLK_ZONE_COND_EMPTY</code>。</p>
<p>当多个区域需要被重置时，使用结构体<code>blk_zone_range</code>追踪这些区域，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct blk_zone_range - BLKRESETZONE/BLKOPENZONE/</span></span><br><span class="line"><span class="comment"> *                         BLKCLOSEZONE/BLKFINISHZONE ioctl</span></span><br><span class="line"><span class="comment"> *                         requests</span></span><br><span class="line"><span class="comment"> * @sector: Starting sector of the first zone to operate on.</span></span><br><span class="line"><span class="comment"> * @nr_sectors: Total number of sectors of all zones to operate on.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_zone_range</span> &#123;</span></span><br><span class="line">	__u64		sector;</span><br><span class="line">	__u64		nr_sectors;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同样，该结构体也可以在，打开区域<code>BLKOPENZONE</code>，关闭区域<code>BLKCLOSEZONE</code>，完成区域<code>BLKFINISHZONE</code> <code>ioctl</code>中使用。</p>
<p>下面是一个简单的例子，该例子重置一个区域起始在274726912位置，该区域大小为256MiB(524288 sectors of 512B)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/blkzoned.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_zone_range</span> <span class="title">zrange</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">zrange.sector = <span class="number">274726912</span>;</span><br><span class="line">zrange.nr_sectors = <span class="number">524288</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*	调用BLKRESETZONE	*/</span></span><br><span class="line">ret = ioctl(fd, BLKRESETZONE, &amp;zrange);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>其中，<code>fd</code>为设备描述符，必须保证该设备是打开的。</p>
<p>命令行工具blkzone使用BLKRESETZONE命令来实现其重置功能。</p>
<h3 id="Opening-Closing-and-Finishing-Zones"><a href="#Opening-Closing-and-Finishing-Zones" class="headerlink" title="Opening. Closing and Finishing Zones"></a>Opening. Closing and Finishing Zones</h3><ul>
<li><code>BLKOPENZONE</code>命令的参数和<code>BLKRESETZONE</code>的命令一样。</li>
<li><code>BLKCLOSEZONE</code>命令关闭一个区域；<code>BLKFINISHZONE</code>会结束一个区域，这意味着将该区域的状态设置为满<code>BLK_ZONE_COND_FULL</code>。以上两个命令均需要指向<code>blk_zone_range</code>的指针，用来表明操作的区域范围。</li>
</ul>
<h3 id="Zone-Size-and-Number-of-Zones"><a href="#Zone-Size-and-Number-of-Zones" class="headerlink" title="Zone Size and Number of Zones"></a>Zone Size and Number of Zones</h3><ul>
<li><code>BLKGETZONESZ</code>：获取分区设备的分区大小<code>zoned device&#39;s zone size</code>。</li>
<li><code>BLKGETNRZONES</code>：获取设备的总分区数。</li>
</ul>
<p>以上两个命令均接受一个指向32位无符号整型的指针， 并返回对应的数量。下面给出例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/blkzoned.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> nr_zones, zone_size;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = ioctl(fd, ,BLKGETZONESZ, &amp;zone_size);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">ret = ioctl(fd, ,BLKGETNRZONES, &amp;nr_zones);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Device has %u zones of %u 512-Bytes sectors\n&quot;</span>,</span><br><span class="line">       nr_zones, zone_size);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们发现，在调用<code>BLKGETNRZONES</code>等函数时，需要通过<code>ioctl</code>。</p>
<p><code>BLKGETNRZONES</code>命令特别适用于分配足够大的分区描述符数组，以便对设备上所有分区进行分区报告</p>
<h1 id="Write-Ordering-Control-1"><a href="#Write-Ordering-Control-1" class="headerlink" title="Write Ordering Control"></a>Write Ordering Control</h1><p>以前，Linux内核块<code>I/O</code>堆栈<code>Linux kernel block I/O stack</code>（例如，块层和<code>SCSI</code>层），并不会保证块<code>I/O</code>请求的执行顺序。不能保证块<code>I/O</code>请求的执行顺序的原因是因为块I&#x2F;O请求内核中执行的异步性质和设备请求队列需要细粒度锁模型的必要性。（当多个上下文同时向块设备发出I&#x2F;O请求时，最大限度地减少锁定竞争开销）。</p>
<p>这种设计直接导致的结果是，<code>well-behaving ZBD-compliant application</code>在沿着<code>LBA</code>顺序进行的写命令无法保证齐顺序性。</p>
<p>为了解决这个问题，内核<code>ZBD</code>支持添加区域写锁<code>zone write locking</code>以保证写请求在每一个区域中的执行顺序。</p>
<h2 id="Zone-Write-Locking"><a href="#Zone-Write-Locking" class="headerlink" title="Zone Write Locking"></a>Zone Write Locking</h2><p>区域写入锁<code>Zone write locking</code>实现了对于每个区域的写锁定，以顺序执行每一个对相同区域的写请求。此功能不保证写入命令始终在区域写入指针的位置发出：这是写<code>I/O</code>发出者的责任。区域写入锁定只保证应用程序，文件系统，设备映射器目标发出的写命令的顺序将被块<code>I/O</code>堆栈所遵守。因此，优秀的区域块设备用户将避免为对齐的写入命令失败。</p>
<p>区域写入锁定不会影响读命令。因为读命令不是顺序的。</p>
<h2 id="Initial-Implementation"><a href="#Initial-Implementation" class="headerlink" title="Initial Implementation"></a>Initial Implementation</h2><p>区域写锁定的第一次实现在内核版本为4.10的<code>SCSI</code>硬盘驱动上（在块层之下），对块<code>I/O</code>调度器已传递给设备调度队列的请求进行操作。</p>
<p>这种早期实现依赖于SCSI层可能会延迟向设备发出任何请求的事实。</p>
<p>通过维护每个区域一个位的位图，SCSI磁盘驱动程序每当看到写入命令时都会将区域标记为锁定。此算法在此更详细地介绍：</p>
<ol>
<li>如果下一个派遣给设备的命令不是写命令，则该命令会被直接派遣。</li>
<li>如果下一个派遣给设备的命令是写命令，则写命令的目标区域的区域写入锁定位<code>zone write lock bit</code>会被检查。<ol>
<li>如果写命令的目标区域未被写锁定（即<code>zone write lock bit is not set</code>），则锁定区域并将写命令发送给设备。写锁定操作和命令发送操作都是在设备请求队列旋转锁下原子执行的。</li>
<li>如果区域已被锁定（即<code>zone write lock bit is set</code>），则<code>SCSI</code>磁盘驱动会延迟发送该命令直到区域写入锁被释放。</li>
<li>当写命令完成时，区域写入锁被释放，调度过程会恢复。意味着如果派遣队列中的头命令（第一个命令）如果指向同一个区域（上述区域写入锁定被释放的区域），该命令会被发出。</li>
</ol>
</li>
</ol>
<p>尽管这种实现为遗留的单对列块<code>I/O</code>路径提供了写顺序的保障，并且不依赖于任何特定的HBA，它仍有一些缺点。</p>
<blockquote>
<p>“HBA” 指的是 “Host Bus Adapter”。HBA 是一种硬件设备，通常以插卡的形式存在，用于连接计算机主机（如服务器或工作站）与外部存储设备，比如硬盘阵列、磁带库或SAN（存储区域网络）设备。HBA 卡负责处理输入&#x2F;输出 (I&#x2F;O) 请求和数据传输，从而将主机与存储设备之间的通信和数据交换工作负载从 CPU 上卸载出来。</p>
<p>在许多高性能计算和数据密集型环境中，HBA 卡是至关重要的组件，因为它们可以提高数据传输速率，减少主机 CPU 的负担，并提高整体系统的 I&#x2F;O 性能。在上下文中提到的“write-ordering guarantees for the legacy single-queue block I&#x2F;O path”与 HBA 的独立性表明，该实现不依赖于特定的 HBA 硬件，从而具有更广泛的兼容性。</p>
</blockquote>
<ul>
<li><p>潜在的性能退化：任何写入任何区域的命令都会导致命令调度处理停止。这阻止了所有其他命令被发送，包括读取命令。这可能会限制在高队列深度操作设备时可以通过设备级命令重新排序获得的性能优势。极端情况是应用程序向具有异步I&#x2F;O系统调用的区域发出写流（例如io_submit()）。在这种情况下，顺序写入命令将在设备调度队列中按顺序排队，导致驱动器在一次一个写入命令的队列深度运行。</p>
</li>
<li><p>不支持块多队列<code>I/O</code>路径：不像遗留的单对列块<code>I/O</code>接口，多队列块<code>I/O</code>的实现并不过多的依赖于设备队列自旋锁来处理磁盘用户（应用程序或者内核组件）发出的多队列块<code>I/O</code>请求。这导致在请求传递到设备调度队列之前发生潜在的块I&#x2F;O请求重新排序，并且区域写入锁定无效。</p>
<blockquote>
<ol>
<li><strong>I&#x2F;O 请求重排序</strong>：由于不是所有的 I&#x2F;O 请求都通过单一的、受自旋锁保护的队列来处理，因此不同队列中的请求可能会出现重排序现象。这意味着即使应用程序或内核组件按照特定的顺序发出 I&#x2F;O 请求，这些请求到达设备调度队列时的顺序可能已经改变。</li>
<li><strong>区域写锁定的无效性</strong>：在支持区域块设备（ZBD）的环境中，维持写操作的顺序是非常重要的，特别是对于顺序写入区域。由于多队列实现可能导致 I&#x2F;O 请求的重排序，区域写锁定机制（旨在保证写操作顺序）可能无法有效地工作。在多队列环境中，即使应用程序尝试按照正确的顺序发出写命令，由于请求在到达设备之前可能被重排序，因此无法保证这些写操作遵循 ZBD 的顺序写入约束。</li>
</ol>
</blockquote>
</li>
</ul>
<p>这些限制导致使用块层I&#x2F;O调度器在I&#x2F;O堆栈中更高级别开发区域写入锁定的新实现。</p>
<h2 id="Improved-Implementation-Block-I-x2F-O-Scheduler"><a href="#Improved-Implementation-Block-I-x2F-O-Scheduler" class="headerlink" title="Improved Implementation: Block I&#x2F;O Scheduler"></a>Improved Implementation: Block I&#x2F;O Scheduler</h2><p>于是我们将区域写入锁定的实现移动到<code>I/O</code>堆栈的更高层级，块多队列（以及 SCSI 多队列）基础设施也得到了支持。这一改进在内核版本 4.16 中被添加，同时移除了 SCSI 层的区域写锁定实现。</p>
<p>这一新的区域写入锁定的实现依赖于块层的<code>deadline</code>和<code>mq-deadline</code> <code>I/O</code>调度器，并解决了之前的实现的缺点。</p>
<p>这种新的算法细节如下：</p>
<ol>
<li>如果调度器正在处理读命令：<ul>
<li>读取命令列表中排队的第一个命令允许继续并提交给设备调度队列。</li>
<li>如果没有可用的读命令，则激活写命令。</li>
<li>如果读命令的处理时间达到限制，切换处理写命令，以避免写命令饥饿。</li>
<li>如果读命令可用，则继续步骤1</li>
</ul>
</li>
<li>在处理写命令时，按从LBA有序列表头部的命令或到达时间有序列表中的第一个命令开始扫描调度器中排队的写命令列表（当存在饥饿命令的风险时）。<ul>
<li>如果第一个写命令的目标区域没有被写锁定，该区域被锁定，然后把写命令发送到设备中。这两个操作都是在调度器维护的自旋锁下原子执行的。</li>
<li>如果目标区域已被锁定（位设置），则跳过该命令，并在LBA有序的写入命令列表中搜索针对不同区域的第一个写入命令。如果找到这样的命令，则再次执行步骤2。</li>
<li>如果所有排队的写入命令都针对锁定区域，则调度器操作模式（批处理模式）将切换到<em>读取</em>并调用步骤1。</li>
</ul>
</li>
<li>当写命令完成后，命令目标区域的区域写锁将被释放，调度程序将被激活。根据当前的批处理模式，在第1或2步恢复操作。</li>
</ol>
<p>从这个算法中，很明显，该设备现在可以在更高的队列深度下操作，只有顺序写入目标同一区域才会受到限制。所有读取命令都可以继续，并编写针对不同区域不会相互影响的命令。</p>
<blockquote>
<p>该实现并不保障所有的命令都是有序的。它只保障对于同一区域的写命令是顺序执行的。调度器可能会更改针对不同区域的写入命令的调度顺序。对于任何单个顺序区域，在任何时候，总是最多执行一个写入命令。当有读取访问和同时写入多个区域时，可以在高队列深度进行整体磁盘操作。</p>
</blockquote>
<h2 id="Block-I-x2F-O-Scheduler-Configuration"><a href="#Block-I-x2F-O-Scheduler-Configuration" class="headerlink" title="Block I&#x2F;O Scheduler Configuration"></a>Block I&#x2F;O Scheduler Configuration</h2><h3 id="null-blk-Logical-Device"><a href="#null-blk-Logical-Device" class="headerlink" title="null_blk Logical Device"></a><code>null_blk</code> Logical Device</h3><p><code>CONFIG_BLK_DEV_ZONED</code>配置选项会自动支持使用<code>null_blk</code>设备驱动程序的区域块设备仿真。</p>
<h3 id="ZBC-and-ZAC-Hard-Disks-Support"><a href="#ZBC-and-ZAC-Hard-Disks-Support" class="headerlink" title="ZBC and ZAC Hard-Disks Support"></a>ZBC and ZAC Hard-Disks Support</h3><p>使用CONFIG_BLK_DEV_ZONED配置选项自动启用对ZBC和ZAC SMR磁盘的SCSI子系统支持。</p>
<h3 id="NVMe-Zoned-Namespace-Solid-State-Disks-Support"><a href="#NVMe-Zoned-Namespace-Solid-State-Disks-Support" class="headerlink" title="NVMe Zoned Namespace Solid State Disks Support"></a>NVMe Zoned Namespace Solid State Disks Support</h3><p>NVM Express分区命名空间命令集依赖于CONFIG_BLK_DEV_ZONED和CONFIG_NVME_CORE。如果启用这两个配置选项，它会自动构建。</p>
<p>此驱动程序要求设备支持Zone Append命令才能成功绑定到分区命名空间。它不支持区域游览。有关这些功能的更多详细信息，请参阅Zoned Namespace（ZNS）SSD。</p>
<h2 id="Device-Mapper-1"><a href="#Device-Mapper-1" class="headerlink" title="Device Mapper"></a>Device Mapper</h2><p>当<code>CONFIG_BLK_DEV_ZONED </code>选项被设置，设备映射器子系统也会自动的启用。这支持dm线性和dmflakey目标。请注意，必须启用dm分区的设备映射器目标才能使用。</p>
<p>通过从菜单设备驱动程序中选择CONFIG_DM_ZONED选项来启用dm分区目标–&gt;多个设备驱动程序支持（RAID和LVM）–&gt;设备映射器支持–&gt;驱动器管理的分区块设备目标支持。</p>
<h2 id="File-Systems-1"><a href="#File-Systems-1" class="headerlink" title="File Systems"></a>File Systems</h2><h3 id="f2fs"><a href="#f2fs" class="headerlink" title="f2fs"></a>f2fs</h3><p>使用CONFIG_BLK_DEV_ZONED配置选项自动启用对f2fs文件系统中分区块设备的支持。</p>
<h3 id="zonefs-1"><a href="#zonefs-1" class="headerlink" title="zonefs"></a>zonefs</h3><p>通过从菜单文件系统-&gt;zonefs文件系统支持中选择CONFIG_ZONEFS_FS选项来启用zonefs文件系统的编译。仅当CONFIG_BLK_DEV_ZONED选项设置为启用分区块设备支持时，此选项才可用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="theLonging"
      src="/images/touxiang.JPG">
  <p class="site-author-name" itemprop="name">theLonging</p>
  <div class="site-description" itemprop="description">不捨晝夜。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/chantchanH7" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chantchanH7" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/562879980@qq.com" title="E-Mail → 562879980@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-07 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">theLonging</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">250k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:48</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
