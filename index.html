<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="不捨晝夜。">
<meta property="og:type" content="website">
<meta property="og:title" content="talk is cheap, show me the code.">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="talk is cheap, show me the code.">
<meta property="og:description" content="不捨晝夜。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="theLonging">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>talk is cheap, show me the code.</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">talk is cheap, show me the code.</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/08/ember-code-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/08/ember-code-analysis/" class="post-title-link" itemprop="url">ember-code-analysis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-08 14:24:07" itemprop="dateCreated datePublished" datetime="2024-06-08T14:24:07+08:00">2024-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-12 14:14:09" itemprop="dateModified" datetime="2024-06-12T14:14:09+08:00">2024-06-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ember源码解析"><a href="#ember源码解析" class="headerlink" title="ember源码解析"></a>ember源码解析</h1><h2 id="features-py"><a href="#features-py" class="headerlink" title="features.py"></a><code>features.py</code></h2><p>思考：</p>
<ol>
<li>如何修改二进制代码，在保留恶意功能的同时破坏特征值</li>
<li>如何挑选效果更好的特征值</li>
</ol>
<ul>
<li><p>用于抽取二进制码特征的父类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FeatureType</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">raw_features</span>(<span class="params">self, bytez, lief_binary</span>): <span class="comment"># 生成一个可以被JSON序列化的特征表示。</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">process_raw_features</span>(<span class="params">self, raw_obj</span>): <span class="comment"># 用于处理 raw_obj 并将其转换为具体的特征向量 </span></span><br><span class="line">    </span><br><span class="line">  <span class="comment"># 这是一个具体方法，它提供了从原始字节和二进制文件中直接计算特征向量的功能。</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">feature_vector</span>(<span class="params">self, bytez, lief_binary</span>): </span><br><span class="line">    <span class="keyword">return</span> self.process_raw_features(self.raw_features(bytez, lief_binary))</span><br></pre></td></tr></table></figure>
</li>
<li><p>继承 featureType，实现字节直方图的计算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ByteHistogram</span>(<span class="title class_ inherited__">FeatureType</span>):</span><br></pre></td></tr></table></figure>
</li>
<li><p>用于计算基于字节值和局部熵的二维直方图，这种直方图是基于熵的度量来近似字节值和其局部熵的联合概率分布。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ByteEntropyHistogram</span>(<span class="title class_ inherited__">FeatureType</span>):</span><br></pre></td></tr></table></figure>
</li>
<li><p>用于提取与文件段（sections）相关的特征信息，如段名称、大小、熵等，并使用哈希技巧（特征哈希）来汇总所有段信息成一个特征向量。</p>
</li>
</ul>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SectionInfo</span>(<span class="title class_ inherited__">FeatureType</span>):</span><br></pre></td></tr></table></figure>

<ul>
<li><p>该类专门用于从二进制文件中提取有关导入库和函数的信息，主要处理和转换这些信息为特征向量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ImportsInfo</span>(<span class="title class_ inherited__">FeatureType</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>从二进制文件中提取导出函数的信息，并将其转换为特征向量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExportsInfo</span>(<span class="title class_ inherited__">FeatureType</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>提取二进制文件的一般信息，并将这些信息转换成特征向量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneralFileInfo</span>(<span class="title class_ inherited__">FeatureType</span>):</span><br></pre></td></tr></table></figure>
</li>
<li><p>从二进制文件的头部信息中提取相关的机器、架构、操作系统、链接器以及其他信息，并将这些信息转换为特征向量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeaderFileInfo</span>(<span class="title class_ inherited__">FeatureType</span>):</span><br></pre></td></tr></table></figure>
</li>
<li><p>从二进制文件的原始字节流中提取字符串信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringExtractor</span>(<span class="title class_ inherited__">FeatureType</span>):</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当分析一个文件（可能是一个文档、压缩包或另一个可执行文件）的二进制内容时，搜索包含“MZ”字样的字节序列是寻找嵌入可执行文件的一个简单且有效的方法。若在文件中的非起始位置发现“MZ”标记，这可能意味着有一个或多个可执行文件被嵌入或附加到了主文件中。</p>
</blockquote>
</li>
<li><p>从二进制文件的数据目录中提取大小和虚拟地址信息，并将这些信息转换为特征向量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataDirectories</span>(<span class="title class_ inherited__">FeatureType</span>):</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="init-py"><a href="#init-py" class="headerlink" title="__init__.py"></a><code>__init__.py</code></h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/02/AVCLASS2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/02/AVCLASS2/" class="post-title-link" itemprop="url">AVCLASS2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-06-02 13:43:51 / 修改时间：14:46:49" itemprop="dateCreated datePublished" datetime="2024-06-02T13:43:51+08:00">2024-06-02</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>55</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="AVclass2-Massive-Malware-Tag-Extraction-from-AV-Labels"><a href="#AVclass2-Massive-Malware-Tag-Extraction-from-AV-Labels" class="headerlink" title="AVclass2: Massive Malware Tag Extraction from AV Labels"></a>AVclass2: Massive Malware Tag Extraction from AV Labels</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/28/A-Deep-Dive-into-VirusTotal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/28/A-Deep-Dive-into-VirusTotal/" class="post-title-link" itemprop="url">A Deep Dive into VirusTotal</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-28 15:10:11" itemprop="dateCreated datePublished" datetime="2024-05-28T15:10:11+08:00">2024-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-30 13:58:45" itemprop="dateModified" datetime="2024-05-30T13:58:45+08:00">2024-05-30</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="A-Deep-Dive-into-VirusTotal-Characterizing-and-Clustering-a-Massive-File-Feed"><a href="#A-Deep-Dive-into-VirusTotal-Characterizing-and-Clustering-a-Massive-File-Feed" class="headerlink" title="A Deep Dive into VirusTotal: Characterizing and Clustering a Massive File Feed"></a>A Deep Dive into VirusTotal: Characterizing and Clustering a Massive File Feed</h1><h2 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h2><p>论文回答的问题：</p>
<ul>
<li><p>这个源的多样性如何？</p>
<p>这个问题询问VT文件源中样本的多样性程度。多样性包括不同类型的恶意软件、不同的攻击技术、不同操作系统的恶意软件等。多样性高意味着数据源可以提供广泛的恶意软件样本，有助于研究和测试不同的防御机制。</p>
</li>
<li><p>它是否允许构建针对不同文件类型的恶意软件数据集？</p>
<p>这个问题探讨VT文件源是否包含足够多的不同文件类型（如可执行文件、脚本、文档等），以便研究人员可以构建专门针对特定文件类型的恶意软件数据集。这对于开发针对特定类型文件的专门安全工具和策略尤为重要。</p>
</li>
<li><p>它提供的样本有多新鲜？</p>
<p>这里询问的是VT文件源中样本的新鲜度，即样本从被捕获到上传到VT并可供研究的时间间隔有多短。新鲜度高的样本可以让研究人员和安全专家及时了解并对抗最新的恶意软件威胁。</p>
</li>
<li><p>它所见的恶意软件家族的分布是怎样的？</p>
<p>这个问题关注的是VT文件源中恶意软件家族的分布情况。家族分布可以反映出哪些类型的恶意软件最常见，哪些正在增加，这有助于安全研究人员和行业了解当前恶意软件的趋势和动态。</p>
</li>
<li><p>这种分布真的能代表用户设备上的恶意软件吗？</p>
<p>这个问题询问VT文件源中的恶意软件家族分布是否能准确反映普通用户设备上遭遇的恶意软件的实际情况。这是评估VT数据源在现实世界安全应用中有效性的重要方面，因为如果数据源的分布与实际情况相差甚远，那么基于这些数据的研究和解决方案可能无法有效应对真实的威胁。</p>
</li>
</ul>
<p>探索了如何通过研究可扩展的方法，在2.35亿样本的数据源上产生高纯度的聚类来进行大规模的威胁猎捕。</p>
<p>三种聚类方法：</p>
<ul>
<li>层次聚合聚类（HAC）</li>
<li>适用于TLSH摘要的更可扩展的HAC变体（HAC-T）</li>
<li>简单的特征值分组（FVG）</li>
</ul>
<p>最后，使用生成的聚类进行威胁猎捕，具体是用来检测那些被认为是良性的19万样本（即，检测结果为零的样本），这些样本可能实际上是恶意的，因为它们属于2.9万个聚类，其中大多数样本被检测为恶意。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul>
<li>如何在不采用极端激进的过滤策略的情况下，将威胁猎捕扩展到文件源的内容上。</li>
</ul>
<h3 id="贡献："><a href="#贡献：" class="headerlink" title="贡献："></a>贡献：</h3><p>以下是对上文中提到的三个主要贡献的总结：</p>
<ol>
<li><p><strong>VT文件源的特性分析</strong>：</p>
<ul>
<li>我们利用一年内收集的2.35亿样本的3.28亿份分析报告，以及同期安全供应商的遥测数据，对VT文件源进行了详细的特性分析。</li>
<li>我们发现，尽管VT文件源的数据量是遥测数据的1&#x2F;17，但观测到的恶意软件数量却是遥测数据的8倍，显示出VT文件源在捕捉恶意软件方面的高效性。</li>
<li>文件源非常新鲜，每天接收超过一百万个新样本，这些样本在用户设备上出现后平均4.4小时就会出现在文件源中。</li>
<li>在新样本中，62%可以立即被标记为已知家族的变体，但有38%未被标记。0.3%的新样本最初完全未被检测到，但随后多个杀毒引擎开始标记它们。</li>
<li>文件源包含丰富的文件类型和至少有100个样本的4.9千个家族，但这种多样性主要由Windows和Android家族驱动。家族分布与遥测数据的观察结果显著不同，表明VT文件源可能不适合推断家族对真实用户的影响。</li>
</ul>
</li>
<li><p><strong>可扩展的聚类方法探索</strong>：</p>
<ul>
<li>我们评估了三种能够处理VT文件源中数亿样本的聚类方法：层次聚合聚类（HAC）、针对TLSH摘要的更高效的HAC版本（HAC-T）以及简单的按特征值分组（FVG）。</li>
<li>首先，我们使用Windows和Android的真实数据集来评估这些方法的准确性。</li>
<li>接着，我们评估了这些方法的可扩展性，发现只有FVG能够适应文件源的庞大数据量。</li>
</ul>
</li>
<li><p><strong>应用FVG聚类来检测完全未被发现的恶意软件</strong>：</p>
<ul>
<li>使用FVG，我们对2.35亿个样本进行聚类，不考虑它们是否已被杀毒引擎检测到。</li>
<li>我们识别出了29,000个FVG-vhash聚类，这些聚类中的多数样本被多个杀毒引擎检测到，包含了190,000个可能是恶意的、但未被检测到的样本。这表明FVG聚类方法在识别潜在恶意软件方面具有有效性。</li>
</ul>
</li>
</ol>
<h2 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h2><h2 id="数据特征"><a href="#数据特征" class="headerlink" title="数据特征"></a>数据特征</h2><ul>
<li>样本特征</li>
<li>扫描特征</li>
<li>派生特征</li>
</ul>
<p><img src="/../images/A-Deep-Dive-into-VirusTotal/%E6%88%AA%E5%B1%8F2024-05-29%2014.46.12.png" alt="截屏2024-05-29 14.46.12"></p>
<p>加密哈希 crypto-graphic hashes</p>
<ul>
<li>应用于整个文件的: sha256、sha1、md5</li>
<li>计算文件部分的：imphash、richpe_hash、cert_thumbprint、authentihash、icon_hash</li>
</ul>
<p>模糊哈希 fuzzy hashes</p>
<ul>
<li>tlsh 研究表明tlsh比ssdeep好；tlsh使用哈希值上的汉明距离来确定两个输入是否相似</li>
<li>ssdeep</li>
</ul>
<p>结构哈希</p>
<ul>
<li><strong>vhash:</strong> <ul>
<li>它考虑了样本属性，如导入、导出、段和文件大小。</li>
<li>vhash似乎是不同文件类型的一组结构哈希的通用名称。</li>
<li>VT为许多文件类型计算vhash（例如，PE可执行文件、APKs、PDFs、Office文档），但并非全部（例如，JPEG和PNG图像没有vhash）。</li>
<li>VT使用vhash为文件提供每日聚类。我们已经确认同一聚类中的样本具有相同的vhash值，因此我们使用等值比较两个vhash值。尽管是专有的且大部分未被文档记录，我们在第5节的实验评估显示vhash是一个用于聚类的良好特征。</li>
</ul>
</li>
</ul>
<p>时间戳（time stamp）</p>
<ul>
<li>scan_date</li>
<li>fseen_date</li>
<li>cert_valid_from</li>
<li>cert_valid_to</li>
</ul>
<p>杀毒扫描 AV scan</p>
<ul>
<li>我们提取检测到样本的引擎数量（即给出非空标签的引擎数量）（vt_score）</li>
</ul>
<p>程序 package_name</p>
<ul>
<li><code>package_name</code> 是Android应用的包标识符</li>
<li><code>vt_meaningful_name</code> 是VT为样本选择的最有意义的文件名（例如，在提交给VT时样本的所有文件名中选择）。</li>
</ul>
<p>派生特征 Derived Features</p>
<p>文件类型：</p>
<p>通过 trid_file_type、vt_tags、vt_meaningful_name</p>
<ul>
<li>trid_file_type 是使用TrID工具识别的文件类型</li>
<li>vt_tag：<img src="/../images/A-Deep-Dive-into-VirusTotal/%E6%88%AA%E5%B1%8F2024-05-29%2016.21.28.png" alt="截屏2024-05-29 16.21.28"></li>
<li>当vt_meaningful_name可用时，我们从文件名中提取扩展名，并将该扩展名映射到一个文件类型。</li>
</ul>
<p>AVClass 特征：</p>
<p>AVCLASS2 是一个病毒标记工具，</p>
<h2 id="文件源分析-Feed-Analysis"><a href="#文件源分析-Feed-Analysis" class="headerlink" title="文件源分析 Feed Analysis"></a>文件源分析 Feed Analysis</h2><p>回答了以下问题：</p>
<ul>
<li><p>(1) VT文件源与AV遥测数据相比有多大？</p>
<p>VT文件源包含的恶意软件数量是遥测数据的八倍，使其成为获取恶意样本的重要来源。</p>
</li>
<li><p>(2) 文件源中的样本有多新鲜？</p>
<p>在收集到的样本中，有89%是新样本，即之前VT未知的样本，而且文件源每天提供超过一百万个新样本。</p>
</li>
<li><p>(3) 文件源在文件类型方面有多样化吗？</p>
<p>文件源中三分之二的样本是Windows PE文件，但该源对于多种文件类型来说都是一个很好的样本来源。文件源缺乏统一的文件类型字段，对于大量样本来说，文件类型的识别是具有挑战性的。</p>
<p><img src="/../images/A-Deep-Dive-into-VirusTotal/%E6%88%AA%E5%B1%8F2024-05-29%2017.17.45.png" alt="截屏2024-05-29 17.17.45"></p>
</li>
<li><p>(4) 有多少比例的样本在首次扫描时可以被检测为恶意的？</p>
<p>VT文件源是一个文件源而不是恶意软件源。其一半的数据量是未被检测到的样本，而53%的样本在首次观察时没有被检测到。另一方面，由于这些样本与之前看到的恶意软件具有相似特征（即匹配现有的签名），有41%至47%的样本在首次被杀毒引擎检测时可以被识别为恶意软件。</p>
</li>
<li><p>(5) 文件源在家族方面有多样化吗？</p>
<p>该数据源具有多样性，拥有至少100个样本的家族达4.9千个。然而，这种多样性主要是由于peexe和apk家族。对于这两种文件类型，该数据源是构建大规模家族分类数据集的良好来源。AVCLASS2在首次观察时就能为62%的样本进行标记。因此，它可以用作过滤器，移除那些已被良好检测的家族的样本，使分析师可以专注于38%未标记的样本。</p>
</li>
<li><p>(6) 有多少比例的恶意样本在首次扫描时完全未被检测到？</p>
<p>至少有0.3%提交给VT的样本最初是完全未被检测到的（FUD），即它们在首次VT观察时没有被检测到，但后来至少有4个引擎认为它们是恶意的。与其他文件类型相比，PDF文档更有可能是FUD。</p>
</li>
<li><p>(7) 有多少比例的样本是签名的？</p>
<p>VT支持提取多种文件类型的代码签名，但整个文件源的样本中只有一小部分（5.6%）以及peexe样本中的3.7%拥有代码签名。</p>
</li>
<li><p>(8) 文件源和AV遥测数据在恶意样本上的重叠情况如何？哪一个更快地看到样本？</p>
<p>遥测数据和VT文件源观察到的恶意样本集大部分是不相交的（共有的样本只占文件源的1.2%到1.8%）。因此，即使是最大的安全供应商也只能看到恶意样本全域的一小部分。VT文件源中的家族分布与遥测观察到的显著不同，这表明VT可能不是一个好的资源来推断家族对真实用户的影响。两个数据集中的新样本在设备上平均提前4.4小时被看到，因此文件源中的新恶意样本相当新近。此外，有39%的新样本在VT中被观察到之前还未在用户设备中出现，所以VT可能为安全供应商提供有用的早期警报。</p>
</li>
</ul>
<h2 id="聚类-Clustering"><a href="#聚类-Clustering" class="headerlink" title="聚类 Clustering"></a>聚类 Clustering</h2><p><strong>聚类特征 Clustering features</strong></p>
<p>检查9个可以识别相似样本的特征。</p>
<p><img src="/../images/A-Deep-Dive-into-VirusTotal/%E6%88%AA%E5%B1%8F2024-05-29%2018.02.59.png" alt="截屏2024-05-29 18.02.59"></p>
<p><strong>聚类方法  Clustering approaches</strong></p>
<ul>
<li>特征值分组（FVG）：通过在单一特征的值上使用等值关系对样本进行分组，例如，所有具有相同vhash值的样本形成一个聚类。使用FVG进行聚类时，特征向量按照（特征值，样本哈希，扫描日期）的三元组排序。特征值的变化表明一个新的聚类。FVG是一种极具可扩展性的方法。我们使用不同的特征评估FVG，以了解哪些特征提供高精度，并且这些特征能达到什么召回率。</li>
<li>单一链接的层次聚合聚类（HAC）：</li>
<li>基于阈值的层次聚合聚类（HAC-T）：这是一种使用TLSH哈希值聚类样本的可扩展方法。</li>
</ul>
<p><strong>精确度评估</strong></p>
<p><strong>可扩展性</strong></p>
<p>FVG-vhash：1.4h 分类效率最高</p>
<p>HAC-T：22.4h</p>
<p><strong>聚类整个数据集</strong> Clustering the whole dataset.</p>
<p>使用FVG-vhash，特征为：</p>
<ul>
<li>Avc2_family:</li>
<li>vhash</li>
<li>Cert_thumbprint</li>
<li>imphash</li>
</ul>
<h2 id="检测不太良性的样本-Detecting-Not-so-Benign-Samples"><a href="#检测不太良性的样本-Detecting-Not-so-Benign-Samples" class="headerlink" title="检测不太良性的样本 Detecting Not-so-Benign Samples"></a>检测不太良性的样本 Detecting Not-so-Benign Samples</h2><p>在图表中描述的聚类分类基于两个比率，即r1和r4，这两个比率定义如下：</p>
<ul>
<li><strong>r1</strong>: 聚类中至少被检测到一次的样本占聚类中所有样本的百分比。</li>
<li><strong>r4</strong>: 聚类中至少被检测到四次的样本占聚类中所有样本的百分比。</li>
</ul>
<p>这两个比率用来判断聚类中样本的检测频率，从而将聚类分为以下几种类型：</p>
<ol>
<li><strong>完全恶意聚类（Fully malicious clusters）</strong>:<ul>
<li>这种类型的聚类中，所有样本（100%）都至少被检测到一次或四次，即r1或r4等于1。这表示聚类中的每一个样本都被视为恶意。</li>
</ul>
</li>
<li><strong>完全良性聚类（Fully benign clusters）</strong>:<ul>
<li>在这种聚类中，没有样本被检测到，即r1和r4都为0。这表示聚类中的所有样本都未被任何检测工具标记为恶意。</li>
</ul>
</li>
<li><strong>混合聚类（Mixed clusters）</strong>:<ul>
<li>混合聚类包含既被检测到也未被检测到的样本，即0 &lt; r1 &lt; 1 和 0 &lt; r4 &lt; 1。这意味着聚类中的一部分样本被检测为恶意，而另一部分没有被检测到。</li>
</ul>
</li>
<li><strong>恶意多数聚类（Malicious majority clusters）</strong>:<ul>
<li>这类聚类中，大部分但不是全部的样本至少被检测到一次或四次，但未达到完全恶意的标准。通常，这意味着超过半数的样本显示出恶意特征，但仍有少数样本未被检测到。</li>
</ul>
</li>
</ol>
<p><img src="/../images/A-Deep-Dive-into-VirusTotal/%E6%88%AA%E5%B1%8F2024-05-30%2013.58.19.png" alt="截屏2024-05-30 13.58.19"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/25/PracticalMalwareAnalysis-Lab01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/25/PracticalMalwareAnalysis-Lab01/" class="post-title-link" itemprop="url">PracticalMalwareAnalysis-Lab01</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-25 13:42:59" itemprop="dateCreated datePublished" datetime="2024-04-25T13:42:59+08:00">2024-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-07 18:26:06" itemprop="dateModified" datetime="2024-05-07T18:26:06+08:00">2024-05-07</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab01-静态分析基础技术"><a href="#Lab01-静态分析基础技术" class="headerlink" title="Lab01 静态分析基础技术"></a>Lab01 静态分析基础技术</h1><h2 id="lab1-1"><a href="#lab1-1" class="headerlink" title="lab1-1"></a>lab1-1</h2><h3 id="1-将文件上传到virustotals分析并查看报告。文件是否匹配到了已有反病毒软件特征？"><a href="#1-将文件上传到virustotals分析并查看报告。文件是否匹配到了已有反病毒软件特征？" class="headerlink" title="1. 将文件上传到virustotals分析并查看报告。文件是否匹配到了已有反病毒软件特征？"></a>1. 将文件上传到virustotals分析并查看报告。文件是否匹配到了已有反病毒软件特征？</h3><p>如图所示，文件匹配到了反病毒软件的特征，并分别被38、51种反病毒软件识别。<img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2015.28.39.png" alt="截屏2024-04-25 15.28.39"></p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2015.26.06.png" alt="截屏2024-04-25 15.26.06"></p>
<h3 id="2-这些文件是什么时候编译的？"><a href="#2-这些文件是什么时候编译的？" class="headerlink" title="2. 这些文件是什么时候编译的？"></a>2. 这些文件是什么时候编译的？</h3><p>这是文件创建的时间。</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2015.51.16.png" alt="截屏2024-04-25 15.51.16"></p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2015.52.01.png" alt="截屏2024-04-25 15.52.01"></p>
<h3 id="3-这些文件是否存在迹象说明它们是否已被加壳或混淆了？如果是，这些迹象在哪里？"><a href="#3-这些文件是否存在迹象说明它们是否已被加壳或混淆了？如果是，这些迹象在哪里？" class="headerlink" title="3. 这些文件是否存在迹象说明它们是否已被加壳或混淆了？如果是，这些迹象在哪里？"></a>3. 这些文件是否存在迹象说明它们是否已被加壳或混淆了？如果是，这些迹象在哪里？</h3><p>通过PEiD 软件的输出得到它们没有被加壳或混淆。</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2016.08.22.png" alt="截屏2024-04-25 16.08.22"></p>
<p>这里举一个已被混淆的输出，这是一个被 UPX版本在0.89.6到2.90之间的某个版本压缩过。</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2016.09.22.png" alt="截屏2024-04-25 16.09.22"></p>
<h3 id="4-是否有导入函数显示出了这个恶意代码是做什么的？如果是，是哪些导入函数？"><a href="#4-是否有导入函数显示出了这个恶意代码是做什么的？如果是，是哪些导入函数？" class="headerlink" title="4. 是否有导入函数显示出了这个恶意代码是做什么的？如果是，是哪些导入函数？"></a>4. 是否有导入函数显示出了这个恶意代码是做什么的？如果是，是哪些导入函数？</h3><p>这是通过Dependency Walker 分析<code>lab01-01.exe</code>的结果，通过导入函数 CopyFileA, FindNextFileA, FindFirstFileA 可知，该代码是<strong>寻找并复制文件</strong></p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2016.30.18.png" alt="截屏2024-04-25 16.30.18"></p>
<p>这是通过Dependency Walker 分析<code>lab01-01.dll</code>的结果，我只在导入表<code>KERNEL32.DLL</code>中找到有用的信息。通过导入函数CreateProcessA, CreateMutexA等函数，推测是创建进程和互斥锁，让进程休眠的作用。</p>
<p><strong>WS2_32.DLL在书的第14 页有提到</strong>，是用来联网的DLL</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2016.34.47.png" alt="截屏2024-04-25 16.34.47"></p>
<h3 id="5-是否有任何其他文件或基于主机的迹象，让你可以在受感染的系统查找？"><a href="#5-是否有任何其他文件或基于主机的迹象，让你可以在受感染的系统查找？" class="headerlink" title="5. 是否有任何其他文件或基于主机的迹象，让你可以在受感染的系统查找？"></a>5. 是否有任何其他文件或基于主机的迹象，让你可以在受感染的系统查找？</h3><p>使用PEview打开lab01-01.exe结果如图所示，我们发现<code>kernel32.dll</code>和<code>kerne132.dll</code>。</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2016.50.15.png" alt="截屏2024-04-25 16.50.15"></p>
<h3 id="6-是否有基于网络的迹象，可以用来发现受感染机器上的这个恶意代码"><a href="#6-是否有基于网络的迹象，可以用来发现受感染机器上的这个恶意代码" class="headerlink" title="6. 是否有基于网络的迹象，可以用来发现受感染机器上的这个恶意代码"></a>6. 是否有基于网络的迹象，可以用来发现受感染机器上的这个恶意代码</h3><p>使用PEview打开lab01-01.dll 结果如图所示，我们可以看到如图所示的ip地址 127.26.152.13，推断可以通过这个信息发现恶意代码。</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2018.38.49.png" alt="截屏2024-04-25 18.38.49"></p>
<h3 id="7-你猜这些文件的目的是什么"><a href="#7-你猜这些文件的目的是什么" class="headerlink" title="7. 你猜这些文件的目的是什么"></a>7. 你猜这些文件的目的是什么</h3><blockquote>
<p>[!WARNING]</p>
<p>猜不出来。。。</p>
<p>答案上说：.dll文件可能是一个后门文件。而.exe文件是用来安装和运行DLL文件的</p>
</blockquote>
<h2 id="lab1-2"><a href="#lab1-2" class="headerlink" title="lab1-2"></a>lab1-2</h2><p>分析lab01-02.exe 文件</p>
<h3 id="1-将Lab01-02-exe-文件上传到virus-total查看报告。"><a href="#1-将Lab01-02-exe-文件上传到virus-total查看报告。" class="headerlink" title="1. 将Lab01-02.exe 文件上传到virus total查看报告。"></a>1. 将Lab01-02.exe 文件上传到virus total查看报告。</h3><p>文件匹配到了已有的反病毒软件特征</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2015.16.01.png" alt="截屏2024-05-07 15.16.01"></p>
<h3 id="2-这个文件是否被加壳或混淆？迹象是什么？如果已加壳，进行脱壳。"><a href="#2-这个文件是否被加壳或混淆？迹象是什么？如果已加壳，进行脱壳。" class="headerlink" title="2. 这个文件是否被加壳或混淆？迹象是什么？如果已加壳，进行脱壳。"></a>2. 这个文件是否被加壳或混淆？迹象是什么？如果已加壳，进行脱壳。</h3><p>该文件已被UPX加壳，如图所示。</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2015.22.43.png" alt="截屏2024-05-07 15.22.43"></p>
<p>使用upx进行脱壳。</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2015.27.38.png" alt="截屏2024-05-07 15.27.38"></p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2015.29.34.png" alt="截屏2024-05-07 15.29.34"></p>
<h3 id="3-有没有任何导入函数能够暗示出这个程序的功能？"><a href="#3-有没有任何导入函数能够暗示出这个程序的功能？" class="headerlink" title="3. 有没有任何导入函数能够暗示出这个程序的功能？"></a>3. 有没有任何导入函数能够暗示出这个程序的功能？</h3><p><del>从导入函数推测该程序可能会产生一个互斥锁。</del></p>
<p>错误的原因：几乎所有的程序都会新建一个线程或打开一个锁。因此我们要查看另外两个库</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2015.43.58.png" alt="截屏2024-05-07 15.43.58"></p>
<p>这两个库中有函数<code>CreateServiceA</code>、<code>InternetOpenUrlA</code>、<code>InternetOpenA</code>。这些函数是用来打开网络和新建服务器的。</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2016.03.16.png" alt="截屏2024-05-07 16.03.16"></p>
<h3 id="4-哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器"><a href="#4-哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器" class="headerlink" title="4. 哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器"></a>4. 哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器</h3><p>结合上文，网络的迹象可能是向 <a target="_blank" rel="noopener" href="http://www.malwareanalysisbook.com/">www.malwareanalysisbook.com</a> 发送一些信息。其中 internet Explorer.8.0 可能是利用该浏览器的漏洞， Malservice 可能是一个恶意服务。</p>
<p>应该通过一个名为Malservice的服务，并通过到 <a target="_blank" rel="noopener" href="http://www.malwareanalysisbook.com/">www.malwareanalysisbook.com</a> 的网络流量，检查被恶意代码感染的主机。</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2015.47.12.png" alt="截屏2024-05-07 15.47.12"></p>
<h2 id="lab1-3"><a href="#lab1-3" class="headerlink" title="lab1-3"></a>lab1-3</h2><p>分析lab01-03.exe 文件</p>
<h3 id="1-将Lab01-03-exe-文件上传到virus-total查看报告。"><a href="#1-将Lab01-03-exe-文件上传到virus-total查看报告。" class="headerlink" title="1. 将Lab01-03.exe 文件上传到virus total查看报告。"></a>1. 将Lab01-03.exe 文件上传到virus total查看报告。</h3><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2016.11.53.png" alt="截屏2024-05-07 16.11.53"></p>
<h3 id="2-这个文件是否有混淆或加壳的迹象？"><a href="#2-这个文件是否有混淆或加壳的迹象？" class="headerlink" title="2. 这个文件是否有混淆或加壳的迹象？"></a>2. 这个文件是否有混淆或加壳的迹象？</h3><p>查看导入表，里面只有两个函数，可以推断该文件已被加壳。</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2017.08.56.png" alt="截屏2024-05-07 17.08.56"></p>
<p>用PEiD无法知道是哪种壳，现阶段的学习无法将该软件脱壳。</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2017.10.20.png" alt="截屏2024-05-07 17.10.20"></p>
<h3 id="3-有无导入函数能够暗示这个程序的功能？"><a href="#3-有无导入函数能够暗示这个程序的功能？" class="headerlink" title="3. 有无导入函数能够暗示这个程序的功能？"></a>3. 有无导入函数能够暗示这个程序的功能？</h3><p>无法脱壳，目前不能回答这个问题</p>
<h3 id="4-哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器-1"><a href="#4-哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器-1" class="headerlink" title="4. 哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器"></a>4. 哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器</h3><p>无法脱壳，目前不能回答这个问题</p>
<h2 id="lab1-3-1"><a href="#lab1-3-1" class="headerlink" title="lab1-3"></a>lab1-3</h2><h3 id="1-将Lab01-04-exe-文件上传到virus-total查看报告。"><a href="#1-将Lab01-04-exe-文件上传到virus-total查看报告。" class="headerlink" title="1. 将Lab01-04.exe 文件上传到virus total查看报告。"></a>1. 将Lab01-04.exe 文件上传到virus total查看报告。</h3><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2017.25.23.png" alt="截屏2024-05-07 17.25.23"></p>
<h3 id="2-这个文件是否有混淆或加壳的迹象？-1"><a href="#2-这个文件是否有混淆或加壳的迹象？-1" class="headerlink" title="2. 这个文件是否有混淆或加壳的迹象？"></a>2. 这个文件是否有混淆或加壳的迹象？</h3><p>这个文件没有被加壳或混淆的迹象。</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2017.25.39.png" alt="截屏2024-05-07 17.25.39"></p>
<h3 id="3-这个文件是什么时候被编译的"><a href="#3-这个文件是什么时候被编译的" class="headerlink" title="3. 这个文件是什么时候被编译的"></a>3. 这个文件是什么时候被编译的</h3><h3 id="4-有无导入函数能够暗示这个程序的功能？"><a href="#4-有无导入函数能够暗示这个程序的功能？" class="headerlink" title="4. 有无导入函数能够暗示这个程序的功能？"></a>4. 有无导入函数能够暗示这个程序的功能？</h3><p>通过导入函数表和部分二进制数据的信息来看，</p>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2018.10.50.png" alt="截屏2024-05-07 18.10.50"></p>
<p>图中的十六进制数据中包含了一些可读的ASCII字符串,其中有两条值得注意:</p>
<ol>
<li>“winup.exe %s%s”: 暗示该文件可能与一个名为”winup.exe”的程序相关,并且可能会向其传递一些参数。</li>
<li>“system32\winup.exe %s%s <a target="_blank" rel="noopener" href="http://www.practicalmalwareanalysis.com/updater.exe">http://www.practicalmalwareanalysis.com/updater.exe</a>“: 这是一个URL,指向一个名为”updater.exe”的文件。结合前面的”winup.exe”和”system32”的信息,可以推测该程序可能会从该URL下载一个名为”updater.exe”的文件,并将其保存在系统的”system32”目录下,伪装成”winup.exe”。</li>
</ol>
<p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2018.21.58.png" alt="截屏2024-05-07 18.21.58"></p>
<h3 id="5-哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器"><a href="#5-哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器" class="headerlink" title="5. 哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器"></a>5. 哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器</h3><h3 id="6-这个文件在资源段中包含一个资源。使用Resource-Hacker-工具来检查资源，然后抽取资源。"><a href="#6-这个文件在资源段中包含一个资源。使用Resource-Hacker-工具来检查资源，然后抽取资源。" class="headerlink" title="6. 这个文件在资源段中包含一个资源。使用Resource Hacker 工具来检查资源，然后抽取资源。"></a>6. 这个文件在资源段中包含一个资源。使用Resource Hacker 工具来检查资源，然后抽取资源。</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/15/LIEF-TUTORIALS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/15/LIEF-TUTORIALS/" class="post-title-link" itemprop="url">LIEF TUTORIALS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-15 09:36:52 / 修改时间：10:21:10" itemprop="dateCreated datePublished" datetime="2024-04-15T09:36:52+08:00">2024-04-15</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LIEF-入门"><a href="#LIEF-入门" class="headerlink" title="LIEF 入门"></a>LIEF 入门</h1><h2 id="1-Parse-and-manipulate-format"><a href="#1-Parse-and-manipulate-format" class="headerlink" title="1. Parse and manipulate format"></a>1. Parse and manipulate format</h2><p>使用<code>lief.PE.parse()</code>创建<code>PE.Binary</code>对象。</p>
<p>访问不同的PE头</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(binary.dos_header)</span><br><span class="line"><span class="built_in">print</span>(binary.header)</span><br><span class="line"><span class="built_in">print</span>(binary.optional_header)</span><br></pre></td></tr></table></figure>

<p>可以通过抽象方法或直接通过PE定义访问类的成员</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Using the abstract layer</span></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> binary.imported_functions:</span><br><span class="line">  <span class="built_in">print</span>(func)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using the PE definition</span></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> binary.imports:</span><br><span class="line">  <span class="built_in">print</span>(func)</span><br></pre></td></tr></table></figure>

<h2 id="2-Create-a-PE-from-scrath"><a href="#2-Create-a-PE-from-scrath" class="headerlink" title="2.Create a PE from scrath"></a>2.Create a PE from scrath</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"><span class="comment"># Create a PE which pop a MessageBox</span></span><br><span class="line"><span class="comment"># with the message &quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> lief <span class="keyword">import</span> PE</span><br><span class="line"></span><br><span class="line">title   = <span class="string">&quot;LIEF is awesome\0&quot;</span></span><br><span class="line">message = <span class="string">&quot;Hello World\0&quot;</span></span><br><span class="line"></span><br><span class="line">data =  <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">ord</span>, title))</span><br><span class="line">data += <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">ord</span>, message))</span><br><span class="line"><span class="comment"># code 是可执行文件的机器代码，也即程序的执行指令</span></span><br><span class="line">code = [</span><br><span class="line">        <span class="number">0x6a</span>, <span class="number">0x00</span>,                         <span class="comment"># push 0x00 uType</span></span><br><span class="line">        <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x20</span>, <span class="number">0x40</span>, <span class="number">0x00</span>,       <span class="comment"># push VA(title)</span></span><br><span class="line">        <span class="number">0x68</span>, <span class="number">0x10</span>, <span class="number">0x20</span>, <span class="number">0x40</span>, <span class="number">0x00</span>,       <span class="comment"># push VA(message)</span></span><br><span class="line">        <span class="number">0x6a</span>, <span class="number">0x00</span>,                         <span class="comment"># push 0 hWnd</span></span><br><span class="line">        <span class="number">0xFF</span>, <span class="number">0x15</span>, <span class="number">0x54</span>, <span class="number">0x30</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="comment"># call MessageBoxA</span></span><br><span class="line">        <span class="number">0x6A</span>, <span class="number">0x00</span>,                         <span class="comment"># push 0 uExitCode</span></span><br><span class="line">        <span class="number">0xFF</span>, <span class="number">0x15</span>, <span class="number">0x4C</span>, <span class="number">0x30</span>, <span class="number">0x40</span>, <span class="number">0x00</span>  <span class="comment"># call ExitProcess</span></span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 PE.Binary 实例</span></span><br><span class="line">binary32 = PE.Binary(<span class="string">&quot;pe_from_scratch&quot;</span>, PE.PE_TYPE.PE32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># PE 的 .text section</span></span><br><span class="line">section_text                 = PE.Section(<span class="string">&quot;.text&quot;</span>)</span><br><span class="line">section_text.content         = code</span><br><span class="line">section_text.virtual_address = <span class="number">0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PE 的 .data section </span></span><br><span class="line">section_data                 = PE.Section(<span class="string">&quot;.data&quot;</span>)</span><br><span class="line">section_data.content         = data</span><br><span class="line">section_data.virtual_address = <span class="number">0x2000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 section</span></span><br><span class="line">section_text = binary32.add_section(section_text, PE.SECTION_TYPES.TEXT)</span><br><span class="line">section_data = binary32.add_section(section_data, PE.SECTION_TYPES.DATA)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(section_text)</span><br><span class="line"><span class="built_in">print</span>(section_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 PE 文件的入口点为 section_text 也即 .text section</span></span><br><span class="line">binary32.optional_header.addressof_entrypoint = section_text.virtual_address</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加库和导入函数</span></span><br><span class="line">kernel32 = binary32.add_library(<span class="string">&quot;kernel32.dll&quot;</span>)</span><br><span class="line">kernel32.add_entry(<span class="string">&quot;ExitProcess&quot;</span>)</span><br><span class="line"></span><br><span class="line">user32 = binary32.add_library(<span class="string">&quot;user32.dll&quot;</span>)</span><br><span class="line">user32.add_entry(<span class="string">&quot;MessageBoxA&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测函数加载到内存后的地址</span></span><br><span class="line">ExitProcess_addr = binary32.predict_function_rva(<span class="string">&quot;kernel32.dll&quot;</span>, <span class="string">&quot;ExitProcess&quot;</span>)</span><br><span class="line">MessageBoxA_addr = binary32.predict_function_rva(<span class="string">&quot;user32.dll&quot;</span>, <span class="string">&quot;MessageBoxA&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Address of &#x27;ExitProcess&#x27;: 0x&#123;:06x&#125; &quot;</span>.<span class="built_in">format</span>(ExitProcess_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Address of &#x27;MessageBoxA&#x27;: 0x&#123;:06x&#125; &quot;</span>.<span class="built_in">format</span>(MessageBoxA_addr))</span><br><span class="line"></span><br><span class="line">builder = PE.Builder(binary32)</span><br><span class="line">builder.build_imports(<span class="literal">True</span>)</span><br><span class="line">builder.build()</span><br><span class="line">builder.write(<span class="string">&quot;pe_from_scratch.exe&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-Play-with-ELF-symbols"><a href="#3-Play-with-ELF-symbols" class="headerlink" title="3. Play with ELF symbols"></a>3. Play with ELF symbols</h2><p>修改ELF文件符号。（由于目前关注的是PE文件，暂时跳过这一节）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/12/Pesidious/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/12/Pesidious/" class="post-title-link" itemprop="url">Pesidious</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-12 16:13:26 / 修改时间：17:00:59" itemprop="dateCreated datePublished" datetime="2024-04-12T16:13:26+08:00">2024-04-12</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Pesidious"><a href="#Pesidious" class="headerlink" title="Pesidious"></a>Pesidious</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction:"></a>Introduction:</h2><p>Pesidious 是一款开源工具，它使用生成对抗网络 (GAN) 和强化学习 (RL) 来生成可以逃避下一代人工智能防病毒扫描程序的变异恶意软件。</p>
<ul>
<li>样本恶意软件分类器：该工具经过训练可以变异恶意软件，从而可以逃避使用梯度增强算法对恶意软件和良性文件进行分类的样本分类器。</li>
<li>GAN 生成看起来良性的部分和导入：GAN 已用于生成可以使恶意软件看起来更良性的部分和导入。</li>
<li>强化学习模型：强化学习模型经过训练，可以选择最佳的突变序列，包括上述部分和导入内容以及其他部分，以欺骗恶意软件分类器。</li>
</ul>
<p><img src="/../images/Pesidious/%E6%88%AA%E5%B1%8F2024-04-12%2016.18.32.png" alt="截屏2024-04-12 16.18.32"></p>
<h2 id="Train-Models-optional"><a href="#Train-Models-optional" class="headerlink" title="Train Models (optional)"></a>Train Models (optional)</h2><p>该工具使用两种模型来变异恶意软件，以增加规避性并维护功能。</p>
<ul>
<li>生成对抗网络用于为恶意软件样本生成看起来良性的导入和部分。</li>
<li>强化学习用于训练代理为恶意软件样本选择最佳突变序列，以逃避分类器。</li>
</ul>
<h3 id="Step-1-Train-Generative-Adversarial-Network-GAN"><a href="#Step-1-Train-Generative-Adversarial-Network-GAN" class="headerlink" title="Step 1: Train Generative Adversarial Network (GAN)"></a>Step 1: Train Generative Adversarial Network (GAN)</h3><p>生成对抗性网络训练模型可以分为以下部分：</p>
<p><strong>Feature Extraction Component（特征提取组件）</strong>: </p>
<p>特征提取组件对于让我们的人工智能模型理解二进制文件所拥有的特征的更简单表示至关重要。</p>
<p><strong>特征</strong> - 提取出的二进制文件中最相关的组成部分包括：</p>
<ul>
<li><strong>节名称（Section names）</strong></li>
<li><strong>导入库和函数（Import libraries and functions）</strong></li>
</ul>
<p><strong>特征向量映射（Feature Vector Map）</strong>- 所有独特的特征都被存储在一个映射中。</p>
<p><strong>二进制特征向量（Binary Feature Vectors）</strong>- 随后，二进制文件通过使用特征向量映射被转换为二进制表示形式。</p>
<p><strong>Table 1: Simplified representation of feature vector map</strong></p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Index</th>
</tr>
</thead>
<tbody><tr>
<td>ConversionListA : inn32.dll</td>
<td>1</td>
</tr>
<tr>
<td>OdQueryStringA : user32.dll</td>
<td>2</td>
</tr>
<tr>
<td>GetTabbedTextExtentA : user32.dll</td>
<td>3</td>
</tr>
<tr>
<td>…</td>
<td>4</td>
</tr>
<tr>
<td>…</td>
<td>5</td>
</tr>
<tr>
<td>…</td>
<td>6</td>
</tr>
<tr>
<td><function_name><dll name></td>
<td>7</td>
</tr>
</tbody></table>
<p><strong>Table 2: Simplified representation of a binary feature vector</strong></p>
<table>
<thead>
<tr>
<th>Feature Index</th>
<th>Boolean</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>0</td>
</tr>
<tr>
<td><feature_index></td>
<td>&lt;Exist&#x2F;Doesn’t Exist&gt;</td>
</tr>
</tbody></table>
<p> <strong>Adversarial Features Generation Component（对抗性特征生成组件）</strong>:</p>
<p>一旦我们对二进制文件有了更简单的表示，我们就可以用它来训练我们的生成对抗网络（GAN）。我们的GAN包括三个组成部分：</p>
<ul>
<li><strong>生成器</strong> - 这是一个人工智能模型，负责生成看起来良性的特征，同时尝试保留恶意功能。</li>
<li><strong>检测器</strong> - 这是一个人工智能模型，负责检测生成器输出的内容是恶意的还是良性的。然后检测器向生成器提供反馈，以便它在下一次迭代中进行改进。</li>
<li><strong>黑盒检测器</strong> - 这个组件使用在杀毒软件中用于分类生成器输出的人工智能模型进行训练，帮助检测器做出决策。</li>
</ul>
<h3 id="Step-2-Train-Reinforcement-Learning-RL-Agent"><a href="#Step-2-Train-Reinforcement-Learning-RL-Agent" class="headerlink" title="Step 2: Train Reinforcement Learning (RL) Agent"></a>Step 2: Train Reinforcement Learning (RL) Agent</h3><p>强化学习训练模块将包括以下内容：</p>
<ul>
<li><strong>恶意软件环境</strong> - 这是一个将帮助代理通过代理选择的变异来分类和评分变异样本的环境。</li>
<li><strong>代理</strong> - 一个神经网络模型，学习恶意软件样本的变异序列，这些变异可以逃避分类器的检测。</li>
<li><strong>突变</strong> - 当前工具中可用的各种变异如下：<ul>
<li>添加导入（查询GAN模型）</li>
<li>添加节（查询GAN模型）</li>
<li>向节中追加字节</li>
<li>重命名节</li>
<li>UPX打包</li>
<li>UPX解包</li>
<li>添加&#x2F;删除签名</li>
<li>追加随机数量的字节</li>
</ul>
</li>
<li><strong>分类器</strong> - 一个人工智能模型，能够接收一个二进制文件作为输入，并将其分类为恶意软件或良性文件。默认情况下，该工具使用一个样本梯度提升分类器。</li>
</ul>
<h2 id="Mutate-Malware"><a href="#Mutate-Malware" class="headerlink" title="Mutate Malware"></a>Mutate Malware</h2><p>这个工具可以用来创建能够逃避基于人工智能的分类器检测的变异恶意软件。</p>
<h3 id="Step-1-Get-the-original-scores-of-malware-samples-获取恶意软件样本的原始分数"><a href="#Step-1-Get-the-original-scores-of-malware-samples-获取恶意软件样本的原始分数" class="headerlink" title="Step 1: Get the original scores of malware samples 获取恶意软件样本的原始分数"></a>Step 1: Get the original scores of malware samples 获取恶意软件样本的原始分数</h3><p>为了评估工具生成的变异恶意软件的逃避能力，你可以首先使用分类器对恶意软件样本进行测试。</p>
<h3 id="Step-2-Mutate-malware-files-突变恶意文件"><a href="#Step-2-Mutate-malware-files-突变恶意文件" class="headerlink" title="Step 2: Mutate malware files 突变恶意文件"></a>Step 2: Mutate malware files 突变恶意文件</h3><p>这个工具配备了预训练模型，可以变异恶意软件以逃避内置的分类器。</p>
<h3 id="Step-3-Check-the-score-for-mutated-malware-检查变异后的恶意软件的分数"><a href="#Step-3-Check-the-score-for-mutated-malware-检查变异后的恶意软件的分数" class="headerlink" title="Step 3: Check the score for mutated malware 检查变异后的恶意软件的分数"></a>Step 3: Check the score for mutated malware 检查变异后的恶意软件的分数</h3><p>您可以再次运行分类器，但要对抗突变的恶意软件，并将其与第一步中检索到的原始分数进行比较 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/24/ifizz/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/24/ifizz/" class="post-title-link" itemprop="url">ifizz</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-24 13:34:51" itemprop="dateCreated datePublished" datetime="2024-03-24T13:34:51+08:00">2024-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-26 18:38:16" itemprop="dateModified" datetime="2024-03-26T18:38:16+08:00">2024-03-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>316</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="IFIZZ-Deep-State-and-Efficient-Fault-Scenario-Generation-to-Test-IoT-Firmware"><a href="#IFIZZ-Deep-State-and-Efficient-Fault-Scenario-Generation-to-Test-IoT-Firmware" class="headerlink" title="IFIZZ: Deep-State and Efficient Fault-Scenario Generation to Test IoT Firmware"></a>IFIZZ: Deep-State and Efficient Fault-Scenario Generation to Test IoT Firmware</h1><h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><ul>
<li>错误处理代码<code>(error-handling code)</code>由于难以被测试，其本身就是error-prone的</li>
<li>错误处理代码中的<code>bug</code>由于难以被探测，可能持续存在很长一段时间。</li>
<li>虽然已经存在像<code>fuzzing</code>的动态探测方法，但是他们在处理由输入无关错误触发的bug时有很大的局限性</li>
</ul>
<h2 id="问题：设计一个有效的错误注入方法用于测试IoT固件中的错误检测代码"><a href="#问题：设计一个有效的错误注入方法用于测试IoT固件中的错误检测代码" class="headerlink" title="问题：设计一个有效的错误注入方法用于测试IoT固件中的错误检测代码"></a>问题：设计一个有效的错误注入方法用于测试<code>IoT</code>固件中的错误检测代码</h2><ul>
<li><h3 id="挑战一：自动识别输入无关错误"><a href="#挑战一：自动识别输入无关错误" class="headerlink" title="挑战一：自动识别输入无关错误"></a>挑战一：自动识别输入无关错误</h3></li>
<li><h3 id="挑战二：测试深度的错误路径"><a href="#挑战二：测试深度的错误路径" class="headerlink" title="挑战二：测试深度的错误路径"></a>挑战二：测试深度的错误路径</h3></li>
</ul>
<h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><h3 id="自动鉴别输入无关错误："><a href="#自动鉴别输入无关错误：" class="headerlink" title="自动鉴别输入无关错误："></a>自动鉴别输入无关错误：</h3><ul>
<li>观察一：错误代码作为返回值，并且将会在调用函数中检查。</li>
<li></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/16/Lab-networking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/16/Lab-networking/" class="post-title-link" itemprop="url">Lab: networking</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-16 09:34:05" itemprop="dateCreated datePublished" datetime="2024-03-16T09:34:05+08:00">2024-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-17 12:58:11" itemprop="dateModified" datetime="2024-03-17T12:58:11+08:00">2024-03-17</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab-networking"><a href="#Lab-networking" class="headerlink" title="Lab: networking"></a>Lab: networking</h1><p>这个实验需要写一个<code>xv6</code>网络接口卡的设备驱动器。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>你需要使用E1000网络设备处理网络通信。对于xv6来说，E1000看起来就像是连接到真实以太网据局域网（LAN）的真实硬件。实际上，你的驱动程序将于之通信的E1000是由qemu提供的仿真，连接到的也是一个由qemu提供的仿真局域网。在这个仿真局域网上，xv6（作为客户机）的ip地址为10.0.2.15。qemu还安排运行qemu的计算机出现在局域网上，IP地址为10.0.2.2。当xv6使用E1000向10.0.2.2发送数据包时，qemu会将数据包递送到运行qemu的（真实）计算机上的适当应用程序（“宿主机”）。</p>
<p>你将使用qemu的用户模式网络栈。Qemu的文档有更多关于user-mode stack的信息。Makefile已经更新并支持QEMU的用户模式网络栈和E1000网卡。</p>
<p>Makefile 配置了 QEMU，以便将所有进出的数据包记录到实验目录中的 packets.pcap 文件。查看这些记录文件可能有助于确认 xv6 是否发送和接收了你期望的数据包。要显示记录的数据包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -XXnr packets.pcap</span><br></pre></td></tr></table></figure>

<p>为了这个实验，我们在 xv6 仓库中添加了一些文件。文件 <code>kernel/e1000.c</code> 包含了 E1000 的初始化代码，以及用于发送和接收数据包的空函数，你将填充这些函数。<code>kernel/e1000_dev.h</code> 包含由 E1000 定义的寄存器和标志位的定义，这些定义在 Intel E1000 软件开发者手册中有描述。<code>kernel/net.c</code> 和 <code>kernel/net.h</code> 包含了一个简单的网络栈，实现了 IP、UDP 和 ARP 协议。这些文件还包含了一种用于存放数据包的灵活数据结构的代码，称为 mbuf。最后，<code>kernel/pci.c</code> 包含了在 xv6 启动时搜索 PCI 总线上的 E1000 卡的代码。</p>
<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>你的任务是完成 <code>kernel/e1000.c</code> 中的 <code>e1000_transmit()</code> 和 <code>e1000_recv()</code> 函数，使得驱动程序能够发送和接收数据包。当 <code>make grade</code> 显示你的解决方案通过了所有测试时，说明你已经完成了任务。</p>
<blockquote>
<p>在编写代码时，你会发现自己需要参考 E1000 软件开发者手册。以下几个部分可能特别有帮助：</p>
<ul>
<li>第2节是必不可少的，提供了整个设备的概览。</li>
<li>第3.2节提供了数据包接收的概览。</li>
<li>第3.3节和第3.4节一起提供了数据包传输的概览。</li>
<li>第13节提供了 E1000 使用的寄存器的概览。</li>
<li>第14节可能会帮助你理解我们提供的初始化代码。</li>
</ul>
</blockquote>
<p>浏览 E1000 软件开发者手册。这份手册涵盖了几个密切相关的以太网控制器。QEMU 模拟的是 82540EM。现在先浏览第2章，以对设备有一个基本了解。为了编写你的驱动程序，你需要熟悉第3章和第14章，以及第4.1章（但不包括4.1章的小节）。你还需要将第13章作为参考。其他章节主要涵盖了你的驱动程序不需要交互的 E1000 的组件。首先不用担心细节；只需了解文档的结构，以便稍后可以找到所需的信息。E1000 有许多高级功能，其中大部分你可以忽略。只需要一小部分基本功能就可以完成这个实验。</p>
<p>我们在 <code>e1000.c</code> 中提供给你的 <code>e1000_init()</code> 函数配置了 E1000 从 RAM 读取要传输的数据包，并将接收到的数据包写入 RAM。这种技术称为 DMA，即直接内存访问，指的是 E1000 硬件直接向 RAM 读写数据包的事实。</p>
<p>由于数据包的突发可能比驱动程序能够处理的更快地到达，<code>e1000_init()</code> 为 E1000 提供了多个缓冲区，E1000 可以将数据包写入这些缓冲区。E1000 要求这些缓冲区通过 RAM 中的一个“描述符”数组来描述；每个描述符包含一个 RAM 中的地址，E1000 可以将接收到的数据包写入该地址。<code>struct rx_desc</code> 描述了描述符的格式。描述符数组被称为接收环或接收队列。从环形的角度来说，当卡或驱动到达数组的末尾时，它会回到开始的位置。<code>e1000_init()</code> 使用 <code>mbufalloc()</code> 为 E1000 分配 <code>mbuf</code> 数据包缓冲区以便 DMA 使用。还有一个发送环，驱动程序应将其希望 E1000 发送的数据包放置在其中。<code>e1000_init()</code> 配置这两个环的大小为 <code>RX_RING_SIZE</code> 和 <code>TX_RING_SIZE</code>。</p>
<p>当 <code>net.c</code> 中的网络栈需要发送数据包时，它会调用 <code>e1000_transmit()</code> 函数，并传入一个包含待发送数据包的 <code>mbuf</code>。你的传输代码必须将指向数据包数据的指针放置在 TX（发送）环的一个描述符中。<code>struct tx_desc</code> 描述了描述符的格式。你需要确保每个 <code>mbuf</code> 最终都被释放，但只有在 E1000 完成数据包传输后才能这么做（E1000 通过在描述符中设置 <code>E1000_TXD_STAT_DD</code> 位来指示这一点）。</p>
<p>当 E1000 从以太网接收到每个数据包时，它会通过直接内存访问（DMA）将数据包传输到 RX（接收）环描述符中的下一个 <code>addr</code> 指向的内存。如果 E1000 中断尚未挂起，E1000 会请求 PLIC 在启用中断后尽快交付一个中断。你的 <code>e1000_recv()</code> 代码必须扫描 RX 环，并通过调用 <code>net_rx()</code> 将每个新数据包的 <code>mbuf</code> 交给 <code>net.c</code> 中的网络栈。然后，你需要分配一个新的 <code>mbuf</code> 并将其放入描述符中，以便当 E1000 再次到达 RX 环的那一点时，它找到一个新的缓冲区，可以将新数据包通过 DMA 传输进去。</p>
<p>除了在 RAM 中读写描述符环，你的驱动程序还需要通过内存映射的控制寄存器与 E1000 交互，以检测何时有接收到的数据包可用，并通知 E1000 驱动程序已经填充了一些 TX 描述符，准备发送数据包。全局变量 <code>regs</code> 保存了一个指向 E1000 第一个控制寄存器的指针；你的驱动程序可以通过将 <code>regs</code> 作为数组进行索引来访问其他寄存器。你特别需要使用索引 <code>E1000_RDT</code> 和 <code>E1000_TDT</code>。</p>
<p>为了测试你的驱动程序，在一个窗口中运行 <code>make server</code>，在另一个窗口运行 <code>make qemu</code>，然后在 xv6 中运行 <code>nettests</code>。<code>nettests</code> 中的第一个测试尝试向宿主操作系统发送一个 UDP 数据包，地址指向 <code>make server</code> 运行的程序。如果你还没有完成实验，E1000 驱动程序实际上不会发送数据包，因此几乎没有什么会发生。</p>
<p>完成实验后，E1000 驱动程序将发送数据包，qemu 将把它传送到你的宿主计算机，<code>make server</code> 将看到它，它将发送一个响应数据包，然后 E1000 驱动程序和 <code>nettests</code> 将看到响应数据包。然而，在宿主发送回复之前，它会向 xv6 发送一个“ARP”请求数据包，以找出其 48 位以太网地址，并期望 xv6 用 ARP 回复进行响应。一旦你完成了 E1000 驱动程序的工作，<code>kernel/net.c</code> 将处理这个问题。如果一切顺利，<code>nettests</code> 将打印 <code>testing ping: OK</code>，而 <code>make server</code> 将打印一条来自 xv6 的消息！</p>
<p>tcpdump -XXnr packets.pcap should produce output that starts like this:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">reading from file packets.pcap, link-type EN10MB (Ethernet)</span><br><span class="line">15:27:40.861988 IP 10.0.2.15.2000 &gt; 10.0.2.2.25603: UDP, length 19</span><br><span class="line">        0x0000:  ffff ffff ffff 5254 0012 3456 0800 4500  ......RT..4V..E.</span><br><span class="line">        0x0010:  002f 0000 0000 6411 3eae 0a00 020f 0a00  ./....d.&gt;.......</span><br><span class="line">        0x0020:  0202 07d0 6403 001b 0000 6120 6d65 7373  ....d.....a.mess</span><br><span class="line">        0x0030:  6167 6520 6672 6f6d 2078 7636 21         age.from.xv6!</span><br><span class="line">15:27:40.862370 ARP, Request who-has 10.0.2.15 tell 10.0.2.2, length 28</span><br><span class="line">        0x0000:  ffff ffff ffff 5255 0a00 0202 0806 0001  ......RU........</span><br><span class="line">        0x0010:  0800 0604 0001 5255 0a00 0202 0a00 0202  ......RU........</span><br><span class="line">        0x0020:  0000 0000 0000 0a00 020f                 ..........</span><br><span class="line">15:27:40.862844 ARP, Reply 10.0.2.15 is-at 52:54:00:12:34:56, length 28</span><br><span class="line">        0x0000:  ffff ffff ffff 5254 0012 3456 0806 0001  ......RT..4V....</span><br><span class="line">        0x0010:  0800 0604 0002 5254 0012 3456 0a00 020f  ......RT..4V....</span><br><span class="line">        0x0020:  5255 0a00 0202 0a00 0202                 RU........</span><br><span class="line">15:27:40.863036 IP 10.0.2.2.25603 &gt; 10.0.2.15.2000: UDP, length 17</span><br><span class="line">        0x0000:  5254 0012 3456 5255 0a00 0202 0800 4500  RT..4VRU......E.</span><br><span class="line">        0x0010:  002d 0000 0000 4011 62b0 0a00 0202 0a00  .-....@.b.......</span><br><span class="line">        0x0020:  020f 6403 07d0 0019 3406 7468 6973 2069  ..d.....4.this.i</span><br><span class="line">        0x0030:  7320 7468 6520 686f 7374 21              s.the.host!</span><br></pre></td></tr></table></figure>

<p>你的输出会有些不同，但它应该包含字符串 “ARP, Request”（ARP 请求），”ARP, Reply”（ARP 回复），”UDP”，”a.message.from.xv6” 和 “this.is.the.host”。</p>
<p><code>nettests</code> 还执行了一些其他测试，最终通过（真实的）互联网向谷歌的某个域名服务器发送了一个 DNS 请求。你应该确保你的代码通过了所有这些测试，之后你应该会看到以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ nettests</span><br><span class="line">nettests running on port 25603</span><br><span class="line">testing ping: OK</span><br><span class="line">testing single-process pings: OK</span><br><span class="line">testing multi-process pings: OK</span><br><span class="line">testing DNS</span><br><span class="line">DNS arecord for pdos.csail.mit.edu. is 128.52.129.126</span><br><span class="line">DNS OK</span><br><span class="line">all tests passed.</span><br></pre></td></tr></table></figure>

<p>你应该确保让分数同意你的解决方案通过。</p>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>首先，在 <code>e1000_transmit()</code> 和 <code>e1000_recv()</code> 中添加打印语句，然后运行 <code>make server</code> 和（在 xv6 中）<code>nettests</code>。你应该从打印语句中看到 <code>nettests</code> 生成了对 <code>e1000_transmit</code> 的调用。实现 <code>e1000_transmit</code> 的一些提示：</p>
<ol>
<li>首先询问 E1000 下一个期望的数据包将放在 TX 环的哪个索引位置，通过读取 <code>E1000_TDT</code> 控制寄存器来实现。</li>
<li>然后检查环是否溢出。如果 <code>E1000_TDT</code> 索引的描述符中没有设置 <code>E1000_TXD_STAT_DD</code>，则 E1000 尚未完成相应的之前的传输请求，因此返回一个错误。</li>
<li>否则，使用 <code>mbuffree()</code> 释放从该描述符传输的最后一个 <code>mbuf</code>（如果有的话）。</li>
<li>然后填写描述符。<code>m-&gt;head</code> 指向内存中数据包的内容，<code>m-&gt;len</code> 是数据包长度。设置必要的 cmd 标志（查看 E1000 手册的第 3.3 节）并保存一个指向 <code>mbuf</code> 的指针以便以后释放。</li>
<li>最后，通过向 <code>E1000_TDT</code> 加一模 <code>TX_RING_SIZE</code> 来更新环位置。</li>
<li>如果 <code>e1000_transmit()</code> 成功将 <code>mbuf</code> 添加到环中，则返回 0。如果失败（例如，没有可用的描述符来传输 <code>mbuf</code>），则返回 -1，以便调用者知道要释放 <code>mbuf</code>。</li>
</ol>
<p>实现 <code>e1000_recv</code> 的一些提示：</p>
<ol>
<li>首先通过获取 <code>E1000_RDT</code> 控制寄存器并加一模 <code>RX_RING_SIZE</code> 来询问 E1000 下一个等待接收的数据包（如果有的话）位于环的哪个索引位置。</li>
<li>然后通过检查描述符的状态部分中的 <code>E1000_RXD_STAT_DD</code> 位来检查是否有新数据包可用。如果没有，停止。</li>
<li>否则，将 <code>mbuf</code> 的 <code>m-&gt;len</code> 更新为描述符报告的长度。使用 <code>net_rx()</code> 将 <code>mbuf</code> 交给网络栈。</li>
<li>然后使用 <code>mbufalloc()</code> 分配一个新的 <code>mbuf</code> 来替换刚刚给 <code>net_rx()</code> 的那个。将其数据指针（<code>m-&gt;head</code>）编程到描述符中。将描述符的状态位清零。</li>
<li>最后，将 <code>E1000_RDT</code> 寄存器更新为最后处理的环描述符的索引。</li>
</ol>
<p><code>e1000_init()</code> 使用 <code>mbufs</code> 初始化 RX 环，你将需要查看它是如何做到的，并可能借用代码。在某个时刻，到达的数据包总数将超过环的大小（16）；确保你的代码能够处理这个情况。你将需要锁来应对 xv6 可能从多个进程使用 E1000，或者在中断到达时在内核线程中使用 E1000 的可能性。</p>
<h2 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h2><p>跟着提示一步一步的走就好</p>
<h3 id="E1000-transmit"><a href="#E1000-transmit" class="headerlink" title="E1000_transmit"></a>E1000_transmit</h3><h4 id="1-首先询问-E1000-下一个期望的数据包将放在-TX-环的哪个索引位置，通过读取-E1000-TDT-控制寄存器来实现。"><a href="#1-首先询问-E1000-下一个期望的数据包将放在-TX-环的哪个索引位置，通过读取-E1000-TDT-控制寄存器来实现。" class="headerlink" title="1.首先询问 E1000 下一个期望的数据包将放在 TX 环的哪个索引位置，通过读取 E1000_TDT 控制寄存器来实现。"></a>1.首先询问 E1000 下一个期望的数据包将放在 TX 环的哪个索引位置，通过读取 <code>E1000_TDT</code> 控制寄存器来实现。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acquire(&amp;e1000_lock); <span class="comment">// 请求锁</span></span><br><span class="line"><span class="type">int</span> index = regs[E1000_TDT]; <span class="comment">// 寄存器 E1000_TDT 中存储了第一个软件可以写入的描述符的位置</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span> * <span class="title">tail_desc</span> =</span> &amp; tx_ring[index]; <span class="comment">// 拿到可用的文件描述符</span></span><br></pre></td></tr></table></figure>

<h4 id="2-然后检查环是否溢出。如果-E1000-TDT-索引的描述符中没有设置-E1000-TXD-STAT-DD，则-E1000-尚未完成相应的之前的传输请求，因此返回一个错误。"><a href="#2-然后检查环是否溢出。如果-E1000-TDT-索引的描述符中没有设置-E1000-TXD-STAT-DD，则-E1000-尚未完成相应的之前的传输请求，因此返回一个错误。" class="headerlink" title="2.然后检查环是否溢出。如果 E1000_TDT 索引的描述符中没有设置 E1000_TXD_STAT_DD，则 E1000 尚未完成相应的之前的传输请求，因此返回一个错误。"></a>2.然后检查环是否溢出。如果 <code>E1000_TDT</code> 索引的描述符中没有设置 <code>E1000_TXD_STAT_DD</code>，则 E1000 尚未完成相应的之前的传输请求，因此返回一个错误。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((tail_desc-&gt;status &amp; E1000_TXD_STAT_DD) == <span class="number">0</span>) &#123; </span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-否则，使用-mbuffree-释放从该描述符传输的最后一个-mbuf（如果有的话）。"><a href="#3-否则，使用-mbuffree-释放从该描述符传输的最后一个-mbuf（如果有的话）。" class="headerlink" title="3.否则，使用 mbuffree() 释放从该描述符传输的最后一个 mbuf（如果有的话）。"></a>3.否则，使用 <code>mbuffree()</code> 释放从该描述符传输的最后一个 <code>mbuf</code>（如果有的话）。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tx_mbufs[index]) &#123;</span><br><span class="line">  mbuffree(tx_mbufs[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-然后填写描述符。m-gt-head-指向内存中数据包的内容，m-gt-len-是数据包长度。设置必要的-cmd-标志（查看-E1000-手册的第-3-3-节）并保存一个指向-mbuf-的指针以便以后释放。"><a href="#4-然后填写描述符。m-gt-head-指向内存中数据包的内容，m-gt-len-是数据包长度。设置必要的-cmd-标志（查看-E1000-手册的第-3-3-节）并保存一个指向-mbuf-的指针以便以后释放。" class="headerlink" title="4.然后填写描述符。m-&gt;head 指向内存中数据包的内容，m-&gt;len 是数据包长度。设置必要的 cmd 标志（查看 E1000 手册的第 3.3 节）并保存一个指向 mbuf 的指针以便以后释放。"></a>4.然后填写描述符。<code>m-&gt;head</code> 指向内存中数据包的内容，<code>m-&gt;len</code> 是数据包长度。设置必要的 cmd 标志（查看 E1000 手册的第 3.3 节）并保存一个指向 <code>mbuf</code> 的指针以便以后释放。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail_desc-&gt;length = m-&gt;len; <span class="comment">// 数据包的长度</span></span><br><span class="line">tail_desc-&gt;addr = (uint64)m-&gt;head; <span class="comment">// 数据包在缓存中的起始位置</span></span><br><span class="line">tail_desc-&gt;cmd |= E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS; <span class="comment">// cmd位，end of packet, report status</span></span><br></pre></td></tr></table></figure>

<h4 id="5-最后，将-E1000-RDT-寄存器更新为最后处理的环描述符的索引。"><a href="#5-最后，将-E1000-RDT-寄存器更新为最后处理的环描述符的索引。" class="headerlink" title="5.最后，将 E1000_RDT 寄存器更新为最后处理的环描述符的索引。"></a>5.最后，将 <code>E1000_RDT</code> 寄存器更新为最后处理的环描述符的索引。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">regs[E1000_RDT] = (index + <span class="number">1</span>) % tx_ring; <span class="comment">// 更新index</span></span><br><span class="line">release(&amp;e1000_lock); <span class="comment">// 释放锁</span></span><br></pre></td></tr></table></figure>

<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">e1000_transmit</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// the mbuf contains an ethernet frame; program it into</span></span><br><span class="line">  <span class="comment">// the TX descriptor ring so that the e1000 sends it. Stash</span></span><br><span class="line">  <span class="comment">// a pointer so that it can be freed after sending.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  acquire(&amp;e1000_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * todo: ask the E1000 for the TX ring index at which it&#x27;s expecting the next packet</span></span><br><span class="line"><span class="comment">   * E1000_TDT 指向 tx_ring 中下一个可以被分配的 descriptor 的索引</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> index = regs[E1000_TDT];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span>* <span class="title">tail_desc</span> =</span> &amp;tx_ring[index];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * todo: check if the ring is overflow</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">  <span class="keyword">if</span>((tail_desc-&gt;status &amp; E1000_TXD_STAT_DD) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//      printf(&quot;tx_ring buffer is overflow\n&quot;);</span></span><br><span class="line">      release(&amp;e1000_lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * todo: use mbuffree() to free the last mbuf that was transmitted from that descriptor</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">  <span class="keyword">if</span>(tx_mbufs[index]) &#123;</span><br><span class="line">      mbuffree(tx_mbufs[index]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// todo: m-&gt;head points to the packet&#x27;s content in memory,</span></span><br><span class="line">  tail_desc-&gt;addr = (uint64)(m-&gt;head);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// todo: m-&gt;len is the packet length</span></span><br><span class="line">  tail_desc-&gt;length = m-&gt;len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// todo: set the necessary cmd flag (look at Section 3.3 in the E1000 manual)</span></span><br><span class="line">  tail_desc-&gt;cmd |= E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// todo: stash away a pointer to the mbuf for later freeing.</span></span><br><span class="line">  tx_mbufs[index] = m;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// todo: update the E1000_TDT</span></span><br><span class="line">  regs[E1000_TDT] = (index + <span class="number">1</span>) % TX_RING_SIZE;</span><br><span class="line">  <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="E1000-recv"><a href="#E1000-recv" class="headerlink" title="E1000_recv"></a>E1000_recv</h3><p>我们要注意的是，在接收数据包时，不是一个一个接收的，所以我们要不断更新index，需要接收的包都接收完毕为止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"> ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-首先通过获取-E1000-RDT-控制寄存器并加一模-RX-RING-SIZE-来询问-E1000-下一个等待接收的数据包（如果有的话）位于环的哪个索引位置。"><a href="#1-首先通过获取-E1000-RDT-控制寄存器并加一模-RX-RING-SIZE-来询问-E1000-下一个等待接收的数据包（如果有的话）位于环的哪个索引位置。" class="headerlink" title="1.首先通过获取 E1000_RDT 控制寄存器并加一模 RX_RING_SIZE 来询问 E1000 下一个等待接收的数据包（如果有的话）位于环的哪个索引位置。"></a>1.首先通过获取 <code>E1000_RDT</code> 控制寄存器并加一模 <code>RX_RING_SIZE</code> 来询问 E1000 下一个等待接收的数据包（如果有的话）位于环的哪个索引位置。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint32 index = (regs[E1000_RDT] + <span class="number">1</span>) % RX_RING_SIZE; <span class="comment">// fetch the index</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rx_desc</span> *<span class="title">des</span> =</span> &amp;rx_ring[index]; <span class="comment">// fetch the desc</span></span><br></pre></td></tr></table></figure>

<h4 id="2-然后通过检查描述符的状态部分中的-E1000-RXD-STAT-DD-位来检查是否有新数据包可用。如果没有，停止。"><a href="#2-然后通过检查描述符的状态部分中的-E1000-RXD-STAT-DD-位来检查是否有新数据包可用。如果没有，停止。" class="headerlink" title="2.然后通过检查描述符的状态部分中的 E1000_RXD_STAT_DD 位来检查是否有新数据包可用。如果没有，停止。"></a>2.然后通过检查描述符的状态部分中的 <code>E1000_RXD_STAT_DD</code> 位来检查是否有新数据包可用。如果没有，停止。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(des-&gt;status &amp; E1000_RXD_STAT_DD)) &#123; <span class="comment">// 如果当前描述符的状态为不可用，则停止</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-否则，将-mbuf-的-m-gt-len-更新为描述符报告的长度。使用-net-rx-将-mbuf-交给网络栈。"><a href="#3-否则，将-mbuf-的-m-gt-len-更新为描述符报告的长度。使用-net-rx-将-mbuf-交给网络栈。" class="headerlink" title="3.否则，将 mbuf 的 m-&gt;len 更新为描述符报告的长度。使用 net_rx() 将 mbuf 交给网络栈。"></a>3.否则，将 <code>mbuf</code> 的 <code>m-&gt;len</code> 更新为描述符报告的长度。使用 <code>net_rx()</code> 将 <code>mbuf</code> 交给网络栈。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">buf</span> =</span> rx_mbufs[index];</span><br><span class="line">buf-&gt;len = des-&gt;length;</span><br><span class="line">net_rx(buf);</span><br></pre></td></tr></table></figure>

<h4 id="4-然后使用-mbufalloc-分配一个新的-mbuf-来替换刚刚给-net-rx-的那个。将其数据指针（m-gt-head）编程到描述符中。将描述符的状态位清零。"><a href="#4-然后使用-mbufalloc-分配一个新的-mbuf-来替换刚刚给-net-rx-的那个。将其数据指针（m-gt-head）编程到描述符中。将描述符的状态位清零。" class="headerlink" title="4.然后使用 mbufalloc() 分配一个新的 mbuf 来替换刚刚给 net_rx() 的那个。将其数据指针（m-&gt;head）编程到描述符中。将描述符的状态位清零。"></a>4.然后使用 <code>mbufalloc()</code> 分配一个新的 <code>mbuf</code> 来替换刚刚给 <code>net_rx()</code> 的那个。将其数据指针（<code>m-&gt;head</code>）编程到描述符中。将描述符的状态位清零。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">new_buf</span> =</span> mbufalloc(<span class="number">0</span>);</span><br><span class="line">rx_mbufs[index] = new_buf;</span><br><span class="line">des-&gt;addr = (uint64)new_buf-&gt;head;</span><br><span class="line">des-&gt;status = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="5-最后，将-E1000-RDT-寄存器更新为最后处理的环描述符的索引。-1"><a href="#5-最后，将-E1000-RDT-寄存器更新为最后处理的环描述符的索引。-1" class="headerlink" title="5.最后，将 E1000_RDT 寄存器更新为最后处理的环描述符的索引。"></a>5.最后，将 <code>E1000_RDT</code> 寄存器更新为最后处理的环描述符的索引。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regs[E1000_RDT] = index;</span><br></pre></td></tr></table></figure>

<h4 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">e1000_recv</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Check for packets that have arrived from the e1000</span></span><br><span class="line">  <span class="comment">// Create and deliver an mbuf for each packet (using net_rx()).</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// todo: First ask the E1000 for the ring index at which the next waiting received packet (if any) is located,</span></span><br><span class="line">      <span class="comment">// todo: by fetching the E1000_RDT control register and adding one modulo RX_RING_SIZE.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">// todo: check if a new packet is available by checking for the E1000_RXD_STAT_DD bit in the status portion of the descriptor.</span></span><br><span class="line">      uint32 index = (regs[E1000_RDT] + <span class="number">1</span>) % RX_RING_SIZE; <span class="comment">// fetch the index</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">rx_desc</span> *<span class="title">des</span> =</span> &amp;rx_ring[index];</span><br><span class="line">      <span class="keyword">if</span>(!(des-&gt;status &amp; E1000_RXD_STAT_DD)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// todo: update the mbuf&#x27;s m-&gt;len to the length reported in the descriptor. Deliver the mbuf to the network stack using net_rx().</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">buf</span> =</span> rx_mbufs[index];</span><br><span class="line">      buf-&gt;len = des-&gt;length;</span><br><span class="line">      net_rx(buf);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// todo: Then allocate a new mbuf using mbufalloc() to replace the one just given to net_rx().</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">new_buf</span> =</span> mbufalloc(<span class="number">0</span>);</span><br><span class="line">      rx_mbufs[index] = new_buf;</span><br><span class="line">      <span class="comment">// todo: Program its data pointer (m-&gt;head) into the descriptor. Clear the descriptor&#x27;s status bits to zero.</span></span><br><span class="line">      des-&gt;addr = (uint64)new_buf-&gt;head;</span><br><span class="line">      des-&gt;status = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// todo: Finally, update the E1000_RDT register to be the index of the last ring descriptor processed.</span></span><br><span class="line">      regs[E1000_RDT] = index;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/15/Lab-Multithreading/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/15/Lab-Multithreading/" class="post-title-link" itemprop="url">Lab: Multithreading
</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-15 11:40:44" itemprop="dateCreated datePublished" datetime="2024-03-15T11:40:44+08:00">2024-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-17 11:29:05" itemprop="dateModified" datetime="2024-03-17T11:29:05+08:00">2024-03-17</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab-Multithreading"><a href="#Lab-Multithreading" class="headerlink" title="Lab: Multithreading"></a>Lab: Multithreading</h1><p>这个实验室将帮助你熟悉多线程编程。你将在用户级线程包中实现线程间的切换，使用多个线程加速程序，并实现一个屏障。</p>
<h2 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h2><p>在这个练习中，你将为用户级线程系统设计上下文切换机制，并实现它。为了帮助你开始，你的 xv6 包含两个文件：user&#x2F;uthread.c 和 user&#x2F;uthread_switch.S，以及 Makefile 中构建 uthread 程序的规则。uthread.c 包含了大部分用户级线程包的代码，以及三个简单测试线程的代码。线程包缺少一些创建线程和线程间切换的代码。</p>
<blockquote>
<p>你的任务是制定一个计划来创建线程，并保存&#x2F;恢复寄存器以便于线程间切换，然后实现该计划。完成后，运行 make grade 应该会显示你的解决方案通过了 uthread 测试。</p>
</blockquote>
<p>一旦你完成了任务，当你在 xv6 上运行 uthread 时，你应该会看到以下输出（三个线程可能会以不同的顺序启动）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make qemu</span></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">uthread</span></span><br><span class="line">thread_a started</span><br><span class="line">thread_b started</span><br><span class="line">thread_c started</span><br><span class="line">thread_c 0</span><br><span class="line">thread_a 0</span><br><span class="line">thread_b 0</span><br><span class="line">thread_c 1</span><br><span class="line">thread_a 1</span><br><span class="line">thread_b 1</span><br><span class="line">...</span><br><span class="line">thread_c 99</span><br><span class="line">thread_a 99</span><br><span class="line">thread_b 99</span><br><span class="line">thread_c: exit after 100</span><br><span class="line">thread_a: exit after 100</span><br><span class="line">thread_b: exit after 100</span><br><span class="line">thread_schedule: no runnable threads</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>

<p>这个输出来自三个测试线程，每个线程都有一个循环，打印一行，然后将 CPU 让给其他线程。</p>
<p>然而，在这一点上，由于没有上下文切换代码，你将看不到任何输出。</p>
<p>你需要在 <code>user/uthread.c</code> 中的 <code>thread_create()</code> 和 <code>thread_schedule()</code> 以及 <code>user/uthread_switch.S</code> 中的 <code>thread_switch</code> 添加代码。一个目标是确保当 <code>thread_schedule()</code> 首次运行给定线程时，该线程在自己的栈上执行传递给 <code>thread_create()</code> 的函数。另一个目标是确保 <code>thread_switch</code> 保存被切换的线程的寄存器，恢复被切换到的线程的寄存器，并返回到后者线程的指令中它上次停止的点。你将需要决定在哪里保存&#x2F;恢复寄存器；修改 <code>struct thread</code> 来保存寄存器是一个好计划。你需要在 <code>thread_schedule</code> 中添加对 <code>thread_switch</code> 的调用；你可以传递任何你需要的参数给 <code>thread_switch</code>，但意图是从线程 <code>t</code> 切换到 <code>next_thread</code>。</p>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul>
<li><p><code>thread_switch</code>只需要保存&#x2F;恢复<code>callee-save registers</code>。为什么？</p>
</li>
<li><p>在<code>user/uthread.asm</code>，你可以查看<code>uthread</code>的汇编代码，这可能对调试很方便。</p>
</li>
<li><p>检测代码可以单步执行<code>thread_switch</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) file user/_uthread</span><br><span class="line">Reading symbols from user/_uthread...</span><br><span class="line">(gdb) b uthread.c:60</span><br></pre></td></tr></table></figure>

<p>这在uthread.c的第60行设置了一个断点。断点可能会在您运行uthread之前触发（也可能不会）触发。这怎么可能发生？</p>
<p>一旦你的 xv6 shell 运行起来，输入 “uthread”，gdb 将会在第60行处中断。如果你从另一个进程中击中了断点，继续进行，直到在 uthread 进程中击中断点。现在，你可以输入如下命令来检查 uthread 的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p/x *next_thread</span><br></pre></td></tr></table></figure>

<p>使用 “x”，你可以检查内存位置的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/x next_thread-&gt;stack</span><br></pre></td></tr></table></figure>

<p>你可以这样跳到 thread_switch 的开始部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b thread_switch</span><br><span class="line">(gdb) c</span><br></pre></td></tr></table></figure>

<p>You can single step assembly instructions using:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) si</span><br></pre></td></tr></table></figure>

<p>On-line documentation for gdb is here.</p>
</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><code>thread</code>的本质就是共享内存的<code>process</code>，因此我们可以根据<code>process</code>中对应的<code>swtch.S</code>，<code>allocpro()</code>，<code>struct context context</code>进行修改即可。</p>
<p><code>struct context</code>中直接声明了我们需要保存的<code>callee-saved register</code>，直接将定义搬到<code>uthread.c</code>中，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Saved registers for kernel context switches.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>并为<code>struct thread</code>添加相应字段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>       <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/* the thread&#x27;s stack */</span></span><br><span class="line">  <span class="type">int</span>        state;             <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>       <span class="comment">/* the thread&#x27;s context */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>直接将<code>switch.S</code>复制到<code>uthread_switch.c</code>中，并在<code>thread_schedule()</code>中添加：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread_switch((uint64)&amp;(t-&gt;context), (uint64)&amp;(current_thread-&gt;context));</span><br></pre></td></tr></table></figure>

<h2 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h2><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/12/xv6-interrputs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/12/xv6-interrputs/" class="post-title-link" itemprop="url">xv6-interrputs</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-12 18:59:14 / 修改时间：19:00:11" itemprop="dateCreated datePublished" datetime="2024-03-12T18:59:14+08:00">2024-03-12</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="theLonging"
      src="/images/touxiang.JPG">
  <p class="site-author-name" itemprop="name">theLonging</p>
  <div class="site-description" itemprop="description">不捨晝夜。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/chantchanH7" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chantchanH7" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/562879980@qq.com" title="E-Mail → 562879980@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-07 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">theLonging</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">362k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:29</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
