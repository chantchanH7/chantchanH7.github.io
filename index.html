<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="不捨晝夜。">
<meta property="og:type" content="website">
<meta property="og:title" content="talk is cheap, show me the code.">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="talk is cheap, show me the code.">
<meta property="og:description" content="不捨晝夜。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="theLonging">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>talk is cheap, show me the code.</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">talk is cheap, show me the code.</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/08/Lab-Copy-on-Write-Fork-for-xv6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/08/Lab-Copy-on-Write-Fork-for-xv6/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-08 16:31:49" itemprop="dateCreated datePublished" datetime="2024-03-08T16:31:49+08:00">2024-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 15:00:21" itemprop="dateModified" datetime="2024-03-12T15:00:21+08:00">2024-03-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>30k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>27 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<h2 id="title-‘Lab-Copy-on-Write-Fork-for-xv6’-date-2024-03-08-16-31-49-tags"><a href="#title-‘Lab-Copy-on-Write-Fork-for-xv6’-date-2024-03-08-16-31-49-tags" class="headerlink" title="  title: ‘Lab: Copy-on-Write Fork for xv6’  date: 2024-03-08 16:31:49  tags:"></a>  title: ‘Lab: Copy-on-Write Fork for xv6’<br>  date: 2024-03-08 16:31:49<br>  tags:</h2><h1 id="Lab-Copy-on-Write-Fork-for-xv6"><a href="#Lab-Copy-on-Write-Fork-for-xv6" class="headerlink" title="Lab: Copy-on-Write Fork for xv6"></a>Lab: Copy-on-Write Fork for xv6</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们先说一下整个流程</p>
<p>设备驱动器也会产生中断，这也是一种陷阱。</p>
<p>许多设备驱动器在两种上下文中执行代码：</p>
<ul>
<li><code>top half</code>运行在进程的内核线程上。上半部分是通过诸如read和write这样的系统调用来调用的，这些调用希望设备执行I&#x2F;O操作。</li>
<li><code>bottom half</code>是驱动器中断处理程序。</li>
</ul>
<h3 id="5-1-Code-Console-input"><a href="#5-1-Code-Console-input" class="headerlink" title="5.1 Code: Console input"></a>5.1 Code: Console input</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户键入字符 =&gt; RISC-V 上的 UART 串行接口 =&gt; console 驱动器 </span><br></pre></td></tr></table></figure>

<p><code>UART</code>硬件对于软件来说是一组内存映射控制寄存器,<code>RISC-V</code>硬件有一些物理地址链接<code>UART</code>设备</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main() = call =&gt;		 	consoleinit 	   =&gt;</span><br><span class="line">            		 |initialize the UART|</span><br></pre></td></tr></table></figure>

<p><code>consoleinit</code>初始化UART硬件，配置<code>UART</code>在接收到字节输入时，产生一个接收中断<code>receive interrupt</code>；在完成输出一个字节的数据时，产生一个传输中断，<code>transmit interrput</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">init.c = open =&gt; file descriptor for console (fp)</span><br><span class="line"></span><br><span class="line">xv6 shell reads from fp</span><br><span class="line"></span><br><span class="line">= call =&gt; read() = invoke =&gt; consoleread() </span><br><span class="line"></span><br><span class="line">consoleread() wait for input arrive (via interrupt) and be buffered in cons.buf</span><br></pre></td></tr></table></figure>

<p>中断是如何产生的？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用户键入字符 =&gt; UART =&gt; 让RISC-V产生中断 =&gt; 激活xv6陷阱处理程序 trap handler</span><br><span class="line"></span><br><span class="line">trap handler = invoke =&gt; devintr() = 在 scause 寄存器中发现中断来自额外设备</span><br><span class="line"></span><br><span class="line">硬件唤醒 PLIC 告知哪个设备产生的中断，如果是UART devintr 调用 uartintr</span><br></pre></td></tr></table></figure>

<p>数据如何输入的？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uartintr = 从UART硬件的等待输入字符中读取并传输给 =&gt; consoleintr</span><br><span class="line"></span><br><span class="line">consoleintr 将输入的字符存入cons.buf中，直到一行输入完成。</span><br><span class="line"></span><br><span class="line">当一个新的行到达时，consoleintr 唤醒 consoleread</span><br></pre></td></tr></table></figure>



<h3 id="kernelvec-S"><a href="#kernelvec-S" class="headerlink" title="kernelvec.S:"></a><code>kernelvec.S</code>:</h3><h4 id="kernelvec"><a href="#kernelvec" class="headerlink" title="kernelvec"></a><code>kernelvec</code></h4><p>当处于<code>Supervisor mode</code>时，中断<code>interrupts</code>和异常<code>exception</code>会来到这里。</p>
<p>当前堆栈为<code>kernel stack</code>。将所有寄存器的值推入栈中，调用<code>kerneltrap()</code>，调用完成时恢复寄存器然后返回。</p>
<blockquote>
<p>这段注释是关于寄存器<code>tp</code>（Thread Pointer）的说明，它通常包含当前硬件线程的ID（hartid）。注释指出不使用<code>tp</code>寄存器的值，以防在中断或异常发生后处理器（CPU）发生了变化。</p>
<p>在多核心或多线程的CPU环境中，每个核心或线程有一个唯一的标识符，通常称为hartid。当一个核心或线程正在执行任务时，它可能会因为中断或调度策略而切换到另一个CPU。如果在中断处理或任务切换过程中代码依赖于特定的<code>tp</code>值，而这个值在不同的CPU之间是不同的，就可能出现问题。</p>
<p>因此，这段注释表明，由于可能会发生CPU切换，代码不应该假设<code>tp</code>寄存器中的hartid在处理过程中是不变的。这是在多核处理器环境中进行系统编程时需要注意的并发和一致性问题之一。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">.globl kerneltrap</span><br><span class="line">.globl kernelvec</span><br><span class="line">.align 4</span><br><span class="line">kernelvec:</span><br><span class="line">        # make room to save registers.</span><br><span class="line">        # 在栈中开辟空间</span><br><span class="line">        addi sp, sp, -256</span><br><span class="line"></span><br><span class="line">        # save the registers.</span><br><span class="line">        sd ra, 0(sp)</span><br><span class="line">        sd sp, 8(sp)	# 保存stack pointer</span><br><span class="line">        sd gp, 16(sp)</span><br><span class="line">        sd tp, 24(sp)</span><br><span class="line">        sd t0, 32(sp)</span><br><span class="line">        sd t1, 40(sp)</span><br><span class="line">        sd t2, 48(sp)</span><br><span class="line">        sd s0, 56(sp)</span><br><span class="line">        sd s1, 64(sp)</span><br><span class="line">        sd a0, 72(sp)</span><br><span class="line">        sd a1, 80(sp)</span><br><span class="line">        sd a2, 88(sp)</span><br><span class="line">        sd a3, 96(sp)</span><br><span class="line">        sd a4, 104(sp)</span><br><span class="line">        sd a5, 112(sp)</span><br><span class="line">        sd a6, 120(sp)</span><br><span class="line">        sd a7, 128(sp)</span><br><span class="line">        sd s2, 136(sp)</span><br><span class="line">        sd s3, 144(sp)</span><br><span class="line">        sd s4, 152(sp)</span><br><span class="line">        sd s5, 160(sp)</span><br><span class="line">        sd s6, 168(sp)</span><br><span class="line">        sd s7, 176(sp)</span><br><span class="line">        sd s8, 184(sp)</span><br><span class="line">        sd s9, 192(sp)</span><br><span class="line">        sd s10, 200(sp)</span><br><span class="line">        sd s11, 208(sp)</span><br><span class="line">        sd t3, 216(sp)</span><br><span class="line">        sd t4, 224(sp)</span><br><span class="line">        sd t5, 232(sp)</span><br><span class="line">        sd t6, 240(sp)</span><br><span class="line"></span><br><span class="line">        # call the C trap handler in trap.c</span><br><span class="line">        call kerneltrap</span><br><span class="line"></span><br><span class="line">        # restore registers.</span><br><span class="line">        ld ra, 0(sp)</span><br><span class="line">        ld sp, 8(sp)</span><br><span class="line">        ld gp, 16(sp)</span><br><span class="line">        # not tp (contains hartid), in case we moved CPUs</span><br><span class="line">        # thread pointer 是当前硬件线程的ID hartid</span><br><span class="line">        </span><br><span class="line">        ld t0, 32(sp)</span><br><span class="line">        ld t1, 40(sp)</span><br><span class="line">        ld t2, 48(sp)</span><br><span class="line">        ld s0, 56(sp)</span><br><span class="line">        ld s1, 64(sp)</span><br><span class="line">        ld a0, 72(sp)</span><br><span class="line">        ld a1, 80(sp)</span><br><span class="line">        ld a2, 88(sp)</span><br><span class="line">        ld a3, 96(sp)</span><br><span class="line">        ld a4, 104(sp)</span><br><span class="line">        ld a5, 112(sp)</span><br><span class="line">        ld a6, 120(sp)</span><br><span class="line">        ld a7, 128(sp)</span><br><span class="line">        ld s2, 136(sp)</span><br><span class="line">        ld s3, 144(sp)</span><br><span class="line">        ld s4, 152(sp)</span><br><span class="line">        ld s5, 160(sp)</span><br><span class="line">        ld s6, 168(sp)</span><br><span class="line">        ld s7, 176(sp)</span><br><span class="line">        ld s8, 184(sp)</span><br><span class="line">        ld s9, 192(sp)</span><br><span class="line">        ld s10, 200(sp)</span><br><span class="line">        ld s11, 208(sp)</span><br><span class="line">        ld t3, 216(sp)</span><br><span class="line">        ld t4, 224(sp)</span><br><span class="line">        ld t5, 232(sp)</span><br><span class="line">        ld t6, 240(sp)</span><br><span class="line"></span><br><span class="line">        addi sp, sp, 256</span><br><span class="line"></span><br><span class="line">        # return to whatever we were doing in the kernel.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>

<h4 id="timervec"><a href="#timervec" class="headerlink" title="timervec:"></a><code>timervec:</code></h4><p><code>start.c</code>已经设置了<code>mscratch</code>指向的地址：</p>
<ul>
<li><code>scratch[0, 8, 16]:</code>存储寄存器的值</li>
<li><code>scratch[24]:</code>保存了CLINT的<code>MTIMECMP</code>寄存器的地址。<code>MTIMECMP</code>寄存器用于设置RISC-V系统的定时器中断阈值。</li>
<li><code>scratch[32]:</code>保存中断之间的期望时间间隔</li>
</ul>
<p>**<code>MTIMECMP</code>**是一个RISC-V架构中的一个定时寄存器，其全称为<code>Machine Time Compare Register</code>，该寄存器是<code>RISC-V</code>的机器模式定时器的一部分，用于设置下一个定时器中断的时间阈值。</p>
<p>工作原理：</p>
<ul>
<li>RISC-V 的 <code>mtime</code> 寄存器持续增加，它通常代表着机器的实时计数器，按照固定的频率（通常与处理器的时钟频率一致）递增。</li>
<li>当 <code>mtime</code> 的值等于或超过 <code>MTIMECMP</code> 寄存器中设置的值时，会触发一个定时器中断。</li>
<li>中断服务程序可以通过设置 <code>MTIMECMP</code> 为 <code>mtime</code> 当前值加上期望的延迟，来安排下一次中断。</li>
</ul>
<p>在多核 RISC-V 系统中，每个处理器核心（hart）通常有它自己的 <code>MTIMECMP</code> 寄存器，允许独立地为每个核心安排中断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># machine-mode timer interrupt.</span><br><span class="line">#</span><br><span class="line">.globl timervec</span><br><span class="line">.align 4</span><br><span class="line">timervec:</span><br><span class="line">        # start.c has set up the memory that mscratch points to:</span><br><span class="line">        # scratch[0,8,16] : register save area.</span><br><span class="line">        # scratch[24] : address of CLINT&#x27;s MTIMECMP register.</span><br><span class="line">        # scratch[32] : desired interval between interrupts.</span><br><span class="line">        </span><br><span class="line">        csrrw a0, mscratch, a0 # 读取mscratch寄存器的值到a0，并将a0的旧值写回mscratch</span><br><span class="line">        sd a1, 0(a0)</span><br><span class="line">        sd a2, 8(a0)</span><br><span class="line">        sd a3, 16(a0)</span><br><span class="line"></span><br><span class="line">        # schedule the next timer interrupt</span><br><span class="line">        # by adding interval to mtimecmp.</span><br><span class="line">        ld a1, 24(a0) # CLINT_MTIMECMP(hart)</span><br><span class="line">        ld a2, 32(a0) # interval</span><br><span class="line">        ld a3, 0(a1)  # 加载当前MTIMECMP的值到a3</span><br><span class="line">        add a3, a3, a2 # 将中断间隔时间加载到MTIMECMP上，准备下一个中断</span><br><span class="line">        sd a3, 0(a1) # 新的MTIMECMP存回到相应的内存位置</span><br><span class="line"></span><br><span class="line">        # arrange for a supervisor software interrupt</span><br><span class="line">        # after this handler returns.</span><br><span class="line">        li a1, 2 	# 2表示软件中断</span><br><span class="line">        csrw sip, a1 # 将软件中断请求写入sip寄存器中</span><br><span class="line"></span><br><span class="line">				# 恢复现场</span><br><span class="line">        ld a3, 16(a0)</span><br><span class="line">        ld a2, 8(a0)</span><br><span class="line">        ld a1, 0(a0)</span><br><span class="line">        csrrw a0, mscratch, a0</span><br><span class="line"></span><br><span class="line">        mret</span><br></pre></td></tr></table></figure>

<h3 id="plic-c-the-RISC-V-Platform-Level-Interrupt-Controller-PLIC"><a href="#plic-c-the-RISC-V-Platform-Level-Interrupt-Controller-PLIC" class="headerlink" title="plic.c: the RISC-V Platform Level Interrupt Controller (PLIC)"></a><code>plic.c:</code> the RISC-V Platform Level Interrupt Controller (PLIC)</h3><p>这段代码对应的硬件设备说明在<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2023/readings/FU540-C000-v1.0.pdf%E7%9A%8460%E9%A1%B5">https://pdos.csail.mit.edu/6.828/2023/readings/FU540-C000-v1.0.pdf的60页</a></p>
<p>给出了<code>PLIC Register Map</code></p>
<h4 id="plicinit"><a href="#plicinit" class="headerlink" title="plicinit():"></a><code>plicinit():</code></h4><ul>
<li><code>PLIC = 0x0c000000</code>是PLIC控制寄存器在物理内存中的起始地址。通过这个地址进行内存映射输入输出的操作。</li>
<li>设置UART0中断优先级</li>
<li>设为VIRTIO0设备的中断优先级</li>
<li>乘4是因为寄存器的值是32位的</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">plicinit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// set desired IRQ priorities non-zero (otherwise disabled).</span></span><br><span class="line">  	<span class="comment">// 设置中断请求优先级</span></span><br><span class="line">    *(uint32*)(PLIC + UART0_IRQ*<span class="number">4</span>) = <span class="number">1</span>;</span><br><span class="line">    *(uint32*)(PLIC + VIRTIO0_IRQ*<span class="number">4</span>) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="plicinithart"><a href="#plicinithart" class="headerlink" title="plicinithart():"></a><code>plicinithart():</code></h4><p>初始化了每个处理器核心（hart）在平台级中断控制器（PLIC）中的设置，具体操作包括启用特定的中断并设置优先级。</p>
<ul>
<li><p><code>PLIC_SENABLE(hart)</code>宏通过给定的核心编号（hart）和以上规则，计算出该核心对应到的<code>supervisor mode</code>中断启用寄存器的地址。</p>
<p>当<code>hart = 0</code>时，我们使用PLIC_SENABLE计算出物理地址<code>0x0c00_2080</code>，通过<code>PLIC Register Map</code>可知：</p>
<p><img src="/../images/Lab-Copy-on-Write-Fork-for-xv6/%E6%88%AA%E5%B1%8F2024-03-08%2019.48.22.png" alt="截屏2024-03-08 19.48.22"></p>
<p>也即使能核心0在Machine mode下的全局中断1</p>
<p>查表发现PLIC_SPRIORITY对应的地址：</p>
<p><img src="/../images/Lab-Copy-on-Write-Fork-for-xv6/%E6%88%AA%E5%B1%8F2024-03-08%2020.02.53.png" alt="截屏2024-03-08 20.02.53"></p>
<p>0会屏蔽所有优先级小于或等于阈值的PLIC中断。例如，阈值为零时允许所有非零优先级的中断，而阈值为7时则屏蔽所有中断。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">plicinithart</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> hart = cpuid();	<span class="comment">// 获取当前处理器核心的hart id ( 硬件线程id )</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set enable bits for this hart&#x27;s S-mode</span></span><br><span class="line">  <span class="comment">// for the uart and virtio disk.</span></span><br><span class="line">  *(uint32*)PLIC_SENABLE(hart) = (<span class="number">1</span> &lt;&lt; UART0_IRQ) | (<span class="number">1</span> &lt;&lt; VIRTIO0_IRQ);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set this hart&#x27;s S-mode priority threshold to 0.</span></span><br><span class="line">  <span class="comment">// 将当前hart的supervisor mode中断优先级阈值设置为0</span></span><br><span class="line">  <span class="comment">// 阈值为0 意味着所有优先级大于0的中断都会被当前hart接受</span></span><br><span class="line">  *(uint32*)PLIC_SPRIORITY(hart) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="plic-claim"><a href="#plic-claim" class="headerlink" title="plic_claim()"></a><code>plic_claim()</code></h4><p>向 <code>plant level interrupt controller</code> 询问我们应该处理什么中断</p>
<p><code>PLIC_SCLAIM</code>宏定义到</p>
<p><img src="/../images/Lab-Copy-on-Write-Fork-for-xv6/%E6%88%AA%E5%B1%8F2024-03-08%2020.09.48.png" alt="截屏2024-03-08 20.09.48"></p>
<p>现在我们知道该代码实际上是读取当前hart的supervisor mode中断 认领&#x2F;完成<code>(SCLAIM)</code>寄存器</p>
<p><img src="/../images/Lab-Copy-on-Write-Fork-for-xv6/%E6%88%AA%E5%B1%8F2024-03-08%2020.11.59.png" alt="截屏2024-03-08 20.11.59"></p>
<blockquote>
<p>读取到的零表示没有中断待处理。非零的读取结果包含了最高优先级待处理中断的ID。向这个寄存器写入数据表示完成了写入的中断ID所对应的中断处理。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这行代码实际上是读取当前hart的S模式中断认领/完成（SCLAIM）寄存器。PLIC_SCLAIM(hart)根据核心ID</span></span><br><span class="line"><span class="comment"> * 计算出SCLAIM寄存器的地址，然后通过解引用该地址获取存储在其中的值。</span></span><br><span class="line"><span class="comment"> * 读取这个寄存器会返回当前有待处理的最高优先级中断的ID。如果没有待处理的中断，寄存器会返回0。</span></span><br><span class="line"><span class="comment"> * 同时，读取操作会自动清除相应的中断源上的待处理位，这意味着中断被核心成功认领。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">plic_claim</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> hart = cpuid();</span><br><span class="line">  <span class="type">int</span> irq = *(uint32*)PLIC_SCLAIM(hart);</span><br><span class="line">  <span class="keyword">return</span> irq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="plic-complete"><a href="#plic-complete" class="headerlink" title="plic_complete()"></a><code>plic_complete()</code></h4><p>向该寄存器写入数据表示完成了写入的中断ID对应的中断处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tell the PLIC we&#x27;ve served this IRQ.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">plic_complete</span><span class="params">(<span class="type">int</span> irq)</span> &#123;</span><br><span class="line">  <span class="type">int</span> hart = cpuid();</span><br><span class="line">  *(uint32*)PLIC_SCLAIM(hart) = irq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="console-c"><a href="#console-c" class="headerlink" title="console.c:"></a><code>console.c:</code></h3><p>控制台输入输出，通过UART。<br>读取操作是一行一行进行的。<br>实现了特殊输入字符：<br>换行符 – 行尾<br>Control-H – 退格<br>Control-U – 删除行<br>Control-D – 文件结束<br>Control-P – 打印进程列表</p>
<h4 id="void-consputc"><a href="#void-consputc" class="headerlink" title="void consputc()"></a><code>void consputc()</code></h4><p>向UART发送一个字符，被函数<code>printf()</code>调用，用于回显输入字符，但不能由<code>write()</code>调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">consputc</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(c == BACKSPACE)&#123;</span><br><span class="line">    <span class="comment">// if the user typed backspace, overwrite with a space.</span></span><br><span class="line">    uartputc_sync(<span class="string">&#x27;\b&#x27;</span>); uartputc_sync(<span class="string">&#x27; &#x27;</span>); uartputc_sync(<span class="string">&#x27;\b&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    uartputc_sync(c); <span class="comment">// 向uart中发送字符c</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uartputc_sync</code>和<code>uartputc</code>的区别：</p>
<blockquote>
<p>假设你的操作系统正在运行一个用户程序，用户程序想要通过调用<code>write()</code>系统调用来输出一些字符到控制台。同时，假设操作系统也希望能够在处理某些内核事件时（如打印内核日志）输出字符到控制台。</p>
<h3 id="使用uartputc"><a href="#使用uartputc" class="headerlink" title="使用uartputc"></a>使用<code>uartputc</code></h3><p>当用户程序调用<code>write()</code>系统调用来输出字符时，内核会使用<code>uartputc</code>函数。因为用户程序的执行不是时间敏感的，如果输出缓冲区满了，它可以等待（即阻塞），直到有空间可用再继续输出。这种方式允许操作系统高效地管理UART的输出缓冲区，减少对CPU资源的占用。</p>
<ul>
<li><strong>例子</strong>：用户程序通过<code>write()</code>输出”Hello, world!”。如果输出缓冲区已满，<code>write()</code>操作会等待，直到缓冲区有足够的空间来存放这些字符。</li>
</ul>
<h3 id="使用uartputc-sync"><a href="#使用uartputc-sync" class="headerlink" title="使用uartputc_sync"></a>使用<code>uartputc_sync</code></h3><p>另一方面，如果内核需要在处理中断时输出字符（例如，打印调试信息），它不能使用会阻塞的<code>uartputc</code>，因为中断处理程序需要快速执行并返回，避免阻塞和延迟。在这种情况下，内核会使用<code>uartputc_sync</code>，它通过轮询等待，直到UART准备好发送新字符，不涉及等待或阻塞。</p>
<ul>
<li><strong>例子</strong>：内核需要在处理一个硬件中断时打印一条调试信息。使用<code>uartputc_sync</code>可以确保信息被立即输出到控制台，而不会阻塞中断处理的其余部分。即使输出寄存器不立即可用，它也会通过忙等（busy-waiting）直到可以发送字符，而不是挂起当前进程。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>uartputc</code>适合在正常的程序执行流程中使用，其中阻塞等待输出空间变得可用是可接受的。<code>uartputc_sync</code>适用于那些不能被阻塞的上下文，如内核打印或中断处理程序，需要立即输出字符而不影响系统的响应性。</p>
</blockquote>
<h4 id="struct-cons"><a href="#struct-cons" class="headerlink" title="struct cons:"></a><code>struct cons:</code></h4><p>这是一个<code>console</code>输入缓冲区的数据结构，用于管理从用户接收到的输入字符。</p>
<ul>
<li><code>spinlock</code>用于保证对缓冲区的访问是互斥的</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// input</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_BUF_SIZE 128</span></span><br><span class="line">  <span class="type">char</span> buf[INPUT_BUF_SIZE];	<span class="comment">// 字符缓冲区数组</span></span><br><span class="line">  uint r;  <span class="comment">// Read index  指向缓冲区中下一个要被读取的字符位置</span></span><br><span class="line">  uint w;  <span class="comment">// Write index 指向缓冲区下一个要写入字符的位置</span></span><br><span class="line">  uint e;  <span class="comment">// Edit index  光标位置或编辑位置</span></span><br><span class="line">&#125; cons;</span><br></pre></td></tr></table></figure>

<h4 id="consolewrite"><a href="#consolewrite" class="headerlink" title="consolewrite()"></a><code>consolewrite()</code></h4><p>用户对<code>console</code>调用的<code>write()</code>来到这里，也即：用于处理用户空间程序向控制台写入数据的请求。</p>
<ul>
<li><p><code>either_copying(void *dst, int user_src, uint64 src, uint64 len)</code></p>
<p>可以实现从用户态或者内核态拷贝数据到目的地址</p>
<p>其中<code>user_src</code>为真是表示原地址在用户态中</p>
</li>
<li><p><code>uartputc(c)</code>将字符c发送至<code>uart</code>中（该函数在uart.c中，稍后我们在讨论这个文件时会做详细解释）</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line"><span class="comment">// user write()s to the console go here.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">consolewrite</span><span class="params">(<span class="type">int</span> user_src, uint64 src, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">if</span>(either_copyin(&amp;c, user_src, src+i, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    uartputc(c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="consoleread"><a href="#consoleread" class="headerlink" title="consoleread()"></a><code>consoleread()</code></h4><p>用于处理用户空间程序从控制台读取数据的请求。</p>
<p>拷贝整个输入行到目的地址<code>dst</code></p>
<ul>
<li><p><code>Sleep(&amp;cons.r, &amp;cons.lock)</code>中传入<code>&amp;cons.r</code>的原因：</p>
<p><code>sleep</code>函数将<code>&amp;cons.r</code>作为<code>chan</code>参数传入，这表示当前进程希望在控制台输入缓冲区的读索引<code>cons.r</code>上睡眠，当前进程将等待，知道有新的数据写入缓冲区（此时<code>cons.r</code>会发生变化）并在另一个进程（可能是中断处理程序）在相同的通道（即<code>&amp;cons.r</code>）上调用<code>wakeup</code>后被唤醒。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">consoleread</span><span class="params">(<span class="type">int</span> user_dst, uint64 dst, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  uint target;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="type">char</span> cbuf;</span><br><span class="line"></span><br><span class="line">  target = n;</span><br><span class="line">  acquire(&amp;cons.lock); <span class="comment">// 尝试获取控制台缓冲区的锁，以保证对缓冲区的访问的互斥</span></span><br><span class="line">  <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// wait until interrupt handler has put some</span></span><br><span class="line">    <span class="comment">// input into cons.buffer.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不断检查是否有数据可读（即检查读索引和写索引是否相等）</span></span><br><span class="line">    <span class="keyword">while</span>(cons.r == cons.w)&#123;</span><br><span class="line">      <span class="keyword">if</span>(killed(myproc()))&#123;</span><br><span class="line">        release(&amp;cons.lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 若缓冲区为空，则当前进程睡眠</span></span><br><span class="line">      sleep(&amp;cons.r, &amp;cons.lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓冲区中读取数据</span></span><br><span class="line">    c = cons.buf[cons.r++ % INPUT_BUF_SIZE]; <span class="comment">// input is buffered in buf</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// C(&#x27;D&#x27;) control-D 表示文件结束</span></span><br><span class="line">    <span class="keyword">if</span>(c == C(<span class="string">&#x27;D&#x27;</span>))&#123;  <span class="comment">// end-of-file</span></span><br><span class="line">      <span class="keyword">if</span>(n &lt; target)&#123;</span><br><span class="line">        <span class="comment">// Save ^D for next time, to make sure</span></span><br><span class="line">        <span class="comment">// caller gets a 0-byte result.</span></span><br><span class="line">        cons.r--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy the input byte to the user-space buffer.</span></span><br><span class="line">    <span class="comment">// 将输入的字节拷贝到用户空间缓冲区</span></span><br><span class="line">    cbuf = c;</span><br><span class="line">    <span class="keyword">if</span>(either_copyout(user_dst, dst, &amp;cbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">    dst++; <span class="comment">// 移动dst一个字节</span></span><br><span class="line">    --n;   <span class="comment">// 已经拷贝了一个字节的数据，n -1 表示剩余要拷贝的数据的字节数</span></span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 已经读取了一行，返回到用户空间的read函数</span></span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// a whole line has arrived, return to</span></span><br><span class="line">      <span class="comment">// the user-level read().</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;cons.lock); <span class="comment">// 解锁</span></span><br><span class="line">  <span class="keyword">return</span> target - n; <span class="comment">// 返回实际读取到的数据的字节数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="consoleintr"><a href="#consoleintr" class="headerlink" title="consoleintr()"></a><code>consoleintr()</code></h4><ul>
<li>控制台输入处理程序</li>
<li>当输入字符时，<code>uartintr()</code>调用该函数</li>
<li>执行擦出&#x2F;删除处理，追加到cons.buf</li>
<li>如果一整行数据到来时，唤醒<code>consoleread()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">consoleintr</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">  acquire(&amp;cons.lock); <span class="comment">// 上锁</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;P&#x27;</span>)</span>:  <span class="comment">// Print process list. 打印进程的信息</span></span><br><span class="line">    <span class="title function_">procdump</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;U&#x27;</span>)</span>:  <span class="comment">// Kill line. 删除这一行</span></span><br><span class="line">    <span class="title function_">while</span><span class="params">(cons.e != cons.w &amp;&amp;</span></span><br><span class="line"><span class="params">          cons.buf[(cons.e<span class="number">-1</span>) % INPUT_BUF_SIZE] != <span class="string">&#x27;\n&#x27;</span>)</span>&#123;</span><br><span class="line">      cons.e--;</span><br><span class="line">      consputc(BACKSPACE); <span class="comment">//对每次删除发送一个退格字符以反映回显</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;H&#x27;</span>)</span>: <span class="comment">// Backspace 回退操作</span></span><br><span class="line">  <span class="keyword">case</span> &#x27;\x7f&#x27;: <span class="comment">// Delete key 删除键</span></span><br><span class="line">    <span class="title function_">if</span><span class="params">(cons.e != cons.w)</span>&#123;</span><br><span class="line">      cons.e--; <span class="comment">// 删除缓冲区的最后一个字符</span></span><br><span class="line">      consputc(BACKSPACE); <span class="comment">// 发送退格字符进行回显</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 输入字符不为空，且控制台缓冲区读取的索引 - 编辑的索引 小于缓冲区大小</span></span><br><span class="line">    <span class="keyword">if</span>(c != <span class="number">0</span> &amp;&amp; cons.e-cons.r &lt; INPUT_BUF_SIZE)&#123;</span><br><span class="line">      c = (c == <span class="string">&#x27;\r&#x27;</span>) ? <span class="string">&#x27;\n&#x27;</span> : c;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// echo back to the user.</span></span><br><span class="line">      consputc(c);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// store for consumption by consoleread().</span></span><br><span class="line">      <span class="comment">// 将该字符追加到控制台缓冲区中</span></span><br><span class="line">      cons.buf[cons.e++ % INPUT_BUF_SIZE] = c;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span> || c == C(<span class="string">&#x27;D&#x27;</span>) || cons.e-cons.r == INPUT_BUF_SIZE)&#123;</span><br><span class="line">        <span class="comment">// wake up consoleread() if a whole line (or end-of-file)</span></span><br><span class="line">        <span class="comment">// has arrived.</span></span><br><span class="line">        <span class="comment">// 整行到达，唤醒consoleread</span></span><br><span class="line">        cons.w = cons.e;</span><br><span class="line">        wakeup(&amp;cons.r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  release(&amp;cons.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="consoleinit"><a href="#consoleinit" class="headerlink" title="consoleinit()"></a><code>consoleinit()</code></h4><ul>
<li><p><code>devsw[CONSOLE]</code></p>
<ul>
<li><p>首先我们查看<code>devsw</code>和<code>CONSOLE</code>的定义：</p>
<ul>
<li>devsw用于映射主设备号到设备函数</li>
<li>定义了CONSOLE为第一个设备</li>
<li>允许操作系统根据设备号调用相应设备的读取和写入操作函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map major device number to device functions.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">devsw</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> (*read)(<span class="type">int</span>, uint64, <span class="type">int</span>);</span><br><span class="line">  <span class="type">int</span> (*write)(<span class="type">int</span>, uint64, <span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">devsw</span> <span class="title">devsw</span>[];</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONSOLE 1</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><code>consoleinit</code>函数将设备CONSOLE的读取和写入函数映射到设备号中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consoleinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;cons.lock, <span class="string">&quot;cons&quot;</span>); <span class="comment">// 初始化 控制台结构的锁</span></span><br><span class="line"></span><br><span class="line">  uartinit(); <span class="comment">// 初始化uart接口</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// connect read and write system calls</span></span><br><span class="line">  <span class="comment">// to consoleread and consolewrite.</span></span><br><span class="line">  devsw[CONSOLE].read = consoleread;</span><br><span class="line">  devsw[CONSOLE].write = consolewrite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uart-c"><a href="#uart-c" class="headerlink" title="uart.c"></a><code>uart.c</code></h3><p>这段代码是针对<code>16550A UART</code>的低级驱动程序。</p>
<p><code>16550A UART</code>是一种广泛使用的串行通信接口芯片。</p>
<h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">define</span> Reg(reg) ((volatile unsigned char *)(UART0 + reg)) <span class="comment">// 返回uart control register在内存映射中的位置。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ReadReg(reg) (*(Reg(reg)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WriteReg(reg, v) (*(Reg(reg)) = (v))</span></span><br></pre></td></tr></table></figure>

<h4 id="UART-control-registers"><a href="#UART-control-registers" class="headerlink" title="UART control registers"></a>UART control registers</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RHR 0                 <span class="comment">// receive holding register (for input bytes)      暂存接收到的输入字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THR 0                 <span class="comment">// transmit holding register (for output bytes)  暂存即将发送的输出字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IER 1                 <span class="comment">// interrupt enable register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IER_RX_ENABLE (1&lt;&lt;0)  <span class="comment">// 启动接收中断的位掩码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IER_TX_ENABLE (1&lt;&lt;1)  <span class="comment">// 启动发送中断的位掩码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FCR 2                 <span class="comment">// FIFO control register </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FCR_FIFO_ENABLE (1&lt;&lt;0) <span class="comment">// 启用FIFO位掩码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FCR_FIFO_CLEAR (3&lt;&lt;1) <span class="comment">// clear the content of the two FIFOs 清除两个FIFO内容的位掩码。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISR 2                 <span class="comment">// interrupt status register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCR 3                 <span class="comment">// line control register LCR寄存器的地址定义为3。这个寄存器用于配置数据格式，比如数据位、停止位和奇偶校验位。 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCR_EIGHT_BITS (3&lt;&lt;0) <span class="comment">// 设置数据位为8位的位掩码。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCR_BAUD_LATCH (1&lt;&lt;7) <span class="comment">// special mode to set baud rate</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR 5                 <span class="comment">// line status register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_RX_READY (1&lt;&lt;0)   <span class="comment">// input is waiting to be read from RHR</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_TX_IDLE (1&lt;&lt;5)    <span class="comment">// THR can accept another character to send</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ReadReg(reg) (*(Reg(reg)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WriteReg(reg, v) (*(Reg(reg)) = (v))</span></span><br></pre></td></tr></table></figure>

<h4 id="uartinit"><a href="#uartinit" class="headerlink" title="uartinit()"></a><code>uartinit()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// disable interrupts.</span></span><br><span class="line">  WriteReg(IER, <span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// special mode to set baud rate.</span></span><br><span class="line">  WriteReg(LCR, LCR_BAUD_LATCH);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// LSB for baud rate of 38.4K. 低字节</span></span><br><span class="line">  WriteReg(<span class="number">0</span>, <span class="number">0x03</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// MSB for baud rate of 38.4K. 高字节</span></span><br><span class="line">  WriteReg(<span class="number">1</span>, <span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// leave set-baud mode,</span></span><br><span class="line">  <span class="comment">// and set word length to 8 bits, no parity.</span></span><br><span class="line">  <span class="comment">// 离开设置波特率的模式，并配置数据字长为8位，无校验位。</span></span><br><span class="line">  <span class="comment">// 这是通过再次写入LCR寄存器，但这次使用LCR_EIGHT_BITS来完成的。</span></span><br><span class="line">  WriteReg(LCR, LCR_EIGHT_BITS);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reset and enable FIFOs.</span></span><br><span class="line">  <span class="comment">// 通过写入FIFO控制寄存器（FCR），启用并清除FIFO（先进先出队列）。</span></span><br><span class="line">  <span class="comment">// 这有助于确保发送和接收的数据能够被正确地缓存，同时清除可能存在的任何旧数据。</span></span><br><span class="line">  WriteReg(FCR, FCR_FIFO_ENABLE | FCR_FIFO_CLEAR);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable transmit and receive interrupts.</span></span><br><span class="line">  <span class="comment">// 再次写入IER寄存器，这次是为了启用发送（IER_TX_ENABLE）和接收（IER_RX_ENABLE）中断。</span></span><br><span class="line">  <span class="comment">// 这允许UART在发送缓冲区空闲或接收到数据时，通过中断通知CPU。</span></span><br><span class="line">  WriteReg(IER, IER_TX_ENABLE | IER_RX_ENABLE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化UART发送锁：</span></span><br><span class="line">  initlock(&amp;uart_tx_lock, <span class="string">&quot;uart&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uartputc()</code></p>
<ul>
<li>将一个字符添加到输出缓冲区并通知UART开始发送（如果尚未开始）</li>
<li>如果输出缓冲区已满，则阻塞</li>
<li>因为该函数可能会阻塞，所以不能被中断调用</li>
<li>所以该函数只适合被<code>write()</code>调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartputc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 如果系统遇到一个严重的错误，则panicked为真，不再执行后续代码</span></span><br><span class="line">  <span class="keyword">if</span>(panicked)&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// UART 传输缓冲区 满</span></span><br><span class="line">  <span class="keyword">while</span>(uart_tx_w == uart_tx_r + UART_TX_BUF_SIZE)&#123;</span><br><span class="line">    <span class="comment">// buffer is full.</span></span><br><span class="line">    <span class="comment">// wait for uartstart() to open up space in the buffer.</span></span><br><span class="line">    <span class="comment">// 调用sleep会导致调用线程阻塞</span></span><br><span class="line">    sleep(&amp;uart_tx_r, &amp;uart_tx_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向uart输出循环缓冲区写入字符c</span></span><br><span class="line">  uart_tx_buf[uart_tx_w % UART_TX_BUF_SIZE] = c;</span><br><span class="line">  uart_tx_w += <span class="number">1</span>; <span class="comment">// 写索引加1</span></span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="uartstart"><a href="#uartstart" class="headerlink" title="uartstart()"></a><code>uartstart()</code></h4><p>如果<code>UART</code>当前是空闲的，且一个字符正在输出缓冲区中等待，该函数将会把这个字符传输出去。</p>
<p>该函数的调用者必须先对<code>uart_tx_lock</code>上锁</p>
<p>设备中断的上半和下半部分都可以调用该函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uartstart</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(uart_tx_w == uart_tx_r)&#123;</span><br><span class="line">      <span class="comment">// transmit buffer is empty.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取 Line Status Register 并判断 UART Transmit Holding Register 是否空闲 </span></span><br><span class="line">    <span class="keyword">if</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// the UART transmit holding register is full,</span></span><br><span class="line">      <span class="comment">// so we cannot give it another byte.</span></span><br><span class="line">      <span class="comment">// it will interrupt when it&#x27;s ready for a new byte.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取 uart 输出缓冲区的一个字符</span></span><br><span class="line">    <span class="type">int</span> c = uart_tx_buf[uart_tx_r % UART_TX_BUF_SIZE];</span><br><span class="line">    uart_tx_r += <span class="number">1</span>; <span class="comment">// uart输出缓冲区读索引加1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// maybe uartputc() is waiting for space in the buffer.</span></span><br><span class="line">    <span class="comment">// 或许有uartputc正在等待uart输出缓冲区的空间</span></span><br><span class="line">    wakeup(&amp;uart_tx_r);</span><br><span class="line">    <span class="comment">// 将缓冲区读取的数据写入UART的发送保持寄存器</span></span><br><span class="line">    WriteReg(THR, c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="uartputc-sync"><a href="#uartputc-sync" class="headerlink" title="uartputc_sync()"></a><code>uartputc_sync()</code></h4><p>uartputc的另一个版本，不使用中断，用于内核的printf和回显字符。它等待循环，知道UART的输出寄存器为空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uartputc_sync</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">  push_off(); <span class="comment">// 禁止中断</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(panicked)&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 轮询等待知道THR为空</span></span><br><span class="line">  <span class="comment">// wait for Transmit Holding Empty to be set in LSR.</span></span><br><span class="line">  <span class="keyword">while</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line">  <span class="comment">// 向 THR 中写入数据c</span></span><br><span class="line">  WriteReg(THR, c);</span><br><span class="line">	</span><br><span class="line">  pop_off(); <span class="comment">// 启用中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uartputc_sync</code>并没有使用 uart输出缓冲区 <code>UART_TX_BUF</code></p>
<h4 id="uartgetc"><a href="#uartgetc" class="headerlink" title="uartgetc()"></a><code>uartgetc()</code></h4><p>从UART中读取一个输入字符，如果没有则返回-1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uartgetc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(ReadReg(LSR) &amp; <span class="number">0x01</span>)&#123;</span><br><span class="line">    <span class="comment">// input data is ready.</span></span><br><span class="line">    <span class="keyword">return</span> ReadReg(RHR); <span class="comment">// Receive Holding Register</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="uartintr"><a href="#uartintr" class="headerlink" title="uartintr()"></a><code>uartintr()</code></h4><p>处理一个uart中断，当一个输入到达时，或者uart已经准备好更多的输出时使用，被<code>devintr()</code>调用，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uartintr</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// read and process incoming characters.</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">int</span> c = uartgetc();<span class="comment">// 读取uart中的输入字符</span></span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    consoleintr(c); <span class="comment">// 将c传输给console</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send buffered characters. 传输缓冲区的字符</span></span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="printf-c"><a href="#printf-c" class="headerlink" title="printf.c"></a><code>printf.c</code></h3><h4 id="pr-struct"><a href="#pr-struct" class="headerlink" title="pr struct"></a><code>pr struct</code></h4><p>锁，用于避免并发的printf操作交互执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> locking;</span><br><span class="line">&#125; pr;</span><br></pre></td></tr></table></figure>

<h4 id="printint"><a href="#printint" class="headerlink" title="printint"></a><code>printint</code></h4><p>打印整型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">printint</span><span class="params">(<span class="type">int</span> xx, <span class="type">int</span> base, <span class="type">int</span> sign)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">16</span>];</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  uint x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(sign &amp;&amp; (sign = xx &lt; <span class="number">0</span>))</span><br><span class="line">    x = -xx;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    x = xx;</span><br><span class="line"></span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    buf[i++] = digits[x % base];</span><br><span class="line">  &#125; <span class="keyword">while</span>((x /= base) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(sign)</span><br><span class="line">    buf[i++] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(--i &gt;= <span class="number">0</span>)</span><br><span class="line">    consputc(buf[i]); <span class="comment">// 向console输入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="printptr"><a href="#printptr" class="headerlink" title="printptr"></a><code>printptr</code></h4><p>打印指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">printptr</span><span class="params">(uint64 x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  consputc(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  consputc(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span>(uint64) * <span class="number">2</span>); i++, x &lt;&lt;= <span class="number">4</span>)</span><br><span class="line">    consputc(digits[x &gt;&gt; (<span class="keyword">sizeof</span>(uint64) * <span class="number">8</span> - <span class="number">4</span>)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="printf"><a href="#printf" class="headerlink" title="printf"></a><code>printf</code></h4><ul>
<li><code>ap</code>是一个可变参数列表</li>
<li><code>va_start(ap, fmt)</code>，fmt是函数中最后一个已知的固定参数，它告诉<code>va_start</code>可变参数列表在内存中的起始位置在哪里</li>
<li><code>va_arg(ap, int)</code>，从<code>ap</code>中提取一个类型为<code>int</code>的参数</li>
<li><strong>用法示例</strong>：在处理<code>printf</code>格式字符串中的<code>%d</code>占位符时，可以使用<code>printint(va_arg(ap, int), 10, 1);</code>来读取一个整数参数，并将其按十进制格式输出。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Print to the console. only understands %d, %x, %p, %s.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">printf</span><span class="params">(<span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  <span class="type">int</span> i, c, locking;</span><br><span class="line">  <span class="type">char</span> *s;</span><br><span class="line"></span><br><span class="line">  locking = pr.locking;</span><br><span class="line">  <span class="keyword">if</span>(locking)</span><br><span class="line">    acquire(&amp;pr.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fmt == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;null fmt&quot;</span>);</span><br><span class="line"></span><br><span class="line">  va_start(ap, fmt); <span class="comment">// 初始化 va_list类型的变量 args 以便后续通过va_arg宏访问函数的可变参数列表</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; (c = fmt[i] &amp; <span class="number">0xff</span>) != <span class="number">0</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(c != <span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">      consputc(c); <span class="comment">// 如果不是%d这样的占位符，则直接输出到console中</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c = fmt[++i] &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">0</span>) <span class="comment">// 结束输出</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">      printint(va_arg(ap, <span class="type">int</span>), <span class="number">10</span>, <span class="number">1</span>); <span class="comment">// 输出整型</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">      printint(va_arg(ap, <span class="type">int</span>), <span class="number">16</span>, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">      printptr(va_arg(ap, uint64));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span>((s = va_arg(ap, <span class="type">char</span>*)) == <span class="number">0</span>)</span><br><span class="line">        s = <span class="string">&quot;(null)&quot;</span>;</span><br><span class="line">      <span class="keyword">for</span>(; *s; s++)</span><br><span class="line">        consputc(*s);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">      consputc(<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// Print unknown % sequence to draw attention.</span></span><br><span class="line">      consputc(<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">      consputc(c);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  va_end(ap);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(locking)</span><br><span class="line">    release(&amp;pr.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="panic"><a href="#panic" class="headerlink" title="panic"></a><code>panic</code></h4><p>打印panic</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">panic</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">  pr.locking = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;panic: &quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  panicked = <span class="number">1</span>; <span class="comment">// freeze uart output from other CPUs</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="printfinit"><a href="#printfinit" class="headerlink" title="printfinit"></a><code>printfinit</code></h4><p>初始化printf锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printfinit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  initlock(&amp;pr.lock, <span class="string">&quot;pr&quot;</span>);</span><br><span class="line">  pr.locking = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><p>虚拟内存提供了一定程度的间接性：内核可以通过将 PTE 标记为无效或只读来拦截内存引用，从而导致页面错误，并且可以通过修改 PTE 来更改地址的含义。 计算机系统中有一种说法，任何系统问题都可以通过一定程度的间接解决。 本实验探讨了一个示例：copy-on-write fork</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>xv6中的<code>fork()</code>系统调用会复制父进程的所有用户空间内存到子进程。如果父进程很大，复制操作可能会花费很长时间。更糟糕的是，这项工作往往大部分是浪费的：<code>fork()</code>通常会在子进程中紧接着执行<code>exec()</code>，这将丢弃已复制的内存，通常在未使用大部分已复制内存的情况下。另一方面，如果父进程和子进程都使用了复制的页面，并且它们中的一个或两个对其进行了写操作，那么真正需要这个副本。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>Copy-on-write (COW) fork() 的目标是推迟分配和复制物理内存页，直到实际需要副本（如果有）。<br>COW fork() 只为子进程创建一个页表，用户内存的 PTE 指向父进程的物理页。 COW fork() 将父级和子级中的所有用户 PTE 标记为只读。 当任一进程尝试写入其中一个 COW 页时，CPU 将强制发生页错误。 内核页面错误处理程序检测到这种情况，为错误进程分配物理内存页面，将原始页面复制到新页面，并修改错误进程中的相关 PTE 以引用新页面，这次使用 PTE 标记为可写。 当页面错误处理程序返回时，用户进程将能够写入其页面副本。</p>
<p>COW fork() 使得释放实现用户内存的物理页变得有点棘手。 给定的物理页可能被多个进程的页表引用，并且仅当最后一个引用消失时才应释放。 在像 xv6 这样的简单内核中，这种簿记相当简单，但在生产内核中，这可能很难正确执行； 例如，参见修补直到奶牛回家。</p>
<h3 id="Implement-copy-on-write-fork"><a href="#Implement-copy-on-write-fork" class="headerlink" title="Implement copy-on-write fork"></a>Implement copy-on-write fork</h3><blockquote>
<p>Your task is to implement copy-on-write fork in the xv6 kernel. You are done if your modified kernel executes both the cowtest and ‘usertests -q’ programs successfully.</p>
</blockquote>
<p>为了帮助你测试你的实现，我们提供了一个名为<code>cowtest</code>的xv6程序（源代码在<code>user/cowtest.c</code>中）。<code>cowtest</code>运行各种测试，但即使是第一个测试也会在未修改的xv6上失败。因此，最初你会看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cowtest</span><br><span class="line">simple: fork() failed</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>“simple”测试分配了超过可用物理内存一半的空间，然后执行<code>fork()</code>。<code>fork</code>失败是因为没有足够的空闲物理内存给子进程完整复制父进程的内存。</p>
<p>当你完成后，你的内核应该通过<code>cowtest</code>和<code>usertests -q</code>中的所有测试。也就是说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cowtest</span><br><span class="line">simple: ok</span><br><span class="line">simple: ok</span><br><span class="line">three: zombie!</span><br><span class="line">ok</span><br><span class="line">three: zombie!</span><br><span class="line">ok</span><br><span class="line">three: zombie!</span><br><span class="line">ok</span><br><span class="line">file: ok</span><br><span class="line">ALL COW TESTS PASSED</span><br><span class="line">$ usertests -q</span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>这表明，完成后的内核应该能够处理写时复制（COW，Copy-On-Write）机制下的内存管理，使得即使在物理内存紧张的情况下也能成功执行<code>fork()</code>，并且通过所有相关的功能和性能测试。</p>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><ol>
<li>修改<code>uvmcopy()</code>将父进程的物理页映射到子进程中，而不是分配新的页。将子进程和父进程所有设置PTE_W的PTE修改为PTE_R</li>
<li>修改<code>usertrap()</code>检测页面错误。当一个向写入页面错误在COW页上发生时，用<code>kalloc()</code>分配一个新的页面并设置PTE_W。最初只读的页面（未映射 PTE_W，如文本段中的页面）应保持只读状态并在父子之间共享； 尝试写入此类页面的进程应该被终止。</li>
<li>确保每个物理页在最后一个 PTE 引用消失时被释放——但不是在此之前。 实现此目的的一个好方法是为每个物理页保留引用该页的用户页表数量的“引用计数”。当 <code>kalloc()</code> 分配页面时，将页面的引用计数设置为 1。 当 <code>fork</code> 导致子进程共享页面时增加页面的引用计数，并在每次任何进程从其页表中删除页面时减少页面的计数。 <code>kfree()</code> 仅当其引用计数为零时才应将页面放回到空闲列表中。 将这些计数保存在固定大小的整数数组中是可以的。 您必须制定一个如何索引数组以及如何选择其大小的方案。 例如，您可以使用页面的物理地址除以 4096 来索引数组，并为数组提供与 <code>kalloc.c</code> 中的 <code>kinit()</code> 放置在空闲列表上的任何页面的最高物理地址相同的元素数。 请随意修改 <code>kalloc.c</code>（例如 <code>kalloc()</code> 和 <code>kfree()</code>）以维护引用计数。</li>
<li>修改 <code>copyout()</code> 以在遇到 <code>COW</code> 页面时使用与页面错误相同的方案。</li>
</ol>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul>
<li>It may be useful to have a way to record, for each PTE, whether it is a COW mapping. You can use the RSW (reserved for software) bits in the RISC-V PTE for this.</li>
<li><code>usertests -q</code> explores scenarios that <code>cowtest</code> does not test, so don’t forget to check that all tests pass for both.</li>
<li>Some helpful macros and definitions for page table flags are at the end of <code>kernel/riscv.h</code>.</li>
<li>If a COW page fault occurs and there’s no free memory, the process should be killed.</li>
</ul>
<h2 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h2><p>为了对每一个<strong>物理页面</strong>进行映射计数，我们首先在kalloc.c中设置一个对所有<strong>物理页面</strong>计数的全局数组，对该数组的操作需要互斥，我们用一个锁解决。</p>
<p><img src="/../images/Lab-Copy-on-Write-Fork-for-xv6/%E6%88%AA%E5%B1%8F2024-03-12%2014.31.22.png" alt="截屏2024-03-12 14.31.22"></p>
<p>从xv6的内核物理地址空间图可以看到，从PHYSTOP到KERNBASE的虚拟地址空间映射带的是物理地址用于RAM的空间，所以我们可以直接计算出最大页面的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">ref_lock</span>;</span> <span class="comment">// 锁</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXPAGES (PHYSTOP - KERNBASE) / PGSIZE</span></span><br><span class="line"><span class="type">int</span> ref_count[MAXPAGES]; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">index_ref</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (pa - KERNBASE) / PGSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">incr_ref</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">    acquire(&amp;kmem.ref_lock);</span><br><span class="line">    ref_count[index_ref(pa)]++;</span><br><span class="line">    release(&amp;kmem.ref_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decr_ref</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">    acquire(&amp;kmem.ref_lock);</span><br><span class="line">    ref_count[index_ref(pa)]--;</span><br><span class="line">    release(&amp;kmem.ref_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_ref</span><span class="params">(uint64 pa, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    acquire(&amp;kmem.ref_lock);</span><br><span class="line">    ref_count[index_ref(pa)] = n;</span><br><span class="line">    release(&amp;kmem.ref_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_ref</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    acquire(&amp;kmem.ref_lock);</span><br><span class="line">    res = ref_count[index_ref(pa)];</span><br><span class="line">    release(&amp;kmem.ref_lock);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着我们在<code>kinit()</code>函数中初始化锁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kinit</span><span class="params">()</span> &#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  initlock(&amp;kmem.ref_lock, <span class="string">&quot;reflock&quot;</span>);</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>kalloc()</code>一个页面的时候，我们将页面对应的映射计数初始化为1，当<code>kfree()</code>一个物理地址对应的页面时，我们减少页面对应的映射计数，当且仅当页面计数为0时，才真正的释放掉这个内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">kfree(<span class="type">void</span> *pa) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查pa的值是否合法</span></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// pa 对应的索引减 1</span></span><br><span class="line">  decr_ref((uint64)pa);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只有 pa 的计数为 0 时，才能把该页释放掉</span></span><br><span class="line">  <span class="keyword">if</span>(get_ref((uint64)pa) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化时置计数位1</span></span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">      set_ref((uint64)r, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，我们在<code>kinit()</code>的时候调用了<code>freerange()</code>，同时又在<code>freerange()</code>函数中调用了<code>kfree()</code>函数，所以我们需要在<code>freerange()</code>中将计数数组初始化为1，放置计数变为负数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">	<span class="comment">// 初始化计数数组</span></span><br><span class="line">  acquire(&amp;kmem.ref_lock);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXPAGES; ++i) &#123;</span><br><span class="line">    ref_count[i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.ref_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们在<code>defs.h</code>中注册这些函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">index_ref</span><span class="params">(uint64 pa)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">incr_ref</span><span class="params">(uint64 pa)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">decr_ref</span><span class="params">(uint64 pa)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">set_ref</span><span class="params">(uint64 pa, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get_ref</span><span class="params">(uint64 pa)</span>;</span><br></pre></td></tr></table></figure>

<p>接着我们修改<code>uvmcopy()</code>函数，将子进程的page table中的page table entry 直接映射到父进程的page中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果父进程的页表页是可写的，我们不允许它可写</span></span><br><span class="line">    <span class="comment">// 并且 PTE_COW 位 = 1</span></span><br><span class="line">    <span class="comment">// 如果父进程的页表本身就是不可写的，那就不需要修改PTE 的 flag</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_W) &#123;</span><br><span class="line">        *pte |= PTE_COW;</span><br><span class="line">        *pte &amp;= ~PTE_W;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mappages(new, i, PGSIZE, (uint64)pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    incr_ref((uint64)pa); <span class="comment">// 增加物理页面的映射计数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改<code>usertrap()</code>函数处理load page fault：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">()</span> &#123;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r_scause() == <span class="number">15</span>) &#123; <span class="comment">// load page fault</span></span><br><span class="line">    		<span class="comment">// 使用 cowalloc 函数分配一个新的页</span></span><br><span class="line">        <span class="keyword">if</span>(cowalloc(p-&gt;pagetable, r_stval()) != <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): cowalloc failed\n&quot;</span>);</span><br><span class="line">          setkilled(p);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    setkilled(p);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cowalloc()</code>函数的实现:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cowalloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (va &gt;= MAXVA) &#123; <span class="comment">// 判断虚拟地址是否越界</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;va cannot be greater than MAXVA: %p\n&quot;</span>, va);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    va = PGROUNDDOWN(va);</span><br><span class="line">    <span class="comment">// 拿到 va 对应的 pte</span></span><br><span class="line">    <span class="type">pte_t</span> *pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">    uint64 pa = PTE2PA(*pte); <span class="comment">// 拿到虚拟地址对应的物理地址</span></span><br><span class="line">    <span class="comment">// 抽取 pte flags</span></span><br><span class="line">    uint64 flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="keyword">if</span> (!(*pte &amp; PTE_COW))&#123; <span class="comment">// check if page is COW page</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not a COW page. Invalid va: %p\n&quot;</span>, va);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配一个新的页</span></span><br><span class="line">    <span class="type">void</span> *mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cowalloc: alloc mem runs out of memory\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把原始页的内容拷贝到 mem 中</span></span><br><span class="line">    memmove(mem, (<span class="type">void</span>*)pa, PGSIZE);</span><br><span class="line">    <span class="comment">// 置 PTE_COW 为 0，PTE_W 为 1</span></span><br><span class="line">    flags |= PTE_W;   <span class="comment">// 0 | 1 = 1</span></span><br><span class="line">    flags ^= PTE_COW; <span class="comment">// 1 ^ 1 = 0</span></span><br><span class="line">    <span class="comment">// 对原先页取消映射并释放页</span></span><br><span class="line">    uvmunmap(pagetable, va, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 映射当前mem</span></span><br><span class="line">    <span class="keyword">if</span> (mappages(pagetable, va, PGSIZE, (uint64) mem, flags) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cowalloc: mappages failed\n&quot;</span>);</span><br><span class="line">        kfree((<span class="type">void</span>*)mem);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们要修改<code>copyout</code>函数，这是因为当我们将内核空间的数据拷贝到用户空间时，目标地址可能为子进程的空间，这片空间在<code>uvmcopy</code>的时候被置为unwriteable，所以我们要为其分配一个新的page。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span> &#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva); <span class="comment">// 拿到对应的page address</span></span><br><span class="line">    <span class="keyword">if</span>(va0 &gt;= MAXVA) &#123; <span class="comment">// 判断是否越界</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;copyout: va0 cannot be greater than MAXVA\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">pte_t</span> *pte = walk(pagetable, va0, <span class="number">0</span>); <span class="comment">// 拿到 pte</span></span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;copyout: pte cannot be 0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 判断pte映射到的page是否合法</span></span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span> || (*pte &amp; PTE_U) == <span class="number">0</span> ||</span><br><span class="line">        ((*pte &amp; PTE_W) == <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_COW) == <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>((*pte &amp; PTE_W) == <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_COW) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 只有当 PTE_W == 0 且 PTE_COW == 1时，才能cowalloc</span></span><br><span class="line">      <span class="keyword">if</span>(cowalloc(pagetable, va0) != <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;copyout cowalloc failed\n&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;copyout: pa0 cannot be 0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记得在<code>defs.h</code>中注册新加的函数<code>cowalloc()</code></p>
<p>测试结果：</p>
<p><img src="/../images/Lab-Copy-on-Write-Fork-for-xv6/%E6%88%AA%E5%B1%8F2024-03-12%2014.57.58.png" alt="截屏2024-03-12 14.57.58"></p>
<p>没有time.txt。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/06/6-5840-Lab-1-MapReduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/06/6-5840-Lab-1-MapReduce/" class="post-title-link" itemprop="url">6.5840 Lab 1: MapReduce</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-06 16:04:23" itemprop="dateCreated datePublished" datetime="2024-03-06T16:04:23+08:00">2024-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-07 13:49:54" itemprop="dateModified" datetime="2024-03-07T13:49:54+08:00">2024-03-07</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="6-5840-Lab-1-MapReduce"><a href="#6-5840-Lab-1-MapReduce" class="headerlink" title="6.5840 Lab 1: MapReduce"></a>6.5840 Lab 1: MapReduce</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在这个实验中你要实现一个<code>MapReduce</code>系统。你将实现一个<code>worker</code>进程调用程序的<code>Map</code>和<code>Reduce</code>函数，并处理文件的读写，以及一个<code>coordinator</code>进程，该进程分配任务给<code>worker</code>并处理<code>failed worker</code>。你将构建的系统与<code>MapReduce</code>论文中描述的类似。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>需要配置go完成这个实验</p>
<p>使用git（版本控制系统）获取初始实验室软件。要了解有关git的更多信息，请查看Pro Git书籍或git用户手册。</p>
<p>我们为你提供了一个简单的顺序MapReduce实现，位于<code>src/main/mrsequential.go</code>。它一次运行一个map和reduce，全部在单个进程中执行。我们还提供了几个MapReduce应用程序：<code>mrapps/wc.go</code>中的单词计数，以及<code>mrapps/indexer.go</code>中的文本索引器。你可以按照以下方式顺序运行单词计数：</p>
<blockquote>
<p>其中，<code>go build -buildmode=plugin ../mrapps/wc.go</code>编译出一个go插件。go插件是一种特殊的共享库，它可以在运行时被go程序动态加载并使用。</p>
<p><code>wc.so</code>就是上面代码编译出的一个go插件。</p>
<p>在<code>mrsequential.go</code>中，<code>wc.so</code>和<code>pg*.txt</code>作为main函数的参数传入。</p>
<p>然后<code>wc.so</code>通过函数<code>loadPlugin</code>加载到程序中。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~/6.5840</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> src/main</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go build -buildmode=plugin ../mrapps/wc.go</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> mr-out*</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go run mrsequential.go wc.so pg*.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">more mr-out-0</span></span><br><span class="line">A 509</span><br><span class="line">ABOUT 2</span><br><span class="line">ACT 8</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>mrsequential.go</code>程序将其输出留在名为<code>mr-out-0</code>的文件中。输入来自于名为<code>pg-xxx.txt</code>的文本文件。</p>
<p>随意借用<code>mrsequential.go</code>中的代码。你也应该查看<code>mrapps/wc.go</code>以了解MapReduce应用程序代码的样子。</p>
<p>对于这个实验室以及所有其他实验室，我们可能会发布我们提供给你的代码的更新。为了确保你可以获取这些更新并通过<code>git pull</code>轻松合并它们，最好将我们提供的代码留在原始文件中。你可以按照实验室说明中的指示添加我们提供的代码；只是不要移动它。将你自己的新函数放在新文件中是可以的。</p>
<h2 id="你的任务："><a href="#你的任务：" class="headerlink" title="你的任务："></a>你的任务：</h2><p>你的任务是实现一个分布式MapReduce，由两个程序组成，协调者（coordinator）和工作者（worker）。系统中将只有一个协调者进程，以及一个或多个并行执行的工作者进程。在真实系统中，工作者会在不同的机器上运行，但对于这个实验室，你将在单一机器上运行它们所有。工作者将通过RPC与协调者通信。每个工作者进程将在循环中，向协调者请求任务，从一个或多个文件中读取任务的输入，执行任务，将任务的输出写入一个或多个文件，然后再次向协调者请求新任务。如果工作者在合理的时间内（对于这个实验室，使用十秒钟）没有完成其任务，协调者应该注意到这一点，并将相同的任务分配给不同的工作者。</p>
<p>我们已经给你提供了一些初始代码。协调者和工作者的“main”函数分别位于<code>main/mrcoordinator.go</code>和<code>main/mrworker.go</code>中；不要修改这些文件。你应该将你的实现放在<code>mr/coordinator.go</code>、<code>mr/worker.go</code>和<code>mr/rpc.go</code>中。</p>
<p>以下是如何在单词计数MapReduce应用程序上运行你的代码。首先，确保单词计数插件是最新构建的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go build -buildmode=plugin ../mrapps/wc.go</span></span><br></pre></td></tr></table></figure>

<p>在文件夹<code>main</code>中，运行<code>coordinator</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> mr-out*</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go run mrcoordinator.go pg-*.txt</span></span><br></pre></td></tr></table></figure>

<p>传递给<code>mrcoordinator.go</code>的<code>pg-*.txt</code>参数是输入文件；每个文件对应一个“分片”，并且是一个Map任务的输入。</p>
<p>在其他终端窗口上运行<code>worker</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go run mrworker.go wc.so</span></span><br></pre></td></tr></table></figure>

<p>当工作者和协调者完成后，查看<code>mr-out-*</code>中的输出。当你完成实验室任务后，输出文件的排序并集应该与顺序输出匹配，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat mr-out-* | sort | more</span><br><span class="line">A 509</span><br><span class="line">ABOUT 2</span><br><span class="line">ACT 8</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们为你提供了一个测试脚本，在<code>main/test-mr.sh</code>中。测试会检查当给定<code>pg-xxx.txt</code>文件作为输入时，<code>wc</code>和<code>indexer</code> MapReduce应用程序是否产生了正确的输出。测试还会检查你的实现是否并行运行Map和Reduce任务，以及你的实现是否能从执行任务时崩溃的工作者中恢复。</p>
<p>如果你现在运行测试脚本，它将会挂起，因为协调者永远不会结束：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~/6.5840/src/main</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bash test-mr.sh</span></span><br><span class="line">*** Starting wc test.</span><br></pre></td></tr></table></figure>

<p>你可以在<code>mr/coordinator.go</code>中的<code>Done</code>函数里将<code>ret := false</code>改为<code>true</code>，这样协调者就会立即退出。然后：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bash test-mr.sh</span></span><br><span class="line">*** Starting wc test.</span><br><span class="line">sort: No such file or directory</span><br><span class="line">cmp: EOF on mr-wc-all</span><br><span class="line">--- wc output is not the same as mr-correct-wc.txt</span><br><span class="line">--- wc test: FAIL</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>

<p>测试脚本期望在名为<code>mr-out-X</code>的文件中看到输出，每个reduce任务一个文件。<code>mr/coordinator.go</code>和<code>mr/worker.go</code>的空实现不会生成这些文件（或者做其他任何事情），因此测试会失败。</p>
<p>当你完成后，测试脚本的输出应该如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bash test-mr.sh</span></span><br><span class="line">*** Starting wc test.</span><br><span class="line">--- wc test: PASS</span><br><span class="line">*** Starting indexer test.</span><br><span class="line">--- indexer test: PASS</span><br><span class="line">*** Starting map parallelism test.</span><br><span class="line">--- map parallelism test: PASS</span><br><span class="line">*** Starting reduce parallelism test.</span><br><span class="line">--- reduce parallelism test: PASS</span><br><span class="line">*** Starting job count test.</span><br><span class="line">--- job count test: PASS</span><br><span class="line">*** Starting early exit test.</span><br><span class="line">--- early exit test: PASS</span><br><span class="line">*** Starting crash test.</span><br><span class="line">--- crash test: PASS</span><br><span class="line">*** PASSED ALL TESTS</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>

<p>你可能会看到一些来自Go RPC包的错误，看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019/12/16 13:27:09 rpc.Register: method &quot;Done&quot; has 1 input parameters; needs exactly three</span><br></pre></td></tr></table></figure>

<p>忽略这些消息；将协调者注册为RPC服务器是为了检查其所有方法是否适合RPC（有3个输入）；我们知道<code>Done</code>不是通过RPC调用的。<br>另外，根据你终止工作者进程的策略，你可能会看到一些形式的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2024/02/11 16:21:32 dialing:dial unix /var/tmp/5840-mr-501: connect: connection refused</span><br></pre></td></tr></table></figure>

<p>每次测试中看到少量这类消息是正常的；它们发生在协调者退出后，工作者无法联系到协调者RPC服务器时。</p>
<h3 id="一些规则："><a href="#一些规则：" class="headerlink" title="一些规则："></a>一些规则：</h3><ul>
<li>Map阶段应该将中间键分配到nReduce个reduce任务的桶中，其中nReduce是reduce任务的数量——这是<code>main/mrcoordinator.go</code>传递给<code>MakeCoordinator()</code>的参数。每个映射器应该为reduce任务创建nReduce个中间文件。</li>
<li>工作者实现应该将第X个reduce任务的输出放在文件<code>mr-out-X</code>中。</li>
<li><code>mr-out-X</code>文件应该包含每个Reduce函数输出的一行。该行应该使用Go的<code>&quot;%v %v&quot;</code>格式生成，调用键和值。可以在<code>main/mrsequential.go</code>中查看标有“这是正确的格式”的注释行。如果你的实现与这个格式偏差太大，测试脚本将会失败。</li>
<li>你可以修改<code>mr/worker.go</code>、<code>mr/coordinator.go</code>和<code>mr/rpc.go</code>。你可以临时修改其他文件进行测试，但请确保你的代码能够与原始版本一起工作；我们将使用原始版本进行测试。</li>
<li>工作者应该将Map输出的中间结果放在当前目录的文件中，以便你的工作者稍后可以将它们作为Reduce任务的输入读取。</li>
<li><code>main/mrcoordinator.go</code>期望<code>mr/coordinator.go</code>实现一个<code>Done()</code>方法，当MapReduce作业完全完成时返回true；此时，<code>mrcoordinator.go</code>将退出。</li>
<li>当作业完全完成时，工作者进程应该退出。实现这一点的一个简单方法是使用<code>call()</code>的返回值：如果工作者无法联系到协调者，它可以假设协调者已经因为作业完成而退出，因此工作者也可以终止。根据你的设计，你可能也会发现让协调者给工作者一个“请退出”的伪任务很有帮助。</li>
</ul>
<h3 id="一些提示："><a href="#一些提示：" class="headerlink" title="一些提示："></a>一些提示：</h3><ul>
<li><p>Guidance page 上有一些有关开发和调试的提示</p>
</li>
<li><p>开始的一种方法是修改<code>mr/worker.go</code>的<code>Worker()</code>，向协调员发送RPC，要求执行任务。然后修改协调员，以响应尚未启动的map任务的文件名。然后修改工作程序以读取该文件并调用应用程序Map函数，如在<code>mrsequential.go</code>中。</p>
</li>
<li><p>应用程序的Map和Reduce函数使用Go的插件包在运行时从文件加载，这些文件的名称以.so结尾。<br>如果你在<code>mr/</code>目录下更改了任何内容，你可能需要重新构建你使用的任何MapReduce插件，可以使用类似<code>go build -buildmode=plugin ../mrapps/wc.go</code>的命令。</p>
</li>
<li><p>这个实验室依赖于工作者共享文件系统。当所有工作者都在同一台机器上运行时，这很简单，但如果工作者在不同的机器上运行，则需要像GFS这样的全局文件系统。</p>
</li>
<li><p>中间文件的一个合理命名约定是<code>mr-X-Y</code>，其中X是Map任务编号，Y是reduce任务编号。</p>
</li>
<li><p>工作者的map任务代码需要一种方法将中间键&#x2F;值对存储在文件中，以便在reduce任务期间可以正确读回。一种可能性是使用Go的<code>encoding/json</code>包。将键&#x2F;值对以JSON格式写入打开的文件：</p>
</li>
<li><pre><code class="json">enc := json.NewEncoder(file)
  for _, kv := ... &#123;
    err := enc.Encode(&amp;kv)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">并回读这样的文件：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
dec := json.NewDecoder(file)
  for &#123;
    var kv KeyValue
    if err := dec.Decode(&amp;kv); err != nil &#123;
      break
    &#125;
    kva = append(kva, kv)
  &#125;
</code></pre>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/29/Lab-traps/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/29/Lab-traps/" class="post-title-link" itemprop="url">Lab: traps</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-29 09:59:40" itemprop="dateCreated datePublished" datetime="2024-02-29T09:59:40+08:00">2024-02-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-05 19:59:10" itemprop="dateModified" datetime="2024-03-05T19:59:10+08:00">2024-03-05</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>44k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>40 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab-traps"><a href="#Lab-traps" class="headerlink" title="Lab: traps"></a>Lab: traps</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="4-1-RISC-V-trap-machinery"><a href="#4-1-RISC-V-trap-machinery" class="headerlink" title="4.1 RISC-V trap machinery"></a>4.1 RISC-V trap machinery</h3><ul>
<li><p><code>stvec</code>：内核将陷阱处理程序<code>trap handler</code>的地址写入此处；<code>RISC-V</code>跳向该地址处理陷阱<code>trap</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* defined in riscv.h */</span></span><br><span class="line"><span class="comment">// Supervisor Trap-Vector Base Address</span></span><br><span class="line"><span class="comment">// low two bits are mode.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">w_stvec</span><span class="params">(uint64 x)</span> &#123; </span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw stvec, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>; <span class="comment">// write stvec</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 <span class="title function_">r_stvec</span><span class="params">()</span> &#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, stvec&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;	<span class="comment">// read stvec</span></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>sepc</code>：当陷阱<code>trap</code>发生时，<code>RISC-V</code>把程序计数器<code>PC</code>的值保存在这里（因为<code>PC</code>的值将会被<code>stvec</code>中的值覆盖）。指令<code>sret (return from trap)</code>将<code>sepc</code>的值拷贝给<code>pc</code>。内核可以写入<code>sepc</code>寄存器来控制<code>sret</code>指令跳转的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* defined in riscv.h */</span></span><br><span class="line"><span class="comment">// supervisor exception program counter, holds the</span></span><br><span class="line"><span class="comment">// instruction address to which a return from</span></span><br><span class="line"><span class="comment">// exception will go.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">w_sepc</span><span class="params">(uint64 x)</span> &#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw sepc, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>; <span class="comment">// 写 sepc 寄存器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 <span class="title function_">r_sepc</span><span class="params">()</span> &#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, sepc&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>; <span class="comment">// 读 sepc 寄存器</span></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>scause</code>：<code>RISC-V</code>将描述<code>trap</code>原因的数字放在这个寄存器里。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Supervisor Trap Cause</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 <span class="title function_">r_scause</span><span class="params">()</span> &#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, scause&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>sscratch</code>：陷阱处理代码使用sscratch寄存器来避免在保存用户寄存器之前覆盖它们。</p>
</li>
<li><p><code>sstatus</code>：<code>sstatus</code>寄存器用于跟踪处理器当前的操作状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Supervisor Status Register, sstatus</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SPP (1L &lt;&lt; 8)  <span class="comment">// Previous mode, 1=Supervisor, 0=User 在trap前是什么模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SPIE (1L &lt;&lt; 5) <span class="comment">// Supervisor Previous Interrupt Enable 之前是否启用supervisor interrupt</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_UPIE (1L &lt;&lt; 4) <span class="comment">// User Previous Interrupt Enable 之前是否启用user interrupt</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SIE (1L &lt;&lt; 1)  <span class="comment">// Supervisor Interrupt Enable 当前是否启用supervisor interrupt</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_UIE (1L &lt;&lt; 0)  <span class="comment">// User Interrupt Enable 当前是否启用user interrupt</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 <span class="title function_">r_sstatus</span><span class="params">()</span> &#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, sstatus&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;	<span class="comment">// 读</span></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">w_sstatus</span><span class="params">(uint64 x)</span>&#123; <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw sstatus, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enable device interrupts 启用设备中断</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">intr_on</span><span class="params">()</span> &#123; w_sstatus(r_sstatus() | SSTATUS_SIE); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// disable device interrupts 禁止设备中断</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">intr_off</span><span class="params">()</span> &#123; w_sstatus(r_sstatus() &amp; ~SSTATUS_SIE); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// are device interrupts enabled? 判断是否启用设备中断</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">intr_get</span><span class="params">()</span> &#123;</span><br><span class="line">  uint64 x = r_sstatus();</span><br><span class="line">  <span class="keyword">return</span> (x &amp; SSTATUS_SIE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>上述寄存器和陷阱处理函数<code>trap handler</code>相关，不能在用户态中读取或写入。</p>
<p>当需要强制陷阱时，RISC-V硬件对所有陷阱类型（计时器中断除外）进行以下操作：</p>
<ol>
<li>如果<code>trap</code>类型是设备中断，且<code>sstatus</code>的<code>SIE</code>位为<code>0</code>，则什么都不做。</li>
<li>通过置<code>sstatus</code>的<code>SIE</code>位为<code>0</code>禁用所有中断。</li>
<li>将<code>pc</code>的值复制到<code>sepc</code>中。</li>
<li>将当前模式<code>user or supervisor</code>保存到<code>sstatus</code>中的<code>SSP</code>位。</li>
<li><code>scause</code>中保存导致陷阱<code>trap</code>的原因。</li>
<li>更改模式为监管<code>supervisor mode</code>。</li>
<li>复制<code>stvec</code>的值到<code>pc</code>。</li>
<li>从新的<code>pc</code>处执行程序。</li>
</ol>
<h3 id="4-2-Trap-from-user-space"><a href="#4-2-Trap-from-user-space" class="headerlink" title="4.2 Trap from user space"></a>4.2 Trap from user space</h3><p>当用户程序执行系统调用（ecall指令）、进行非法操作或设备中断时，可能会在用户空间执行时发生陷阱。用户空间陷阱的处理路径是首先通过uservec（位于kernel&#x2F;trampoline.S:21），然后是usertrap（位于kernel&#x2F;trap.c:37）；在返回时，通过usertrapret（位于kernel&#x2F;trap.c:90）然后是userret（位于kernel&#x2F;trampoline.S:101）。</p>
<ul>
<li><p><code>uservec</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">.section trampsec</span><br><span class="line">.globl trampoline</span><br><span class="line">.globl usertrap</span><br><span class="line">trampoline:</span><br><span class="line">.align 4</span><br><span class="line">.globl uservec</span><br><span class="line">uservec:    </span><br><span class="line">	#</span><br><span class="line">        # trap.c sets stvec to point here, so</span><br><span class="line">        # traps from user space start here,</span><br><span class="line">        # in supervisor mode, but with a</span><br><span class="line">        # user page table.</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        # save user a0 in sscratch so</span><br><span class="line">        # a0 can be used to get at TRAPFRAME.</span><br><span class="line">        csrw sscratch, a0 // 将 a0 寄存器的值存储到 sscratch 寄存器中，也就是0x3f ffff e000</span><br><span class="line"></span><br><span class="line">        # each process has a separate p-&gt;trapframe memory area,</span><br><span class="line">        # but it&#x27;s mapped to the same virtual address</span><br><span class="line">        # (TRAPFRAME) in every process&#x27;s user page table.</span><br><span class="line">        li a0, TRAPFRAME # 这里开始 a0 指向 TRAPFRAME </span><br><span class="line">        </span><br><span class="line">        # save the user registers in TRAPFRAME 每个寄存器占8字节</span><br><span class="line">        sd ra, 40(a0)</span><br><span class="line">        sd sp, 48(a0)</span><br><span class="line">        sd gp, 56(a0)</span><br><span class="line">        sd tp, 64(a0)</span><br><span class="line">        sd t0, 72(a0)</span><br><span class="line">        sd t1, 80(a0)</span><br><span class="line">        sd t2, 88(a0)</span><br><span class="line">        sd s0, 96(a0)</span><br><span class="line">        sd s1, 104(a0)</span><br><span class="line">        sd a1, 120(a0)</span><br><span class="line">        sd a2, 128(a0)</span><br><span class="line">        sd a3, 136(a0)</span><br><span class="line">        sd a4, 144(a0)</span><br><span class="line">        sd a5, 152(a0)</span><br><span class="line">        sd a6, 160(a0)</span><br><span class="line">        sd a7, 168(a0)</span><br><span class="line">        sd s2, 176(a0)</span><br><span class="line">        sd s3, 184(a0)</span><br><span class="line">        sd s4, 192(a0)</span><br><span class="line">        sd s5, 200(a0)</span><br><span class="line">        sd s6, 208(a0)</span><br><span class="line">        sd s7, 216(a0)</span><br><span class="line">        sd s8, 224(a0)</span><br><span class="line">        sd s9, 232(a0)</span><br><span class="line">        sd s10, 240(a0)</span><br><span class="line">        sd s11, 248(a0)</span><br><span class="line">        sd t3, 256(a0)</span><br><span class="line">        sd t4, 264(a0)</span><br><span class="line">        sd t5, 272(a0)</span><br><span class="line">        sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# save the user a0 in p-&gt;trapframe-&gt;a0</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, 112(a0) # 将 t0 寄存器的值存储到 a0 寄存器指向的偏移量为 112 字节的位置</span><br><span class="line"></span><br><span class="line">        # initialize kernel stack pointer, from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">        ld sp, 8(a0) # 将 a0 寄存器指向的地址加上8字节偏移后的内存位置的内容加载到栈指针sp寄存器中</span><br><span class="line">        # a0 寄存器指向的地址加上8字节偏移后的内存位置就是 内核栈指针</span><br><span class="line"></span><br><span class="line">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">        ld tp, 32(a0)</span><br><span class="line"></span><br><span class="line">        # load the address of usertrap(), from p-&gt;trapframe-&gt;kernel_trap</span><br><span class="line">        ld t0, 16(a0) # t0 指向 usertrap() 的地址</span><br><span class="line"></span><br><span class="line">        # fetch the kernel page table address, from p-&gt;trapframe-&gt;kernel_satp.</span><br><span class="line">        ld t1, 0(a0) 	# </span><br><span class="line"></span><br><span class="line">        # wait for any previous memory operations to complete, so that</span><br><span class="line">        # they use the user page table.</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # install the kernel page table.</span><br><span class="line">        csrw satp, t1</span><br><span class="line"></span><br><span class="line">        # flush now-stale user entries from the TLB.</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # jump to usertrap(), which does not return</span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure>

<p>这里解释一下<code>satp</code>寄存器。<code>satp</code>寄存器用于监督模式下的地址转换和保护。这个寄存器包含根页表的物理页号（PPN）、一个地址空间标识符（ASID），以及选择当前地址转换方案的MODE字段。ASID用于基于每个地址空间的地址转换隔离，而PPN是根页表的监督物理地址除以4KiB的结果。</p>
<p>也即，<code>satp</code>寄存器指向<code>page table</code></p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-02-29%2012.01.53.png" alt="截屏2024-02-29 12.01.53"></p>
</li>
<li><p><code>usertrap()</code>处理来自用户空间的中断、异常或系统调用。由<code>trampoline.S</code>调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* 寄存器 sstatus 的 SSP 位指明 trap 是否来自用户态 */</span></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  <span class="comment">// 在发生用户陷阱（user trap）时，硬件自动将用户程序计数器的值存储到sepc寄存器中。</span></span><br><span class="line">  <span class="comment">// 现在我们将该值存储到 trapframe 中以用于之后恢复现场</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(killed(p))</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    <span class="comment">// 因为系统调用时程序计数器指向 ecall 指令</span></span><br><span class="line">    <span class="comment">// trap处理完后要执行 ecall 指令的下一条指令</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sepc, scause, and sstatus,</span></span><br><span class="line">    <span class="comment">// so enable only now that we&#x27;re done with those registers.</span></span><br><span class="line">    intr_on();	<span class="comment">// 允许supervisor interrupt</span></span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok device interrupt</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// exception</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    setkilled(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(killed(p))</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>usertrapret()</code>用于返回到用户态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// return to user space</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">  <span class="comment">// 在回到用户态之前，禁用所有中断</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to uservec in trampoline.S</span></span><br><span class="line">  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);</span><br><span class="line">  w_stvec(trampoline_uservec);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">  <span class="comment">// the process next traps into the kernel.</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jump to userret in trampoline.S at the top of memory, which </span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="type">void</span> (*)(uint64))trampoline_userret)(satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>userret</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        # userret(pagetable)</span><br><span class="line">        # called by usertrapret() in trap.c to</span><br><span class="line">        # switch from kernel to user.</span><br><span class="line">        # a0: user page table, for satp.</span><br><span class="line"></span><br><span class="line">        # switch to the user page table.</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line">        csrw satp, a0</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        li a0, TRAPFRAME</span><br><span class="line"></span><br><span class="line">        # restore all but a0 from TRAPFRAME</span><br><span class="line">        ld ra, 40(a0)</span><br><span class="line">        ld sp, 48(a0)</span><br><span class="line">        ld gp, 56(a0)</span><br><span class="line">        ld tp, 64(a0)</span><br><span class="line">        ld t0, 72(a0)</span><br><span class="line">        ld t1, 80(a0)</span><br><span class="line">        ld t2, 88(a0)</span><br><span class="line">        ld s0, 96(a0)</span><br><span class="line">        ld s1, 104(a0)</span><br><span class="line">        ld a1, 120(a0)</span><br><span class="line">        ld a2, 128(a0)</span><br><span class="line">        ld a3, 136(a0)</span><br><span class="line">        ld a4, 144(a0)</span><br><span class="line">        ld a5, 152(a0)</span><br><span class="line">        ld a6, 160(a0)</span><br><span class="line">        ld a7, 168(a0)</span><br><span class="line">        ld s2, 176(a0)</span><br><span class="line">        ld s3, 184(a0)</span><br><span class="line">        ld s4, 192(a0)</span><br><span class="line">        ld s5, 200(a0)</span><br><span class="line">        ld s6, 208(a0)</span><br><span class="line">        ld s7, 216(a0)</span><br><span class="line">        ld s8, 224(a0)</span><br><span class="line">        ld s9, 232(a0)</span><br><span class="line">        ld s10, 240(a0)</span><br><span class="line">        ld s11, 248(a0)</span><br><span class="line">        ld t3, 256(a0)</span><br><span class="line">        ld t4, 264(a0)</span><br><span class="line">        ld t5, 272(a0)</span><br><span class="line">        ld t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# restore user a0</span><br><span class="line">        ld a0, 112(a0)</span><br><span class="line">        </span><br><span class="line">        # return to user mode and user pc.</span><br><span class="line">        # usertrapret() set up sstatus and sepc.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ECALL-指令之前的状态"><a href="#ECALL-指令之前的状态" class="headerlink" title="ECALL 指令之前的状态"></a>ECALL 指令之前的状态</h3><p>跟踪一个xv6的系统调用，也就是Shell将它的提示信息通过write系统调用走到操作系统再输出到console的过程。</p>
<p>在代码<code>sh.c</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">getcmd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> nbuf)</span></span><br><span class="line">&#123;</span><br><span class="line">  write(<span class="number">2</span>, <span class="string">&quot;$ &quot;</span>, <span class="number">2</span>); <span class="comment">// 	write 系统调用</span></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, nbuf);</span><br><span class="line">  gets(buf, nbuf);</span><br><span class="line">  <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="number">0</span>) <span class="comment">// EOF</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动<code>gdb</code>。</p>
<p>作为用户代码的<code>Shell</code>调用<code>write</code>时，实际上调用的是关联到<code>Shell</code>一个库函数。查看这个库的源代码，在<code>usys.S</code>中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.global write</span><br><span class="line">write:</span><br><span class="line"> li a7, SYS_write	# 将SYS_write 加载到 寄存器a7 中</span><br><span class="line"> ecall	# 执行ecall指令</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>

<p>我们通过在ecall指令处放置一个断点展示系统调用，为了放置断点，我们首先要知道指令地址，查看<code>XV6</code>编译过程产生的<code>sh.asm</code>找出这个地址。<code>sh.asm</code>是带有指令地址的汇编代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000000e2c &lt;write&gt;:</span><br><span class="line">.global write</span><br><span class="line">write:</span><br><span class="line"> li a7, SYS_write</span><br><span class="line">     e2c:	48c1                	li	a7,16</span><br><span class="line"> ecall</span><br><span class="line">     e2e:	00000073          	ecall</span><br><span class="line"> ret</span><br><span class="line">     e32:	8082                	ret</span><br></pre></td></tr></table></figure>

<p>在<code>ecall</code>指令处放置一个断点，这条指令的地址是<code>0xe2e</code>。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2010.05.14.png" alt="截屏2024-03-01 10.05.14"></p>
<p>从<code>gdb</code>中，我们看到下一条要执行的指令就是<code>ecall</code>。打印并检查程序计数器，确实是在<code>0xe2e</code>的位置。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2010.07.06.png" alt="截屏2024-03-01 10.07.06"></p>
<p>通过<code>info reg</code>打印全部用户寄存器。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2010.10.28.png" alt="截屏2024-03-01 10.10.28"></p>
<p><code>a0 a1 a2</code>是<code>Shell</code>传递给<code>write</code>系统调用的参数。所以<code>a0</code>是文件描述符<code>2</code>，<code>a1</code>是<code>Shell</code>想要写入字符串的指针，<code>a2</code>是想要写入的字符数。还可以通过打印<code>Shell</code>想要写入的字符串内容，来证明断点停留在我们认为它应该停在的位置。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2010.14.21-9259264.png" alt="截屏2024-03-01 10.14.21"></p>
<p>一个美元符号和一个空格。</p>
<p>值得注意的是，寄存器中程序计数器<code>pc</code>和堆栈指针<code>sp</code>（上图没显示全<code>sp = 0x4f80</code>都在距离0较近的地址，这进一步说明当前代码运行在用户空间，因为<strong>用户空间中所有地址都比较小</strong>，一旦进入内核，<strong>内核会使用大得多的内存空间</strong>。</p>
<p>系统调用的时间点会有大量状态的变更，其中一个最重要的需要变更的状态，并且在它变更之前我们对它还有依赖的，就是当前的<code>page table</code>。可以查看<code>SATP</code>寄存器。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2010.20.40.png" alt="截屏2024-03-01 10.20.40"></p>
<p>这是物理内存地址，它并没有说明有关<code>page table</code>中的映射关系是什么，<code>page table</code>长什么样。<code>QEMU</code>中有一个方法可以打印当前<code>page table</code>。从<code>QEMU</code>界面中输入<code>ctrl a + c</code>可以进入到<code>QEMU</code>的<code>console</code>，之后输入<code>info mem</code>，<code>QEMU</code>会打印完整的<code>page table</code>。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2011.03.07.png" alt="截屏2024-03-01 11.03.07"></p>
<p>接着在<code>Shell</code>中打印出<code>write</code>函数的内容。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2010.30.34.png" alt="截屏2024-03-01 10.30.34"></p>
<p>程序计数器现在指向<code>ecall</code>指令，我们接下来要执行<code>ecall</code>指令。现在我们还在用户空间，但是即将进入内核空间了。</p>
<h3 id="ECALL指令之后的状态"><a href="#ECALL指令之后的状态" class="headerlink" title="ECALL指令之后的状态"></a><code>ECALL</code>指令之后的状态</h3><p>执行<code>ecall</code>指令，</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2011.16.13.png" alt="截屏2024-03-01 11.16.13"></p>
<p>看到程序计数器的值变为一个大得多的地址。但是通过<code>QEMU</code>执行<code>info mem</code>后发现<code>page table</code>并没有改变。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2011.16.33.png" alt="截屏2024-03-01 11.16.33"></p>
<p>在<code>memlayout.h</code>中定义了<code>TRAMPOLINE</code>和<code>TRAPFRAME</code>的物理地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map the trampoline page to the highest address,</span></span><br><span class="line"><span class="comment">// in both user and kernel space.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAMPOLINE (MAXVA - PGSIZE)</span></span><br><span class="line"><span class="comment">// User memory layout.</span></span><br><span class="line"><span class="comment">// Address zero first:</span></span><br><span class="line"><span class="comment">//   text</span></span><br><span class="line"><span class="comment">//   original data and bss</span></span><br><span class="line"><span class="comment">//   fixed-size stack</span></span><br><span class="line"><span class="comment">//   expandable heap</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   USYSCALL (shared with kernel)</span></span><br><span class="line"><span class="comment">//   TRAPFRAME (p-&gt;trapframe, used by the trampoline)</span></span><br><span class="line"><span class="comment">//   TRAMPOLINE (the same page as in the kernel)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE)</span></span><br></pre></td></tr></table></figure>

<p>在<code>riscv.h</code>中定义了<code>MAXVA</code>，<code>MAXVA = 0x40 0000 0000</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// one beyond the highest possible virtual address.</span></span><br><span class="line"><span class="comment">// MAXVA is actually one bit less than the max allowed by</span></span><br><span class="line"><span class="comment">// Sv39, to avoid having to sign-extend virtual addresses</span></span><br><span class="line"><span class="comment">// that have the high bit set.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))</span></span><br></pre></td></tr></table></figure>

<p>因此我们得到<code>TRAMPOLINE = 0x3f ffff f000</code>，<code>TRAPFRAM = 0x3f ffff e000</code>。</p>
<p>程序计数器指示代码正在<code>trampoline page</code>得最开始，这是用户内存中一个非常大的地址。我们可以查看一下将要运行的指令。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2011.19.56.png" alt="截屏2024-03-01 11.19.56"></p>
<p>这些指令是内核在<code>supervisor mode</code>中将要执行的最开始的几条指令，也是在<code>trap</code>机制中最开始要执行的几条指令。</p>
<p>查看寄存器:</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2011.28.24.png" alt="截屏2024-03-01 11.28.24"></p>
<p>发现并没有变化，这里还是用户程序拥有的一些寄存器内容。所以现在寄存器里还是用户程序的数据，并且这些数据也还只保存在这些寄存器中，所以我们将这些寄存器的值保存在某处之前，<strong>我们在这个时间点不能使用任何寄存器</strong>，内核会覆盖寄存器内的用户数据，之后如果我们尝试要恢复用户程序，我们就不能回复寄存器中的正确数据，用户程序执行将会出错。</p>
<p>我们现在所在的地址为<code>0x3f ffff ffff</code>，这是<code>page table</code>的最后一个<code>page</code>，这是<code>trampoline page</code>。我们现在正在<code>trampoline page</code>中执行程序，这个<code>page</code>包含了内核的<code>trap</code>处理代码。**<code>ecall</code>并不会切换<code>page table</code>，这是<code>ecall</code>指令非常重要的一个特点。**所以这意味着，<code>trap</code>处理代码必须存在于每个<code>user page table</code>中。因为<code>ecall</code>并不会切换<code>page table</code>，我们需要在<code>user page table</code>中的某个地方来执行最初的内核代码。而这个<code>trampoline page</code>，是由内核小心映射到每一个<code>user page table</code>中，以使我们仍然在使用<code>user page table</code>时，内核在一个地方能够执行<code>trap</code>机制的最开始的一些指令。</p>
<p>这里的控制是通过<code>stvec</code>寄存器完成的，这是一个只能在<code>supervisor mode</code>下读写的特权寄存器。在从内核空间进入到用户空间之前，内核会设置好<code>stvec</code>寄存器指向内核希望<code>trap</code>代码允许的位置。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2011.47.27-9264852.png" alt="截屏2024-03-01 11.47.27"></p>
<p>如图所示，内核已经事先设置好了<code>STVEC</code>寄存器的内容为<code>0x3f ffff f000</code>，这就是<code>trampoline page</code>的起始位置。<code>STVEC</code>寄存器的内容，就是在<code>ecall</code>指令执行之后，我们会在这个特定地址执行指令的原因。</p>
<p>即使<code>trampoline page</code>是在用户地址空间的<code>user page table</code>完成的映射，用户代码不能写它，因为这些<code>page</code>对应的<code>PTE</code>并没有设置<code>PTE_u</code>标志位。因此<code>trap</code>机制是安全的。</p>
<p>虽然一直说已经在supervisor mode 中了，但是实际上并没有任何能直接确认当前在哪种mode下的方法。不过我们的确发现程序计数器正在<code>trampoline page</code>执行代码，而这些page对应的PTE并没有设置PTE_u标识位。所以现在只有当代码在supervisor mode时，才可能在程序运行的同时而不崩溃。所以我们推导出当前必然在<code>supervisor mode</code></p>
<p>通过<code>ecall</code>走到<code>trampoline page</code>，<code>ecall</code>实际上指改变三件事：</p>
<p>第一，<code>ecall</code>将代码从<code>user mode</code>改到<code>supervisor mode</code></p>
<p>第二，<code>ecall</code>将程序计数器的值保存在<code>sepc</code>寄存器。通过打印程序计数器看到这里的效果，</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2013.29.24.png" alt="截屏2024-03-01 13.29.24"></p>
<p>尽管其他的寄存器还是原来用户寄存器的值，但是这里的程序计数器明显已经不是用户代码的程序计数器了。这里的程序计数器是从<code>stvec</code>寄存器拷贝过来的值。我们打印<code>sepc</code>寄存器，这是<code>ecall</code>保存用户程序计数器的地方。</p>
<p>这个寄存器里面有熟悉的地址<code>0xe2e</code>，这是<code>ecall</code>指令在用户空间的地址。所以<code>ecall</code>至少保存了程序计数器的数值。</p>
<p>第三，<code>ecall</code>会跳转到<code>stvec</code>寄存器指向的指令。</p>
<p>所以现在，ecall 帮我们做了一点点工作，但实际上我们离执行内核中的c代码还差的很远。接下来：</p>
<ul>
<li>我们需要保存32个用户寄存器的内容，这样当我们想要恢复用户代码执行时，我们才能恢复这些寄存器的内容。</li>
<li>因为现在我们还在user page table，我们需要切换到kernel page table</li>
<li>我们需要创建或者找到一个kernel stack，并将stack pointer 寄存器的内容指向那个kernel stack。这样才能给c代码提供栈。</li>
<li>我们还需要跳转到内核中c代码的某些合理的位置。</li>
</ul>
<p>然而<code>ecall</code>并不会做这里的任何一件事。</p>
<p>当然可以通过修改硬件让<code>ecall</code>完成这些工作，而不是交给软件完成。并且，我们也将会看到，在软件中完成这些工作并不是特别简单。那为什么<code>ecall</code>不多做点工作来讲代码执行从用户态切换到内核空间呢？为什么ecall不会保存用户寄存器，或者切换<code>page table</code>的指针来指向<code>kernel page table</code>，或者自动的设置<code>Stack Pointer</code>指向<code>kernel stack</code>，或者直接跳转到kernel的c代码，而不是在这里运行复杂的汇编代码？</p>
<p>实际上，有的机器在执行系统调用时，会在硬件中完成所有这些工作。但是<code>RISC-V</code>并不会，<code>RISC-V</code>秉持了这样一个观点：ecall只完成尽量少必须要完成的工作，其他的工作都交给软件完成。这里的原因是，RISC-V设计者想要为软件和操作系统的程序员提供最大的灵活性，这样他们就能按照他们想要的方式开发操作系统。所以你可以这样想，尽管XV6并没有使用这里提供的灵活性，但是一些其他操作系统用到了。</p>
<ul>
<li>举个例子，因为这里的ecall是如此简单，或许某些操作系统可以在不切换page table的前提下，执行部分系统调用。切换page table的代价比较高，如果ecall打包完成了这部分工作，那就不能对一些系统调用进行改进，使其不用在不必要的场景切换page table。</li>
<li>某些操作系统同时将user和kernel的虚拟地址映射到一个page table中，这样在user和kernel之间切换时根本就不需要切换page table。对于这样的操作系统来说，如果ecall切换了page table那将会是一种浪费，并且也减慢了程序的运行。</li>
<li>或许在一些系统调用过程中，一些寄存器不用保存，而哪些寄存器需要保存，哪些不需要，取决于软件，编程语言和编译器。通过不保存所有的32个寄存器获取可以节省大量的程序运行时间，所以你不会想ecall迫使你保存所有的寄存器。</li>
<li>最后，对于某些简单的系统调用或许根本就不要任何stack，所以对于一些非常关注性能的操作系统，ecall不会自动位你完成stack切换是极好的。</li>
</ul>
<p>所以，ecall尽量的简单可以提升软件设计的灵活性。</p>
<p>在代码或者gdb中看不到ecall的具体内容的原因：</p>
<p><strong>ecall实际上是cpu的指令，自然在gdb或者代码中看不到具体内容</strong></p>
<h3 id="uservec函数"><a href="#uservec函数" class="headerlink" title="uservec函数"></a>uservec函数</h3><p>在ecall指令执行后，现在程序位于trampoline page的起始，也就是<code>uservec</code>函数的起始。现在需要做的第一件事就是保存寄存器内容。</p>
<p>在一些机器中，可以直接将寄存器中的内容写到物理内存的合适位置。但是我们不能在<code>RISC-V</code>中这样做，因为在RISV-V中，supervisor mode下的代码不允许直接访问物理内存。所以只能使用page table中的内容，但是从输出来看（见下文**<code>ECALL</code>指令之后的状态**），page table中也没有多少内容。</p>
<p>虽然xv6并没有使用，但是另一种可能的操作是，直接讲satp寄存器指向kernel page table，之后我们就可以直接使用所有的kernel mapping来帮助我们存储用户寄存器。这是合法的，因为supervisor mode可以更改satp寄存器。但是在trap机制的最开始，我们并不知道kernel page table的地址。并且更改satp寄存器的指令，要求写入satp寄存器的内容来自于另一个寄存器。所以，位了能执行更新page table的指令，我们需要一些空闲寄存器，这样才能先将page table的地址存在这些寄存器中，然后再执行修改satp寄存器的指令。</p>
<p>对于保存用户寄存器，XV6在RISC-V上的实现包括了两个部分。第一个部分是，XV6在每个user page table映射了trapframe page，这样每个进程都有自己的trapframe page。这个page包含了很多有趣的数据，但是现在最重要的数据是用来保存用户寄存器的32个空槽位。所以，在trap处理代码中，现在的好消息是，我们在user page table有一个之前由kernel设置好的映射关系，这个映射关系指向了一个可以用来存放这个进程的用户寄存器的内存位置。这个位置的虚拟地址总是0x3ffffffe000。</p>
<p>xv6的trapframe中存储了如下信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// per-process data for the trap handling code in trampoline.S.</span></span><br><span class="line"><span class="comment">// sits in a page by itself just under the trampoline page in the</span></span><br><span class="line"><span class="comment">// user page table. not specially mapped in the kernel page table.</span></span><br><span class="line"><span class="comment">// uservec in trampoline.S saves user registers in the trapframe,</span></span><br><span class="line"><span class="comment">// then initializes registers from the trapframe&#x27;s</span></span><br><span class="line"><span class="comment">// kernel_sp, kernel_hartid, kernel_satp, and jumps to kernel_trap.</span></span><br><span class="line"><span class="comment">// usertrapret() and userret in trampoline.S set up</span></span><br><span class="line"><span class="comment">// the trapframe&#x27;s kernel_*, restore user registers from the</span></span><br><span class="line"><span class="comment">// trapframe, switch to the user page table, and enter user space.</span></span><br><span class="line"><span class="comment">// the trapframe includes callee-saved user registers like s0-s11 because the</span></span><br><span class="line"><span class="comment">// return-to-user path via usertrapret() doesn&#x27;t return through</span></span><br><span class="line"><span class="comment">// the entire kernel call stack.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// kernel page table tarp处理代码将要加载到satp寄存器的数值</span></span><br><span class="line">  <span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// top of process&#x27;s kernel stack</span></span><br><span class="line">  <span class="comment">/*  16 */</span> uint64 kernel_trap;   <span class="comment">// usertrap()</span></span><br><span class="line">  <span class="comment">/*  24 */</span> uint64 epc;           <span class="comment">// saved user program counter</span></span><br><span class="line">  <span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp</span></span><br><span class="line">  <span class="comment">/*  40 */</span> uint64 ra;</span><br><span class="line">  <span class="comment">/*  48 */</span> uint64 sp;</span><br><span class="line">  <span class="comment">/*  56 */</span> uint64 gp;</span><br><span class="line">  <span class="comment">/*  64 */</span> uint64 tp;</span><br><span class="line">  <span class="comment">/*  72 */</span> uint64 t0;</span><br><span class="line">  <span class="comment">/*  80 */</span> uint64 t1;</span><br><span class="line">  <span class="comment">/*  88 */</span> uint64 t2;</span><br><span class="line">  <span class="comment">/*  96 */</span> uint64 s0;</span><br><span class="line">  <span class="comment">/* 104 */</span> uint64 s1;</span><br><span class="line">  <span class="comment">/* 112 */</span> uint64 a0;</span><br><span class="line">  <span class="comment">/* 120 */</span> uint64 a1;</span><br><span class="line">  <span class="comment">/* 128 */</span> uint64 a2;</span><br><span class="line">  <span class="comment">/* 136 */</span> uint64 a3;</span><br><span class="line">  <span class="comment">/* 144 */</span> uint64 a4;</span><br><span class="line">  <span class="comment">/* 152 */</span> uint64 a5;</span><br><span class="line">  <span class="comment">/* 160 */</span> uint64 a6;</span><br><span class="line">  <span class="comment">/* 168 */</span> uint64 a7;</span><br><span class="line">  <span class="comment">/* 176 */</span> uint64 s2;</span><br><span class="line">  <span class="comment">/* 184 */</span> uint64 s3;</span><br><span class="line">  <span class="comment">/* 192 */</span> uint64 s4;</span><br><span class="line">  <span class="comment">/* 200 */</span> uint64 s5;</span><br><span class="line">  <span class="comment">/* 208 */</span> uint64 s6;</span><br><span class="line">  <span class="comment">/* 216 */</span> uint64 s7;</span><br><span class="line">  <span class="comment">/* 224 */</span> uint64 s8;</span><br><span class="line">  <span class="comment">/* 232 */</span> uint64 s9;</span><br><span class="line">  <span class="comment">/* 240 */</span> uint64 s10;</span><br><span class="line">  <span class="comment">/* 248 */</span> uint64 s11;</span><br><span class="line">  <span class="comment">/* 256 */</span> uint64 t3;</span><br><span class="line">  <span class="comment">/* 264 */</span> uint64 t4;</span><br><span class="line">  <span class="comment">/* 272 */</span> uint64 t5;</span><br><span class="line">  <span class="comment">/* 280 */</span> uint64 t6;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以，如何保存用户寄存器的一半答案是，内核非常方便的将trapframe page 映射到了每个user page table。</p>
<p>另一半的答案在于我们之前提到过的SSCRATCH寄存器。这个由RISC-V提供的SSRCATCH寄存器，就是为接下来的目的而创建的。内核会将trapframe page的地址保存在这个寄存器中，也就是0x3fffffe000这个地址。更重要的是，RISC-V有一个指令允许交换任意两个寄存器的值。而SSCRATCH寄存器的作用就是保存另一个寄存器的值，并将自己的值加载给另一个寄存器。如果我查看trampoline.S代码，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">.section trampsec</span><br><span class="line">.globl trampoline</span><br><span class="line">.globl usertrap</span><br><span class="line">trampoline:</span><br><span class="line">.align 4</span><br><span class="line">.globl uservec</span><br><span class="line">uservec:    </span><br><span class="line">	#</span><br><span class="line">        # trap.c sets stvec to point here, so</span><br><span class="line">        # traps from user space start here,</span><br><span class="line">        # in supervisor mode, but with a</span><br><span class="line">        # user page table.</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        # save user a0 in sscratch so</span><br><span class="line">        # a0 can be used to get at TRAPFRAME.</span><br><span class="line">        csrw sscratch, a0 // 将 a0 寄存器的值存储到 sscratch 寄存器中，也就是0x3f ffff e000</span><br><span class="line"></span><br><span class="line">        # each process has a separate p-&gt;trapframe memory area,</span><br><span class="line">        # but it&#x27;s mapped to the same virtual address</span><br><span class="line">        # (TRAPFRAME) in every process&#x27;s user page table.</span><br><span class="line">        li a0, TRAPFRAME # 这里开始 a0 指向 TRAPFRAME </span><br><span class="line">        </span><br><span class="line">        # save the user registers in TRAPFRAME 每个寄存器占8字节</span><br><span class="line">        sd ra, 40(a0)</span><br><span class="line">        sd sp, 48(a0)</span><br><span class="line">        sd gp, 56(a0)</span><br><span class="line">        sd tp, 64(a0)</span><br><span class="line">        sd t0, 72(a0)</span><br><span class="line">        sd t1, 80(a0)</span><br><span class="line">        sd t2, 88(a0)</span><br><span class="line">        sd s0, 96(a0)</span><br><span class="line">        sd s1, 104(a0)</span><br><span class="line">        sd a1, 120(a0)</span><br><span class="line">        sd a2, 128(a0)</span><br><span class="line">        sd a3, 136(a0)</span><br><span class="line">        sd a4, 144(a0)</span><br><span class="line">        sd a5, 152(a0)</span><br><span class="line">        sd a6, 160(a0)</span><br><span class="line">        sd a7, 168(a0)</span><br><span class="line">        sd s2, 176(a0)</span><br><span class="line">        sd s3, 184(a0)</span><br><span class="line">        sd s4, 192(a0)</span><br><span class="line">        sd s5, 200(a0)</span><br><span class="line">        sd s6, 208(a0)</span><br><span class="line">        sd s7, 216(a0)</span><br><span class="line">        sd s8, 224(a0)</span><br><span class="line">        sd s9, 232(a0)</span><br><span class="line">        sd s10, 240(a0)</span><br><span class="line">        sd s11, 248(a0)</span><br><span class="line">        sd t3, 256(a0)</span><br><span class="line">        sd t4, 264(a0)</span><br><span class="line">        sd t5, 272(a0)</span><br><span class="line">        sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# save the user a0 in p-&gt;trapframe-&gt;a0</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, 112(a0) # 将 t0 寄存器的值存储到 a0 寄存器指向的偏移量为 112 字节的位置</span><br><span class="line"></span><br><span class="line">        # initialize kernel stack pointer, from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">        ld sp, 8(a0) # 将 a0 寄存器指向的地址加上8字节偏移后的内存位置的内容加载到栈指针sp寄存器中</span><br><span class="line">        # a0 寄存器指向的地址加上8字节偏移后的内存位置就是 内核栈指针</span><br><span class="line"></span><br><span class="line">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">        ld tp, 32(a0)</span><br><span class="line"></span><br><span class="line">        # load the address of usertrap(), from p-&gt;trapframe-&gt;kernel_trap</span><br><span class="line">        ld t0, 16(a0) # t0 指向 usertrap() 的地址</span><br><span class="line"></span><br><span class="line">        # fetch the kernel page table address, from p-&gt;trapframe-&gt;kernel_satp.</span><br><span class="line">        ld t1, 0(a0) 	# </span><br><span class="line"></span><br><span class="line">        # wait for any previous memory operations to complete, so that</span><br><span class="line">        # they use the user page table.</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # install the kernel page table.</span><br><span class="line">        csrw satp, t1</span><br><span class="line"></span><br><span class="line">        # flush now-stale user entries from the TLB.</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # jump to usertrap(), which does not return</span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure>

<p>这里解释一下<code>satp</code>寄存器。<code>satp</code>寄存器用于监督模式下的地址转换和保护。这个寄存器包含根页表的物理页号（PPN）、一个地址空间标识符（ASID），以及选择当前地址转换方案的MODE字段。ASID用于基于每个地址空间的地址转换隔离，而PPN是根页表的监督物理地址除以4KiB的结果。</p>
<p>也即，<code>satp</code>寄存器指向<code>page table</code></p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-02-29%2012.01.53.png" alt="截屏2024-02-29 12.01.53"></p>
<p>指令csrrw执行完后，交换了a0和sscratch的值，寄存器a0中的值为<code>0x3f ffff e000</code>，这是trapframe的虚拟地址。他之前保存在<code>SSCRATCH</code>寄存器中，但是现在交换到了a0中。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2015.08.25.png" alt="截屏2024-03-01 15.08.25"></p>
<p>我们也可以打印<code>sscratch</code>寄存器的值：</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2015.12.37.png" alt="截屏2024-03-01 15.12.37"></p>
<p>他现在的内容是2，这就是a0寄存器之前的值。a0寄存器保存的是write函数的第一个参数，在这个场景下，是Shell传入的文件描述符2。所以我们现在将a0的值保存起来了，并且我们有了指向trapframe page的指针。现在我们正在朝着保存用户寄存器的道路上前进。实际上，这就是trampoline.S中接下来30多个奇怪指令的工作。这些指令就是的执行sd，将每个寄存器保存在trapframe的不同偏移位置。因为a0在交换完之后包含的是trapframe page地址，也就是0x3fffffe000。所以，每个寄存器被保存在了偏移量+a0的位置。这些存储的指令比较无聊，我就不介绍了。</p>
<p>trapframe的地址是怎么出现在sscratch寄存器中的？</p>
<p>在内核前一次切换回用户空间时，内核会执行set sscratch指令，将这个寄存器的内容设置为<code>0x3f ffff e000</code>，也就是trapframe page的虚拟地址。所以，当我们运行用户代码，比如运行Shell时，sscratch保存的就是指向trapframe的地址。之后，Shell执行了ecall指令，跳转到了trampoline page，这个page中的第一条指令和第二条指令会将a0的值保存到sscratch中，然后将TRAPFRAME的地址加载到a0寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># save user a0 in sscratch so</span><br><span class="line"># a0 can be used to get at TRAPFRAME.</span><br><span class="line">csrw sscratch, a0</span><br><span class="line"></span><br><span class="line"># each process has a separate p-&gt;trapframe memory area,</span><br><span class="line"># but it&#x27;s mapped to the same virtual address</span><br><span class="line"># (TRAPFRAME) in every process&#x27;s user page table.</span><br><span class="line">li a0, TRAPFRAME</span><br></pre></td></tr></table></figure>

<p><strong>sscratch寄存器存在于cpu上</strong>，是一个特殊寄存器。</p>
<p>需要注意的是，一台机器总是从内核开始运行的，当机器启动的时候，它就是在内核中。任何时候，不管是进程第一次启动还是从一个系统调用返回，进入到用户空间的唯一方法就是执行sret指令。sret指令是由RISC-V定义的用来从supervisor mode 转换到 user mode。所以，在执行任何用户代码之前，都会调用函数<code>usertrapret()</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jump to userret in trampoline.S at the top of memory, which </span></span><br><span class="line"><span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line"><span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">((<span class="type">void</span> (*)(uint64))trampoline_userret)(satp);</span><br></pre></td></tr></table></figure>

<p>在该函数的最后通过<code>((void (*)(uint64))trampoline_userret)(satp);</code>将satp传入trampoline.S的userret中。</p>
<p>现在运行程序并停留在寄存器拷贝结束的位置：</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2016.46.17.png" alt="截屏2024-03-01 16.46.17"></p>
<p>这条指令将从a0指向的内存地址往后数的第8个字节开始的数据加载到stack pointer寄存器。当前a0的内容为trapframe page的地址，在<code>proc.h</code>中的<code>trapframe</code>结构体也可以看出第8个字节开始的数据是内核的stack pointer（kernel_sp）。trapframe中的kernel_sp是由内核在进入用户空间前就设置好的，他的值是这个进程的kernel stack的最顶端。执行完这条指令之后，我们打印当前stack pointer寄存器。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2016.52.39.png" alt="截屏2024-03-01 16.52.39"></p>
<p>这是这个进程的kernel stack。因为xv6在每个kernel stack下面放置一个guard page，所以kernel stack的地址都比较大。</p>
<p>下一条指令向tp寄存器写入数据。因为在RISC-V中，没有一个直接的方法来确认当前运行在多处理器的哪个核上，<strong>XV6会将CPU核的编号，也就是hartid保存在tp寄存器中</strong>。在内核中好几个地方都会使用这个值，例如，内核可以通过这个值确定某个CPU核上运行了哪些进程。我们执行这条指令，并打印tp寄存器。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2017.04.19-9283865.png" alt="截屏2024-03-01 17.04.19"></p>
<p>现在我们知道当前进程运行在CPU的0核，这是因为我们配置的QEMU只给xv6分配了一个核，所以我们只能运行在核0上。</p>
<p>下一条指令向t0寄存器中写入数据。这里写入的是我们将要执行的第一个c函数的指针，也就是函数<code>usertrap()</code>的指针。我们在后面会使用这个指针。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2017.07.39.png" alt="截屏2024-03-01 17.07.39"></p>
<p>检索文件后发现，usertrap函数的地址确实为<code>0x80001e4e</code></p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2017.13.59.png" alt="截屏2024-03-01 17.13.59"></p>
<p>下一条指令是向<code>t1</code>寄存器中写入<code>kernel page table</code>的地址，我们可以打印<code>t1</code>寄存器的内容。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2018.33.41.png" alt="截屏2024-03-01 18.33.41"></p>
<p>严格来说，t1的内容并不是kernel page table的地址，这是你需要向SATP寄存器写入的数据。它包含了kernel page table的地址，但是移位了，并且包含了各种标志位。</p>
<p>下一条指令是交换satp和t1寄存器。这条指令执行完之后，当前程序会从user page table切换到 kernel page table。现在我们在QEMU中打印page table，可以看出与之前的page table完全不一样。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2018.43.58.png" alt="截屏2024-03-01 18.43.58"></p>
<p>现在这里输出的是由内核设置好的巨大的kernel page table。所以现在我们成功的切换了page table，我们在这个位置进展的很好，Stack Pointer指向了kernel stack；我们有了kernel page table，可以读取kernel data。我们已经准备好了执行内核中的C代码了。</p>
<p>这里还有个问题，为什么代码没有崩溃？毕竟我们在内存中的某个位置执行代码，程序计数器保存的是虚拟地址，如果我们切换了page table，为什么同一个虚拟地址不会通过新的page table寻址走到一些无关的page中？看起来我们现在没有崩溃并且还在执行这些指令。</p>
<blockquote>
<p>这是因为我们还在 trampoline page 中，而trampoline代码在用户空间和内核空间都映射到了同一个地址。</p>
</blockquote>
<p>完全正确。我不知道你们是否还记得user page table的内容，trampoline page在user page table中的映射与kernel page table中的映射是完全一样的。这两个page table中其他所有的映射都是不同的，只有trampoline page的映射是一样的，因此我们在切换page table时，寻址的结果不会改变，我们实际上就可以继续在同一个代码序列中执行程序而不崩溃。这是trampoline page的特殊之处，它同时在user page table和kernel page table都有相同的映射关系。</p>
<p>之所以叫trampoline page，是因为你某种程度在它上面“弹跳”了一下，然后从用户空间走到了内核空间。</p>
<p>最后一条指令是<code>jr t0</code>。执行了这条指令，我们就要从trampoline跳到内核的c代码中。这条指令的作用是跳转到t0指向的函数中。我们打印t0对应的一些命令。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2018.49.11.png" alt="截屏2024-03-01 18.49.11"></p>
<p>可以看到t0的位置对应于usertrap函数的开始。接下来就要以kernel stack，kernel page table跳转到usertrap函数。</p>
<h3 id="usertrap-函数"><a href="#usertrap-函数" class="headerlink" title="usertrap 函数"></a>usertrap 函数</h3><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2018.58.03.png" alt="截屏2024-03-01 18.58.03"></p>
<p>有很多原因都可以让程序运行进入到usertrap函数中来，比如系统调用，运算时除以0，使用了一个未被映射的虚拟地址，或者是设备中断。<code>usertrap</code>某种程度上存储并恢复硬件状态，但是它也需要检查触发trap的原因，以确定相应的处理方式。</p>
<p>接下来，让我们一步步执行usertrap函数。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2019.02.00.png" alt="截屏2024-03-01 19.02.00"></p>
<p>它做的第一件事情是更改<code>stvec</code>寄存器。取决于trap是来自于用户空间还是内核空间，实际上xv6处理trap的方法是不一样的。目前为止，我们只讨论过当trap是由用户空间发起时会发生什么。如果trap从内核空间发起，将会是一个不同的处理流程，因为从内核发起的话，程序已经在使用kernel page table。所以当trap发生时，程序执行仍然在内核的话，很多处理不必要存在。</p>
<p>在内核中执行任何操作之前，usertrap中先将stvec指向kernelvec变量，这是内核空间trap处理代码的位置，而不是用户空间trap处理代码的位置。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2019.14.07.png" alt="截屏2024-03-01 19.14.07"></p>
<p>我们需要知道当前运行的是什么进程，我们通过调用myproc函数来做到这一点。myproc函数实际上会查找一个根据当前CPU核的编号索引的数组，CPU核的编号是hartid，如果你还记得，我们之前在uservec函数中将它存在了tp寄存器。这是myproc函数找出当前运行进程的方法。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2019.15.42.png" alt="截屏2024-03-01 19.15.42"></p>
<p>接下来我们要保存用户程序计数器，它仍然保存在SEPC寄存器中，但是可能发生这种情况：当程序还在内核中执行时，我们可能切换到另一个进程，并进入到那个程序的用户空间，然后那个进程可能再调用一个系统调用进而导致SEPC寄存器的内容被覆盖。所以，我们需要保存当前进程的SEPC寄存器到一个与该进程关联的内存中，这样这个数据才不会被覆盖。这里我们使用trapframe来保存这个程序计数器。</p>
<p>接下来我们需要找出我们现在会在usertrap函数的原因。根据触发trap的原因，RISC-V的SCAUSE寄存器会有不同的数字。数字8表明，我们现在在trap代码中是因为系统调用。可以打印SCAUSE寄存器，它的确包含了数字8，我们的确是因为系统调用才走到这里的。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2019.17.39.png" alt="截屏2024-03-01 19.17.39"></p>
<p>所以，我们可以进到这个if语句中。接下来第一件事情是检查是不是有其他的进程杀掉了当前进程，但是我们的Shell没有被杀掉，所以检查通过。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2019.19.16.png" alt="截屏2024-03-01 19.19.16"></p>
<p>在RISC-V中，存储在SEPC寄存器中的程序计数器，是用户程序中触发trap的指令的地址。但是当我们恢复用户程序时，我们希望在下一条指令恢复，也就是ecall之后的一条指令。所以对于系统调用，我们对于保存的用户程序计数器加4，这样我们会在ecall的下一条指令恢复，而不是重新执行ecall指令。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2019.19.52.png" alt="截屏2024-03-01 19.19.52"></p>
<p>XV6会在处理系统调用的时候使能中断，这样中断可以更快的服务，有些系统调用需要许多时间处理。中断总是会被RISC-V的trap硬件关闭，所以在这个时间点，我们需要显式的打开中断。</p>
<p>下一行代码中，我们会调用syscall函数。这个函数定义在syscall.c</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2019.21.36.png" alt="截屏2024-03-01 19.21.36"></p>
<p>它的作用是从syscall表单中，根据系统调用的编号查找相应的系统调用函数。如果你还记得之前的内容，Shell调用的write函数将a7设置成了系统调用编号，对于write来说就是16。所以syscall函数的工作就是获取由trampoline代码保存在trapframe中a7的数字，然后用这个数字索引实现了每个系统调用的表单。</p>
<p>我们可以打印num，的确是16。这与Shell调用的write函数写入的数字是一致的。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2015.08.25-9294458.png" alt="截屏2024-03-01 15.08.25"></p>
<p>之后查看通过num索引得到的函数，正是sys_write函数。sys_write函数是内核对于write系统调用的具体实现。这里再往后的代码执行就非常复杂了，我就不具体介绍了。在这节课中，对于系统调用的实现，我只对进入和跳出内核感兴趣。这里我让代码直接执行sys_write函数。</p>
<p>这里有件有趣的事情，系统调用需要找到它们的参数。你们还记得write函数的参数吗？分别是文件描述符2，写入数据缓存的指针，写入数据的长度2。syscall函数直接通过trapframe来获取这些参数，就像这里刚刚可以查看trapframe中的a7寄存器一样，我们可以查看a0寄存器，这是第一个参数，a1是第二个参数，a2是第三个参数。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2020.01.59.png" alt="截屏2024-03-01 20.01.59"></p>
<p>现在syscall执行了真正的系统调用，之后sys_write返回了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use num to lookup the system call function for num, call it,</span></span><br><span class="line"><span class="comment">// and store its return value in p-&gt;trapframe-&gt;a0</span></span><br><span class="line">p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br></pre></td></tr></table></figure>

<p>这里向trapframe中的a0赋值的原因是：所有的系统调用都有一个返回值，比如write会返回实际写入的字节数，而RISC-V上的C代码的习惯是函数的返回值存储于寄存器a0，所以为了模拟函数的返回，我们将返回值存储在trapframe的a0中。之后，当我们返回到用户空间，trapframe中的a0槽位的数值会写到实际的a0寄存器，Shell会认为a0寄存器中的数值是write系统调用的返回值。执行完这一行代码之后，我们打印这里trapframe中a0的值，可以看到输出2。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-02%2009.58.11.png" alt="截屏2024-03-02 09.58.11"></p>
<p>这意味这sys_write的返回值是2，符合传入的参数，这里只写入了2个字节。</p>
<p>从syscall函数返回之后，我们回到了trap.c中的usertrap函数。</p>
<p>我们再次检查当前用户进程是否被杀掉了，因为我们不想恢复一个被杀掉的进程。当然，在我们的场景中，Shell没有被杀掉。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-02%2009.59.40.png" alt="截屏2024-03-02 09.59.40"></p>
<p>最后，usertrap调用了一个函数usertrapret。</p>
<h3 id="usertrapret函数"><a href="#usertrapret函数" class="headerlink" title="usertrapret函数"></a>usertrapret函数</h3><p>usertrap函数的最后调用了usertrapret函数，来设置好之前说过的，在返回到用户空间之前内核要做的工作。查看usertrapret函数的内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// return to user space</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to uservec in trampoline.S</span></span><br><span class="line">  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);</span><br><span class="line">  w_stvec(trampoline_uservec);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">  <span class="comment">// the process next traps into the kernel.</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jump to userret in trampoline.S at the top of memory, which </span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="type">void</span> (*)(uint64))trampoline_userret)(satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><pre><code class="c">  // we&#39;re about to switch the destination of traps from
  // kerneltrap() to usertrap(), so turn off interrupts until
  // we&#39;re back in user space, where usertrap() is correct.
  intr_off();
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   该函数首先关闭中断。因为之前我们在系统调用过程中是打开了中断的，这里关闭中断是因为我们将要更新stvec寄存器来指向用户空间的trap处理代码，而之前在内核中的时候，我们指向的是内核空间的trap处理代码。我们关闭中断是因为当我们将stvec更新到指向用户空间的trap处理代码时，我们仍然在内核中执行代码。如果这时发生了一个中断，那么程序执行会走向用户空间的trap处理代码，即便我们现在仍然在内核中，处于各种各样具体细节的原因，这会导致内核出错。所以我们这里关闭中断。</span><br><span class="line"></span><br><span class="line">2. ```c</span><br><span class="line">     // send syscalls, interrupts, and exceptions to uservec in trampoline.S</span><br><span class="line">     uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);</span><br><span class="line">     w_stvec(trampoline_uservec);</span><br></pre></td></tr></table></figure>

接着设置stvec寄存器指向trampoline代码，在那里终会执行sret指令返回到用户空间。位于trampoline代码的最后sret指令会重新打开中断。这样，即使我们刚刚关闭中断，当我们在执行用户代码时中断是打开的。
</code></pre>
</li>
<li><pre><code class="c">  // set up trapframe values that uservec will need when
  // the process next traps into the kernel.
  p-&gt;trapframe-&gt;kernel_satp = r_satp();         // kernel page table
  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; // process&#39;s kernel stack
  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;
  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         // hartid for cpuid()
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   接下来填入trapframe的内容，这些内容对于执行trampoline代码非常有用。</span><br><span class="line"></span><br><span class="line">   - 存储kernel page table的地址</span><br><span class="line">   - 存储当前用户进程的kernel stack</span><br><span class="line">   - 存储usertrap函数的地址，这样trampoline代码才能跳转到这个函数</span><br><span class="line">   - 从tp寄存器中读取当前的cpu核编号，并存储在trapframe中，这样trampoline代码才能恢复这个数字，因为用户代码可能会修改这个数字</span><br><span class="line"></span><br><span class="line">   现在我们在usertrapret函数中并正在设置trapframe中的数据，这样下一次从用户空间转换到内核空间时可以用到这些数据。</span><br><span class="line"></span><br><span class="line">4. ```c</span><br><span class="line">   // set S Previous Privilege mode to User.</span><br><span class="line">     unsigned long x = r_sstatus();</span><br><span class="line">     x &amp;= ~SSTATUS_SPP; // clear SPP to 0 for user mode</span><br><span class="line">     x |= SSTATUS_SPIE; // enable interrupts in user mode</span><br><span class="line">     w_sstatus(x);</span><br></pre></td></tr></table></figure>

接下来设置sstatus寄存器，这是一个控制寄存器。这个寄存器的spp bit位控制了sret指令的行为，该bit为0表示下次执行sret时，我们想要返回到user mode 而不是 supervisor mode。这个寄存器的SPIE bit位控制了在执行完sret后是否打开中断。因为我们在返回到用户空间后，的确希望打开中断，所以我们这里设置SPIE bit 为1，修改完这些bit之后，我们会把新的值写回到sstatus寄存器。
</code></pre>
</li>
<li><pre><code class="c"> // set S Exception Program Counter to the saved user pc.
  w_sepc(p-&gt;trapframe-&gt;epc);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   trampoline的最后会执行sret指令。这条指令会将程序计数器设置成spec寄存器的值，所以现在我们将sepc寄存器的值设置成之前保存的用户程序计数器的值。在不久之前，我们在usertrap函数中将用户程序计数器保存在trapframe中的epc字段。</span><br><span class="line"></span><br><span class="line">6. ```c</span><br><span class="line">    // tell trampoline.S the user page table to switch to.</span><br><span class="line">     uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br></pre></td></tr></table></figure>

接着根据user page table地址生成相应的satp值，这样我们在返回到用户空间的时候才能完成page table的切换。实际上，我们会在汇编代码trampoline中完成page table的切换，并且也只能在trampoline中完成切换，因为只有trampoline中的代码是同时在用户和内核空间中映射的。但我们现在还没有在trampoline代码中，我们现在还在一个普通的c函数中，所以这里我们将page table地址准备好，并将这个地址作为参数传递给汇编代码，这个参数会出现在a0寄存器中。
</code></pre>
</li>
<li><pre><code class="c">// jump to userret in trampoline.S at the top of memory, which 
// switches to the user page table, restores user registers,
// and switches to user mode with sret.
uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);
((void (*)(uint64))trampoline_userret)(satp);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   然后计算出我们将要跳转到的汇编代码的地址。我们期望跳转的地址是trampoline中的userret函数，这个函数包含了所有能将我们带回到用户空间的指令。所以这里我们计算出userret函数的地址。</span><br><span class="line"></span><br><span class="line">   最后一行将 trampoline_userret地址作为一个函数指针，执行相应的函数，即userret函数，并传入参数satp，存储在a0寄存器中。</span><br><span class="line"></span><br><span class="line">### userret 函数</span><br><span class="line"></span><br><span class="line">现在跳转到trampoline代码。</span><br><span class="line"></span><br><span class="line">```assembly</span><br><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        # userret(pagetable)</span><br><span class="line">        # called by usertrapret() in trap.c to</span><br><span class="line">        # switch from kernel to user.</span><br><span class="line">        # a0: user page table, for satp.</span><br><span class="line"></span><br><span class="line">        # switch to the user page table.</span><br><span class="line">        sfence.vma zero, zero		# 清空页表缓存</span><br><span class="line">        csrw satp, a0</span><br><span class="line">        sfence.vma zero, zero 	# 清空页表缓存</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p>首先切换page table。在执行完<code>csrw satp, a0</code>之前，page table还是巨大的kernel page table。这条指令将a0寄存器中的值存储到satp中。执行完后page table变成了小得多的user page table。幸运的是user page table也映射了trampoline page，所以程序还能继续执行而不是崩溃。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">li a0, TRAPFRAME</span><br></pre></td></tr></table></figure>

<p>将trapframe的地址加载到a0中，到目前为止，所有的寄存器内容还是属于内核。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># restore all but a0 from TRAPFRAME</span><br><span class="line">        ld ra, 40(a0)</span><br><span class="line">        ld sp, 48(a0)</span><br><span class="line">        ld gp, 56(a0)</span><br><span class="line">        ld tp, 64(a0)</span><br><span class="line">        ld t0, 72(a0)</span><br><span class="line">        ld t1, 80(a0)</span><br><span class="line">        ld t2, 88(a0)</span><br><span class="line">        ld s0, 96(a0)</span><br><span class="line">        ld s1, 104(a0)</span><br><span class="line">        ld a1, 120(a0)</span><br><span class="line">        ld a2, 128(a0)</span><br><span class="line">        ld a3, 136(a0)</span><br><span class="line">        ld a4, 144(a0)</span><br><span class="line">        ld a5, 152(a0)</span><br><span class="line">        ld a6, 160(a0)</span><br><span class="line">        ld a7, 168(a0)</span><br><span class="line">        ld s2, 176(a0)</span><br><span class="line">        ld s3, 184(a0)</span><br><span class="line">        ld s4, 192(a0)</span><br><span class="line">        ld s5, 200(a0)</span><br><span class="line">        ld s6, 208(a0)</span><br><span class="line">        ld s7, 216(a0)</span><br><span class="line">        ld s8, 224(a0)</span><br><span class="line">        ld s9, 232(a0)</span><br><span class="line">        ld s10, 240(a0)</span><br><span class="line">        ld s11, 248(a0)</span><br><span class="line">        ld t3, 256(a0)</span><br><span class="line">        ld t4, 264(a0)</span><br><span class="line">        ld t5, 272(a0)</span><br><span class="line">        ld t6, 280(a0)</span><br></pre></td></tr></table></figure>

<p>接下来的指令将之前保存在trapframe中的寄存器的值加载到对应的各个寄存器中。之后，我们离能真正运行用户代码就很近了。</p>
<p>现在打印所有的寄存器。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-02%2011.12.27.png" alt="截屏2024-03-02 11.12.27"></p>
<p>这些寄存器的值就是我们在最开始的时候看到的寄存器的值。但是a0寄存器现在还是个例外，它仍然指向trapframe的指针，而不是保存了的用户数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># restore user a0</span><br><span class="line"> ld a0, 112(a0)</span><br><span class="line">       </span><br><span class="line"> # return to user mode and user pc.</span><br><span class="line"> # usertrapret() set up sstatus and sepc.</span><br><span class="line"> sret</span><br></pre></td></tr></table></figure>

<p>接下来，我们将进入内核态前存储在trapframe + 112 处的用户态a0寄存器的值重新加载到a0中，然后执行我们在kernel中的最后一条指令sret，当我们执行完这条指令：</p>
<ul>
<li>程序会切换回user mode</li>
<li>sepc寄存器的数值会被拷贝到pc寄存器</li>
<li>重新打开中断</li>
</ul>
<p>现在我们回到了用户空间。打印pc寄存器</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-02%2011.21.13.png" alt="截屏2024-03-02 11.21.13"></p>
<p>程序计数器的值的确对应<code>sh.asm</code>文件中<code>write</code>函数的<code>ret</code>指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000000e2c &lt;write&gt;:</span><br><span class="line">.global write</span><br><span class="line">write:</span><br><span class="line"> li a7, SYS_write</span><br><span class="line">     e2c:	48c1                	li	a7,16</span><br><span class="line"> ecall</span><br><span class="line">     e2e:	00000073          	ecall</span><br><span class="line"> ret</span><br><span class="line">     e32:	8082                	ret</span><br></pre></td></tr></table></figure>

<p>所以我们回到了用户空间，执行完ret指令后就可以从write系统调用返回到shell中了。更严格的说，是从触发了系统调用的write库函数中返回到shell中。</p>
<p>最后总结一下，系统调用被刻意设计的看起来像是函数调用，但是背后的user&#x2F;kernel转换比函数调用要复杂的多。之所以这么复杂，很大一部分原因是要保持user&#x2F;kernel之间的隔离性，内核不能信任来自用户空间的任何内容。</p>
<p>另一方面，XV6实现trap的方式比较特殊，XV6并不关心性能。但是通常来说，操作系统的设计人员和CPU设计人员非常关心如何提升trap的效率和速度。必然还有跟我们这里不一样的方式来实现trap，当你在实现的时候，可以从以下几个问题出发：</p>
<ul>
<li>硬件和软件需要协同工作，你可能需要重新设计XV6，重新设计RISC-V来使得这里的处理流程更加简单，更加快速。</li>
<li>另一个需要时刻记住的问题是，恶意软件是否能滥用这里的机制来打破隔离性。</li>
</ul>
<h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><h3 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h3><p>知道一些RISC-V 汇编代码是重要的。在xv6资源中有<code>user/call.c</code>文件。通过make fs.img编译它并产生一些可读的程序汇编代码<code>user/call.asm</code></p>
<p>阅读call.asm中函数g、f和main的代码。RISC-V的说明手册在参考页面上。在answers-traps.txt中回答以下问题：</p>
<ul>
<li><p><code>Which registers contain arguments to functions? For example, which register holds 13 in main&#39;s call to printf ?</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%d %d\n&quot;, f(8)+1, 13);</span><br><span class="line">24:	4635                	li	a2,13</span><br></pre></td></tr></table></figure>

<p><code>a2</code>寄存器保存值13</p>
</li>
<li><p><code>Where is the call to function </code>f<code>in the assembly code for main? Where is the call to</code>g<code>? (Hint: the compiler may inline functions.)</code></p>
<p>对函数g 和函数f 已经被编译器内联，所以在汇编代码中没有对它们的调用</p>
</li>
<li><p>At what address is the function <code>printf</code> located?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000000000630 &lt;printf&gt;:</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">  1c:	1141                	add	sp,sp,-16</span><br><span class="line">  1e:	e406                	sd	ra,8(sp)</span><br><span class="line">  20:	e022                	sd	s0,0(sp)</span><br><span class="line">  22:	0800                	add	s0,sp,16</span><br><span class="line">  printf(&quot;%d %d\n&quot;, f(8)+1, 13);</span><br><span class="line">  24:	4635                	li	a2,13</span><br><span class="line">  26:	45b1                	li	a1,12</span><br><span class="line">  28:	00000517          	auipc	a0,0x0</span><br><span class="line">  2c:	7a850513          	add	a0,a0,1960 # 7d0 &lt;malloc+0xe8&gt;</span><br><span class="line">  30:	00000097          	auipc	ra,0x0</span><br><span class="line">  34:	600080e7          	jalr	1536(ra) # 630 &lt;printf&gt;</span><br></pre></td></tr></table></figure>

<p>通过上面两段代码，我们可以知道函数<code>printf</code>的地址为<code>0x630</code></p>
</li>
<li><p><code>What value is in the register ra just after the jalr to printf in main ?</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">  1c:	1141                	add	sp,sp,-16</span><br><span class="line">  1e:	e406                	sd	ra,8(sp)</span><br><span class="line">  20:	e022                	sd	s0,0(sp)</span><br><span class="line">  22:	0800                	add	s0,sp,16</span><br><span class="line">  printf(&quot;%d %d\n&quot;, f(8)+1, 13);</span><br><span class="line">  24:	4635                	li	a2,13</span><br><span class="line">  26:	45b1                	li	a1,12</span><br><span class="line">  28:	00000517          	auipc	a0,0x0</span><br><span class="line">  2c:	7a850513          	add	a0,a0,1960 # 7d0 &lt;malloc+0xe8&gt;</span><br><span class="line">  30:	00000097          	auipc	ra,0x0</span><br><span class="line">  34:	600080e7          	jalr	1536(ra) # 630 &lt;printf&gt;</span><br><span class="line">  exit(0);</span><br><span class="line">  38:	4501                	li	a0,0</span><br><span class="line">  3a:	00000097          	auipc	ra,0x0</span><br><span class="line">  3e:	28e080e7          	jalr	654(ra) # 2c8 &lt;exit&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在执行<code>jalr</code>指令调用<code>printf</code>函数后，<code>ra</code>（返回地址寄存器）中的值将是该<code>jalr</code>指令的下一条指令的地址。<code>jalr</code>（Jump and Link Register）指令的作用是跳转到通过寄存器和偏移量计算得到的地址执行，并将下一条指令的地址（即<code>jalr</code>指令后面那条指令的地址）保存到<code>ra</code>寄存器中，以便函数执行完后可以通过<code>ra</code>寄存器中的地址返回到调用位置继续执行。</p>
</blockquote>
<p>在<code>jalr</code>指令后，<code>ra</code>寄存器将包含下一条指令的地址，即<code>exit(0)</code>对应的第一条地址<code>0x38</code>，这确保了在<code>printf</code>函数执行完后，程序能够通过<code>ra</code>寄存器中的返回地址继续执行。</p>
</li>
<li><pre><code>Run the following code.

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned int i = 0x00646c72;</span><br><span class="line">printf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</span><br><span class="line">     </span><br></pre></td></tr></table></figure>

What is the output? [Here&#39;s an ASCII table](https://www.asciitable.com/) that maps bytes to characters.

The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set `i` to in order to yield the same output? Would you need to change `57616` to a different value?
</code></pre>
<p>输出<code>Hello World</code></p>
<p>在小端序系统中，使用<code>i = 0x00646c72;</code>。</p>
<p>要在大端序系统中获得相同的输出，应设置<code>i = 0x726c6400;</code>。</p>
<p><code>57616</code>的值保持不变</p>
</li>
<li><pre><code>In the following code, what is going to be printed after `&#39;y=&#39;`? (note: the answer is not a specific value.) Why does this happen?

printf(&quot;x=%d y=%d&quot;, 3);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 打印`x=3 y=`之后的内容不会是一个具体的值，而是未定义的行为（Undefined Behavior）。这是因为`printf`函数期望根据格式字符串中的占位符（这里有两个`%d`）接收相同数量的参数，但实际上只提供了一个参数（`3`）。对于第二个`%d`占位符，`printf`会尝试从调用的参数列表中读取下一个值来打印，但因为没有提供足够的参数，所以它会尝试读取未初始化的内存或超出了函数调用提供的参数范围的内存位置。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 结果是，`y=`之后打印的值将是那个内存位置的当前值，这个值是不确定的，可能每次运行时都不同，甚至可能导致程序崩溃，因为这是典型的未定义行为。在C语言中，未定义行为意味着编译器不保证程序会有任何特定的行为，程序的行为可能不可预测。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 为了避免这种情况，应该确保为`printf`（或任何函数）提供的参数数量与格式字符串中指定的占位符数量一致：</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
&gt; printf(&quot;x=%d y=%d&quot;, 3, /* 需要一个额外的整数参数 */);
&gt; <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">只有这样，才能保证程序的正确和可预测的行为。</span><br><span class="line"></span><br><span class="line">### BackTrace</span><br><span class="line"></span><br><span class="line">为了调试，通常需要有一个回溯（backtrace）：在发生错误的点以上的堆栈上的函数调用列表。为了帮助进行回溯，编译器生成的机器码会在堆栈上为当前调用链中的每个函数维护一个堆栈帧。每个堆栈帧由返回地址和指向调用者堆栈帧的“帧指针”组成。寄存器`s0`包含指向当前堆栈帧的指针（实际上，它指向堆栈上保存的返回地址的地址加上8）。你的回溯应该使用帧指针在堆栈上向上遍历，并打印每个堆栈帧中保存的返回地址。</span><br><span class="line"></span><br><span class="line">在`kernel/printf.c`中实现`backtrace()`函数。在`sys_sleep`中插入对该函数的调用，然后执行`bttest`，该测试会调用sys_sleep。你的输出应该是一系列的返回地址，格式如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<blockquote>
<p>backtrace:<br>0x0000000080002cda<br>0x0000000080002bb6<br>0x0000000080002898</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在`bitetest`退出qemu后。在终端窗口中运行：`addr2line -e kernel/kernel (or riscv64-unknown-elf-addr2line -e kernel/kernel)` 并复制粘贴`backtrace`中返回的地址：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$ addr2line -e kernel&#x2F;kernel<br>0x0000000080002cda<br>0x0000000080002bb6<br>0x0000000080002898<br>Ctrl-D</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">终端会输出：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>kernel&#x2F;sysproc.c:74<br>kernel&#x2F;syscall.c:224<br>kernel&#x2F;trap.c:85</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">一些提示：</span><br><span class="line"></span><br><span class="line">- 在文件`kernel/defs.h`中添加`backtrace()`函数的原型，这样才能在`sys_sleep`中调用`backtrace`</span><br><span class="line"></span><br><span class="line">- GCC编译器将当前执行函数的栈桢指针（地址）保存在寄存器a0中。在`kernel/riscv.h`中添加如下函数：</span><br><span class="line"></span><br><span class="line"> ```c</span><br><span class="line"> static inline uint64 r_fp() &#123;</span><br><span class="line">   uint64 x;</span><br><span class="line">   asm volatile(&quot;mv %0, s0&quot; : &quot;=r&quot; (x) );</span><br><span class="line">   return x;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>  然后调用函数<code>backtrace</code>读取当前栈帧。函数<code>r_fp</code>使用内联汇编代码读取<code>s0</code>。</p>
<ul>
<li><p>课程笔记有栈帧指针（地址）的分布情况。请注意，返回地址位于堆栈帧的帧指针的固定偏移处（-8），而保存的帧指针位于帧指针的固定偏移处（-16）。</p>
</li>
<li><p><code>backtrace()</code>函数需要能够识别到最后一个栈，然后停止。一个有用的事实是，为每个内核栈分配的内存由一个单独的、与页面对齐的页面组成，因此给定栈的所有栈帧都位于同一个页面上。你可以使用<code>PGROUNDDOWN(fp)</code>（参见<code>kernel/riscv.h</code>）来识别帧指针所指向的页面。</p>
</li>
</ul>
<p>一旦你的回溯功能正常工作，就从<code>kernel/printf.c</code>中的<code>panic</code>函数调用它，这样当内核出现panic时，你就能看到内核的回溯信息。</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-04%2019.43.45.png" alt="截屏2024-03-04 19.43.45"></p>
<h3 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h3><blockquote>
<p>在这个练习中，你将为xv6添加一个特性，该特性会定期提醒一个进程关于它所使用的CPU时间。这对于想要限制自己消耗CPU时间的计算密集型进程来说可能很有用，或者对于想要计算同时又想定期执行某些操作的进程来说也很有用。更一般地，你将实现一种原始形式的用户级中断&#x2F;故障处理器；例如，你可以使用类似的机制来处理应用中的页面故障。如果你的解决方案通过了alarmtest和’usertests -q’，则认为是正确的。</p>
</blockquote>
<p>你应该添加一个新的<code>sigalarm(interval, handler)</code>系统调用。如果一个应用程序调用了<code>sigalarm(n, fn)</code>，那么在程序消耗了每<code>n</code>个”ticks”的CPU时间后，内核应该使应用程序函数<code>fn</code>被调用。当<code>fn</code>返回时，应用程序应该从中断处继续执行。在xv6中，一个tick是一个相当任意的时间单位，由硬件定时器产生中断的频率决定。如果应用程序调用<code>sigalarm(0, 0)</code>，内核应该停止生成周期性的警报调用。</p>
<p>在你的xv6仓库中，你会找到一个名为<code>user/alarmtest.c</code>的文件。将它添加到Makefile中。在你添加了<code>sigalarm</code>和<code>sigreturn</code>系统调用之前（见下文），它不会正确编译。</p>
<p><code>alarmtest</code>在<code>test0</code>中调用<code>sigalarm(2, periodic)</code>，请求内核每2个ticks强制调用一次<code>periodic()</code>函数，然后进行一段时间的循环。你可以在<code>user/alarmtest.asm</code>中看到<code>alarmtest</code>的汇编代码，这可能对调试很有帮助。当<code>alarmtest</code>产生如下输出，并且<code>usertests -q</code>也正确运行时，你的解决方案就是正确的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">alarmtest</span></span><br><span class="line">test0 start</span><br><span class="line">........alarm!</span><br><span class="line">test0 passed</span><br><span class="line">test1 start</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">test1 passed</span><br><span class="line">test2 start</span><br><span class="line">................alarm!</span><br><span class="line">test2 passed</span><br><span class="line">test3 start</span><br><span class="line">test3 passed</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">usertest -q</span></span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>

<p>完成这个任务时，你的解决方案只需要几行代码，但要做到正确可能会有些棘手。我们将使用原始仓库中的<code>alarmtest.c</code>版本来测试你的代码。你可以修改<code>alarmtest.c</code>来帮助你调试，但请确保原始的<code>alarmtest</code>表示所有测试都通过了。</p>
<h4 id="Test0-invoke-handler"><a href="#Test0-invoke-handler" class="headerlink" title="Test0: invoke handler"></a>Test0: invoke handler</h4><p>开始时，通过修改内核来跳转到用户空间的警报处理程序，这将导致<code>test0</code>打印”alarm!”。目前不用担心alarm后会发生什么；如果你的程序在打印”alarm!”之后崩溃，目前这样也是可以的。以下是一些提示：</p>
<ul>
<li><p>修改Makefile文件，是的<code>alarmtest.c</code>将被当作xv6的用户程序被编译</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">	$U/_alarmtest\</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>user/user.h</code>中声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigalarm</span><span class="params">(<span class="type">int</span> ticks, <span class="type">void</span> (*handler)())</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigreture</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更新<code>user/usys.pl</code>（该文件会生成<code>user/usys.S</code>），<code>kernel/syscall.h</code>，和<code>kernel/syscall.c</code>以允许<code>alarmtest</code>调用<code>sigalarm</code>和<code>sigreturn</code>系统调用。</p>
<p>In <code>user/usys.pl</code>:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">entry(<span class="string">&quot;sigalarm&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sigreturn&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>In <code>kernel/syscall.h</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sigalarm 22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sigreturn 23</span></span><br></pre></td></tr></table></figure>

<p>In <code>kernel/syscall.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span>;   <span class="comment">// add syscall</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// add syscall</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123; </span><br><span class="line">  ...</span><br><span class="line">	[SYS_sigalarm] sys_sigalarm,</span><br><span class="line">	[SYS_sigreturn] sys_sigreturn,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当前，<code>sys_sigreturn</code>只用返回0。</p>
</li>
<li><p>函数<code>sys_sigalarm</code>应该在结构体<code>proc</code>的新区域中保存<code>alarm interval</code>和<code>the pointer to the handler function</code>。</p>
<p>In <code>kernel/proc.h</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="type">int</span> alarm_interval;</span><br><span class="line">  uint64 handler_pointer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>In <code>kernel/sysproc.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get the alarm interval and handler pointer from syscall</span></span><br><span class="line"><span class="comment">     * and store them in process</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="type">int</span> alarm_interval = <span class="number">0</span>;</span><br><span class="line">    uint64 handler_pointer = <span class="number">0</span>;</span><br><span class="line">    argint(<span class="number">0</span>, &amp;alarm_interval);</span><br><span class="line">    argaddr(<span class="number">1</span>, &amp;handler_pointer);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> * <span class="title">proc</span> =</span> myproc();</span><br><span class="line">    proc-&gt;alarm_interval = alarm_interval;</span><br><span class="line">    proc-&gt;handler_pointer = handler_pointer;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>你需要跟踪自上一次调用（或距离下一次调用）进程的警报处理程序以来已经过去了多少个ticks；为此你还需要在<code>struct proc</code>中添加一个新的字段。你可以在<code>proc.c</code>中的<code>allocproc()</code>函数中初始化<code>proc</code>字段。</p>
<p>In <code>kernel/proc.h</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> passed_time;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>In <code>kernel/proc.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc* <span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  	...</span><br><span class="line">found:</span><br><span class="line">  p-&gt;passed_time = <span class="number">0</span>;</span><br><span class="line">  p-&gt;alarm_interval = <span class="number">0</span>;</span><br><span class="line">  p-&gt;handler_pointer = <span class="number">0</span>;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每个tick，硬件时钟产生一个中断，该中断在<code>kernel/trap.c</code>中的函数<code>usertrap()</code>里被处理。</p>
</li>
<li><p>你只想在有定时器中断的情况下操作进程的警报计时器；你需要像如下的东西一样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) ... <span class="comment">// this is a timer interrupt</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>只需要在计时器超时时调用警报函数。注意用户的警报函数的地址看可能为0。</p>
</li>
<li><p>你需要修改<code>usertrap()</code>，这样当进程的警报间隔到期时，用户进程执行处理函数。当RISC-V上的一个陷阱返回到用户空间时，决定用户空间代码恢复执行的指令地址是什么？</p>
<p>从<code>trampoline.S</code>的<code>userret</code>函数中我们可以看到，内核通过<code>sret</code>指令返回到用户空间。</p>
<p>In <code>kernel/trap.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">    ++p-&gt;passed_time;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;passed_time % p-&gt;alarm_interval == <span class="number">0</span>) &#123;</span><br><span class="line">        p-&gt;trapframe-&gt;epc = p-&gt;handler_pointer;</span><br><span class="line">    &#125;</span><br><span class="line">    yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你告诉 QEMU 只使用一个 CPU，在 GDB 中查看陷阱会更容易，你可以通过运行以下命令来实现这一点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make CPUS=1 qemu-gdb</span><br></pre></td></tr></table></figure>
</li>
<li><p>You’ve succeeded if alarmtest prints “alarm!”.</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-05%2015.48.18.png" alt="截屏2024-03-05 15.48.18"></p>
</li>
</ul>
<h4 id="test1-x2F-test2-x2F-test3-resume-interrupted-code"><a href="#test1-x2F-test2-x2F-test3-resume-interrupted-code" class="headerlink" title="test1&#x2F;test2()&#x2F;test3(): resume interrupted code"></a>test1&#x2F;test2()&#x2F;test3(): resume interrupted code</h4><p>有可能在<code>alarmtest</code>执行<code>test0</code>或<code>test1</code>并打印出”alarm!”之后会发生崩溃，或者<code>alarmtest</code>最终打印出”test1 failed”，或者<code>alarmtest</code>退出而没有打印出”test1 passed”。为了解决这个问题，你必须确保当警报处理器完成时，控制权返回到用户程序原本由于定时器中断而被打断的那条指令处。你必须确保寄存器内容被恢复到中断时的值，这样用户程序在警报之后可以继续无干扰地运行。最后，你应该在每次警报计数器触发后重新设置它，以便定期调用处理器。</p>
<p>作为一个起点，我们已经为你做了一个设计决定：用户警报处理程序在完成后需要调用<code>sigreturn</code>系统调用。可以查看<code>alarmtest.c</code>中的<code>periodic</code>函数作为一个例子。这意味着你可以在<code>usertrap</code>和<code>sys_sigreturn</code>中添加代码，使它们协作，以便在用户处理完警报之后，用户进程能够正确地恢复执行。</p>
<p>提示：</p>
<ul>
<li><p>你的解决方案需要你保存和恢复寄存器——你需要保存和重新加载哪些寄存器来恢复中断的程序？</p>
</li>
<li><p>当定时器触发时，让<code>usertrap</code>在<code>struct proc</code>中保存足够的状态，以便<code>sigreturn</code>可以正确返回到被中断的用户代码。</p>
</li>
<li><p>防止对处理程序的重入调用——如果一个处理程序还没有返回，内核不应该再次调用它。<code>test2</code>就是用来测试这一点的。</p>
</li>
<li><p>确保恢复<code>a0</code>。<code>sigreturn</code>是一个系统调用，它的返回值存储在<code>a0</code>中。</p>
</li>
</ul>
<p>首先我们在<code>struct proc</code>中增加两个成员，用于表示当前进程是否正在执行<code>handler</code>和保存执行<code>handler</code>之前的<code>trapframe</code>：</p>
<p>In <code>kernel/proc.h</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="type">int</span> is_handling;             <span class="comment">// indicates that the process is handling the handler</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">saved_trapframe</span>;</span>    <span class="comment">// used to save the trapframe</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，我们要在<code>kernel/proc.c</code>中的<code>allocproc()</code>函数中初始化它们；并在<code>freeproc()</code>函数中释放它们。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc* <span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  p-&gt;is_handling = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;saved_trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">      freeproc(p);</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;saved_trapframe)</span><br><span class="line">      kfree((<span class="type">void</span>*)p-&gt;saved_trapframe);</span><br><span class="line">  p-&gt;saved_trapframe = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着在<code>usertrap</code>函数中处理时间中断<code>timer interrupt</code>:</p>
<p>在这里我们把当前进程的<code>trapframe-&gt;epc</code>设置为<code>handler</code>的地址，这是因为在函数<code>usertrap()</code>执行完成后会调用<code>usertrapret()</code>函数，在该函数中会通过：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br></pre></td></tr></table></figure>

<p>将<code>sepc</code>寄存器设置为<code>p-&gt;trapframe-&gt;epc</code>的值，使程序跳转到其指向的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">	<span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">      p-&gt;passed_time++;	<span class="comment">// 每一次时间中断，使进程的passed_time增加1</span></span><br><span class="line">    	<span class="comment">// 如果增加的时间为间隔时间的倍数，且当前进程没有执行处理函数</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;passed_time % p-&gt;alarm_interval == <span class="number">0</span> &amp;&amp; p-&gt;is_handling == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="comment">// 保存现场</span></span><br><span class="line">          memmove(p-&gt;saved_trapframe, p-&gt;trapframe, PGSIZE);</span><br><span class="line">        	<span class="comment">// 将当前进程的trapframe-&gt;epc设置为handler函数的地址上</span></span><br><span class="line">          p-&gt;trapframe-&gt;epc = p-&gt;handler_pointer;</span><br><span class="line">        	<span class="comment">// 置正在处理为1</span></span><br><span class="line">          p-&gt;is_handling = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      yield();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后修改<code>sys_sigreturn</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  	<span class="comment">// 恢复现场</span></span><br><span class="line">    memmove(myproc()-&gt;trapframe, myproc()-&gt;saved_trapframe, PGSIZE);</span><br><span class="line">    <span class="comment">// 置为0</span></span><br><span class="line"> 		myproc()-&gt;is_handling = <span class="number">0</span>;</span><br><span class="line">  	<span class="comment">// 恢复寄存器a0的值</span></span><br><span class="line">    <span class="keyword">return</span> myproc()-&gt;trapframe-&gt;a0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试通过：</p>
<p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-05%2019.39.18.png" alt="截屏2024-03-05 19.39.18"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/27/GDBtutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/27/GDBtutorial/" class="post-title-link" itemprop="url">GDBtutorial</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-27 20:19:04" itemprop="dateCreated datePublished" datetime="2024-02-27T20:19:04+08:00">2024-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-28 10:15:45" itemprop="dateModified" datetime="2024-02-28T10:15:45+08:00">2024-02-28</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>36</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="GDBtutorial"><a href="#GDBtutorial" class="headerlink" title="GDBtutorial"></a>GDBtutorial</h2><h3 id="打断点"><a href="#打断点" class="headerlink" title="打断点"></a>打断点</h3><ol>
<li>断点在函数上面：<code>b main</code></li>
<li>断点在文件的gu</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/22/HOT-COLD-DATA-SEPARATION-POLICIES/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/22/HOT-COLD-DATA-SEPARATION-POLICIES/" class="post-title-link" itemprop="url">HOT/COLD DATA SEPARATION POLICIES</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-22 15:50:49" itemprop="dateCreated datePublished" datetime="2024-01-22T15:50:49+08:00">2024-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-23 09:44:27" itemprop="dateModified" datetime="2024-01-23T09:44:27+08:00">2024-01-23</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SSD中冷热数据分类策略的总结"><a href="#SSD中冷热数据分类策略的总结" class="headerlink" title="SSD中冷热数据分类策略的总结"></a>SSD中冷热数据分类策略的总结</h1><h2 id="2-Level-LRU"><a href="#2-Level-LRU" class="headerlink" title="2-Level LRU"></a>2-Level LRU</h2><p>两级<code>LRU</code>策略使用了两种<code>LRU-based</code>列表：热列表<code>(hot list)</code>和候选列表<code>(candidate list)</code>。每个列表包含逻辑页号<code>(LPNs) Logic Page Number</code>。基本上，只有存储在<code>hot list</code>上的逻辑页号才被当作热数据。在这个策略下，当一个写操作被接收时，<code>FTL</code>在两个列表中寻找相关的<code>LPN</code>，如果逻辑页号在<code>host list</code>中，它被提升到<code>host list</code>的首位，以减少被驱逐的机会。如果<code>LPN</code>在<code>candidate list</code>上，将其从<code>candidate list</code>中移除并放入<code>hot list</code>中。如果两个<code>list</code>中都没有该<code>LPN</code>，则将其放到<code>candidate list</code>中。每个<code>list</code>的大小是固定的。如果<code>hot list</code>满了，<code>candidate list</code>中的最后一个<code>LPN</code>会被丢弃。</p>
<p>该策略简单但有问题。固定大小的<code>hot list</code>意味着它无法适应热数据量超过热列表大小的各种工作负载。另一个问题是基于<code>LRU list</code>的查找操作因为线性查找会消耗大量时间。</p>
<h2 id="Multiple-Bloom-Filter"><a href="#Multiple-Bloom-Filter" class="headerlink" title="Multiple Bloom Filter"></a>Multiple Bloom Filter</h2><p><code>MBF</code>策略使用<code>bloom filters (BF)</code>测试当前<code>LPN</code>是否属于热数据集<code>set of hot data</code>。<code>BF</code>由一个位数组组成，其大小是<code>BLOOM_FILTER_SIZE</code>（即位数）。每个逻辑页号<code>(LPN)</code>通过多个不同的哈希函数进行哈希处理，根据每个<code>LPN</code>的哈希结果，BF中相应的位被设置为1。这意味着每个LPN的哈希结果会影响BF中特定位的状态。这个策略通过将<code>LPN</code>映射到BF的特定位来跟踪哪些<code>LPN</code>属于热数据集。如果一个LPN的哈希结果对应的位在BF中已经被设置为1，那么这个<code>LPN</code>被认为是热数据的一部分。这种方法用于快速检测和过滤热数据，优化数据存储和访问效率。</p>
<p>为了最小化错误地将一些非热数据错误分类为热数据的假阳性错误，多重布隆过滤器（MBF）策略利用了多个布隆过滤器（BF）。BF（数字过滤器）的实际数量是可配置的，建议至少有四个BF。在某一点上，其中一个布隆过滤器被指定为当前过滤器<code>cur_filter</code>。对于每个写请求，如果当前过滤器中相应的位已经被设置为<code>1</code>，<code>MBF</code>策略会尝试以循环方式在下一个布隆过滤器的相同位置设置该位。在每个衰减周期之后，当前过滤器被设置为最长时间间隔内未被选中的布隆过滤器，并且该布隆过滤器中的所有位都被清除，以去除旧信息。在<code>MBF</code>策略下，通过使用相同的哈希函数对<code>LPN</code>进行哈希处理，然后计算所有布隆过滤器中对应位位置的置<code>1</code>位数，来估计<code>LPN</code>的热度。如果所有哈希位置的计数超过预定义的阈值，该LPN被分类为热数据。</p>
<p><code>MBF</code>的优点之一是它只消耗很少的内存空间。然而<code>MBF</code>的性能很大程度上依赖于哈希函数的选择，过滤器的数量，过滤器的规模，阈值等。</p>
<blockquote>
<p>什么是布隆过滤器</p>
<p><strong>数据结构：</strong>它实际上是一个很长的二进制向量和一系列随机映射函数。以Redis中的布隆过滤器实现为例，Redis中的布隆过滤器底层是</p>
<ul>
<li><strong>一个大型位数组（二进制数组）</strong></li>
<li><strong>多个无偏hash函数：</strong>无偏hash函数就是能把元素的hash值计算的比较均匀的hash函数，能使得计算后的元素下标比较均匀的映射到位数组中。</li>
</ul>
<p><strong>空间计算：</strong>在布隆过滤器增加元素之前，首先需要初始化布隆过滤器的空间，也就是上面说的二进制数组，除此之外还需要计算无偏hash函数的个数。布隆过滤器提供了两个参数，分别是预计加入元素的大小n，运行的错误率f。布隆过滤器中有算法根据这两个参数会计算出二进制数组的大小l，以及无偏hash函数的个数k。<br>它们之间的关系比较简单：</p>
<ul>
<li>错误率越低，位数组越长，控件占用较大</li>
<li>错误率越低，无偏hash函数越多，计算耗时较长</li>
</ul>
</blockquote>
<h2 id="Dynamic-dAta-Clustering"><a href="#Dynamic-dAta-Clustering" class="headerlink" title="Dynamic dAta Clustering"></a>Dynamic dAta Clustering</h2><p>在<code>LRU</code>和<code>MBF</code>策略中，数据被简单的分为冷热两种。然而，<code>DAC</code>策略通过<code>regions</code>提供更细粒度的数据分类。所有的逻辑页<code>LPN</code>一开始被放在<code>region 0 (coldest)</code>中接着会被慢慢的提升到更高的区域当对同一个逻辑页号有连续的写操作时。另一方面，当一个块被选为垃圾回收对象时，该块中的所有有效页会被降级到更低的<code>region</code>中。</p>
<p><code>DAC</code>中的<code>region</code>数量通常来说被置为4或者更多，当通常是根据工作负载而改变的。此外，由于每个分区都分配了单独的更新块，当干净块的数量紧张时，<code>DAC</code>策略可能表现不佳。</p>
<h2 id="A-New-LSM-style-Garbage-Collection-Scheme-for-ZNS-SSDs中的方法"><a href="#A-New-LSM-style-Garbage-Collection-Scheme-for-ZNS-SSDs中的方法" class="headerlink" title="A New LSM-style Garbage Collection Scheme for ZNS SSDs中的方法"></a>A New LSM-style Garbage Collection Scheme for ZNS SSDs中的方法</h2><p>基于我们的观察，具有类似寿命的数据表现出强烈的空间局部性。例如，在键值存储中，每个层级显示不同的寿命，而同一层级中的<code>SSTables</code>是以批量方式写入的，这一点在之前的研究中也有观察到。</p>
<blockquote>
<ol>
<li><strong>CAO, Z., DONG, S., VEMURI, S., AND DU, D. H. Characteriz- ing, modeling, and benchmarking rocksdb key-value workloads at facebook. In <em>USENIX FAST</em> (2020).</strong></li>
<li><strong>KIM, T., HONG, D., HAHN, S. S., CHUN, M., LEE, S., HWANG, J., LEE, J., AND KIM, J. Fully automatic stream management for multi-streamed ssds using program contexts. In <em>FAST</em> (2019).</strong></li>
</ol>
</blockquote>
<p><img src="/../images/HOT-COLD-DATA-SEPARATION-POLICIES/%E6%88%AA%E5%B1%8F2024-01-22%2019.06.46.png" alt="截屏2024-01-22 19.06.46"></p>
<p>为了分别冷热数据并将它们分到不同的区域中，我们定义四种状态的区域，<code>C0_Zone</code>，<code>C1C_Zone</code>，<code>C1H_Zone</code>和<code>C2_Zone</code>。新到的数据顺序写入<code>C0_zone</code>，删除的数据从图中的状态中删除。</p>
<p>假设<code>LSM_ZGC</code>选择一个状态为<code>C0_zone</code>的候选区域。它读取区域中所有的段并尝试识别冷热数据。我们定义当段的利用率大于阈值<code>thresholdcold</code>时被称为冷。被识别为冷的段中有效块被合并和写入状态为<code>C1C_zone</code>的区域中。其他段中的有效块被合并和写入状态为<code>C1H_zone</code>中。</p>
<p>当候选区域是C1C区域或C1H区域时，LSM ZGC会读取所有段，并将所有有效块视为冷数据。这是因为这些有效块在两次垃圾收集尝试后仍然存在。它们被合并并写入到状态为C2区域的区域中。我们可以进一步扩展，例如C3区域等，但在这项研究中，我们在此停止，并将从C2区域存活下来的有效块写入另一个C2区域。我们期望这种机制能够将冷数据与其他数据隔离开来，这将增加在垃圾收集期间找到利用率较低的候选区域的机会。</p>
<h2 id="Dynamic-Hot-Data-Identification-Using-a-Stack-Distance-Approximation"><a href="#Dynamic-Hot-Data-Identification-Using-a-Stack-Distance-Approximation" class="headerlink" title="Dynamic Hot Data Identification Using a Stack Distance Approximation"></a>Dynamic Hot Data Identification Using a Stack Distance <strong>Approximation</strong></h2><p>热数据的鉴别需要同时考虑最近性<code>(recency)</code>和频率<code>(frequency)</code>。</p>
<p>本文提出一种利用堆栈距离近似的动态热数据鉴别策略。包含三部分：工作负载分析器，负载分配器，冷热数据鉴别器。</p>
<p>我们提议的热&#x2F;冷数据标识符还采用了多个<code>bloom filter</code>和多个<code>hash function</code>。多个<code>bloom filter</code>可以捕获最近性和频率。然而，我们的动态方案和MBF之间的主要区别在于<code>bloom filter</code>选择机制。我们提议的方案明智地选择了其中一个<code>bloom filter</code>，并由我们的<code>workload analyzer</code>和<code>weight allocator</code>协助。</p>
<p>工作负载分析仪通过采用堆栈距离来提供工作负载特征分析。栈距离<code>stack distance</code>是指两次连续访问同一对象之间访问的不同对象的数量。对于时间局部访问模式<code>temporally localized access patterns</code>来说，最近性<code>recency</code>是一个更有价值的因素，堆栈距离是衡量这种时间位置的良好指标。因此，所有引用的平均堆栈距离小，表明时间局部性良好，这意味着堆栈距离较小的工作负载应将最近因素<code>recency</code>视为更重要的因素。栈距离可用于测量最近性，但同时需要高计算复杂度和高空间消耗。因此一个高效的栈距离计算方法是该设计的关键。它只使用一个哈希表，为每个桶维护简单的信息，并通过非常简单的计算生成近似的堆栈距离。因此，拟议的近似机制大大减少了开销，并以非常高的精度表现出显著的性能。</p>
<p>根据工作负载分析，权重分配器通过智能地（而不仅仅是顺序地）选择每个布隆过滤器，动态地赋予最近性或频率更多的权重。此外，与MBF不同，我们的初步工作[1]采用了一个线性递减的最近性权重函数，而我们选择了一个指数递减的权重函数，以更真实地为每个布隆过滤器分配最近性权重。因此，这种动态方案更有效地捕捉了最近性以及频率。</p>
<p><strong>A dynamic hot data identification scheme:</strong> 当工作负载有小的栈距离时，通过选择存储数据最新的重置<code>bloom filter</code>给最近性<code>recency</code>分配更多的权重。当工作负载变现出更大的栈距离时，通过选择相邻的下一个<code>bloom filter</code>分配更多的权重给频率。</p>
<p><strong>A stack distance approximation algorithm:</strong> 它采用了一个哈希表，该哈希表维护简单信息并执行非常简单的计算（即简单的两个值的平均值），从而大幅度降低计算复杂度（O(1)）。权重分配基本上基于这个近似算法。广泛的评估表明，它表现出极高的精确性和优异的性能。</p>
<p><strong>A novel baseline scheme:</strong> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/18/Improving-Flash-Write-Performance-by-Using-Update-Frequency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/18/Improving-Flash-Write-Performance-by-Using-Update-Frequency/" class="post-title-link" itemprop="url">Improving Flash Write Performance by Using Update Frequency</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-18 14:18:15" itemprop="dateCreated datePublished" datetime="2024-01-18T14:18:15+08:00">2024-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-22 11:51:27" itemprop="dateModified" datetime="2024-01-22T11:51:27+08:00">2024-01-22</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Improving-Flash-Write-Performance-by-Using-Update-Frequency"><a href="#Improving-Flash-Write-Performance-by-Using-Update-Frequency" class="headerlink" title="Improving Flash Write Performance by Using Update Frequency"></a>Improving Flash Write Performance by Using Update Frequency</h1><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>由于擦除块的规尺寸很大，有效数据和无效数据通常会被拼接在一起，导致回收空间需要高昂的数据移动。经验表明<code>FTL</code>通常很难”正确”，这是因为闪存清洁开销复杂的依赖性：</p>
<ul>
<li><code>I/O</code>负载性。</li>
<li>多种<code>FTL</code>设计选择，例如空间过度配置，数据放置算法，数据清理策略。</li>
</ul>
<p>尽管有大量的研究工作，但最终结果是低且不可预测的<code>SSD</code>写性能。特别对于产生小而分散的数据库<code>I/O</code>写入密集型工作负载。</p>
<h3 id="这片文章回答的问题：通过利用写斜来指导数据放置，我们可以在多大程度上减少FTL的写入开销？"><a href="#这片文章回答的问题：通过利用写斜来指导数据放置，我们可以在多大程度上减少FTL的写入开销？" class="headerlink" title="这片文章回答的问题：通过利用写斜来指导数据放置，我们可以在多大程度上减少FTL的写入开销？"></a>这片文章回答的问题：通过利用写斜来指导数据放置，我们可以在多大程度上减少FTL的写入开销？</h3><p>我们用一组基本的<code>I/O</code>写入模式（k模态更新分布）、数据放置策略和清理策略的清理开销进行分析建模。基于分析结果，我们提出了一种新的数据放置算法，利用更新频率来减少<code>FTL</code>清理开销，从而提高写入性能和设备寿命。</p>
<h2 id="贡献："><a href="#贡献：" class="headerlink" title="贡献："></a>贡献：</h2><ul>
<li>模拟了空间过度配置、写入频率、数据放置策略和垃圾收集策略对FTL清理开销的影响。该模型对于验证和指导<code>FTL</code>的数据放置算法的设计很有用。通过详细的模拟来验证分析结果。</li>
<li>我们在误差范围内估算出任何给定 I&#x2F;O 工作负载可实现的最小清理开销，这使我们能够量化减少任何 FTL 清理开销的空间。</li>
<li>基于建模结果，提出了一种数据放置算法，该算法以原则性的方式利用更新频率，并且能够动态适应 I&#x2F;O 写入模式，而不依赖于特定于工作负载的参数。 新的数据放置算法可以集成到现有的混合或页面级映射 FTL 中（正如我们在 2.4 节中讨论的）。 实验结果表明，与从标准 DBMS 基准（例如 TPC-C）收集的各种微基准和 I&#x2F;O 跟踪的最先进技术相比，我们的算法将清理开销减少了 20%-75% [24] 或 TATP [19]。</li>
</ul>
<h2 id="相关工作："><a href="#相关工作：" class="headerlink" title="相关工作："></a>相关工作：</h2><h3 id="一些数据放置算法："><a href="#一些数据放置算法：" class="headerlink" title="一些数据放置算法："></a>一些数据放置算法：</h3><p>我们强调了异地更新的数据放置算法的演变，并深入了解为什么一种新方法可以降低FTL清洁开销。事实上，所有<code>FTL</code>数据放置建议都尝试根据数据的更新频率对数据进行分组。</p>
<h3 id="数据放置挑战："><a href="#数据放置挑战：" class="headerlink" title="数据放置挑战："></a>数据放置挑战：</h3><p>在两个区域间移动数据的两个挑战。</p>
<ul>
<li>第一、一个区域<code>(region)</code>的占用率与其清洁成本<code>(cleaning cost)</code>之间存在高度非线性的关系。</li>
<li>第二、各区域<code>(region)</code>清理成本的增加或减少不能立即评估，而在很长一段时间后才能感受到（评估到）。</li>
</ul>
<p>例如，考虑两个分区，第一个分区与第二个分区相比，其占用率和清理成本异常高。显然我们需要将一些数据从第一个分区移动到第二个分区：然而，移动多少数据以及哪些数据并不明确。一个静态的数据提升策略（例如，尝试平衡两个分区之间的清理成本，或者简单的始终提升&#x2F;降级策略）会导致由区域占用率的变化而非工作负载偏差的变化触发的数据移动波动。页面最初从第一个分区向德格清理成本较低的分区移动。在某个点上，清理频率和&#x2F;或清理成本变得相似，页面迁移就停止了。不幸的是，到了这个时候，已经有太多页面被移动，第二个分区的清理成本继续增加。最终，迁移过程反向进行。</p>
<p>在这篇论文中，我们通过对清理成本与数据放置决策之间关系的原理性理解，解决了以往数据放置方法的局限性。我们为足够通用的更新分布建立了清理成本的分析模型，这使我们能够推理出任何给定<code>I/O</code>工作负载的基本清理开销。基于分析模型的发现，我们提出了一个原理性的数据放置算法，该算法在一定误差范围内解决最优解&#x2F;我们的数据放置算法与以往的提议有以下不同之处：</p>
<ul>
<li>没有可调参数。以前的提案依赖于工作负载特点的可变参数。例如区域的数量，从一个区域迁移到下一个区域的时间阈值，经验概率模型。</li>
<li>区域大小与页面更新频率之间没有不匹配。之前的方法建议固定大小的区域，可能导致将更新频率非常不同的页面放在一起；我们的数据提案在运行时确定最优的区域数量（即日志结构）及其最优大小。</li>
<li>准确的页面提升&#x2F;降级。<code>strawman strategy</code>总是将更新的页面提升到热区域， 将擦除的页面降级为冷区域。这样的策略会导致次优性能。清理时，我们可以区分页面是否因区域占用而被清理，还是因为它确实具有较低的更新频率。更新时，当页面足够热以证明将其推广到更热的区域时，我们可以识别精确的阈值。</li>
</ul>
<h2 id="符号和假设"><a href="#符号和假设" class="headerlink" title="符号和假设"></a>符号和假设</h2><ul>
<li><code>α</code>: 过度配置：用户空间和额外空间的比例。</li>
<li><code>μ</code>: 设备利用率：用户空间和总空间。</li>
</ul>
<p>清理块（又称垃圾收集）的开销由有效且需要在擦除块之前重新定位的页面分数给出。表示为<code>Pgc</code>：可解释为百分比或概率，块中的有效页数 &#x2F; 块的总页数。</p>
<p>清理开销 &#x3D; 需要重新定位的有效页面数量 &#x2F; 块中的总页面数量<br>$$<br>P_{gc}&#x3D;\frac{P_{valid}}{P_{total}}<br>$$<br>擦除操作带来的好处，即回收的可用空间量，是块的容量减去页面迁移所消耗的空间。因此，我们定义写放大的概念，即每次用户写入时<code>FTL</code>写入的额外物理空间。<br>$$<br>WA&#x3D;1+\frac{P_{gc}}{1-P_{gc}}&#x3D;1+\frac{P_{valid}}{P_{total}-P_{valid}}<br>$$<br>其中，<code>1</code>代表了存储新写入的用户数据所需的物理写入，只能通过压缩或去重才能避免。第二项代表了由于非原地写入而产生的实际清理开销。我们同样把第二项称为<code>GC (Garbage Collection)</code>。</p>
<p> <strong><code>I/O</code>工作负载：</strong>这篇文章对<code>k-model I/O</code>工作负载的变体进行建模。<code>k-model I/O</code>工作负载代表一种更新分布，其中任何页面的更新频率只能有<code>k</code>个可能的离散值<code>(fi,...,fk)</code>。我们将具有给定更新频率的所有页面称为一个更新集。每个更新集都有一个相关的大小，定义为总用户数据的一部分<code>si</code>，并接收到总更新的一部分<code>fsi</code>。</p>
<p><code>k-model</code>工作负载有两个优势：</p>
<ul>
<li>建模简单。</li>
<li>足够通用，可以近似模拟真实的<code>I/O</code>工作负载。通过将具有相似更新频率的页面”分箱”组合在一起，可以通过<code>k</code>模态工作负载来抽象一般的<code>I/O</code>工作负载。正如我们将看到，页面可以安全地分组到具有指数级增常更新频率的箱中。</li>
</ul>
<h3 id="模型假设"><a href="#模型假设" class="headerlink" title="模型假设"></a>模型假设</h3><p>建模清理开销时，做出如下假设：</p>
<ul>
<li>我们排除了顺序写入。利用顺序写入模式是一个正交的主题，相对容易实现，例如通过检测顺序写入模式并将更新存储在同一个擦除块中。如果同样的页面再次顺序写入，该块被置为无效，并且可以在不进行任何数据移动的情况下被擦除。然而，我们的模型支持任何偏斜的<code>I/O</code>工作负载。</li>
<li>我们只建模长期<code>FTL</code>擦除开销。新格式化的<code>SSD</code>没有立即的清理开销，因为所有闪存块都被擦除并可用于写入，这导致好的但是短暂的写入性能。</li>
</ul>
<h2 id="FTL清理策略"><a href="#FTL清理策略" class="headerlink" title="FTL清理策略"></a><code>FTL</code>清理策略</h2><h3 id="随机更新-1-Modal-Distribution"><a href="#随机更新-1-Modal-Distribution" class="headerlink" title="随机更新(1-Modal Distribution)"></a>随机更新<code>(1-Modal Distribution)</code></h3><p>假设一个由单页更新组成的随机更新工作负载。所有页面拥有相同的更新概率，因此，数据放置并不重要，例如，将任何页面存储在一起没有任何好处，清除成本只依赖于块选择策略。</p>
<p>贪婪策略：选择具有最少有效页的块进行更新。由于所有页面的更新频率相同，并且更新不相关，因此贪婪政策是最佳的。</p>
<p>我们首先对<code>LRU</code>和<code>Greedy policy</code>进行建模，表明<code>LRU</code>清洁政策接近最佳是实际重要性的。</p>
<p>闪存设备可以考虑为圆形日志结构，其中更新附加到尾部，每当需要空间时，清理总是从日志头开始，写入最古老的块。</p>
<p>在完整的日志循环中，写入操作要么是由页面迁移引起的，要么是由实际用户更新引起的。</p>
<p>在每次用户更新时，一个给定页面不会被置为无效的概率是，其中<code>N</code>是页面的总数：<br>$$<br>1-\frac{1}{N}<br>$$<br>而清理过程不会产生无效化（一旦有效页面被重新定位，一个块就会立即被擦除）。因此，一个给定页面在整个日志循环期间保持有效的概率是它在一次更新中避免无效化的概率的总用户更新次数的幂。</p>
<p>假设总共有<code>(1 + α) * N</code>个物理页，<code>Pgc</code>的一部分会因为擦除过程中的重新分配被”浪费”，而<code>(1 - Pgc)</code>的物理页面事实上存储新的用户数据。因此，我们可以通过方程的极限推导出<code>Pgc</code>。<br>$$<br>P_{gc}&#x3D;(1-\frac{1}{N})^{N(1+α)(1-p_{gc})}<br>$$<br>当<code>N</code>足够大的时候，我们应用欧拉极限<code>Euler&#39;s limit</code> :<br>$$<br>P_{gc}&#x3D;e^{-(1+α)(1-p_{gc})}<br>$$<br>它接受解析解：<br>$$<br>P_{gc}&#x3D;-\frac{W(-(1+α)e^{-(1+α)})}{1+α}<br>$$<br>上面公式中的<code>W</code>是<code>Lambert-W</code>函数，即:<br>$$<br>z&#x3D;W(z)e^{W(z)}<br>$$<br>的解。<code>W</code>不能表示为代数函数的组合。然而，<code>W</code>可以进行数值计算（例如通过泰勒展开），尽管从实际角度来看，这相当繁琐。</p>
<p>因此我们提出一种简单的近似方法。注意到：<br>$$<br>-(1+α)e^{-α}⊂(-e^{-1},0)\quadα ∈ R^+<br>$$<br>因此我们需要在一个相当小的范围内近似<code>W</code>。最终得到代数近似：<br>$$<br>P_{gc}\approx\frac{e^{-0.9\alpha}}{1+\alpha}<br>$$<br>方程<code>(9)</code>提供了在分配额外容量和清理性能之间的定量权衡，它表明，随着超额配置的增加，<code>Pgc</code>的减少速度略快于指数级。</p>
<h4 id="贪婪清除策略Greedy-cleaning-policy"><a href="#贪婪清除策略Greedy-cleaning-policy" class="headerlink" title="贪婪清除策略Greedy cleaning policy"></a>贪婪清除策略<code>Greedy cleaning policy</code></h4><p>为了量化贪婪清洁政策的好处，我们需要考虑超过方程4给出的平均pgc值：我们还需要对有效页面在擦除块上的分布进行建模。</p>
<p>对于<code>LRU</code>和<code>Greedy</code>策略：无论何时我们需要回收空间时，我们选择具有最少有效页数量的最老写入的<code>B</code>个块。当<code>B = 1</code>时，清除策略变为<code>LRU</code>；当<code>B = (1 + α) N / C</code>时变为贪婪策略。建模时考虑如下：</p>
<ul>
<li><p>概率分布函数<code>Pgc</code>，简称为<code>(PDF)</code>，是关于<code>α</code>过量配置的函数。</p>
<p>块中的有效页数量遵循二项分布，块中任何两个页拥有相等且无关的<code>Pgc</code>概率是有效的。因此，一个块有<code>k</code>个有效页面的概率是：<br>$$<br>p(k)&#x3D;\begin{pmatrix}<br>C\<br>k\<br>\end{pmatrix}\cdot {P_{pc}}^k \cdot (1-p_{gc})^{C-k}<br>$$<br>请注意，<code>Pgc(α)</code>由方程4给出，概率分布函数<code>PDF(Pgc)</code>是一个向量：<br>$$<br>PDF(p_{gc})&#x3D;\begin{bmatrix}p(C) &amp; p(C - 1) &amp; … &amp; p(0)\end{bmatrix}<br>$$<br>标准差为：<br>$$<br>stddev&#x3D;\sqrt{C\cdot p_{gc}\cdot (1-p_{gc})}<br>$$</p>
</li>
<li></li>
<li><p>PDF更改为块在清洁窗口中位置的函数。</p>
<p>使页面失效的过程可以用以下马尔可夫链过渡矩阵表示：<br>$$<br>M&#x3D;\begin{bmatrix}<br>\frac{N-C}{N} &amp; \frac{C}{N} &amp; … &amp; 0 \<br>. &amp; . &amp; . &amp; \<br>&amp; &amp; \frac{1}{N} &amp; \frac{C-1}{N}\<br>0 &amp; 0 &amp; 0 &amp; 1\<br>\end{bmatrix}<br>$$<br><code>M(i, i)</code> 代表一个块在更新时所有页面避免无效化的概率，并且该块保持有<code> C - i</code> 个有效页面的同一状态。<code>M(i, i + 1)</code> 代表迁移到下一个状态的概率，这个状态定义为有 <code>C - i - 1</code> 个有效页面。在 <code>n</code> 次更新后的 <code>PDF</code> 变化简单地表示为<br>$$<br>PDF_{new} &#x3D; PDF_{old} · M^n<br>$$<br>而更新的次数 n 反过来由块在清理窗口中的位置决定。</p>
</li>
<li><p>如何计算通过增加<code>B</code>窗口获得的收益。</p>
<p>我们无法推断出分析公式来给出<code>Pgc</code>和窗口大小<code>B</code>之间的简明关系，但是，<code>Pgc</code>减少可以计算为：<br>$$<br>Benefit&#x3D;\sum_{i&#x3D;2}^{B}(PDF_{old}-PDF_i)\cdot \begin{bmatrix}<br>C &amp; C-1 &amp;…&amp; 1 &amp; 0\end{bmatrix}’<br>$$<br>“Benefit” 指的是通过设置大小为 B 的清理窗口，从而节省的平均有效页面数量，这些页面不需要重新定位。请注意，所有的术语都是向量，而且最后一个元素代表马尔可夫链模型状态的有效页面数量。</p>
<p>最终结果表明窗口贪婪策略只有很少的好处。</p>
<p>于是我们总结<code>Greedy</code>和<code>Window-Greedy</code>策略对于随机更新来说不是必须的。</p>
</li>
</ul>
<h3 id="2-modal-Distribution"><a href="#2-modal-Distribution" class="headerlink" title="2-modal Distribution"></a>2-modal Distribution</h3><p>我们模拟两种不同情况下双模态工作负载（页面要么是热的，要么是冷的）的清理开销：a) 当页面是随机共置的，b) 当页面根据它们的更新频率分开存储时。</p>
<h4 id="随机数据放置"><a href="#随机数据放置" class="headerlink" title="随机数据放置"></a>随机数据放置</h4><p>页面更新的频率只有<code>f1</code>和<code>f2</code>两种情况，两种集合的大小为<code>s1</code>和<code>s2</code>，并让<code>fr = f1 / f2</code>为两个更新集之间的相对页面更新频率。我们假设页面是随机配置的，并且使用LRU策略（即日志结构化数据放置）清理块。</p>
<p>设<code>Pgc1</code>、<code>Pgc2</code>为更新集1和更新集2的页面分别在垃圾收集中有效的概率，并设<code>Pavg</code>为随机选择的页面有效的概率。<code>Pgc1</code>、<code>Pgc2</code>可以使用与第4.1节类似的逻辑表示，经过一系列操作后我们得到：<br>$$<br>\frac{log(p_{gc1})}{log(p_{gc2})}&#x3D;f_r ⇔ p_{gc1}&#x3D;p_{gc2}^{f_r}<br>$$<br>公式(16)总结了两组的有效页面概率之间的关系，并表明在垃圾收集中必须重新放置较冷的页面的概率与<code>fr-th</code>根向1增长。例如，如果集合2是冷<code>cold</code>则<code>fr &gt; 1</code>且<br>$$<br>P_{gc2}&#x3D;\sqrt[fr]{p_{gc1}}<br>$$<br><code>Pavg</code>和<code>pgc1</code>,<code>pgc2</code>之间的关系是从以下条件下推导出的，即总清洁开销等于与每个更新集相关的部分清洁开销的总和。也即：<br>$$<br>p_{avg}&#x3D;1-\frac{(1-p_{gc1})(1-p_{gc2})}{f_{s1}(1-p_{gc2})+f_{s2}(1-p_{gc1})}<br>$$<br><strong>解析近似：</strong>为了便于理解清理开销，我们还提出了一个封闭公式近似，用于<code>Pavg</code>，<code>Pgc1</code>，<code>Pgc2</code>。该近似基于对每个更新集的页面数量计数。如果我们在某一时刻抓取日志结构<code>log-structure</code>中的所有页面，会发现有<br>$$<br>\frac{s_1+s_2}{1+\alpha}<br>$$<br>比例的页面包含集合1和集合2的有效用户页。</p>
<h4 id="基于频率的数据放置策略"><a href="#基于频率的数据放置策略" class="headerlink" title="基于频率的数据放置策略"></a>基于频率的数据放置策略</h4><p>直观上，根据更新频率，可以通过分页减少清洁开销，正如之前的工作所观察到的那样。在第4.2.1节中，我们确定了热数据和冷数据之间的相对差异，根据更新频率来分离页面是合理的。<strong>接下来，我们将展示如何优化分离数据并计算最低清洁开销。</strong></p>
<p>规定<br>$$<br>\beta \cdot N \quad (\beta &lt; \alpha)<br>$$<br>为分配给第一个日志结构的过度配置页数。剩余的过度配置分配给第二个日志结构。</p>
<p>由于每个页面有单一的更新频率，新的页面更新概率可以用方程<code>(9)</code>来计算。</p>
<p>全局清洁开销，<code>GCavg</code>，是每个区域的单个清洁开销的总和，按区域的更新频率加权：<br>$$<br>GC_{tot}&#x3D;f_{s1}\frac{p_{gc1}}{1-p_{gc1}}+f_{s2}\frac{p_{gc2}}{1-p_{gc2}}<br>$$<br>由于<code>Pgc1</code>，<code>Pgc2</code>依赖于额外的空间分配，剩余的挑战是如何将额外的容量预算最优地分配给每个更新集合。即如何选择β以减小<code>GCtot</code>。</p>
<p>通过对方程10求导，我们找到了使 <code>GC(β)</code> 达到全局最小值的 <code>β</code> （<code>GC(β)</code> 是一个凸函数）。将方程3代入方程10之后，我们将导数表示为：<br>$$<br>\frac{\partial GC_{tot}}{\partial \beta} &#x3D; \frac{f_{s1} W_1}{s_1(W_1 + 1)(W_1 + z_1)} - \frac{f_{s2} W_2}{s_2(W_2 + 1)(W_2 + z_2)}<br>$$<br>使用简化符号：<br>$$<br>z_1&#x3D;1+\frac{\beta}{s_1};\<br>z_2&#x3D;1+\frac{\alpha-\beta}{s_2};\<br>W_i&#x3D;W(-z_ie^{z_i});\<br>$$<br>最优点<code>β</code>是导数为0的点，也即当：<br>$$<br>f_r&#x3D;\frac{W_1}{(W_1+1)(W_1+z_1)}&#x3D;\frac{W_2}{(W_2+1)(W_2+z_2)}<br>$$<br>影响最优点<code>β</code>的参数有三个：</p>
<ul>
<li>过度配置<code>α</code></li>
<li>相对更新频率<code>fr</code></li>
<li>更新集合的大小<code>si</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/17/SSD-based-Workload-Characteristics-and-Their-Performance-Implications/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/17/SSD-based-Workload-Characteristics-and-Their-Performance-Implications/" class="post-title-link" itemprop="url">SSD-based Workload Characteristics and Their Performance Implications</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-17 11:11:02" itemprop="dateCreated datePublished" datetime="2024-01-17T11:11:02+08:00">2024-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-27 19:49:15" itemprop="dateModified" datetime="2024-01-27T19:49:15+08:00">2024-01-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SSD-based-Workload-Characteristics-and-Their-Performance-Implications"><a href="#SSD-based-Workload-Characteristics-and-Their-Performance-Implications" class="headerlink" title="SSD-based Workload Characteristics and Their Performance Implications"></a>SSD-based Workload Characteristics and Their Performance Implications</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction:"></a>Introduction:</h2><h3 id="SSD的优化目标与硬盘不同："><a href="#SSD的优化目标与硬盘不同：" class="headerlink" title="SSD的优化目标与硬盘不同："></a>SSD的优化目标与硬盘不同：</h3><ul>
<li>SSD上组织数据，目标是最大化并行性和最小化垃圾收集开销。</li>
<li>SSD优化以数据移动为目标，而不是数据放置。</li>
<li>允许进行复杂的优化并快速调整工作负载的变化。</li>
</ul>
<h3 id="与SSD设计和性能相关的特征："><a href="#与SSD设计和性能相关的特征：" class="headerlink" title="与SSD设计和性能相关的特征："></a>与SSD设计和性能相关的特征：</h3><ul>
<li>温度范围。</li>
<li>逻辑局部性（概括了简单的空间局部性和顺序性）。</li>
<li>增加SSD页面大小的敏感性。</li>
</ul>
<h3 id="将上述特征与SSD性能相关联："><a href="#将上述特征与SSD性能相关联：" class="headerlink" title="将上述特征与SSD性能相关联："></a>将上述特征与SSD性能相关联：</h3><ul>
<li>写放大：设备上写入的数据量与应用程序写入的数据量之间的比率与高尾延迟和降低的耐用性相关。</li>
<li>读放大：从SSD读取的数据量与应用程序请求的数据量之间的比率。</li>
<li>闪存读取成本：包括从闪存介质读取数据并将其传输到控制器的低级延迟。</li>
</ul>
<h3 id="发现证实了建议的特征与SSD设计和优化的相关性："><a href="#发现证实了建议的特征与SSD设计和优化的相关性：" class="headerlink" title="发现证实了建议的特征与SSD设计和优化的相关性："></a>发现证实了建议的特征与SSD设计和优化的相关性：</h3><ul>
<li>增加 SSD 内逻辑分区的数量可减少写入放大。 然而，这需要大量的开销并且带来收益递减。 最佳分区数量小于以前研究中建议的数量。</li>
<li>读取放大随着页面大小的增加而增加，并且主要取决于请求大小的分布。 然而，对地址范围的重复访问会显着降低读取放大。 这种减少的程度可以通过逻辑空间局部性来估计。</li>
<li>通过有选择地从大页中读取部分字节范围，可以有效降低闪存读取成本。 我们简单的贪婪算法足以达到此目的，展示了向主机导出“部分读取”接口的潜在好处。</li>
</ul>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background:"></a>Background:</h2><h3 id="工作负载"><a href="#工作负载" class="headerlink" title="工作负载"></a>工作负载</h3><ul>
<li>the University of Massachusetts (SPC traces) </li>
<li>Microsoft Research at Cambridge</li>
<li>Microsoft production servers</li>
<li>Florida International University</li>
</ul>
<p>我们关注这些工作负载上的普遍属性</p>
<ul>
<li>Request arrival time (relative to the beginning of the trace) 请求到达时间，与trace的开始相关。</li>
<li>Volume number 存储体编号</li>
<li>Request size (in byte) 请求大小</li>
<li>I&#x2F;O operation I&#x2F;O操作（读或写）</li>
</ul>
<h3 id="温度范围"><a href="#温度范围" class="headerlink" title="温度范围"></a>温度范围</h3><p>工作负载偏斜传统上被用来通过使用缓存来优化性能。如果缓存足够大能存储应用程序的工作集，则大部分请求不需要访问底层设备。在这种情况下，常用的经验法则，比如80-20法则——它指出80%的请求访问了20%的数据——经常被用来估计工作负载所需的缓存大小。因此，传统的分析通过评估工作集大小或热数据（频繁访问的数据）的数量来描述工作负载的偏斜程度。虽然这些对于优化硬盘和缓存性能是足够的，但对于固态硬盘（SSD）的优化，更详细的分析可能会带来更多的好处。</p>
<p>在闪存层的设计中，通过分离冷热数据到不同的逻辑分区中可以减小写放大，垃圾回收开销，和单元磨损。这样的分类同样也可以优化磨损均衡和页面重用。因此，许多闪存将数据分类到两个区域。</p>
<p>Stoica和Ailamaki的研究表明，只要每个分区内的访问偏斜足够小，就可以将几种不同的温度级别的数据分组到同一个分区中，而不会增加写放大的现象。我们基于这一分析，根据工作负载所需的最小分区数量来进行特征描述。然后我们量化了在最佳数量过高时分配较少分区的成本。我们特别感兴趣的是常见的两个分区情况，用于热数据和冷数据。</p>
<h4 id="表征温度范围"><a href="#表征温度范围" class="headerlink" title="表征温度范围"></a>表征温度范围</h4><p>​	当一个逻辑页被写入SSD时，FTL将原来的物理地址标记为无效的然后选择芯片和平面，根据条带和负载均匀策略将一页写入。然后将页写入平面中的一个活跃块（一个已经被擦除但还没有完全写满的块）。将数据分别放入N个逻辑分区需要每个平面有N个活跃块。</p>
<p>​	根据<code>Stoica 和 Ailamaki</code>的定义，<code>fi</code>表示页面<code>i</code>的更新频率。理想的情况下，每个分区将包含具有相同更新频率的页面。这显然是不切实际的，因为现代芯片每个平面只有512个块。相反，具有多个访问频率的逻辑页面被分组到每个分区（读者认为这里的一个分区<code>partition</code>就是一个块<code>block</code>）中。<code>fr(p)</code>表示分区<code>p</code>中的更新频率比，这是存储在<code>p</code>中的页面的最大和最小更新频率之间的比率。<code>fr</code>表示所有分区的最大比率。参考[57]中的理论分析表明，确保<code>fr ≤ 2</code>足以最小化垃圾回收开销。然而，这个结果没有考虑到维护所需分区数量的开销。</p>
<p>​	为了确定在现代芯片组织下这种优化是否现实，我们计算了确保<code>fr ≤ 2</code>所需的最小分区数量。我们根据更新的频率对每个工作负载中的逻辑扇区进行排名，并贪婪的将他们分配给不同的分区：：我们从第一个分区开始，分配给它更新频率最高的页面<code>i</code>以及所有满足<code>fj ≥ fi /2</code>的页面<code>&#123;j&#125;</code>。然后我们将下一个页面分配给第二个分区，以此类推。我们在分析基于硬件驱动器<code>(HDD)</code>的迹象和基于固态硬盘<code>SSD</code>的<code>RocksDB</code>迹象时，分别使用了512字节和4KB的扇区大小，以反映这些迹象中观察到的访问粒度。我们将在第4节中更详细地讨论访问粒度。</p>
<p>​	我们的结果显示，所需的最少分区数量在2到16之间变化，并且在不同类别之间有所不同。图<code>1(a)</code>展示了每个类别的第25、50和第75百分位数，垂直线显示了每个类别所需的最小和最大分区数量（键值类别包括单个RocksDB迹象，因此用一个小圆圈表示）。例如，对于75%的数据库管理系统（DBMS）工作负载和键值工作负载，9个分区就足够了，而75%的邮件服务器工作负载至少需要14个分区。我们在不同限制下的<code>fr</code>上重复了这个实验。不出所料，位了维持更低的比例，需要更多的分区。所需最少分区数量从3到26不等，用于<code>fr ≤ 1.5</code>，当<code>fr ≤ 3</code>时，需要2到11个分区。</p>
<p>​	<strong>发现一：</strong>实现写入放大的理论下限需要大量的分区。</p>
<p>​	为了理解这些结果的影响，考虑最先进的企业<code>SSD</code>，每个平面有521个块和<code>28%</code>的过度配置空间。每个平面将有400个可用的逻辑块。因此为了维持<code>16</code>个分区，<code>4%</code>的块需要作为活跃块，平均<code>2%</code>的逻辑容量将无法利用。除了这种开销外，还必须考虑在<code>SSD</code>的<code>RAM</code>中将页面维护和分类为几个分区的成本。</p>
<p>​	SSD设计可能会限制分区数量，以利用专用硬件，或最大限度地减少分区开销。为了评估次优分区的影响，我们重复上述过程以穷尽地找到<code>fmin(N)</code>–贪婪分区方案导致N个预定数量的分区时的最低比率。图<code>1(c)</code>展示了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/11/Lab-page-tables/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/11/Lab-page-tables/" class="post-title-link" itemprop="url">Lab: page tables</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-11 20:03:25" itemprop="dateCreated datePublished" datetime="2024-01-11T20:03:25+08:00">2024-01-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-28 13:40:02" itemprop="dateModified" datetime="2024-02-28T13:40:02+08:00">2024-02-28</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>33k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>30 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab-page-tables"><a href="#Lab-page-tables" class="headerlink" title="Lab: page tables"></a>Lab: page tables</h1><p>准备工作：</p>
<ol>
<li>阅读<code>book-riscv-rev1</code>第三章</li>
<li>阅读<code>memlayout.h</code></li>
<li>阅读<code>vm.c</code></li>
<li>阅读<code>riscv.h</code></li>
<li>阅读<code>kalloc.c</code></li>
<li>阅读<code>exec.c</code></li>
</ol>
<h2 id="从main-c开始："><a href="#从main-c开始：" class="headerlink" title="从main.c开始："></a>从<code>main.c</code>开始：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start() jumps here in supervisor mode on all CPUs.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">    kinit();         <span class="comment">// physical page allocator</span></span><br><span class="line">    kvminit();       <span class="comment">// create kernel page table</span></span><br><span class="line">    kvminithart();   <span class="comment">// turn on paging</span></span><br><span class="line">    procinit();      <span class="comment">// process table</span></span><br><span class="line">    trapinit();      <span class="comment">// trap vectors</span></span><br><span class="line">    trapinithart();  <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinit();      <span class="comment">// set up interrupt controller</span></span><br><span class="line">    plicinithart();  <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">    binit();         <span class="comment">// buffer cache</span></span><br><span class="line">    iinit();         <span class="comment">// inode table</span></span><br><span class="line">    fileinit();      <span class="comment">// file table</span></span><br><span class="line">    virtio_disk_init(); <span class="comment">// emulated hard disk</span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(started == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hart %d starting\n&quot;</span>, cpuid());</span><br><span class="line">    kvminithart();    <span class="comment">// turn on paging</span></span><br><span class="line">    trapinithart();   <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinithart();   <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">  &#125;</span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kinit-函数分配物理页面physical-page-allocator"><a href="#kinit-函数分配物理页面physical-page-allocator" class="headerlink" title="kinit()函数分配物理页面physical page allocator:"></a><code>kinit()</code>函数分配物理页面<code>physical page allocator:</code></h3><p>其中<code>end</code>指向内核代码后的第一个地址，也即<code>kernel data</code>结束的地方，现在我们知道，<code>freerange()</code>函数将图中<code>Free memory</code>的部分全部清空，并以页面对齐的形式存入<code>freelist</code>中。</p>
<p><img src="/../images/Lab-page-tables/%E6%88%AA%E5%B1%8F2024-01-16%2011.02.46.png" alt="截屏2024-01-16 11.02.46"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kinit</span><span class="params">()</span> &#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>); <span class="comment">// kinit 初始化保护 kmem 的自旋锁</span></span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP); <span class="comment">// freerange 对 end 到 PHYSTOP 之间的每一页调用 kfree 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="freerange-函数"><a href="#freerange-函数" class="headerlink" title="freerange()函数:"></a><code>freerange()</code>函数:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);	<span class="comment">// 将起始地址按页对齐</span></span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="kfree-函数"><a href="#kfree-函数" class="headerlink" title="kfree()函数:"></a><code>kfree()</code>函数:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free the page of physical memory pointed at by pa,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP) <span class="comment">// 判断物理地址是否规范</span></span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">  <span class="comment">// 将该页填充垃圾数据</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line">  acquire(&amp;kmem.lock);	<span class="comment">// 请求锁</span></span><br><span class="line">  r-&gt;next = kmem.freelist;	<span class="comment">// 头插法插入空闲页列表</span></span><br><span class="line">  kmem.freelist = r;	</span><br><span class="line">  release(&amp;kmem.lock);	<span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kvminit-函数创建内核页表："><a href="#kvminit-函数创建内核页表：" class="headerlink" title="kvminit()函数创建内核页表："></a><code>kvminit()</code>函数创建内核页表：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the one kernel_pagetable</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvminit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  kernel_pagetable = kvmmake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="kvmmake-为内核制作一个直接映射的页表："><a href="#kvmmake-为内核制作一个直接映射的页表：" class="headerlink" title="kvmmake()为内核制作一个直接映射的页表："></a><code>kvmmake()</code>为内核制作一个直接映射的页表：</h4><p>其中<code>etext</code>指向内核代码结束的地方，即<code>kernel text</code>结束的地方。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Make a direct-map page table for the kernel.</span></span><br><span class="line"><span class="type">pagetable_t</span> <span class="title function_">kvmmake</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">pagetable_t</span> kpgtbl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建内核页表</span></span><br><span class="line">  kpgtbl = (<span class="type">pagetable_t</span>) kalloc();	<span class="comment">// kalloc()函数从freelist中取出一页并返回</span></span><br><span class="line">  <span class="built_in">memset</span>(kpgtbl, <span class="number">0</span>, PGSIZE);	<span class="comment">// 将内核页表填充空</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W); <span class="comment">// 直接映射 uart 寄存器的 虚拟地址 到 物理地址</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W); <span class="comment">// 直接映射 virtio disk 接口的 虚拟地址 到 物理地址</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  kvmmap(kpgtbl, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W); <span class="comment">// 直接映射 PLIC 的 虚拟地址 到 物理地址，大小为 0x400000</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// kernel text 在 内核代码结束的地方往下增长一个 KERNBASE 大小</span></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将内核数据和物理内存映射</span></span><br><span class="line">  <span class="comment">// 接着上面映射，将kernel data 和 free memory 映射到 从 etext 到 PHYSTOP 的物理地址空间中</span></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 映射 负责 trap entry/exit 的 trampoline</span></span><br><span class="line">  <span class="comment">// trampoline 是在 内核虚拟地址的最高处</span></span><br><span class="line">  <span class="comment">// 即从最大的虚拟地址向下分配一页给 trampoline</span></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为每一个进程分配和映射 内核栈</span></span><br><span class="line">  <span class="comment">// allocate and map a kernel stack for each process.</span></span><br><span class="line">  proc_mapstacks(kpgtbl);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> kpgtbl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="proc-mapstacks-函数为进程分配一页内核栈："><a href="#proc-mapstacks-函数为进程分配一页内核栈：" class="headerlink" title="proc_mapstacks()函数为进程分配一页内核栈："></a><code>proc_mapstacks()</code>函数为进程分配一页内核栈：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map kernel stacks beneath the trampoline,</span></span><br><span class="line"><span class="comment">// each surrounded by invalid guard pages.</span></span><br><span class="line"><span class="comment">// 内核栈映射到 trampoline 的下方，每一个内核栈页紧跟一个保护页</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACK(p) (TRAMPOLINE - (p)*2*PGSIZE - 3*PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a page for each process&#x27;s kernel stack.</span></span><br><span class="line"><span class="comment">// Map it high in memory, followed by an invalid guard page.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">proc_mapstacks</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="comment">// 遍历所有进程，为每一个进程分配一页内核栈</span></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="type">char</span> *pa = kalloc();	<span class="comment">// 分配物理页面</span></span><br><span class="line">    <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">    uint64 va = KSTACK((<span class="type">int</span>) (p - proc));	<span class="comment">// 映射后返回虚拟地址</span></span><br><span class="line">    kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);	<span class="comment">// 将虚拟地址 映射到 物理地址上</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kvminithart-函数启用分页："><a href="#kvminithart-函数启用分页：" class="headerlink" title="kvminithart()函数启用分页："></a><code>kvminithart()</code>函数启用分页：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Switch h/w page table register to the kernel&#x27;s page table, and enable paging.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvminithart</span><span class="params">()</span>	<span class="comment">// 将硬件页表寄存器切换到内核的页表，并启用分页</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// wait for any previous writes to the page table memory to finish.</span></span><br><span class="line">  sfence_vma();</span><br><span class="line">  <span class="comment">// install the kernel page table</span></span><br><span class="line">  <span class="comment">// writes the physical page address of the root page-table page into the register satp</span></span><br><span class="line">  <span class="comment">// after this the CPU will translate addresses using the kernel page table</span></span><br><span class="line">  <span class="comment">// 加载内核页表</span></span><br><span class="line">  <span class="comment">// 将 根页表页的物理页地址写入 寄存器satp 中</span></span><br><span class="line">  <span class="comment">// 然后 cpu 可以通过 内核页表 翻译地址</span></span><br><span class="line">  w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line">  <span class="comment">// flush stale entries from the TLB.</span></span><br><span class="line">  sfence_vma();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use riscv&#x27;s sv39 page table scheme.</span></span><br><span class="line"><span class="comment">// 使用 riscv&#x27;s sv39 页表标准</span></span><br><span class="line"><span class="comment">// SV39是一种支持39位虚拟地址的页表模式。将8L左移60位，是为了将模式设置位放置在`satp`寄存器的最高位，因为在SV39模式中，`satp`寄存器的 [63:60] 位用于指定页表模式。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP_SV39 (8L &lt;&lt; 60)</span></span><br><span class="line"><span class="comment">// 右移12位是因为RISC-V中的页表基地址是按4KB对齐的，所以低12位应该是0。右移操作删除了这些对齐位。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAKE_SATP(pagetable) (SATP_SV39 | (((uint64)pagetable) &gt;&gt; 12))</span></span><br></pre></td></tr></table></figure>

<h3 id="procinit-初始化进程表："><a href="#procinit-初始化进程表：" class="headerlink" title="procinit()初始化进程表："></a><code>procinit()</code>初始化进程表：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize the proc table.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">procinit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  initlock(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);</span><br><span class="line">  initlock(&amp;wait_lock, <span class="string">&quot;wait_lock&quot;</span>);</span><br><span class="line">  <span class="comment">// 开始时 p = proc，p 的位置是数组 proc[NPROC] 的起始位置</span></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      initlock(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line">      p-&gt;state = UNUSED;</span><br><span class="line">      p-&gt;kstack = KSTACK((<span class="type">int</span>) (p - proc));</span><br><span class="line">      <span class="comment">// 指针相减就是地址相减，获取当前进程p和proc数组最开始位置的偏移量</span></span><br><span class="line">      <span class="comment">// 比如第一次 p - proc = 0，则p-&gt;kstack = TRAMPOLINE - 3 * PGSIZE</span></span><br><span class="line">      <span class="comment">// 3 个 pagesize 分别是</span></span><br><span class="line">      <span class="comment">// trampolie</span></span><br><span class="line">      <span class="comment">// guard page 占一个 pagesize</span></span><br><span class="line">      <span class="comment">// kstack0    占一个 pagesize</span></span><br><span class="line">      <span class="comment">// guard page 占一个 pagesize</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="memlayout-h头文件描述了物理内存的布局"><a href="#memlayout-h头文件描述了物理内存的布局" class="headerlink" title="memlayout.h头文件描述了物理内存的布局"></a><code>memlayout.h</code>头文件描述了物理内存的布局</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Physical memory layout</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu -machine virt is set up like this,</span></span><br><span class="line"><span class="comment">// based on qemu&#x27;s hw/riscv/virt.c:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 00001000 -- boot ROM, provided by qemu</span></span><br><span class="line"><span class="comment">// 02000000 -- CLINT</span></span><br><span class="line"><span class="comment">// 0C000000 -- PLIC</span></span><br><span class="line"><span class="comment">// 10000000 -- uart0 </span></span><br><span class="line"><span class="comment">// 10001000 -- virtio disk </span></span><br><span class="line"><span class="comment">// 80000000 -- boot ROM jumps here in machine mode</span></span><br><span class="line"><span class="comment">//             -kernel loads the kernel here</span></span><br><span class="line"><span class="comment">// unused RAM after 80000000.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the kernel uses physical memory thus:</span></span><br><span class="line"><span class="comment">// 80000000 -- entry.S, then kernel text and data</span></span><br><span class="line"><span class="comment">// end -- start of kernel page allocation area</span></span><br><span class="line"><span class="comment">// PHYSTOP -- end RAM used by the kernel</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu puts UART registers here in physical memory.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0 0x10000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0_IRQ 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// virtio mmio interface</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO0 0x10001000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO0_IRQ 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_NET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E1000_IRQ 33</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// core local interruptor (CLINT), which contains the timer.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT 0x2000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT_MTIMECMP(hartid) (CLINT + 0x4000 + 8*(hartid))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT_MTIME (CLINT + 0xBFF8) <span class="comment">// cycles since boot.</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu puts platform-level interrupt controller (PLIC) here.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC 0x0c000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_PRIORITY (PLIC + 0x0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_PENDING (PLIC + 0x1000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_MENABLE(hart) (PLIC + 0x2000 + (hart)*0x100)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SENABLE(hart) (PLIC + 0x2080 + (hart)*0x100)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_MPRIORITY(hart) (PLIC + 0x200000 + (hart)*0x2000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SPRIORITY(hart) (PLIC + 0x201000 + (hart)*0x2000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_MCLAIM(hart) (PLIC + 0x200004 + (hart)*0x2000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SCLAIM(hart) (PLIC + 0x201004 + (hart)*0x2000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the kernel expects there to be RAM</span></span><br><span class="line"><span class="comment">// for use by the kernel and user pages</span></span><br><span class="line"><span class="comment">// from physical address 0x80000000 to PHYSTOP.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNBASE 0x80000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHYSTOP (KERNBASE + 128*1024*1024)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map the trampoline page to the highest address,</span></span><br><span class="line"><span class="comment">// in both user and kernel space.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAMPOLINE (MAXVA - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map kernel stacks beneath the trampoline,</span></span><br><span class="line"><span class="comment">// each surrounded by invalid guard pages.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACK(p) (TRAMPOLINE - (p)*2*PGSIZE - 3*PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// User memory layout.</span></span><br><span class="line"><span class="comment">// Address zero first:</span></span><br><span class="line"><span class="comment">//   text</span></span><br><span class="line"><span class="comment">//   original data and bss</span></span><br><span class="line"><span class="comment">//   fixed-size stack</span></span><br><span class="line"><span class="comment">//   expandable heap</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   USYSCALL (shared with kernel)</span></span><br><span class="line"><span class="comment">//   TRAPFRAME (p-&gt;trapframe, used by the trampoline)</span></span><br><span class="line"><span class="comment">//   TRAMPOLINE (the same page as in the kernel)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE)  <span class="comment">// 将 USYSCALL 映射到 TRAPFRAME 地址空间后的一页</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> pid;  <span class="comment">// Process ID</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="vm-c描述了内核地址和用户地址的处理："><a href="#vm-c描述了内核地址和用户地址的处理：" class="headerlink" title="vm.c描述了内核地址和用户地址的处理："></a><code>vm.c</code>描述了内核地址和用户地址的处理：</h2><h3 id="pte-t-walk-pagetable-t-pagetable-uint64-va-int-alloc-函数返回虚拟地址va对应的页表项"><a href="#pte-t-walk-pagetable-t-pagetable-uint64-va-int-alloc-函数返回虚拟地址va对应的页表项" class="headerlink" title="pte_t *walk(pagetable_t pagetable, uint64 va, int alloc)函数返回虚拟地址va对应的页表项"></a><code>pte_t *walk(pagetable_t pagetable, uint64 va, int alloc)</code>函数返回虚拟地址va对应的页表项</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the address of the PTE in page table pagetable</span></span><br><span class="line"><span class="comment">// that corresponds to virtual address va. If alloc!=0,</span></span><br><span class="line"><span class="comment">// create any required page-table pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The risc-v Sv39 scheme has three levels of page-table</span></span><br><span class="line"><span class="comment">// pages. A page-table page contains 512 64-bit PTEs.</span></span><br><span class="line"><span class="comment">// A 64-bit virtual address is split into five fields:</span></span><br><span class="line"><span class="comment">//   39..63 -- must be zero.</span></span><br><span class="line"><span class="comment">//   30..38 -- 9 bits of level-2 index.</span></span><br><span class="line"><span class="comment">//   21..29 -- 9 bits of level-1 index.</span></span><br><span class="line"><span class="comment">//   12..20 -- 9 bits of level-0 index.</span></span><br><span class="line"><span class="comment">//    0..11 -- 12 bits of byte offset within the page.</span></span><br><span class="line"><span class="comment">// walk函数为给定va找到其对应的PTE</span></span><br><span class="line"><span class="type">pte_t</span> *<span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)   <span class="comment">// 给定va不能大于最大虚拟地址</span></span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">    <span class="comment">// 根据当前level，对va进行移位和掩码操作，得到当前level页表的中对应PTE</span></span><br><span class="line">    <span class="comment">// 当 level = 2 时，向右移出 12 + 2 * 9 = 30, 经掩码后得到9位level=2页表的PTE编号</span></span><br><span class="line">    <span class="comment">// 当 level = 1 时，向右移出 12 + 1 * 9 = 21, 经掩码后得到9位level=1页表的PTE编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;  <span class="comment">// 判断有效位</span></span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">      <span class="comment">// 提取物理地址，对应一个页的首地址</span></span><br><span class="line">      <span class="comment">// PTE2PA 函数将最右10位标志位移出，补充12位全0偏移位（12位对应offset），原44位 PPN 保留，得到指向下一层页表的物理地址</span></span><br><span class="line">      <span class="comment">// level = 2 时，pagetable 指向 level = 1 的页表</span></span><br><span class="line">      <span class="comment">// level = 1 时，pagetable 指向 level = 0 的页表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 对应PTE不存在，且alloc被置位，则为该PTE指向的下一层页表分配一页</span></span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 一切清0，新分配的下一级页表的所有PTE也是无效的</span></span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      <span class="comment">// 更新PTE，将56位物理地址右移12位去掉偏移位，移进10位标志位，同时将PTE_V置1</span></span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 跳出循环，此时 pagetable 指向level = 0 的页表</span></span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">  <span class="comment">// level=0，向右移出12位，经掩码后得到9位level=0页表的PTE编号</span></span><br><span class="line">  <span class="comment">// 返回va对应的level=0页表中的对应PTE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uint64-walkaddr-pagetable-t-pagetable-uint64-va-返回虚拟地址va对应的物理地址："><a href="#uint64-walkaddr-pagetable-t-pagetable-uint64-va-返回虚拟地址va对应的物理地址：" class="headerlink" title="uint64 walkaddr(pagetable_t pagetable, uint64 va)返回虚拟地址va对应的物理地址："></a><code>uint64 walkaddr(pagetable_t pagetable, uint64 va)</code>返回虚拟地址<code>va</code>对应的物理地址：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look up a virtual address, return the physical address,</span></span><br><span class="line"><span class="comment">// or 0 if not mapped.</span></span><br><span class="line"><span class="comment">// Can only be used to look up user pages.</span></span><br><span class="line">uint64 <span class="title function_">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> &#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  pa = PTE2PA(*pte);	<span class="comment">// 通过PTE寻找PA</span></span><br><span class="line">  <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kvmmap-为内核页表添加映射："><a href="#kvmmap-为内核页表添加映射：" class="headerlink" title="kvmmap()为内核页表添加映射："></a><code>kvmmap()</code>为内核页表添加映射：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a mapping to the kernel page table.</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvmmap</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kpgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-mappages-pagetable-t-pagetable-uint64-va-uint64-size-uint64-pa-int-perm"><a href="#int-mappages-pagetable-t-pagetable-uint64-va-uint64-size-uint64-pa-int-perm" class="headerlink" title="int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)"></a><code>int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)</code></h3><p>该函数为虚拟地址<code>va</code>设置到物理地址<code>pa</code>的页表项，<code>va</code>和<code>size</code>必须是按页对齐的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class="line"><span class="comment">// physical addresses starting at pa.</span></span><br><span class="line"><span class="comment">// va and size MUST be page-aligned.</span></span><br><span class="line"><span class="comment">// Returns 0 on success, -1 if walk() couldn&#x27;t</span></span><br><span class="line"><span class="comment">// allocate a needed page-table page.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span> &#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;   <span class="comment">// 指向将要分配的 page table entry</span></span><br><span class="line">  <span class="comment">// 判断是否按页对齐</span></span><br><span class="line">  <span class="keyword">if</span>((va % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: va not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((size % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: size not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: size&quot;</span>);</span><br><span class="line">  <span class="comment">// a 是 va的起始地址</span></span><br><span class="line">  a = va;</span><br><span class="line">  <span class="comment">// last 是 va 的终止地址，按页对齐</span></span><br><span class="line">  last = va + size - PGSIZE;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;mappages: remap&quot;</span>); <span class="comment">// 该 pte 已经被分配，其 PTE_V 位 有效</span></span><br><span class="line">    <span class="comment">// 将物理地址的 PPN 取出来，加上标志位信息 prem 和 有效位 PTE_V</span></span><br><span class="line">    <span class="comment">// 然后将该有效位 放入 pte 中</span></span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="keyword">if</span>(a == last)   <span class="comment">// 分配到了足够的页数就跳出循环</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">    <span class="comment">// 已经分配了一页，虚拟地址的起始位置和物理地址的起始位置都增加一页</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-uvmunmap"><a href="#void-uvmunmap" class="headerlink" title="void uvmunmap()"></a><code>void uvmunmap()</code></h3><p>从虚拟地址<code>va</code>开始，移除 <code>npages</code> 个映射。<code>va</code>必须是页对齐的。这些映射必须是存在的。且可选的释放物理内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remove npages of mappings starting from va. va must be</span></span><br><span class="line"><span class="comment">// page-aligned. The mappings must exist.</span></span><br><span class="line"><span class="comment">// Optionally free the physical memory.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  <span class="keyword">if</span>((va % PGSIZE) != <span class="number">0</span>)	<span class="comment">// 虚拟地址必须是页对齐的</span></span><br><span class="line">    panic(<span class="string">&quot;uvmunmap: not aligned&quot;</span>);</span><br><span class="line">  <span class="comment">/* 循环遍历从 va 开始的 n 个页 */</span></span><br><span class="line">  <span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)	<span class="comment">// walk函数找到a对应的PTE</span></span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: walk&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)	<span class="comment">// 检查该 PTE 是否有效</span></span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: not mapped&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(PTE_FLAGS(*pte) == PTE_V) <span class="comment">// 检查是否为叶子页表条目</span></span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(do_free)&#123;	<span class="comment">// do_free 为真时，释放内存</span></span><br><span class="line">      uint64 pa = PTE2PA(*pte);	<span class="comment">// 通过 PTE2PA 获取物理地址 </span></span><br><span class="line">      kfree((<span class="type">void</span>*)pa);	<span class="comment">// 释放物理内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pagetable-t-uvmcreate-创建一个空用户页表并返回"><a href="#pagetable-t-uvmcreate-创建一个空用户页表并返回" class="headerlink" title="pagetable_t uvmcreate()创建一个空用户页表并返回"></a><code>pagetable_t uvmcreate()</code>创建一个空用户页表并返回</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create an empty user page table.</span></span><br><span class="line"><span class="comment">// returns 0 if out of memory.</span></span><br><span class="line"><span class="type">pagetable_t</span> <span class="title function_">uvmcreate</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line">  pagetable = (<span class="type">pagetable_t</span>) kalloc();	<span class="comment">// 分配一页</span></span><br><span class="line">  <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uint64-uvmalloc-为进程分配PTE和物理内存，以便增加进程的内存大小"><a href="#uint64-uvmalloc-为进程分配PTE和物理内存，以便增加进程的内存大小" class="headerlink" title="uint64 uvmalloc()为进程分配PTE和物理内存，以便增加进程的内存大小"></a><code>uint64 uvmalloc()</code>为进程分配<code>PTE</code>和物理内存，以便增加进程的内存大小</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">uvmalloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz, <span class="type">int</span> xperm)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line">  uint64 a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(newsz &lt; oldsz)</span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line"></span><br><span class="line">  oldsz = PGROUNDUP(oldsz);	<span class="comment">// 将 oldsz 上调到最近的页大小倍数</span></span><br><span class="line">  <span class="comment">// 按页大小循环</span></span><br><span class="line">  <span class="keyword">for</span>(a = oldsz; a &lt; newsz; a += PGSIZE)&#123;</span><br><span class="line">    mem = kalloc();	<span class="comment">// 分配一页</span></span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="comment">// 将虚拟地址 a 以页大小映射到 新分配的物理地址 mem 中</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != <span class="number">0</span>)&#123;</span><br><span class="line">      kfree(mem);</span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newsz;	<span class="comment">// 返回新大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uint64-uvmdealloc-减少进程的内存大小，即释放一部分用户空间内存。"><a href="#uint64-uvmdealloc-减少进程的内存大小，即释放一部分用户空间内存。" class="headerlink" title="uint64 uvmdealloc()减少进程的内存大小，即释放一部分用户空间内存。"></a><code>uint64 uvmdealloc()</code>减少进程的内存大小，即释放一部分用户空间内存。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Deallocate user pages to bring the process size from oldsz to</span></span><br><span class="line"><span class="comment">// newsz.  oldsz and newsz need not be page-aligned, nor does newsz</span></span><br><span class="line"><span class="comment">// need to be less than oldsz.  oldsz can be larger than the actual</span></span><br><span class="line"><span class="comment">// process size.  Returns the new process size.</span></span><br><span class="line">uint64 <span class="title function_">uvmdealloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(newsz &gt;= oldsz)	<span class="comment">// 新的大小必须小于旧的大小</span></span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line">	<span class="comment">// 将 newsz, oldsz 上调到最近的页大小倍数</span></span><br><span class="line">  <span class="keyword">if</span>(PGROUNDUP(newsz) &lt; PGROUNDUP(oldsz))&#123;</span><br><span class="line">    <span class="comment">// 计算出新旧大小间的页面数量</span></span><br><span class="line">    <span class="type">int</span> npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;</span><br><span class="line">    uvmunmap(pagetable, PGROUNDUP(newsz), npages, <span class="number">1</span>);	<span class="comment">// 取消从新的大小开始，到旧的大小之间的 n 页映射</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="freewalk-pagetable-t-pagetable-递归释放页表中的页面，所有的叶子映射必须被移除"><a href="#freewalk-pagetable-t-pagetable-递归释放页表中的页面，所有的叶子映射必须被移除" class="headerlink" title="freewalk(pagetable_t pagetable)递归释放页表中的页面，所有的叶子映射必须被移除"></a><code>freewalk(pagetable_t pagetable)</code>递归释放页表中的页面，所有的叶子映射必须被移除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recursively free page-table pages.</span></span><br><span class="line"><span class="comment">// All leaf mappings must already have been removed.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freewalk</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123; <span class="comment">// 检查条目是否有效且非叶子（即指向另一个页表）</span></span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      freewalk((<span class="type">pagetable_t</span>)child);</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      panic(<span class="string">&quot;freewalk: leaf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*)pagetable);	<span class="comment">// 释放当前页表所占用的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-uvmfree-释放用户空间页，然后释放页表页面"><a href="#void-uvmfree-释放用户空间页，然后释放页表页面" class="headerlink" title="void uvmfree()释放用户空间页，然后释放页表页面"></a><code>void uvmfree()</code>释放用户空间页，然后释放页表页面</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free user memory pages,</span></span><br><span class="line"><span class="comment">// then free page-table pages.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uvmfree</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(sz &gt; <span class="number">0</span>)</span><br><span class="line">    uvmunmap(pagetable, <span class="number">0</span>, PGROUNDUP(sz)/PGSIZE, <span class="number">1</span>); <span class="comment">// 先取消映射</span></span><br><span class="line">  freewalk(pagetable);	<span class="comment">// 然后释放页表中的所有页</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h2><p>一些操作系统通过共享用户空间和内核之间的仅读区域的数据加速某些系统调用。这消除了在执行这些系统调用时对内核交叉的需求。为了帮助你学习如何向页表中插入映射，你的第一个任务是为<code>xv6</code>的<code>getpid()</code>系统调用实现这种优化。</p>
<blockquote>
<p>当进程被创建时，在<code>USYSCALL</code>（一个在<code>memlayout.h</code>定义的虚拟地址）映射一个只读页面。在这个页面的开始，存储了一个<code>struct usyscall</code>，用于保存当前进程的<code>PID</code>。这个实验中，<code>ugetpid()</code>在用户空间中被提供并将会自动的使用<code>USYSCALL</code>映射。</p>
</blockquote>
<p>提示：</p>
<ul>
<li>选择合适的允许位使用户空间访问只读页面。</li>
<li>在新页面的生命周期中需要完成一些事情。为了获得灵感，请了解内核<code>kernel/proc.c</code>中的陷阱框架处理。</li>
</ul>
<p>结构体<code>usyscall</code>用于保存进程<code>ID</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> pid;  <span class="comment">// Process ID</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>函数<code>ugetpid()</code>，其中<code>USYSCALL</code>是一个全局变量，指向用户空间的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ugetpid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> *<span class="title">u</span> =</span> (<span class="keyword">struct</span> usyscall *)USYSCALL;</span><br><span class="line">  <span class="keyword">return</span> u-&gt;pid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>看一看<code>kernel/proc.c</code>中如何描述一个<code>page table</code>的生命周期的？</p>
<blockquote>
<p><code>trampoline (跳板)</code>：通常指的是一种用于实现不同函数或程序段之间跳转的技术，特别是在操作系统内核中用于系统调用和中断处理的上下文切换。</p>
<p><code>trampoline</code>在操作系统内核中的应用</p>
<p>1.系统调用和中断处理：</p>
<ul>
<li>在操作系统中，当程序执行1系统调用或当发生中断时，需要从用户模式<code>(user mode)</code>切换到内核模式<code>(kernel mode)</code>。</li>
<li>这种模式切换涉及到处理器状态的大量改变，如切换栈，改变权限级别等。</li>
</ul>
<p>2.上下文切换：</p>
<ul>
<li><code>Trampoline</code>通常用于这种上下文切换的过程。它提供了一个固定的、已知的内核空间地址，用户模式代码可以跳转到这个地址以执行系统调用或响应中断。</li>
<li>这个跳板代码负责保存当前的执行上下文（如寄存器状态），设置适当的内核栈，然后跳转到实际的系统调用或中断处理函数。</li>
</ul>
<p><code>trapframe (陷阱帧)</code>通常指的是一种数据结构，它用于在发生异常或中断（统称为“陷阱”）时保存进程或线程的状态。当操作系统必须处理这样的事件时，它会保存当前执行环境的关键信息到<code>trapframe</code>中，以便之后可以恢复并继续执行。</p>
<ol>
<li>保存上下文：<ul>
<li>当系统调用、中断或其他异常发生时，当前进程的状态（如CPU寄存器的值）会被保存到<code>trapframe</code>中。</li>
<li>这包含程序计数器（PC）、堆栈指针（SP）、状态寄存器和其他重要的寄存器。</li>
</ul>
</li>
<li>上下文切换</li>
</ol>
<ul>
<li><code>Trapframe</code>使得操作系统能够在处理完中断或异常后，准确地恢复到发生中断前的状态，继续执行进程。</li>
<li>这是多任务操作系统实现时间共享的关键机制之一。</li>
</ul>
<ol start="3">
<li>系统调用：<ul>
<li>对于系统调用，<code>trapframe</code>可以用来传递调用参数和返回值。</li>
</ul>
</li>
</ol>
<p><code>Trapframe page:</code></p>
<ul>
<li>特定内存页：<ul>
<li>在某些操作系统实现中，每个进程或线程的<code>trapframe</code>可能被存储在一个特定的内存页中，这个页称为<code>trapframe page</code>。</li>
<li>这个页面通常位于进程的用户空间内存中的一个固定位置。</li>
</ul>
</li>
<li>访问和管理：<ul>
<li>操作系统内核负责管理这些页面，并在需要时读写<code>trapframe</code>的内容。</li>
<li>这种方法为每个进程提供了一个独立的空间来存放其中断或异常的状态信息。</li>
</ul>
</li>
</ul>
</blockquote>
<p>在<code>kernel/proc.c</code>中，观察<code>fork</code>函数是如何创建一个进程的。</p>
<p><code>fork()</code>函数通过调用<code>allocproc()</code>创建一个新的进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new process, copying the parent.</span></span><br><span class="line"><span class="comment">// Sets up child kernel stack to return as if from fork() system call.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们看看<code>allocproc()</code>做了什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look in the process table for an UNUSED proc.</span></span><br><span class="line"><span class="comment">// If found, initialize state required to run in the kernel,</span></span><br><span class="line"><span class="comment">// and return with p-&gt;lock held.</span></span><br><span class="line"><span class="comment">// If there are no free procs, or a memory allocation fails, return 0.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc* <span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="comment">/* 遍历线程池，寻找未使用的线程 */</span></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = allocpid();	<span class="comment">// 分配 pid</span></span><br><span class="line">  p-&gt;state = USED;	<span class="comment">// 标记当前线程为已使用</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page. 通过 kalloc() 为 trapframe 分配一页</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to user space.</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空闲用户页表通过函数<code>proc_pagetable()</code>分配，让我们看看函数<code>proc_pagetable</code>做了什么</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a user page table for a given process, with no user memory,</span></span><br><span class="line"><span class="comment">// but with trampoline and trapframe pages.</span></span><br><span class="line"><span class="type">pagetable_t</span> <span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty page table.</span></span><br><span class="line">  pagetable = uvmcreate();	<span class="comment">// 分配一个空闲的用户页表</span></span><br><span class="line">  <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline code (for system call return)</span></span><br><span class="line">  <span class="comment">// at the highest user virtual address.</span></span><br><span class="line">  <span class="comment">// only the supervisor uses it, on the way</span></span><br><span class="line">  <span class="comment">// to/from user space, so not PTE_U.</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在 pagetable 中，创建一个PTE，从 TRAMPOLINE 映射到 trampoline，大小为 PGSIZE</span></span><br><span class="line"><span class="comment">   * 权限为 可读，可执行</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,</span><br><span class="line">              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trapframe page just below the trampoline page, for</span></span><br><span class="line">  <span class="comment">// trampoline.S.</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在 pagetable 中，创建一个PTE，从 TRAPFRAME 映射到 p-&gt;trapframe，大小为 PGSIZE</span></span><br><span class="line"><span class="comment">   * 权限为可读，可写</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们看看释放进程时函数<code>freeproc()</code>做了什么：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free a proc structure and the data hanging from it,</span></span><br><span class="line"><span class="comment">// including user pages.</span></span><br><span class="line"><span class="comment">// p-&gt;lock must be held.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)	</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;trapframe);	<span class="comment">// 释放 trapframe</span></span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);	<span class="comment">// 释放进程页表，但proc_freepagetable 函数没有定义</span></span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回头再看实验，要加速系统调用<code>getpid()</code>，首先我们要知道<code>getpid()</code>中的<code>pid</code>存放在什么地方，观察代码后发现<code>pid</code>存放在内核代码段<code>struct proc</code>中，因此要访问<code>pid</code>必须要进行用户态和内核态之间的切换。有什么办法能避免用户态和内核态的切换？我们知道操作系统为每个进程在用户态维护一个页表，如果我们把<code>pid</code>存储到进程页表中，则省去了切换到内核态的开销。下面讲讲怎么做。</p>
<p>在<code>memlayout.h</code>中发现，用户页表中的布局为：</p>
<p>我们发现<code>USYSCALL</code>页表已经布局到用户页表中了，并且是与内核共享的一段页面（注意，这是一个虚拟地址）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User memory layout.</span></span><br><span class="line"><span class="comment">// Address zero first:</span></span><br><span class="line"><span class="comment">//   text</span></span><br><span class="line"><span class="comment">//   original data and bss</span></span><br><span class="line"><span class="comment">//   fixed-size stack</span></span><br><span class="line"><span class="comment">//   expandable heap</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   USYSCALL (shared with kernel)</span></span><br><span class="line"><span class="comment">//   TRAPFRAME (p-&gt;trapframe, used by the trampoline)</span></span><br><span class="line"><span class="comment">//   TRAMPOLINE (the same page as in the kernel)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> pid;  <span class="comment">// Process ID</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>为了在进程中访问这段页面，我们需要在<code>struct proc</code>中添加一个新的指针，指向该段页面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line"> 	...</span><br><span class="line">	...</span><br><span class="line">  <span class="comment">// used to speed up system call</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> * <span class="title">usyscall</span>;</span>   <span class="comment">// 加速系统调用，指向共享的页的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们在创建一个进程的时候，同样要为<code>USYSCALL</code>页面分配物理地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look in the process table for an UNUSED proc.</span></span><br><span class="line"><span class="comment">// If found, initialize state required to run in the kernel,</span></span><br><span class="line"><span class="comment">// and return with p-&gt;lock held.</span></span><br><span class="line"><span class="comment">// If there are no free procs, or a memory allocation fails, return 0.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = allocpid();</span><br><span class="line">  p-&gt;state = USED;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// allocate a usyscall page using kalloc()</span></span><br><span class="line">  <span class="comment">// 使用 kalloc() 函数为 usyscall 分配一页物理页面</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;usyscall = (<span class="keyword">struct</span> usyscall * )kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">      freeproc(p);</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	p-&gt;usyscall-&gt;pid = p-&gt;pid;	<span class="comment">// 让 p-&gt;usyscall-&gt;pid 为 p-&gt;pid</span></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to user space.</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，在<code>proc_pagetable</code>中，我们要添加虚拟地址到物理地址的映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a user page table for a given process, with no user memory,</span></span><br><span class="line"><span class="comment">// but with trampoline and trapframe pages.</span></span><br><span class="line"><span class="type">pagetable_t</span> <span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty page table.</span></span><br><span class="line">  pagetable = uvmcreate();</span><br><span class="line">  <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 注意到在allocproc()中我们已经为p-&gt;usyscall分配了一个物理页面并且 p-&gt;usyscall 指针指向该物理页面的</span></span><br><span class="line">  <span class="comment">// 首地址，现在我们通过 mappages 在 页表中将虚拟地址 USYSCALL 映射到 p-&gt;usyscall 中。</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p-&gt;usyscall), PTE_R | PTE_U | PTE_W) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline code (for system call return)</span></span><br><span class="line">  <span class="comment">// at the highest user virtual address.</span></span><br><span class="line">  <span class="comment">// only the supervisor uses it, on the way</span></span><br><span class="line">  <span class="comment">// to/from user space, so not PTE_U.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,</span><br><span class="line">              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trapframe page just below the trampoline page, for</span></span><br><span class="line">  <span class="comment">// trampoline.S.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在创建进程的操作就结束了，要注意到的是，我们在释放进程的时候，同时也要把该页表项及映射释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free a proc structure and the data hanging from it,</span></span><br><span class="line"><span class="comment">// including user pages.</span></span><br><span class="line"><span class="comment">// p-&gt;lock must be held.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 kfree 函数将 p-&gt;usyscall 指向的一页物理地址释放掉</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;usyscall)</span><br><span class="line">      kfree((<span class="type">void</span>*)p-&gt;usyscall);</span><br><span class="line">  p-&gt;usyscall = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅仅释放掉物理地址还不够，我们还需要调用函数<code>proc_freepagetable()</code>取消页表中相应页表项的映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free a process&#x27;s page table, and free the</span></span><br><span class="line"><span class="comment">// physical memory it refers to.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);	<span class="comment">// 取消 pagetable 中映射到 TRAMPOLINE 的页表项</span></span><br><span class="line">    uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);	<span class="comment">// 取消 pagetable 中映射到 TRAPFRAME 的页表项</span></span><br><span class="line">    uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);	<span class="comment">// 取消 pagetable 中映射到 USYSCALL 的页表项</span></span><br><span class="line">    uvmfree(pagetable, sz);	<span class="comment">// 调用 uvmfree 释放整个页表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试通过。</p>
<p><img src="/../images/Lab-page-tables/%E6%88%AA%E5%B1%8F2024-01-25%2020.54.17-6187266-6187267.png" alt="截屏2024-01-25 20.54.17"></p>
<h3 id="Question-Which-other-xv6-system-call-s-could-be-made-faster-using-this-shared-page-Explain-how"><a href="#Question-Which-other-xv6-system-call-s-could-be-made-faster-using-this-shared-page-Explain-how" class="headerlink" title="Question: Which other xv6 system call(s) could be made faster using this shared page? Explain how."></a>Question: Which other xv6 system call(s) could be made faster using this shared page? Explain how.</h3><p>通过共享页面能加速的系统调用，首先要求不能是对共享页中的数据进行写操作，因为对内核页面的写操作需要切换到内核态，这违背了加速系统调用的初衷。于是我们推测：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return how many clock tick interrupts have occurred since start.</span></span><br><span class="line">uint64 <span class="title function_">sys_uptime</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  uint xticks;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  xticks = ticks;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">  <span class="keyword">return</span> xticks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也是可以映射到共享页面上。</p>
<h2 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h2><p>为了帮助你可视化<code>RISC-V</code>页表，也可能为了帮助未来的调试工作，你的第二个任务是编写一个函数用来打印页表的内容。</p>
<blockquote>
<p>定义一个叫做<code>vmprint()</code>的函数。传入的参数类型为<code>pagetable_t</code>，打印页表格式如下。在<code>exec.c</code>中的<code>return argc</code>语句前加入<code>if(p-&gt;pid == 1) vmprint(p-&gt;pagetable)</code>，这样可以打印第一个进程的页表。如果你通过了 ‘make grade’ 中的 ‘pte printout’ 测试，那么你将获得这部分实验的全部学分。</p>
</blockquote>
<p>现在当你启动 xv6 时，它应该会打印类似于这样的输出，描述在刚刚完成执行 init 函数时第一个进程的页表情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">page table 0x0000000087f6b000</span><br><span class="line"> ..0: pte 0x0000000021fd9c01 pa 0x0000000087f67000</span><br><span class="line"> .. ..0: pte 0x0000000021fd9801 pa 0x0000000087f66000</span><br><span class="line"> .. .. ..0: pte 0x0000000021fda01b pa 0x0000000087f68000</span><br><span class="line"> .. .. ..1: pte 0x0000000021fd9417 pa 0x0000000087f65000</span><br><span class="line"> .. .. ..2: pte 0x0000000021fd9007 pa 0x0000000087f64000</span><br><span class="line"> .. .. ..3: pte 0x0000000021fd8c17 pa 0x0000000087f63000</span><br><span class="line"> ..255: pte 0x0000000021fda801 pa 0x0000000087f6a000</span><br><span class="line"> .. ..511: pte 0x0000000021fda401 pa 0x0000000087f69000</span><br><span class="line"> .. .. ..509: pte 0x0000000021fdcc13 pa 0x0000000087f73000</span><br><span class="line"> .. .. ..510: pte 0x0000000021fdd007 pa 0x0000000087f74000</span><br><span class="line"> .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000</span><br><span class="line">init: starting sh</span><br></pre></td></tr></table></figure>

<p>第一行显示了vmprint的参数。在此之后，每个PTE都会占据一行，包括那些引用到树更深层次的页表页的PTE。每个PTE行通过一些” ..”进行缩进，以表示其在树中的深度。每个PTE行展示了其在页表页中的PTE索引、pte位，以及从PTE中提取的物理地址。不打印那些无效的PTE。在上述例子中，顶层页表页对于条目0和255有映射。下一层的条目0只映射了索引0，而该索引0的底层映射了条目0、1和2。</p>
<p>你的代码可能会生成与上述不同的物理地址。条目数量和虚拟地址应当是相同的。</p>
<p>提示：</p>
<p>你可以在 <code>kernel/vm.c</code> 中放置 <code>vmprint()</code>。<br>使用 <code>kernel/riscv.h</code> 文件末尾的宏。<br>函数 <code>freewalk</code> 可能会提供一些灵感。<br>在 <code>kernel/defs.h</code> 中定义 <code>vmprint</code> 的原型，这样你就可以从 <code>exec.c</code> 调用它。<br>使用 <code>%p</code> 在你的 <code>printf</code> 调用中打印出如示例所示的完整的64位十六进制PTE和地址。</p>
<p>观察函数<code>freewalk()</code>，该函数递归的释放页表，我们可以发现<code>pte &amp; PTE_V</code>检测一个页表项是否合法，<code>pte &amp; (PTE_R | PTE_W | PTE_X)</code>检测一个页表项是否指向下一层页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recursively free page-table pages.</span></span><br><span class="line"><span class="comment">// All leaf mappings must already have been removed.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freewalk</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      freewalk((<span class="type">pagetable_t</span>)child);</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      panic(<span class="string">&quot;freewalk: leaf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是我们递归的打印页表项：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* lab page table: Print a page table */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> * indent[] = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;..&quot;</span>,</span><br><span class="line">        <span class="string">&quot;.. ..&quot;</span>,</span><br><span class="line">        <span class="string">&quot;.. .. ..&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recursive_print</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">    <span class="comment">// judge if depth is legal</span></span><br><span class="line">    <span class="keyword">if</span>(depth == <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(depth &lt; <span class="number">1</span> || depth &gt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Recursive print failed: depth must be 1, 2, or 3&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// there are 512 pte in each page table</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">        <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">        <span class="keyword">if</span>(pte &amp; PTE_V) &#123;</span><br><span class="line">            <span class="comment">// this is a valid PTE</span></span><br><span class="line">            <span class="comment">// print the current PTE</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s%d: pte %p pa %p\n&quot;</span>, indent[depth], i, pte, PTE2PA(pte));</span><br><span class="line">            <span class="keyword">if</span>((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">                uint64 child = PTE2PA(pte);</span><br><span class="line">                <span class="comment">// recursive print</span></span><br><span class="line">                recursive_print((<span class="type">pagetable_t</span>)child, depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">    recursive_print(pagetable, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过测试：</p>
<p><img src="/../images/Lab-page-tables/%E6%88%AA%E5%B1%8F2024-02-24%2016.07.33.png" alt="截屏2024-02-24 16.07.33"></p>
<h2 id="Detect-which-pages-have-been-accessed"><a href="#Detect-which-pages-have-been-accessed" class="headerlink" title="Detect which pages have been accessed"></a>Detect which pages have been accessed</h2><p>一些垃圾收集器（一种自动内存管理形式）可以从有关哪些页面已被访问（读或写）的信息中受益。在实验室的这一部分中，你将为xv6添加一个新功能，该功能通过检查RISC-V页表中的访问位来检测并向用户空间报告这一信息。RISC-V硬件页表遍历器在解决TLB缺失时会在PTE中标记这些位。</p>
<blockquote>
<p>你的任务是实现 <code>pgaccess()</code>，一个系统调用，用于报告哪些页面已被访问。这个系统调用接受三个参数。首先，它接受第一个用户页面的起始虚拟地址以供检查。其次，它接受要检查的页面数量。最后，它接受一个用户地址，指向一个缓冲区，以将结果存储到位掩码中（一种数据结构，每个页面使用一个位，其中第一个页面对应最不重要的位）。如果 <code>pgaccess</code> 测试用例在运行 <code>pgtbltest</code> 时通过，你将为这部分实验室获得全部学分。</p>
</blockquote>
<p>建议：</p>
<ul>
<li>阅读 <code>user/pgtbltest.c</code> 中的 <code>pgaccess_test()</code> 以了解 <code>pgaccess</code> 是如何被使用的。</li>
<li>首先在 <code>kernel/sysproc.c</code> 中实现 <code>sys_pgaccess()</code>。</li>
<li>你需要使用 <code>argaddr()</code> 和 <code>argint()</code> 解析参数。</li>
<li>对于输出位掩码，最简单的方法是在内核中存储一个临时缓冲区，并在填充了正确的位后通过 <code>copyout()</code> 将其复制到用户空间。</li>
<li>为可以扫描的页面数量设置一个上限是可以接受的。</li>
<li><code>kernel/vm.c</code> 中的 <code>walk()</code> 对于找到正确的PTE非常有用。</li>
<li>你需要在 <code>kernel/riscv.h</code> 中定义 <code>PTE_A</code>（访问位）。参考RISC-V特权架构手册来确定它的值。</li>
<li>确保在检查 <code>PTE_A</code> 是否设置后清除它。否则，将无法确定自上次调用 <code>pgaccess()</code> 以来页面是否被访问过（即，该位将永远被设置）。</li>
<li><code>vmprint()</code> 可能在调试页表时非常有用。</li>
</ul>
<p>首先我们找到<code>pgaccess_test()</code>，观察程序是如何测试<code>pgaccess</code>的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pgaccess_test</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> *buf;	<span class="comment">// 用户页面的起始虚拟地址</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> abits;	<span class="comment">// 掩码</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pgaccess_test starting\n&quot;</span>);</span><br><span class="line">  testname = <span class="string">&quot;pgaccess_test&quot;</span>;</span><br><span class="line">  buf = <span class="built_in">malloc</span>(<span class="number">32</span> * PGSIZE);	<span class="comment">// 分配32个页大小的空间</span></span><br><span class="line">  <span class="keyword">if</span> (pgaccess(buf, <span class="number">32</span>, &amp;abits) &lt; <span class="number">0</span>)	<span class="comment">// 调用 pgaccess() 函数</span></span><br><span class="line">    err(<span class="string">&quot;pgaccess failed&quot;</span>);</span><br><span class="line">  buf[PGSIZE * <span class="number">1</span>] += <span class="number">1</span>;	<span class="comment">// 访问第一页</span></span><br><span class="line">  buf[PGSIZE * <span class="number">2</span>] += <span class="number">1</span>; <span class="comment">// 访问第二页</span></span><br><span class="line">  buf[PGSIZE * <span class="number">30</span>] += <span class="number">1</span>; <span class="comment">// 访问第三页</span></span><br><span class="line">  <span class="keyword">if</span> (pgaccess(buf, <span class="number">32</span>, &amp;abits) &lt; <span class="number">0</span>)	<span class="comment">// 调用 pgaccess() 函数</span></span><br><span class="line">    err(<span class="string">&quot;pgaccess failed&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (abits != ((<span class="number">1</span> &lt;&lt; <span class="number">1</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">2</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">30</span>))) <span class="comment">// 检查位掩码的第1，2，30位</span></span><br><span class="line">    err(<span class="string">&quot;incorrect access bits set&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(buf);	<span class="comment">// 释放分配的地址</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pgaccess_test: OK\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们修改<code>sys_pgaccess()</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in riscv.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A (1L &lt;&lt; 6)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* in sysproc.c*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  uint64 va; <span class="comment">// 存储用户态传过来的用户页面起始虚拟地址</span></span><br><span class="line">  <span class="type">int</span> pgnum; <span class="comment">// 存储用户态传过来的页面数量</span></span><br><span class="line">  uint64 abitsaddr; <span class="comment">// 存储用户态传过来的位掩码</span></span><br><span class="line">  </span><br><span class="line">  argaddr(<span class="number">0</span>, &amp;va); <span class="comment">// 将a0寄存器的值，第一个参数，写入av</span></span><br><span class="line">  argint(<span class="number">1</span>, &amp;pgnum); <span class="comment">// 将a1寄存器的值，第二个参数，写入pgnum</span></span><br><span class="line">  argaddr(<span class="number">2</span>, &amp;abitsaddr); <span class="comment">// 将a2寄存器的值，第三个参数，写入abitsaddr</span></span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> * <span class="title">p</span> =</span> myproc(); <span class="comment">// 获取当前进程</span></span><br><span class="line">  uint64 bitmask = <span class="number">0</span>; <span class="comment">// 初始化掩码</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; pgnum; ++i) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = walk(p-&gt;pagetable, va + i * PGSIZE, <span class="number">0</span>); <span class="comment">// 获取每个虚拟地址的页表项</span></span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span>) &#123;</span><br><span class="line">      panic(<span class="string">&quot;invalid PTE\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断该页表项是否被访问</span></span><br><span class="line">    <span class="keyword">if</span>(PTE_FLAGS(*pte) &amp; PTE_A) &#123;</span><br><span class="line">      bitmask = bitmask | (<span class="number">1L</span> &lt;&lt; i); <span class="comment">// 如果该页表项对应的页表页被访问，则把对应的bitmask中的位设为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 然后将页表项中 access flag 设置为0</span></span><br><span class="line">  	*pte = ((*pte &amp; PTE_A) ^ *pte) ^ <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/27/confzns/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/27/confzns/" class="post-title-link" itemprop="url">confzns</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-27 14:08:58" itemprop="dateCreated datePublished" datetime="2023-12-27T14:08:58+08:00">2023-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-02 20:33:46" itemprop="dateModified" datetime="2024-01-02T20:33:46+08:00">2024-01-02</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ConfZNS学习记录"><a href="#ConfZNS学习记录" class="headerlink" title="ConfZNS学习记录"></a>ConfZNS学习记录</h1><h2 id="阅读confZNS论文"><a href="#阅读confZNS论文" class="headerlink" title="阅读confZNS论文"></a>阅读confZNS论文</h2><p><code>confzns</code>是一个基于<code>femu</code>的<code>zns ssd</code>模拟器。源码地址在 <a target="_blank" rel="noopener" href="https://github.com/DKU-StarLab/ConfZNS%E3%80%82">https://github.com/DKU-StarLab/ConfZNS。</a></p>
<p>论文地址在 <a target="_blank" rel="noopener" href="https://dl.acm.org/doi/abs/10.1145/3579370.3594772">https://dl.acm.org/doi/abs/10.1145/3579370.3594772</a></p>
<h3 id="解决的问题："><a href="#解决的问题：" class="headerlink" title="解决的问题："></a>解决的问题：</h3><p><code>ZNS SSD</code>的内部架构是如何影响使用这些设备的应用程序的并行性和隔离性的。</p>
<blockquote>
<p>例如，如果区域与多个通道和路径相关联，即使在与单个区域进行大请求大小交互时，应用程序也可以获得高内部并行性的好处。</p>
</blockquote>
<h3 id="ConfZNS的特性"><a href="#ConfZNS的特性" class="headerlink" title="ConfZNS的特性"></a><code>ConfZNS</code>的特性</h3><ol>
<li><code>ConfZNS</code>支持<code>zns ssd</code>多样化区域映射。</li>
<li><code>ConfZNS</code>模拟的时间是精确的。</li>
<li><code>ConfZNS</code>允许从内部设备结构到应用软件的全栈探索。</li>
</ol>
<h3 id="ConfZNS设计"><a href="#ConfZNS设计" class="headerlink" title="ConfZNS设计"></a><code>ConfZNS</code>设计</h3><ol>
<li><code>ZNS</code>架构</li>
<li>时间估算器</li>
<li>资源监视器</li>
<li><code>ZNS</code>配置器</li>
</ol>
<h3 id="ZNS架构"><a href="#ZNS架构" class="headerlink" title="ZNS架构"></a><code>ZNS</code>架构</h3><p>在<code>SSD</code>中，通道<code>(channels)</code>、路径<code>(ways)</code>、晶圆<code>(dies)</code>、平面<code>(planes)</code>等都可以称为并行单元。可以利用这样的并行单元来达到最大的吞吐量。</p>
<p>如图所示，同一区域可以分配给不同的并行单元。</p>
<p><img src="/../images/confzns/%E6%88%AA%E5%B1%8F2023-12-27%2016.11.11.png" alt="截屏2023-12-27 16.11.11"></p>
<h3 id="时间估算器"><a href="#时间估算器" class="headerlink" title="时间估算器"></a><code>时间估算器</code></h3><p>服务延迟和队列延迟是影响<code>SSD I/O</code>延迟的两个因素。</p>
<p>图3、图4展示了<code>confzns</code>如何估算读写请求的延迟。</p>
<p>其中<code>Logic Page Numbers</code>被暴露给主机，而<code>Physic Page Numbers</code>靠设备维护。</p>
<p>由于区域映射的方式不同，每个区域覆盖的<code>PPN</code>也不同。</p>
<p>通过使用两种时钟，全局时钟<code>gc</code>，本地时钟<code>lc</code>。</p>
<ul>
<li><p><code>gc</code>: 会在每一个<code>tick</code>是增加</p>
</li>
<li><p><code>lc</code>: 每个资源维护一个<code>lc</code>，<code>lc</code>表示该资源的下一次可用时间。</p>
<p><code>lc = max(gc, lc) + service_time</code>，表示该资源的下一次可用时间。</p>
</li>
<li><p>如果<code>local clock</code>小于或者等于<code>global clock</code>，这表示该<code>local clock</code>对应的资源当前是空闲的。</p>
</li>
</ul>
<p><img src="/../images/confzns/%E6%88%AA%E5%B1%8F2023-12-27%2016.49.23.png" alt="截屏2023-12-27 16.49.23"></p>
<p><img src="/../images/confzns/%E6%88%AA%E5%B1%8F2023-12-27%2016.49.37.png" alt="截屏2023-12-27 16.49.37"></p>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>**混合区域支持<code>Mixed zone support</code>**：<code>confzns</code>可以同时支持<code>Single Unit Zone</code>或者<code>Full Unit Zone</code>。这使得<code>ZNS SSD</code>的应用程序有两种控制方式。一种是传统的线程，通过创建不同数量的线程，它们可以控制并行性。第二个是不同的区域。通过分配不同的区域，它们可以控制SSD中可以使用多少并行单元。同时也支持每个鱼去使用不同类型的闪存。</p>
<p><strong>传统区域支持</strong>：<code>ConfZNS</code>同样支持传统区域。</p>
<p><strong>PCIe链接带宽延迟模型</strong>：在ConfZNS中，PCIe链接带宽和版本是可配置的。此外，ConfZNS可以调节I&#x2F;O请求以满足PCIe接口的最大带宽。带宽调节的时间模型是基于漏桶算法实现的。当PCIe链接带宽未饱和时，所有请求都可以无延迟转移，只有转移时间会应用于这些请求。然而，如果达到最大带宽（例如3.94GB&#x2F;s），剩余的请求必须等待直到它们可以被转移。随着带宽接近其极限，这个等待时间会增加，并且会应用于所有待处理的请求。</p>
<h2 id="运行ConfZNS："><a href="#运行ConfZNS：" class="headerlink" title="运行ConfZNS："></a>运行<code>ConfZNS</code>：</h2><p>拉取<code>ConfZNS</code>源码：<a target="_blank" rel="noopener" href="https://github.com/DKU-StarLab/ConfZNS">https://github.com/DKU-StarLab/ConfZNS</a></p>
<p>根据<code>README.md</code>运行</p>
<p>先安装必要的工具链</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Switch to the FEMU building directory</span></span><br><span class="line">cd build-femu</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">only Debian/Ubuntu based distribution supported</span></span><br><span class="line">sudo ./pkgdep.sh</span><br></pre></td></tr></table></figure>

<p>编译<code>FEMU</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./femu-compile.sh</span><br></pre></td></tr></table></figure>

<p>下载镜像，这里我们用到的是<code>FEMU</code>官网提供的镜像。填个问卷就可以获得了。</p>
<p>然后模拟运行<code>zns ssd</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run-zns.sh</span><br></pre></td></tr></table></figure>

<p>我在这里遇到了一些打印时结构体访问越界的错误问题，把那段代码注释后可以成功运行。</p>
<p>不过接着遇到的问题是<code>run-zns.sh</code>运行失败。这是因为在<code>confzns</code>的源码中<code>-device femu, devsz_mb = 4096, femu_mode = 1</code>，其中<code>femu_mode = 1</code>表示<code>ssd</code>类型为<code>black box</code>。修改后的<code>run-zns.sh</code>如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Huaicheng Li &lt;hcli@cmu.edu&gt;</span></span><br><span class="line"><span class="comment"># Run FEMU as Zoned-Namespace (ZNS) SSDs</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Image directory</span></span><br><span class="line">IMGDIR=/home/parallels/images</span><br><span class="line"><span class="comment"># Virtual machine disk image</span></span><br><span class="line">OSIMGF=<span class="variable">$IMGDIR</span>/u20s.qcow2</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ ! -e <span class="string">&quot;<span class="variable">$OSIMGF</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;VM disk image couldn&#x27;t be found ...&quot;</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Please prepare a usable VM image and place it as <span class="variable">$OSIMGF</span>&quot;</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Once VM disk image is ready, please rerun this script again&quot;</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">sudo x86_64-softmmu/qemu-system-x86_64 \</span><br><span class="line">    -name <span class="string">&quot;FEMU-ZNSSD-VM&quot;</span> \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -cpu host \</span><br><span class="line">    -smp $(<span class="built_in">nproc</span>) \ 虚拟机CPU数量等于宿主机的处理器数量</span><br><span class="line">    -m 4G \					为虚拟机分配4GB内存</span><br><span class="line">    -device virtio-scsi-pci,<span class="built_in">id</span>=scsi0 \	</span><br><span class="line">    -device scsi-hd,drive=hd0 \</span><br><span class="line">    -drive file=<span class="variable">$OSIMGF</span>,<span class="keyword">if</span>=none,aio=native,cache=none,format=qcow2,<span class="built_in">id</span>=hd0 \</span><br><span class="line">    -device femu,devsz_mb=4096,femu_mode=3 \	表示分配的FEMU设备的大小为4GB 模式为zns ssd</span><br><span class="line">    -net user,hostfwd=tcp::8080-:22 \	设置端口为 8080</span><br><span class="line">    -net nic,model=virtio \</span><br><span class="line">    -nographic \</span><br><span class="line">    -qmp unix:./qmp-sock,server,nowait 2&gt;&amp;1 | <span class="built_in">tee</span> <span class="built_in">log</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>ConfZNS</code>启动后，我们新建一个终端，通过命令<code>ssh -p 8080 femu@localhost</code>远程连接终端，输入密码后成功连接。</p>
<p>首先键入命令<code>nvme list</code>查看系统中所有的<code>NVMe</code>设备的概览。</p>
<ul>
<li><code>node</code>是设备节点。</li>
<li><code>SN</code>是设备序列号<code>serial number</code>的缩写，用于唯一标识硬件设备。</li>
<li><code>Model</code>: 这是NVMe设备的模型名称，由制造商指定。（比如这里是 FEMU模拟的ZNS SSD）</li>
<li><code>Namespace</code>这是NVMe设备上的命名空间编号，命名空间是NVMe存储的逻辑分区。</li>
<li><code>Usage</code>:显示当前命名空间已使用的存储空间以及总可用空间。</li>
<li><code>Format</code>：描述了该命名空间的数据格式，包括扇区大小。这里的<code>512B + 0B</code>表示扇区大小为<code>512</code>字节加上<code>0</code>字节的元数。</li>
<li><code>FW Rev</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ sudo nvme list</span><br><span class="line">Node          SN       Model                    Namespace   Usage              Format           FW Rev  </span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line">/dev/nvme0n1  vZNSSD0  FEMU ZNS-SSD Controller  1          4.29  GB / 4.29  GB  512   B +  0 B   1.0     </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输入命令<code>nvme zns help</code>查看命令的帮助。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ nvme zns help</span><br><span class="line">nvme-1.13.48.g33c6</span><br><span class="line">usage: nvme zns &lt;command&gt; [&lt;device&gt;] [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">The &#x27;&lt;device&gt;&#x27; may be either an NVMe character device (ex: /dev/nvme0) or an</span><br><span class="line">nvme block device (ex: /dev/nvme0n1).</span><br><span class="line"></span><br><span class="line">Zoned Namespace Command Set</span><br><span class="line"></span><br><span class="line">The following are all implemented sub-commands:</span><br><span class="line">  id-ctrl             Retrieve ZNS controller identification</span><br><span class="line">  id-ns               Retrieve ZNS namespace identification</span><br><span class="line">  zone-mgmt-recv      Sends the zone management receive command</span><br><span class="line">  zone-mgmt-send      Sends the zone management send command</span><br><span class="line">  report-zones        Retrieve the Report Zones report</span><br><span class="line">  close-zone          Closes one or more zones</span><br><span class="line">  finish-zone         Finishes one or more zones</span><br><span class="line">  open-zone           Opens one or more zones</span><br><span class="line">  reset-zone          Resets one or more zones</span><br><span class="line">  offline-zone        Offlines one or more zones</span><br><span class="line">  set-zone-desc       Attaches zone descriptor extension data</span><br><span class="line">  zone-append         Writes data and metadata (if applicable), appended to the end of the requested zone</span><br><span class="line">  changed-zone-list   Retrieves the changed zone list log</span><br><span class="line">  version             Shows the program version</span><br><span class="line">  help                Display this help</span><br><span class="line"></span><br><span class="line">See &#x27;nvme zns help &lt;command&gt;&#x27; for more information on a specific command</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>让我们一一解释这些命令的用法：</p>
<ul>
<li><p><code>nvme zns id-ctrl</code>: Send NVMe Zoned Command Set Identify Controller, return result and structure.下面给出一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ sudo nvme zns id-ctrl /dev/nvme0n1</span><br><span class="line">NVMe ZNS Identify Controller:</span><br><span class="line">zasl    : 5</span><br></pre></td></tr></table></figure>

<p><code>zone append size limit</code>是区域追加大小限制，这里指的区域追加大小限制应该是append命令的大小限制。</p>
<blockquote>
<p>分区命名空间命令集规范目前在命令集的识别控制器中只定义了一个字段：区域追加大小限制（ZASL）。区域追加大小限制（ZASL）编码了区域追加命令的最大命令大小。下面的例子返回的是‘5’，这对应于128千字节（在这个例子中可以追加的最大大小）。</p>
</blockquote>
</li>
<li><p><code>nvme zns id-ns</code> 获取 <code>ZNS namespace</code> 标识</p>
<p>人不可读的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ sudo nvme zns id-ns /dev/nvme0n1 </span><br><span class="line">ZNS Command Set Identify Namespace:</span><br><span class="line">zoc     : 0</span><br><span class="line">ozcs    : 1</span><br><span class="line">mar     : 0xffffffff</span><br><span class="line">mor     : 0xffffffff</span><br><span class="line">rrl     : 0</span><br><span class="line">frl     : 0</span><br><span class="line">lbafe  0: zsze:0x20000 zdes:0 (in use)</span><br><span class="line">lbafe  1: zsze:0x0 zdes:0</span><br><span class="line">lbafe  2: zsze:0x0 zdes:0</span><br><span class="line">lbafe  3: zsze:0x0 zdes:0</span><br><span class="line">lbafe  4: zsze:0x0 zdes:0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>人可读的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ sudo nvme zns id-ns /dev/nvme0n1 -H</span><br><span class="line">ZNS Command Set Identify Namespace:</span><br><span class="line">zoc     : 0	Zone Operation Characteristics</span><br><span class="line">  [1:1] : 0	  Zone Active Excursions: No</span><br><span class="line">  [0:0] : 0	  Variable Zone Capacity: No</span><br><span class="line"></span><br><span class="line">ozcs    : 1	Optional Zoned Command Support</span><br><span class="line">  [0:0] : 0x1	  Read Across Zone Boundaries: Yes</span><br><span class="line">mar     : No Active Resource Limit</span><br><span class="line">mor     : No Open Resource Limit</span><br><span class="line">rrl     : Not Reported</span><br><span class="line">frl     : Not Reported</span><br><span class="line">LBA Format Extension  0 : Zone Size: 0x20000 LBAs - Zone Descriptor Extension Size: 0 bytes (in use)</span><br><span class="line">LBA Format Extension  1 : Zone Size: 0x0 LBAs - Zone Descriptor Extension Size: 0 bytes</span><br><span class="line">LBA Format Extension  2 : Zone Size: 0x0 LBAs - Zone Descriptor Extension Size: 0 bytes</span><br><span class="line">LBA Format Extension  3 : Zone Size: 0x0 LBAs - Zone Descriptor Extension Size: 0 bytes</span><br><span class="line">LBA Format Extension  4 : Zone Size: 0x0 LBAs - Zone Descriptor Extension Size: 0 bytes</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>zoc</code>：区域活动波动<code>Zone Active Excursions</code>和可变区域容量<code>Variable Zone Capability</code>的特性都不支持。</li>
<li><code>Optional Zoned Command Support</code>：表示支持的可选分区命令。<code>1</code>表示跨区域边界读取是支持的。</li>
<li><code>mar</code> <code>Max Active Resources</code>：表示没有限制可以活动的资源数量。</li>
<li><code>mor</code> <code>Maximum Open Resources</code>：表示没有开放资源的限制。</li>
<li><code>rrl</code> <code>Read Recovery Levels</code>：未报告，意味着没有读取恢复级别的信息。</li>
<li><code>frl</code> <code>Finish Recovery Levels</code>：未报告，意味着没有提供关于完成恢复级别的信息。</li>
<li><code>LBA Format Extension</code>：这些是逻辑块地址格式扩展条目，描述了不同区域的大小和描述符扩展大小。‘<ul>
<li><code>Zone Size</code>的大小为：<code>0x20000</code>的逻辑块地址，区域描述符扩展大小为0字节，表示这个区域格式当前正在使用中。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>zone-mgmt-recv      Sends the zone management receive command</code> 不太明白咋用，一用内核就挂了。</strong></p>
</li>
<li><p><strong><code>zone-mgmt-send      Sends the zone management send command</code> 同上。</strong></p>
</li>
<li><p><code>report-zones</code>：获取分区的报告，以下是一部分输出。</p>
<ul>
<li><code>nr_zones</code>表示一共有64个分区。</li>
<li><code>SLBA</code>表示每个分区的起始逻辑块地址。</li>
<li><code>WP</code>表示每个分区的写指针指向的逻辑块地址。<ul>
<li><code>Cap</code>表示每个分区的<code>Zone capability</code>，大小为<code>0x20000</code>。</li>
<li><code>State</code>表示每个分区的类型，这里的类型是<code>EMPTY</code>。</li>
<li><code>Type</code>类型为<code>Unknown</code>或者<code>SEQWRITE_REQ</code>顺序写规定。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ sudo nvme zns report-zones /dev/nvme0n1 </span><br><span class="line">nr_zones: 64</span><br><span class="line">SLBA: 0x380000   WP: 0x380000   Cap: 0x20000    State: EMPTY        Type: Unknown        Attrs: 0x0</span><br><span class="line">SLBA: 0x3a0000   WP: 0x3a0000   Cap: 0x20000    State: EMPTY        Type: Unknown        Attrs: 0x0</span><br><span class="line">SLBA: 0x3c0000   WP: 0x3c0000   Cap: 0x20000    State: EMPTY        Type: Unknown        Attrs: 0x0</span><br><span class="line">SLBA: 0x3e0000   WP: 0x3e0000   Cap: 0x20000    State: EMPTY        Type: Unknown        Attrs: 0x0</span><br><span class="line">SLBA: 0x400000   WP: 0x400000   Cap: 0x20000    State: EMPTY        Type: SEQWRITE_REQ   Attrs: 0x0</span><br><span class="line">SLBA: 0x420000   WP: 0x420000   Cap: 0x20000    State: EMPTY        Type: SEQWRITE_REQ   Attrs: 0x0</span><br><span class="line">SLBA: 0x440000   WP: 0x440000   Cap: 0x20000    State: EMPTY        Type: SEQWRITE_REQ   Attrs: 0x0</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>open-zone</code>: 显示打开区域，<code>action:3</code>表示执行的具体操作；<code>zone:0</code>表示操作的是第0个区域；<code>nsid:1</code>表示操作的区域的命名空间标识符是1。<strong>区域需要先打开才能关闭，否则会出现错误。</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ sudo nvme zns open-zone /dev/nvme0n1</span><br><span class="line">zns-open-zone: Success, action:3 zone:0 nsid:1</span><br></pre></td></tr></table></figure>

<p>执行命令<code>sudo nvme zns report-zones /dev/nvme0n1</code>查看区域状态。我们可以发现区域的状态为<code>EXP_OPENED</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nr_zones: 64</span><br><span class="line">SLBA: 0x0        WP: 0x0        Cap: 0x20000    State: EXP_OPENED   Type: Unknown        Attrs: 0x0</span><br><span class="line">SLBA: 0x20000    WP: 0x20000    Cap: 0x20000    State: EMPTY        Type: Unknown        Attrs: 0x0</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>close-zone</code>关闭区域，关闭后再通过<code>report-zones</code>命令得到区域的报告。状态为关闭。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ sudo nvme zns close-zone /dev/nvme0n1</span><br><span class="line">zns-close-zone: Success, action:1 zone:0 nsid:1</span><br><span class="line">femu@fvm:~$ sudo nvme zns report-zones /dev/nvme0n1</span><br><span class="line">nr_zones: 64</span><br><span class="line">SLBA: 0x0        WP: 0x0        Cap: 0x20000    State: CLOSED       Type: Unknown        Attrs: 0x0</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>finish-zone</code>完成区域，即将该区域设置为满。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ sudo nvme zns finish-zone /dev/nvme0n1 </span><br><span class="line">zns-finish-zone: Success, action:2 zone:0 nsid:1</span><br><span class="line">femu@fvm:~$ sudo nvme zns report-zones /dev/nvme0n1 </span><br><span class="line">nr_zones: 64</span><br><span class="line">SLBA: 0x0        WP: 0xffffffffffffffff Cap: 0x20000    State: FULL         Type: Unknown        Attrs: 0x0</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>offline-zone</code>：将一个区域设置为离线会使该区域变得无法访问。在离线区域上的数据将无法访问，且在区域被重置之前，无法向该区域写入数据。运行此命令来将第一个区域设置为离线。</p>
<p><strong>对状态为空的区域关闭不行，对状态为显示打开的区域关闭也不行，对状态为满的区域关闭也不行。</strong></p>
</li>
<li><p><code>zone-append</code>和<code>read</code>命令，这里 <code>-z 512</code>代表追加操作追加的数据大小为<code>512B</code>。通过区域报告，我们可以知道每个逻辑块的大小为<code>512B</code>（因为我们发现读指针增加了1）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ echo &quot;Hello World&quot; | sudo nvme zns zone-append /dev/nvme0n1 -z 512</span><br><span class="line">Success appended data to LBA 0</span><br><span class="line">femu@fvm:~$ sudo nvme read /dev/nvme0n1 -z 512</span><br><span class="line">Hello World</span><br><span class="line">read: Success</span><br><span class="line">femu@fvm:~$ sudo nvme zns report-zones /dev/nvme0n1</span><br><span class="line">nr_zones: 64</span><br><span class="line">SLBA: 0x0        WP: 0x1        Cap: 0x20000    State: EXP_OPENED   Type: Unknown        Attrs: 0x0</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">femu@fvm:~$ echo &quot;Goodbye World&quot; | sudo nvme zns zone-append /dev/nvme0n1 -z 512</span><br><span class="line">Success appended data to LBA 1</span><br><span class="line">femu@fvm:~$ sudo nvme read /dev/nvme0n1 -z 512</span><br><span class="line">Hello World</span><br><span class="line">read: Success</span><br><span class="line">femu@fvm:~$ sudo nvme read /dev/nvme0n1 -z 1024</span><br><span class="line">Hello World</span><br><span class="line">read: Success</span><br><span class="line">femu@fvm:~$ sudo nvme read /dev/nvme0n1 -z 512 -s 1</span><br><span class="line">Goodbye World</span><br><span class="line">read: Success</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​	当我们再次使用<code>zone-append</code>命令写入数据时，我们无须指定逻辑块地址。但在读取数据的时候，我们需要通过<code>-s</code>选项指定逻辑块地址以实现随机读。</p>
<ul>
<li>为什么使用nvme-cli write 命令也可以？</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/16/Lab-system-calls-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不捨晝夜。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="talk is cheap, show me the code.">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/16/Lab-system-calls-1/" class="post-title-link" itemprop="url">Lab: system calls</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-16 11:16:19" itemprop="dateCreated datePublished" datetime="2023-12-16T11:16:19+08:00">2023-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-26 08:59:15" itemprop="dateModified" datetime="2023-12-26T08:59:15+08:00">2023-12-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab-system-calls"><a href="#Lab-system-calls" class="headerlink" title="Lab: system calls"></a>Lab: system calls</h1><p>决定重新开始捡起<code>xv6</code>的实验。</p>
<h2 id="1-Using-gdb"><a href="#1-Using-gdb" class="headerlink" title="1.Using gdb:"></a>1.Using gdb:</h2><p>这个就跟着教程一步一步来。简单说一下在<code>mac os</code>下如何使用<code>gdb</code>，打开两个终端窗口：</p>
<ul>
<li><p>在第一个窗口下：</p>
<ol>
<li><p>执行<code>cd xv6-labs-2023</code>，进入目标文件。</p>
</li>
<li><p>运行<code>make qemu-gdb</code>。</p>
</li>
<li><p>终端会输出当前窗口的tcp，例如<code>tcp::26000</code>。</p>
<blockquote>
<p>以远程调试模式连接到本地主机上的端口<code>26000</code></p>
</blockquote>
</li>
</ol>
<p>	</p>
</li>
<li><p>在第二个窗口下：</p>
<ol>
<li><p>执行<code>cd xv6-labs-2023</code>，进入目标文件。</p>
</li>
<li><p>执行<code>riscv64-unknown-elf-gdb</code>，运行<code>gdb</code>。</p>
</li>
<li><p>在<code>gdb</code>中执行<code>target remote localhost:26000</code>，链接第一个窗口。</p>
</li>
<li><p>然后在<code>gdb</code>窗口中执行<code>file kernel/kernel</code>，加载可执行文件<code>kernel</code>到调试器<code>gdb</code>中。</p>
<blockquote>
<p>这一步只是加载可执行文件，并没有运行该文件。</p>
</blockquote>
</li>
<li><p>在<code>gdb</code>窗口中，执行<code>b syscall</code>，这一步是在<code>syscall</code>函数处打断点。</p>
</li>
<li><p>在<code>gdb</code>窗口中，执行<code>c</code>，运行上文加载的<code>kernel/kernel</code>可执行文件，可执行文件会在第一个调用<code>syscall</code>处暂停。</p>
</li>
<li><p>通过在<code>gdb</code>窗口中执行<code>layout src</code>命令启动和显示源代码布局。</p>
</li>
<li><p>然后调用执行<code>backtrace</code>，用于显示当前线程的调用堆栈。</p>
</li>
</ol>
</li>
</ul>
<p>效果如图所示：</p>
<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-16%2014.12.00-2707131.png" alt="截屏2023-12-16 14.12.00"></p>
<h3 id="Question-Looking-at-the-backtrace-output-which-function-called-syscall"><a href="#Question-Looking-at-the-backtrace-output-which-function-called-syscall" class="headerlink" title="Question: Looking at the backtrace output, which function called syscall?"></a>Question: Looking at the backtrace output, which function called <code>syscall</code>?</h3><p>如图所示，我们发现是在<code>kernel/trap.c:67</code>行，即函数<code>usertrap()</code>中调用了<code>syscall()</code>。检查源码确实如此。</p>
<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-16%2014.16.15.png" alt="截屏2023-12-16 14.16.15"></p>
<p>键入<code>n</code>命令让程序执行过<code>struct proc *p = myproc();</code>，然后键入<code>p /x *p</code>，打印指针<code>p</code>指向的<code>struct pro</code>结构体内容。</p>
<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-16%2014.28.45.png" alt="截屏2023-12-16 14.28.45"></p>
<p>上图中显示了结构体<code>struct proc</code>中的大部分内容。</p>
<h3 id="Question-What-is-the-value-of-p-gt-trapframe-gt-a7-and-what-does-that-value-represent-Hint-look-user-initcode-S-the-first-user-program-xv6-starts"><a href="#Question-What-is-the-value-of-p-gt-trapframe-gt-a7-and-what-does-that-value-represent-Hint-look-user-initcode-S-the-first-user-program-xv6-starts" class="headerlink" title="Question: What is the value of p-&gt;trapframe-&gt;a7 and what does that value represent? (Hint: look user/initcode.S, the first user program xv6 starts.)"></a>Question: What is the value of <code>p-&gt;trapframe-&gt;a7</code> and what does that value represent? (Hint: look <code>user/initcode.S</code>, the first user program xv6 starts.)</h3><p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-16%2014.32.49.png" alt="截屏2023-12-16 14.32.49"></p>
<p>接着我们打印<code>p-&gt;trapframe-&gt;a7</code>，发现值为7。问题的提示让我们去看<code>user/initcode.S</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Initial process that execs /init.</span><br><span class="line"># This code runs in user space.</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line"># exec(init, argv)</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        la a0, init</span><br><span class="line">        la a1, argv</span><br><span class="line">        li a7, SYS_exec</span><br><span class="line">        ecall</span><br><span class="line"></span><br><span class="line"># for(;;) exit();</span><br><span class="line">exit:</span><br><span class="line">        li a7, SYS_exit</span><br><span class="line">        ecall</span><br><span class="line">        jal exit</span><br><span class="line"></span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">  .string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">  .long init</span><br><span class="line">  .long 0</span><br></pre></td></tr></table></figure>

<p>我们发现这段代码把<code>SYS_exec</code>的值加载到寄存器<code>a7</code>中，然后通过<code>ecall</code>执行<code>a7</code>中的系统调用。</p>
<p>处理器当前在内核模式下运行，我们可以打印特权寄存器<code>(privileged registers)</code>，例如<code>sstatus (supervisor Status Register)</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p /x $sstatus</span><br><span class="line">$3 = 0x200000022</span><br></pre></td></tr></table></figure>

<p>图4.1和图4.2展示了64位机器和32位机器下的<code>sstatus</code>每一位的含义。</p>
<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-17%2010.18.16.png" alt="截屏2023-12-17 10.18.16"></p>
<h3 id="Question-What-was-the-previous-mode-that-the-CPU-was-in"><a href="#Question-What-was-the-previous-mode-that-the-CPU-was-in" class="headerlink" title="Question: What was the previous mode that the CPU was in?"></a>Question: What was the previous mode that the CPU was in?</h3><p>如图所示，<code>SSP</code>在64位机器上的<code>sstatus</code>的第八位，得到值为<code>0</code>。现在我们知道，当<code>trap</code>发生前，硬件线程<code>hart</code>处于用户态<code>user mode</code>。</p>
<p>在接下来的实验中，一些编程错误会导致<code>xv6</code>内核崩溃。例如，替换<code>num = p-&gt;trapframe-&gt;a7</code>为<code>num = *(int *)0;</code>，然后执行<code>make qemu</code>，会看见：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 1 starting</span><br><span class="line">hart 2 starting</span><br><span class="line">scause 0x000000000000000d</span><br><span class="line">sepc=0x0000000080002054 stval=0x0000000000000000</span><br><span class="line">panic: kerneltrap</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sepc: When a trap occurs, RISC-V saves the program counter here (since the pc is then overwritten with the value in stvec). The sret (return from trap) instruction copies sepc to the pc. The kernel can write sepc to control where sret goes.</p>
</blockquote>
<p><code>sepc</code>中存储的值是发生<code>trap</code>时，程序计数器中存储的处理器即将执行的下一条指令在内存中的地址。</p>
<h3 id="Question-Write-down-the-assembly-instruction-the-kernel-is-panicing-at-Which-register-corresponds-to-the-variable-num"><a href="#Question-Write-down-the-assembly-instruction-the-kernel-is-panicing-at-Which-register-corresponds-to-the-variable-num" class="headerlink" title="Question: Write down the assembly instruction the kernel is panicing at. Which register corresponds to the variable num?"></a>Question: Write down the assembly instruction the kernel is panicing at. Which register corresponds to the variable <code>num</code>?</h3><p><code>kernel/kernel.asm</code>是通过编译器将<code>c语言</code>编译成的内核汇编语言源文件，包含了原代码的汇编语言表示。</p>
<p>我们在<code>kernel/kernel.asm</code>中找到<code>sepc=0x0000000080002054</code>地址对应的汇编指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = *(int*)0;</span><br><span class="line">80002054:	00002683          	lw	a3,0(zero) # 0 &lt;_entry-0x80000000&gt;</span><br></pre></td></tr></table></figure>

<p>该指令尝试从零地址加载一个字<code>load word</code>到<code>a3</code>寄存器中。这会产生错误：因为地址0在大多数操作系统中是不可访问的，在<code>xv6</code>系统中<code>0x0-0x80000000</code>地址用于<code>I/O</code>设备。并且我们发现，<code>num</code>的值存储在<code>a3</code>寄存器中。</p>
<blockquote>
<p>The loader loads the xv6 kernel into memory at physical address <code>0x80000000</code>. The reason it places the kernel at <code>0x80000000</code> rather than <code>0x0</code> is because the address range <code>0x0:0x80000000</code> contains I&#x2F;O devices.</p>
</blockquote>
<p>要在故障指令处检查处理器和内核的状态，请启动gdb，并在故障epc上设置断点，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x0000000080002054</span><br><span class="line">Breakpoint 1 at 0x80002054: file kernel/syscall.c, line 138</span><br><span class="line">(gdb) layout asm</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[Switching to Thread 1.2]</span><br><span class="line"></span><br><span class="line">Thread 2 hit Breakpoint 1, syscall () at kernel/syscall.c:138</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-17%2011.40.13.png" alt="截屏2023-12-17 11.40.13"></p>
<p><code>gdb</code>展示的结果和<code>sepc</code>的结果相同。</p>
<h3 id="Question-Why-does-the-kernel-crash-Hint-look-at-figure-3-3-in-the-text-is-address-0-mapped-in-the-kernel-address-space-Is-that-confirmed-by-the-value-in-scause-above-See-description-of-scause-in-RISC-V-privileged-instructions"><a href="#Question-Why-does-the-kernel-crash-Hint-look-at-figure-3-3-in-the-text-is-address-0-mapped-in-the-kernel-address-space-Is-that-confirmed-by-the-value-in-scause-above-See-description-of-scause-in-RISC-V-privileged-instructions" class="headerlink" title="Question: Why does the kernel crash? Hint: look at figure 3-3 in the text; is address 0 mapped in the kernel address space? Is that confirmed by the value in scause above? (See description of scause in RISC-V privileged instructions)"></a>Question: Why does the kernel crash? Hint: look at figure 3-3 in the text; is address 0 mapped in the kernel address space? Is that confirmed by the value in <code>scause</code> above? (See description of <code>scause</code> in <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2023/labs/n//github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">RISC-V privileged instructions</a>)</h3><p>首先我们要清楚，在<code>kernel/kernel.asm</code>中的地址为虚拟地址。然后找到图3.3。如图，我们可以发现，虚拟地址0并没有映射到任何一个物理地址上。检查<code>scause</code>寄存器的值<code>scause = 0x000000000000000d</code>，通过图4.2可知，<code>0xd=13</code>对应<code>Load Page Fault</code>。</p>
<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-17%2020.08.43.png" alt="截屏2023-12-17 20.08.43"></p>
<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-18%2018.53.43.png" alt="截屏2023-12-18 18.53.43"></p>
<p><code>scause</code>是被上面的<code>kernel panic</code>打印出来的，但是你通常需要额外的信息来追踪导致崩溃的问题。例如，找到崩溃时是哪个用户进程正在运行，可以通过<code>p p-&gt;name</code>命令打印进程的名字。</p>
<p><code>process name is &quot;initcode\000\000\000\000\000\000\000&quot;</code>，进程的<code>pid</code>是<code>1</code>。</p>
<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-18%2019.12.14.png" alt="截屏2023-12-18 19.12.14"></p>
<p><img src="/../images/Lab-system-calls-1/%E6%88%AA%E5%B1%8F2023-12-18%2019.16.08.png" alt="截屏2023-12-18 19.16.08"></p>
<h2 id="2-System-call-tracing"><a href="#2-System-call-tracing" class="headerlink" title="2. System call tracing"></a>2. System call tracing</h2><h3 id="In-this-assignment-you-will-add-a-system-call-tracing-feature-that-may-help-you-when-debugging-later-labs-You’ll-create-a-new-trace-system-call-that-will-control-tracing-It-should-take-one-argument-an-integer-“mask”-whose-bits-specify-which-system-calls-to-trace-For-example-to-trace-the-fork-system-call-a-program-calls-trace-1-lt-lt-SYS-fork-where-SYS-fork-is-a-syscall-number-from-kernel-syscall-h-You-have-to-modify-the-xv6-kernel-to-print-out-a-line-when-each-system-call-is-about-to-return-if-the-system-call’s-number-is-set-in-the-mask-The-line-should-contain-the-process-id-the-name-of-the-system-call-and-the-return-value-you-don’t-need-to-print-the-system-call-arguments-The-trace-system-call-should-enable-tracing-for-the-process-that-calls-it-and-any-children-that-it-subsequently-forks-but-should-not-affect-other-processes"><a href="#In-this-assignment-you-will-add-a-system-call-tracing-feature-that-may-help-you-when-debugging-later-labs-You’ll-create-a-new-trace-system-call-that-will-control-tracing-It-should-take-one-argument-an-integer-“mask”-whose-bits-specify-which-system-calls-to-trace-For-example-to-trace-the-fork-system-call-a-program-calls-trace-1-lt-lt-SYS-fork-where-SYS-fork-is-a-syscall-number-from-kernel-syscall-h-You-have-to-modify-the-xv6-kernel-to-print-out-a-line-when-each-system-call-is-about-to-return-if-the-system-call’s-number-is-set-in-the-mask-The-line-should-contain-the-process-id-the-name-of-the-system-call-and-the-return-value-you-don’t-need-to-print-the-system-call-arguments-The-trace-system-call-should-enable-tracing-for-the-process-that-calls-it-and-any-children-that-it-subsequently-forks-but-should-not-affect-other-processes" class="headerlink" title="In this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new trace system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls trace(1 &lt;&lt; SYS_fork), where SYS_fork is a syscall number from kernel/syscall.h. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The trace system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes."></a>In this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new <code>trace</code> system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls <code>trace(1 &lt;&lt; SYS_fork)</code>, where <code>SYS_fork</code> is a syscall number from <code>kernel/syscall.h</code>. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The <code>trace</code> system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</h3><blockquote>
<p>这个实验做着比较奇怪，感觉只是做出来了，但为啥是这样的？</p>
</blockquote>
<p>我们先跟着<code>hints</code>走一遍流程：</p>
<ul>
<li><p><strong>Add <code>$U/_trace</code> to UPROGS in Makefile</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in Makefile</span><br><span class="line">UPROGS=\</span><br><span class="line">		...</span><br><span class="line">		$U/_trace</span><br></pre></td></tr></table></figure>
</li>
<li><p>Run make qemu and you will see that the compiler cannot compile <code>user/trace.c</code>, because the user-space stubs for the system call don’t exist yet: add a prototype for the system call to <code>user/user.h</code>, a stub to <code>user/usys.pl</code>, and a syscall number to <code>kernel/syscall.h</code>. The Makefile invokes the perl script <code>user/usys.pl</code>, which produces <code>user/usys.S</code>, the actual system call stubs, which use the RISC-V <code>ecall</code> instruction to transition to the kernel. Once you fix the compilation issues, run trace 32 grep hello README; it will fail because you haven’t implemented the system call in the kernel yet.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*In user/user.h*/</span></span><br><span class="line"><span class="comment">// system calls</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In user/usys.pl</span></span><br><span class="line">entry(<span class="string">&quot;trace&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Add a <code>sys_trace()</code> function in <code>kernel/sysproc.c</code> that implements the new system call by remembering its argument in a new variable in the <code>proc</code> structure (see <code>kernel/proc.h</code>). The functions to retrieve system call arguments from user space are in <code>kernel/syscall.c</code>, and you can see examples of their use in <code>kernel/sysproc.c</code>.</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in the proc structure of kernel/pro.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="type">int</span> tracemask;            <span class="comment">// Used to store trace mask number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> maskval;</span><br><span class="line">    argint(<span class="number">0</span>, &amp;maskval);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * when we run trace 32 grep hello README</span></span><br><span class="line"><span class="comment">     * terminal outputs p-&gt;trapframe-&gt;a0 32</span></span><br><span class="line"><span class="comment">     * thus we know the first argument is stored on register a0</span></span><br><span class="line"><span class="comment">     * now we store the trace mask into the structure proc-&gt;tracemask</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">cp</span> =</span> myproc();</span><br><span class="line">    cp-&gt;tracemask = maskval;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Modify <code>fork()</code> (see <code>kernel/proc.c</code>) to copy the trace mask from the parent to the child process.</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* function fork() in kernel/proc.c */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  	...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   	* modified by theFutile</span></span><br><span class="line"><span class="comment">   	* copy trace mask from parent to child</span></span><br><span class="line"><span class="comment">   	*/</span></span><br><span class="line">  	np-&gt;tracemask = p-&gt;tracemask;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Modify the <code>syscall()</code> function in <code>kernel/syscall.c</code> to print the trace output. You will need to add an array of syscall names to index into.</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in kernel/syscall.c */</span></span><br><span class="line"><span class="comment">/* add a new array stored syscall name*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span>* syscallsInfo[<span class="number">23</span>] = &#123;</span><br><span class="line">  			<span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;fork&quot;</span>,</span><br><span class="line">  			...</span><br><span class="line">        <span class="string">&quot;trace&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* modified the syscall function */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">syscall(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    <span class="comment">// Use num to lookup the system call function for num, call it,</span></span><br><span class="line">    <span class="comment">// and store its return value in p-&gt;trapframe-&gt;a0</span></span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * judge the trace mask bit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;tracemask &amp; (<span class="number">1ULL</span> &lt;&lt; num)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscallsInfo[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意，在上述操作结束后，<code>trace</code>命令在不传入<code>mask</code>时仍会打印信息，这是因为在创建进程的时候并没有初始化<code>tracemask</code>的值。所以，我们要在初始化进程的时候将<code>tracemask</code>赋值为<code>0</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* function freeproc() in kernel/proc.c */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">  	...</span><br><span class="line">		<span class="comment">/* free trace mask bits */</span></span><br><span class="line">  	p-&gt;tracemask = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阅读<code>syscall()</code>函数我们知道，系统调用的返回值被存储在<code>p-&gt;trapframe-&gt;a0</code>寄存器中，</p>
<p>在操作系统内核中，我们可以定义一个函数指针数组来映射系统调用编号到它们的处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">    [SYS_fork] = sys_fork,</span><br><span class="line">    [SYS_exit] = sys_exit,</span><br><span class="line">    [SYS_read] = sys_read,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-Sysinfo"><a href="#3-Sysinfo" class="headerlink" title="3. Sysinfo"></a>3. Sysinfo</h2><h3 id="In-this-assignment-you-will-add-a-system-call-sysinfo-that-collects-information-about-the-running-system-The-system-call-takes-one-argument-a-pointer-to-a-struct-sysinfo-see-kernel-sysinfo-h-The-kernel-should-fill-out-the-fields-of-this-struct-the-freemem-field-should-be-set-to-the-number-of-bytes-of-free-memory-and-the-nproc-field-should-be-set-to-the-number-of-processes-whose-state-is-not-UNUSED-We-provide-a-test-program-sysinfotest-you-pass-this-assignment-if-it-prints-“sysinfotest-OK”"><a href="#In-this-assignment-you-will-add-a-system-call-sysinfo-that-collects-information-about-the-running-system-The-system-call-takes-one-argument-a-pointer-to-a-struct-sysinfo-see-kernel-sysinfo-h-The-kernel-should-fill-out-the-fields-of-this-struct-the-freemem-field-should-be-set-to-the-number-of-bytes-of-free-memory-and-the-nproc-field-should-be-set-to-the-number-of-processes-whose-state-is-not-UNUSED-We-provide-a-test-program-sysinfotest-you-pass-this-assignment-if-it-prints-“sysinfotest-OK”" class="headerlink" title="In this assignment you will add a system call, sysinfo, that collects information about the running system. The system call takes one argument: a pointer to a struct sysinfo (see kernel/sysinfo.h). The kernel should fill out the fields of this struct: the freemem field should be set to the number of bytes of free memory, and the nproc field should be set to the number of processes whose state is not UNUSED. We provide a test program sysinfotest; you pass this assignment if it prints “sysinfotest: OK”."></a>In this assignment you will add a system call, <code>sysinfo</code>, that collects information about the running system. The system call takes one argument: a pointer to a <code>struct sysinfo</code> (see <code>kernel/sysinfo.h</code>). The kernel should fill out the fields of this struct: the <code>freemem</code> field should be set to the number of bytes of free memory, and the <code>nproc</code> field should be set to the number of processes whose <code>state</code> is not <code>UNUSED</code>. We provide a test program <code>sysinfotest</code>; you pass this assignment if it prints “sysinfotest: OK”.</h3><p>还是跟着<code>hints</code>走一遍流程：</p>
<ul>
<li><p><strong>Add <code>$U/_sysinfotest</code> to UPROGS in Makefile</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in Makefile</span><br><span class="line">UPROGS=\</span><br><span class="line">		...</span><br><span class="line">		$U/_trace</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Run make qemu; <code>user/sysinfotest.c</code> will fail to compile. Add the system call sysinfo, following the same steps as in the previous assignment. To declare the prototype for sysinfo() <code>in user/user.h</code> you need predeclare the existence of <code>struct sysinfo</code></strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*In user/user.h*/</span></span><br><span class="line"><span class="comment">// declare prototype</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span>;</span></span><br><span class="line"><span class="comment">// system calls</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo*)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In user/usys.pl</span></span><br><span class="line">entry(<span class="string">&quot;sysinfo&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>sysinfo needs to copy a <code>struct sysinfo</code> back to user space; see <code>sys_fstat()</code> (<code>kernel/sysfile.c</code>) and <code>filestat()</code> (<code>kernel/file.c</code>) for examples of how to do that using <code>copyout()</code>.</strong></p>
<p>我们知道，<code>sys_sysinfo()</code>函数是在内核代码部分声明的，但我们观察到用于测试<code>sysinfo()</code>的代码是在用户态中运行的。所以在用户态中运行的代码需要和在内核态中运行的代码进行交互。观察<code>sys_fstat()</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_fstat</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  uint64 st; <span class="comment">// user pointer to struct stat</span></span><br><span class="line">  argaddr(<span class="number">1</span>, &amp;st); <span class="comment">// store p-&gt;trapframe-&gt;a1 into st</span></span><br><span class="line">  <span class="keyword">if</span>(argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> filestat(f, st);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数将进程<code>p</code>中<code>trapframe-&gt;a1</code>中存储的地址赋值给<code>st</code>，该地址是从用户态中的代码传到内核空间中的。然后函数进一步将该地址传递到函数<code>filestat()</code>中，现在我们观察<code>filestat()</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get metadata about file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address, pointing to a struct stat.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">filestat</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_INODE || f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    stati(f-&gt;ip, &amp;st);</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">    <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;st, <span class="keyword">sizeof</span>(st)) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，该函数声明一个<code>struct stat</code>，然后将数据存储到当前的<code>stat</code>中，再调用<code>copyout()</code>函数，观察<code>copyout()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy from kernel to user.</span></span><br><span class="line"><span class="comment">// Copy len bytes from src to virtual address dstva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    <span class="keyword">if</span>(va0 &gt;= MAXVA)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    pte = walk(pagetable, va0, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span> || (*pte &amp; PTE_U) == <span class="number">0</span> ||</span><br><span class="line">       (*pte &amp; PTE_W) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    pa0 = PTE2PA(*pte);</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过注释，我们知道该函数从内核中拷贝数据到用户态中，其中，<code>pagetable</code>是<code>dstva</code>所在的页表中。该函数将内核空间中指针<code>src</code>指向的地址，拷贝<code>len</code>个字节，到虚拟地址<code>dstva</code>中，这个虚拟地址也即用户态空间中的位置。现在我们大致明白数据是如何从内核空间拷贝到用户空间。</p>
</li>
<li><p><strong>To collect the amount of free memory, add a function to <code>kernel/kalloc.c</code></strong></p>
<p>在结构体<code>struct sysinfo</code>中，我们要填写两个成员，<code>freemem</code>和<code>nproc</code>。其中<code>freemem</code>是存储空闲内存的数量的。观察<code>kernel/kalloc.c</code>代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>

<p>两个结构体<code>kmem</code>表示内核中的内存空间，其中 <code>lock</code>是一个自旋锁，在分配空间时需要加锁，<code>freelist</code>是一个指向空闲空间的链表，换句话说，空闲空间通过链表的形式存储。观察函数<code>kalloc()</code>的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现在分配物理空间的时候，首先通过<code>acquire(&amp;kmem.lock)</code>请求锁，然后获取当前内存的<code>freelist</code>，如果有空闲的内存，我们将内存取出并释放锁，然后将指针指向的空闲内存填充一些垃圾并返回该指针。并且，我们可以从上述代码中知道，每个<code>struct run</code>只想一个大小为<code>PGSIZE</code>的空间，也即<code>4096</code>比特。</p>
<p>现在我们尝试实现<code>collect_free_memory</code>。该函数首先获取<code>kmem</code>的空闲链表，然后请求锁，这保证了在计算空闲空间的时候内存不会被改变。然后每有一个空闲节点，<code>mem_byte</code>增加一个<code>PAGESIZE = 4096</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">count_free_mem</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> * <span class="title">r</span> =</span> kmem.freelist;</span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    uint64 mem_byte = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r) &#123;</span><br><span class="line">        mem_byte += PGSIZE;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">    <span class="keyword">return</span> mem_byte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>To collect the number of processes, add a function to <code>kernel/proc.c</code></strong></p>
<p>我们需要统计当前系统中状态不为<code>UNUSED</code>的进程数量，然后存储到<code>nproc</code>中，观察<code>kernel/proc.c</code>中函数<code>wakeup()</code>的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wake up all processes sleeping on chan.</span></span><br><span class="line"><span class="comment">// Must be called without any p-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p != myproc())&#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">        p-&gt;state = RUNNABLE;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道了内核代码遍历所有进程的方法，进程是在进程池中的，<code>NPROC</code>表示了进程的数量，于是我们实现<code>collect the number of processes</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">collect_process_num</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; ++p) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;state != UNUSED) &#123;</span><br><span class="line">            ++num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意，我们需要在<code>kernel/defs.h</code>中声明这些函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in kernel/defs.h */</span></span><br><span class="line"><span class="comment">// kalloc.c</span></span><br><span class="line">uint64          <span class="title function_">count_free_mem</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// proc.c</span></span><br><span class="line"><span class="type">int</span> 						<span class="title function_">collect_process_num</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>同时，要在<code>kernel/sysproc.c</code>中添加头文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/sysinfo.h&quot;</span></span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="theLonging"
      src="/images/touxiang.JPG">
  <p class="site-author-name" itemprop="name">theLonging</p>
  <div class="site-description" itemprop="description">不捨晝夜。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/chantchanH7" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chantchanH7" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/562879980@qq.com" title="E-Mail → 562879980@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-07 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">theLonging</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">335k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:05</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
