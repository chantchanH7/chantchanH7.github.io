<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="不舍昼夜">
<meta property="og:type" content="website">
<meta property="og:title" content="master haodong">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="master haodong">
<meta property="og:description" content="不舍昼夜">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="theLonging">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>master haodong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">master haodong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/22/dlco-nju/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不舍昼夜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="master haodong">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/22/dlco-nju/" class="post-title-link" itemprop="url">dlco_nju</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-22 15:13:02 / 修改时间：17:10:05" itemprop="dateCreated datePublished" datetime="2023-08-22T15:13:02+08:00">2023-08-22</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="南京大学-计算机科学与技术系-数字逻辑与计算机组成-课程实验"><a href="#南京大学-计算机科学与技术系-数字逻辑与计算机组成-课程实验" class="headerlink" title="南京大学 计算机科学与技术系 数字逻辑与计算机组成 课程实验"></a><a target="_blank" rel="noopener" href="https://nju-projectn.github.io/dlco-lecture-note/index.html">南京大学 计算机科学与技术系 数字逻辑与计算机组成 课程实验</a></h2><h2 id="实验一-选择器"><a href="#实验一-选择器" class="headerlink" title="实验一 选择器"></a>实验一 选择器</h2><h3 id="任务：1-上板实验-二位四选一选择器；2-实现一个简单的二位四选一选择器。"><a href="#任务：1-上板实验-二位四选一选择器；2-实现一个简单的二位四选一选择器。" class="headerlink" title="任务：1.上板实验: 二位四选一选择器；2.实现一个简单的二位四选一选择器。"></a>任务：1.<strong>上板实验: 二位四选一选择器</strong>；2.实现一个简单的二位四选一选择器。</h3><blockquote>
<p>用选择器模板实现一个2位4选1的选择器，如下图所示，选择器有5个2位输入端，分别为X0, X1, X2, X3和Y，输出端为F；X0, X1, X2, X3是四个2位的输入变量。输出F端受控制端Y的控制，选择其中的一个X输出，当Y &#x3D; 00时，输出端输出X0，即F &#x3D; X0；当Y &#x3D; 01时，输出端输出X1，即F &#x3D; X1；以此类推。</p>
<p><img src="/../images/dlco-nju/%E6%88%AA%E5%B1%8F2023-08-22%2015.30.30.png" alt="截屏2023-08-22 15.30.30"></p>
<p>选择开发板上的SW0和SW1作为控制端Y，SW2—SW9作为四个两位数据输入端X0–X3，将两位的输出端F接到发光二极管LEDR0和LEDR1上显示输出，完成设计，对自己的设计进行功能仿真，并下载到开发板上验证电路性能。</p>
</blockquote>
<p>​	简单的二位四选一选择器实现比较简单，参照讲义上 <em>Listing 5</em> <em>4选1选择器case语句实现</em> 使用<code>case</code>语句实现即可。但是选择器模版应该如何使用呢？阅读并观察讲义中<em>Listing 8</em> <em>使用选择器模板实现选择器</em>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">module mux21e(a,b,s,y);</span><br><span class="line">  input   a,b,s;</span><br><span class="line">  output  y;</span><br><span class="line">  MuxKey #(2, 1, 1) i0 (y, s, &#123;</span><br><span class="line">    1&#x27;b0, a,</span><br><span class="line">    1&#x27;b1, b</span><br><span class="line">  &#125;);</span><br><span class="line">endmodule</span><br><span class="line"></span><br><span class="line">module mux41b(a,s,y);</span><br><span class="line">  input  [3:0] a;</span><br><span class="line">  input  [1:0] s;</span><br><span class="line">  output y;</span><br><span class="line">  MuxKeyWithDefault #(4, 2, 1) i0 (y, s, 1&#x27;b0, &#123;</span><br><span class="line">    2&#x27;b00, a[0],</span><br><span class="line">    2&#x27;b01, a[1],</span><br><span class="line">    2&#x27;b10, a[2],</span><br><span class="line">    2&#x27;b11, a[3]</span><br><span class="line">  &#125;);</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module MuxKey #(NR_KEY = 2, KEY_LEN = 1, DATA_LEN = 1) (</span><br><span class="line">  output [DATA_LEN-1:0] out,</span><br><span class="line">  input [KEY_LEN-1:0] key,</span><br><span class="line">  input [NR_KEY*(KEY_LEN + DATA_LEN)-1:0] lut</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>​	<code>MuxKey</code>接受6个参数，三个一组，<code>#(NR_KEY = 2, KEY_LEN = 1, DATA_LEN = 1)</code>前三个参数以#开始在()内，分别为键值对的数量，键值的位宽，数据的位宽 ，后三个参数为引脚名称，分别为输出引脚out，给定的键值和<code>(键值，数据)</code> 的列表 <code>lut</code>。</p>
<p>​	现在我们可以编写用选择器模板实现的一个2位4选1的选择器，键值对的数量为4，键值的位宽，数据的位宽均为2。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module top(X0, X1, X2, X3, Y, F);</span><br><span class="line">	input [1:0] X0, X1, X2, X3, Y;</span><br><span class="line">	output [1:0] F;</span><br><span class="line">	MuxKey #(4, 2, 2) i0 (F, Y, &#123;</span><br><span class="line">		2&#x27;b00, X0,</span><br><span class="line">		2&#x27;b01, X1,</span><br><span class="line">		2&#x27;b10, X2,</span><br><span class="line">		2&#x27;b11, X3	</span><br><span class="line">		&#125;);</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<p>​	此时编译未成功，提示缺少模块<code>MuxKey</code>。如何结构化模块？首先寻找示例代码中是否有相关的例子。观察到<code>nvboard/example/vsrc</code>中有多个<code>.v</code>文件，且<code>top.v</code>中有实例化模块的例子，这说明该示例使用了结构化模块，阅读<code>Makefile</code>文件发现，编译时使用–top-module指出顶层模块名。我们仿照示例编写<code>Makefile</code>文件，并在目录中添加<code>MuxKey.v</code>和<code>MuxKeyInternal.v</code>模块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(VERILATOR) $(VERILATOR_CFLAGS) \</span><br><span class="line">		--top-module $(TOPNAME) $^ \</span><br><span class="line">		$(addprefix -CFLAGS , $(CFLAGS)) $(addprefix -LDFLAGS , $(LDFLAGS)) \</span><br><span class="line">		--Mdir $(OBJ_DIR) --exe -o $(abspath $(BIN))</span><br></pre></td></tr></table></figure>

<p>​	通过前一节搭建verilator仿真环境，我们知道如何在<code>nvboard</code>上连接引脚进行测试。此处就不再赘述。实现效果如下：	 <img src="/../images/dlco-nju/%E6%88%AA%E5%B1%8F2023-08-22%2015.55.17-2690921.png" alt="截屏2023-08-22 15.55.17"></p>
<p>​	当使能端<code>Y = 10</code>时，选择器选择<code>X2 = 11</code>，<code>LED0，LED1</code>被点亮。而不会输出其他信号。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>​	不要使用行为建模方式设计电路，即Verilog不像C语言编程一样是在过程中发现错误并优化代码的。一定要在脑海或者图纸上先将电路画出来，再进行编码仿真。特别是当开发者心里没有电路但期望通过行为建模让综合器生成某种行为的电路，这就已经偏离“描述电路”的本质了。对于代码来说，多尝试总是没错的，尽量把自己脑海中想到的东西写下来验证，电脑永远是对的。</p>
<h3 id="遗留问题："><a href="#遗留问题：" class="headerlink" title="遗留问题："></a>遗留问题：</h3><blockquote>
<p>​	所以，直到大家掌握“描述电路”的思维而不被行为建模误导之前，我们强烈建议初学者远离行为建模方式，仅通过数据流建模和结构化建模方式直接描述电路。例如，上文关于if和always的说法从某种程度上来说是正确的，但下面的问题可以帮助大家测试自己是否已经掌握了Verilog的本质：</p>
<ul>
<li>在硬件描述语言中，“执行”的精确含义是什么？</li>
<li>是谁在执行Verilog的语句？ 是电路，综合器，还是其它的？</li>
<li>if的条件满足，就不执行else后的语句，这里的“不执行”又是什么意思？ 和描述电路有什么联系？</li>
<li>有“并发执行”，又有“顺序执行”，还有“任何一个变量发生变化就立即执行”，以及“在任何情况下都执行”，它们都是如何在设计出来的电路中体现的？</li>
</ul>
<p>​	如果你无法对这些问题作出明确的回答，我们强烈建议你不要使用行为建模方式。如果你真的想弄懂它们，你需要阅读 <a target="_blank" rel="noopener" href="https://nju-projectn.github.io/dlco-lecture-note/exp/inst.eecs.berkeley.edu/~cs150/fa06/Labs/verilog-ieee.pdf">Verilog标准手册</a> 。</p>
</blockquote>
<p>​		标准手册太长了，留着慢慢读。</p>
<h2 id="实验二-译码器和编码器"><a href="#实验二-译码器和编码器" class="headerlink" title="实验二 译码器和编码器"></a>实验二 译码器和编码器</h2><h3 id="任务：实现一个8-3优先编码器并在七段数码管上显示"><a href="#任务：实现一个8-3优先编码器并在七段数码管上显示" class="headerlink" title="任务：实现一个8-3优先编码器并在七段数码管上显示"></a>任务：<strong>实现一个8-3优先编码器并在七段数码管上显示</strong></h3><blockquote>
<p><strong>功能描述</strong></p>
<p>查找8-3优先编码器相关原理和实现方法，实现一个8-3编码器，完成8-3编码器的设计、功能仿真和硬件实现。</p>
<p>输入一个8位二进制数，对此8位二进制数进行高位优先编码成一个3位二进制值，并根据是否有输入增加一位输入指示位，即8个输入全0时指示位为0，有任何一个输入为1时指示位为1。编码器的使能端可选实现。将此编码结果及指示位以二进制形式显示在四个发光二极管LED上。再将此结果跟据七段数码管的显示进行译码，将二进制的优先编码结果以十进制的形式显示在数码管上。</p>
<p><strong>输入输出建议</strong></p>
<p>输入可以使用拨动开关SW7-SW0。使能端可以用SW8。输出为LED2-0，输出指示可以是LED4，数码管输出为HEX0。</p>
<p>例：我们从SW7—SW0输入00001110，因为我们设计的是一个高位优先的优先编码器，从左（高位）开始，第一位为1的是第3号位，那么优先编码器的编码二进制结果就为011，将这个值显示在发光二极管上，并且指示位也同时置为1。再对这个数值跟据七段数码管的显示进行译码，此时应显示为 <code>3</code> ，用HEX0显示，所以HEX0[6:0]应该译码为0110000（注意高低位顺序），那么在七段数码管上就会显示 <code>3</code> 这个字符。</p>
</blockquote>
<p>​	首先我们先在<code>vsrc</code>中新建文件<code>bcd7seg.v</code>实现七段数码管编码的模块。该模块在网上已经有很多实现方式了，这里需要注意一点，我们在<code>nvboard/board/N4</code>中能找到LED数码管每个管的名称，在组合显示数字时多尝试查看显示是否正确。接着实现顶层模块<code>top.v</code>，代码及注释如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">module top(x, en, y, f, led);</span><br><span class="line">	input [7:0] x;	//输入码</span><br><span class="line">	input en;	// 使能端</span><br><span class="line">	output reg [6:0] led; // 灯，数码管的引脚</span><br><span class="line">	output reg f;					// 输入指示位</span><br><span class="line">	output reg [2:0] y;		// 输出编码</span><br><span class="line">	integer i;</span><br><span class="line">	</span><br><span class="line">	// 实例化七段数码管编码模块</span><br><span class="line">	bcd7seg seg(</span><br><span class="line">		.b(&#123;1&#x27;b0, y&#125;), //接入引脚</span><br><span class="line">		.h(led)</span><br><span class="line">	);</span><br><span class="line">	</span><br><span class="line">	// 逻辑</span><br><span class="line">	always @(x or en) begin</span><br><span class="line">		f = 0;</span><br><span class="line">		if (en) begin</span><br><span class="line">			y = 0;</span><br><span class="line">			for(i = 0; i &lt;= 7; i = i + 1)</span><br><span class="line">				if(x[i] == 1) begin </span><br><span class="line">					y = i[2:0];	// 把十进制i转化为3位二进制数存入y中</span><br><span class="line">					f = 1&#x27;b1;</span><br><span class="line">				end</span><br><span class="line">			end</span><br><span class="line">		else y = 0;</span><br><span class="line">	end</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	<code>nvboard</code>的引脚接线和<code>Makefile</code>参照上一个实验即可。</p>
<p>​	最终效果如下图所示，<code>LED4</code>是输入指示位，<code>SW8</code>是使能端，当使能端为1时允许输出，输入端为<code>00010100</code>，由于是优先编码，最高位4对应的LED2被点亮，数码管显示4。</p>
<p><img src="/../images/dlco-nju/%E6%88%AA%E5%B1%8F2023-08-22%2016.41.08-2693675-2693707.png" alt="截屏2023-08-22 16.41.08"></p>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>​	在实例化时发现引脚数目不对，8-3优先编码器的输出端为3位而数码管的输入端为4位，用<code>&#123;&#125;</code>将输出扩展一位达到效果。</p>
<p>​	在数字电路设计与计算机组成一书中有提到电路中存在高阻态<code>Z</code>和不定值<code>X</code>，这类状态在<code>Verilog</code>中用<code>casez</code>和<code>casex</code>解决。首先要明确的是’?’代表的不是don’t care，而是’z’。再有就是case&#x2F;casez&#x2F;casex其实都是可综合的，这一点也要记住。</p>
<p> 区分：</p>
<ul>
<li><p>case语句的表达式的值有4中情况：0、1、z、x。4种是不同的，故表达式要严格的相等才可以操作分支语句。</p>
</li>
<li><p>casez语句中的表达式情况有三种：0、1、x。不用关心z，z可以和任何数值相等，即z &#x3D;0.z&#x3D; 1,z&#x3D;x;</p>
</li>
<li><p>casex语句的表达式情况有二种：0、1.不用关心x和z。即x&#x3D;z&#x3D;0,x&#x3D;z&#x3D;1<img src="/../images/dlco-nju/%E6%88%AA%E5%B1%8F2023-08-22%2017.02.57-2694983.png" alt="截屏2023-08-22 17.02.57"></p>
</li>
</ul>
<p>​		<code>casez </code>用<code>?</code>表示无关项；<code>casex</code>用<code>x</code>表示无关值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/21/%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不舍昼夜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="master haodong">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/21/%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/" class="post-title-link" itemprop="url">搭建verilator仿真环境</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-21 13:21:14 / 修改时间：17:04:57" itemprop="dateCreated datePublished" datetime="2023-08-21T13:21:14+08:00">2023-08-21</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="搭建verilator仿真环境"><a href="#搭建verilator仿真环境" class="headerlink" title="搭建verilator仿真环境"></a>搭建verilator仿真环境</h1><blockquote>
<p>verilator是一款开源的verilog仿真工具, 在”一生一芯”项目中, 你将会使用它来进行RTL功能仿真, 从而验证你编写的RTL代码.</p>
<p>框架代码默认提供了一个<code>npc</code>目录, 这里的<code>npc</code>是<code>New Processor Core</code>的含义, 将来大家就会在这个目录下设计自己的处理器. 不过为了设置一个环境变量<code>NPC_HOME</code>, 你需要运行如下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ysyx-workbench</span><br><span class="line">bash init.sh npc</span><br></pre></td></tr></table></figure>

<p>这个环境变量会在将来使用. <code>npc</code>目录下有一些简单的文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ysyx-workbench/npc</span><br><span class="line">├── csrc</span><br><span class="line">│   └── main.cpp</span><br><span class="line">├── Makefile</span><br><span class="line">└── vsrc</span><br><span class="line">    └── example.v</span><br></pre></td></tr></table></figure>

<p>目前这三个文件几乎都是空文件, 在这一小节中, 我们将会引导大家搭建verilator仿真环境, 并编写两个简单的数字电路模块来进行仿真.</p>
</blockquote>
<h2 id="任务：认识verilator"><a href="#任务：认识verilator" class="headerlink" title="任务：认识verilator"></a>任务：认识verilator</h2><blockquote>
<p>你很可能是第一次听说过verilator这个工具, 这是很正常的. 然后你就会想进一步了解verilator的各种信息, 这也是很正常的. 但如果你的第一反应是去问人, 这就不恰当了. 事实上, verilator这个工具在仿真领域已经非常有名, 以至于你可以很容易在互联网上搜索到它的相关信息. 你需要通过STFW找到它的官方网站, 然后阅读一下相关的介绍.</p>
</blockquote>
<p>​	verilator是一个用作仿真电路的软件，将Verilog或者SystemVerilog文件转换为c或者c++文件，然后可以通过自己编辑的testbench测试用例观察电路是否正确。</p>
<h2 id="任务：安装verilator"><a href="#任务：安装verilator" class="headerlink" title="任务：安装verilator"></a>任务：安装verilator</h2><blockquote>
<p>在官网中找到安装verilator的步骤, 然后按照从git安装的相应步骤进行操作. 我们之所以不采用<code>apt-get</code>安装, 是因为其版本较老. 此外, 为了统一版本, 你需要通过git安装<code>5.008</code>的版本. 为此, 你还需要进行一些简单的git操作, 如果你对此感到生疏, 你可能需要寻找一些git教程来学习. 另外, 你最好在<code>ysyx-workbench/</code>之外的目录进行这一操作, 否则git将会追踪到verilator的源代码, 从而占用不必要的磁盘空间.</p>
<p>安装成功后, 运行以下命令来检查安装是否成功，以及版本是否正确</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verilator --version</span><br></pre></td></tr></table></figure>
</blockquote>
<p>​	找到verilator官网的<a target="_blank" rel="noopener" href="https://verilator.org/guide/latest/install.html">install部分</a>，跟着官网步骤一步一步来就可以了，注意切换版本时使用git checkout的地方。</p>
<h2 id="任务：运行示例"><a href="#任务：运行示例" class="headerlink" title="任务：运行示例"></a>任务：运行示例</h2><blockquote>
<p>verilator手册中包含一个C++的示例, 你需要在手册中找到这个示例, 然后按照示例的步骤进行操作.</p>
</blockquote>
<p>​	也是照着<a target="_blank" rel="noopener" href="https://verilator.org/guide/latest/example_cc.html#example-c-execution">官网的步骤</a>，注意：verilog代码文件名必须与模块名一致，如our.v的模块名必须命名<code>module our</code>。</p>
<p><img src="/../images/%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/%E6%88%AA%E5%B1%8F2023-08-21%2013.47.39-2596869.png" alt="截屏2023-08-21 13.47.39"></p>
<h2 id="示例：双控开关"><a href="#示例：双控开关" class="headerlink" title="示例：双控开关"></a>示例：双控开关</h2><blockquote>
<p>手册中的示例非常简单, 甚至算不上是一个真正的电路模块. 接下来我们编写一个真正的电路模块, 双控开关, 来进行测试. 编写如下的verilog代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module top(</span><br><span class="line">  input a,</span><br><span class="line">  input b,</span><br><span class="line">  output f</span><br><span class="line">);</span><br><span class="line">  assign f = a ^ b;</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<p>双控开关的一个应用是通过两个开关(<code>a</code>和<code>b</code>)联合控制同一盏灯的亮灭(<code>f</code>). 和手册中的示例不同, 这个模块有输入输出端口. 为了驱动输入端口, 并从输出端口获得结果, 我们需要对C++文件中的<code>while</code>循环进行修改:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 以下为伪代码</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">while (???) &#123;</span><br><span class="line">  int a = rand() &amp; 1;</span><br><span class="line">  int b = rand() &amp; 1;</span><br><span class="line">  top-&gt;a = a;</span><br><span class="line">  top-&gt;b = b;</span><br><span class="line">  top-&gt;eval();</span><br><span class="line">  printf(&quot;a = %d, b = %d, f = %d\n&quot;, a, b, top-&gt;f);</span><br><span class="line">  assert(top-&gt;f == (a ^ b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一次循环中, 代码将会随机生成两个1比特信号, 用来驱动两个输入端口, 然后通过<code>eval()</code>函数更新电路的状态, 这样我们就可以读取输出端口的值并打印. 为了自动检查结果是否正确, 我们通过<code>assert()</code>语句对输出结果进行检查.</p>
</blockquote>
<h2 id="任务：对双控开关模块进行仿真"><a href="#任务：对双控开关模块进行仿真" class="headerlink" title="任务：对双控开关模块进行仿真"></a>任务：对双控开关模块进行仿真</h2><blockquote>
<p>尝试在verilator中对双控开关模块进行仿真. 由于顶层模块名与手册中的示例有所不同, 你还需要对C++文件进行一些相应的修改. 此外, 这个项目没有指示仿真结束的语句, 为了退出仿真, 你需要键入<code>Ctrl+C</code>.</p>
</blockquote>
<p>​	verilog代码不做更改，但需要将它存放在<code>top.v</code>中，接着编辑C++文件，观察<strong>任务：运行示例</strong>中的C++代码。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mkdir test_our</span><br><span class="line">cd test_our</span><br><span class="line"></span><br><span class="line">cat &gt;our.v &lt;&lt;&#x27;EOF&#x27;</span><br><span class="line">  module our;</span><br><span class="line">     initial begin $display(&quot;Hello World&quot;); $finish; end</span><br><span class="line">  endmodule</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &gt;sim_main.cpp &lt;&lt;&#x27;EOF&#x27;</span><br><span class="line">  #include &quot;Vour.h&quot;</span><br><span class="line">  #include &quot;verilated.h&quot;</span><br><span class="line">  int main(int argc, char** argv) &#123;</span><br><span class="line">      VerilatedContext* contextp = new VerilatedContext;</span><br><span class="line">      contextp-&gt;commandArgs(argc, argv);</span><br><span class="line">      Vour* top = new Vour&#123;contextp&#125;;</span><br><span class="line">      while (!contextp-&gt;gotFinish()) &#123; top-&gt;eval(); &#125;</span><br><span class="line">      delete top;</span><br><span class="line">      delete contextp;</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</blockquote>
<p>​	<code>#include &quot;Vour.h&quot;</code>和<code>#include &quot;verilated.h&quot;</code> 第一个头文件是verilator将our.v转换为的c++头文件，这样我们可以在C++文件中构建一个our模块的实例<code>Vour* top = new Vour&#123;contextp&#125;;</code> <code>top-&gt;eval();</code>用来更新模拟状态。</p>
<p>​	<strong>以下是个人的理解！！不一定对！！</strong></p>
<ul>
<li><code>contextp</code>是一个指向<code>VerilatedContext</code>(Verilated 上下文)的指针 。<code>contextp-&gt;commandArgs(argc, argv);</code>将verilator上下文与命令行参数联系在一起。<code>Vour* top = new Vour&#123;contextp&#125;;</code> 将实例与上下文联系在一起。<code>contextp-&gt;gotFinish()</code>是用来判断verilator是否接收到终止指令。</li>
</ul>
<p>​	现在我们编写双控开关的C++文件，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Vtop.h&quot;</span><br><span class="line">#include &quot;verilated.h&quot;</span><br><span class="line">int main(int argc, char ** argv) &#123;</span><br><span class="line">	VerilatedContext* contextp = new VerilatedContext;</span><br><span class="line">	contextp-&gt;commandArgs(argc, argv);</span><br><span class="line">	Vtop* top = new Vtop&#123;contextp&#125;;</span><br><span class="line">	while (!contextp-&gt;gotFinish()) &#123;</span><br><span class="line">		int a = rand() &amp; 1;</span><br><span class="line">		int b = rand() &amp; 1;</span><br><span class="line">		top-&gt;a = a;</span><br><span class="line">		top-&gt;b = b;</span><br><span class="line">		top-&gt;eval();</span><br><span class="line">		printf(&quot;a = %d, b = %d, f = %d\n&quot;, a, b, top-&gt;f);</span><br><span class="line">		assert(top-&gt;f == (a ^ b));</span><br><span class="line">	&#125;</span><br><span class="line">	delete top;</span><br><span class="line">	delete contextp;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="任务：理解RTL仿真的行为"><a href="#任务：理解RTL仿真的行为" class="headerlink" title="任务：理解RTL仿真的行为"></a>任务：理解RTL仿真的行为</h2><blockquote>
<p>阅读verilator编译出的C++代码, 然后结合verilog代码, 尝试理解仿真器进行仿真的时候都发生了什么。</p>
</blockquote>
<p>​	将verilog的模块作为一个类实现。并且结合C++testbench文件实现了仿真功能。</p>
<h2 id="打印并查看波形"><a href="#打印并查看波形" class="headerlink" title="打印并查看波形"></a>打印并查看波形</h2><blockquote>
<p>查看波形文件是RTL调试的常用手段之一. verilator支持波形的生成, 你可以通过开源的波形查看工具GTKWave来查看波形.</p>
</blockquote>
<h2 id="任务：生成波形并查看"><a href="#任务：生成波形并查看" class="headerlink" title="任务：生成波形并查看"></a>任务：生成波形并查看</h2><blockquote>
<p>verilator手册中已经介绍了波形生成的方法, 你需要阅读手册找到相关内容, 然后按照手册中的步骤生成波形文件, 并通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install gtkwave</span><br></pre></td></tr></table></figure>

<p>安装GTKWave来查看波形.</p>
</blockquote>
<p>​	下载手册后用<code>ctrl+f</code>搜索<code>gtkwave</code>找到<code>Install GTKWave</code>，跟着步骤一步一步来就装好了。装好之后怎么用呢？提示说verilator中有答案，但是我们在手册里面没有搜到有关教程。回到代码里看一看，我们知道一般代码包里都会有example，打开example发现有如下文件。</p>
<p><img src="/../images/%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/%E6%88%AA%E5%B1%8F2023-08-21%2014.44.20-2600269.png" alt="截屏2023-08-21 14.44.20"></p>
<p>​	<del>之前有说-c是C++文件-SC是systemC文件，我们用的是Makefile，tracing后缀用来追踪波形，那就打开<code>make_tracing_sc</code>文件看看Makefile写了些什么。(笔者好像是在网上搜索了一下博客发现的，有点忘记了)。</del></p>
<p>​	这部分是在南京大学数字逻辑与计算机组成课程实验里找到答案的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Make waveforms</span><br><span class="line">VERILATOR_FLAGS += --trace</span><br></pre></td></tr></table></figure>

<p>​	现在我们知道要得到波形文件需要添加<code>--trace</code>，由于波形文件一般会占用较多的磁盘空间, 长时间生成波形可能会导致磁盘空间耗尽, 从而导致系统崩溃。所以适当修改testbench。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &quot;Vtop.h&quot;</span><br><span class="line">#include &quot;verilated.h&quot;</span><br><span class="line">+++</span><br><span class="line">#include &quot;verilated_vcd_c.h&quot;</span><br><span class="line">+++</span><br><span class="line">int main(int argc, char** argv, char** env) &#123;</span><br><span class="line">	VerilatedContext* contextp = new VerilatedContext;</span><br><span class="line">	contextp-&gt;commandArgs(argc, argv);</span><br><span class="line">	Vtop* top = new Vtop&#123;contextp&#125;;</span><br><span class="line"></span><br><span class="line">+++</span><br><span class="line">	VerilatedVcdC* tfp = new VerilatedVcdC; // initialize VDC pointer</span><br><span class="line">	contextp-&gt;traceEverOn(true); // turn on the tracing mode</span><br><span class="line">	top-&gt;trace(tfp, 0);</span><br><span class="line">	tfp-&gt;open(&quot;wave.vcd&quot;); // set the output file wave.vcd</span><br><span class="line">+++</span><br><span class="line"></span><br><span class="line">	// while(!contextp-&gt;gotFinish()) &#123;</span><br><span class="line">	for(int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">		int a = rand() &amp; 1;</span><br><span class="line">		int b = rand() &amp; 1;</span><br><span class="line">		top-&gt;a = a;</span><br><span class="line">		top-&gt;b = b;</span><br><span class="line">		top-&gt;eval();</span><br><span class="line">		printf(&quot;a = %d, b = %d, f= %d\n&quot;, a, b , top-&gt;f);</span><br><span class="line">+++</span><br><span class="line">		tfp-&gt;dump(contextp-&gt;time()); // dump wave</span><br><span class="line">		contextp-&gt;timeInc(1); // push simulate time                      +++                   </span><br><span class="line">		assert(top-&gt;f == (a ^ b));</span><br><span class="line">	&#125;</span><br><span class="line">	delete top;</span><br><span class="line">	tfp-&gt;close();</span><br><span class="line">	delete contextp;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	大概是这样的写法，波形文件如下图所示：符合 <code>f = a ^ b </code></p>
<p><img src="/../images/%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/%E6%88%AA%E5%B1%8F2023-08-21%2015.11.15-2601879-2601886-2601889-2601914.png" alt="截屏2023-08-21 15.11.15"></p>
<h2 id="任务：一键仿真"><a href="#任务：一键仿真" class="headerlink" title="任务：一键仿真"></a>任务：一键仿真</h2><blockquote>
<p>反复键入编译运行的命令是很不方便的, 尝试为<code>npc/Makefile</code>编写规则<code>sim</code>, 实现一键仿真, 如键入<code>make sim</code>即可进行上述仿真.</p>
</blockquote>
<p>​	这部分是关于Makefile的学习，推荐看<a target="_blank" rel="noopener" href="https://www.itsembedded.com/dhd/vivado_sim_3/">itsembedded的教程</a>进行学习。笔者将自己的简易实现放在这里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">all:</span><br><span class="line">	@echo &quot;Write this Makefile by your self.&quot;</span><br><span class="line">sim:</span><br><span class="line">	$(call git_commit, &quot;sim RTL&quot;) # DO NOT REMOVE THIS LINE!!!</span><br><span class="line">	@echo &quot;Write this Makefile by your self.&quot;</span><br><span class="line">	verilator -Wall csrc/main.cpp vsrc/example.v --cc --trace --exe --build</span><br><span class="line">include ../Makefile</span><br></pre></td></tr></table></figure>

<h2 id="接入NVBOARD"><a href="#接入NVBOARD" class="headerlink" title="接入NVBOARD"></a>接入NVBOARD</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/NJU-ProjectN/nvboard.git">NVBoard</a>(NJU Virtual Board)是南京大学开发的, 用于教学的虚拟FPGA板卡项目, 可以在RTL仿真环境中提供一个虚拟板卡的界面, 支持拨码开关, LED灯, VGA显示等功能, 在速度要求不高的场景下可完全替代真实的FPGA板卡(毕竟不是每人身边都有一块FPGA). 通过以下命令获取NVBoard的代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ysyx-workbench</span><br><span class="line">bash init.sh nvboard</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="任务：运行NVBoard示例"><a href="#任务：运行NVBoard示例" class="headerlink" title="任务：运行NVBoard示例"></a>任务：运行NVBoard示例</h2><blockquote>
<p>阅读NVBoard项目的介绍, 尝试运行NVBoard项目中提供的示例.</p>
</blockquote>
<p>​	浏览器可以直接搜到nvboard的github，阅读readme，并运行example里的实例</p>
<h2 id="任务：在NVBoard上实现双控开关"><a href="#任务：在NVBoard上实现双控开关" class="headerlink" title="任务：在NVBoard上实现双控开关"></a>任务：在NVBoard上实现双控开关</h2><blockquote>
<p>阅读NVBoard项目的说明, 然后仿照该示例下的C++文件和Makefile, 修改你的C++文件, 为双控开关的输入输出分配引脚, 并修改<code>npc/Makefile</code>使其接入NVBoard.</p>
</blockquote>
<p>​	双控开关的verilog 文件不需要更改，仿照<code>NVboard/example</code>的testbench文件修改C++文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;nvboard.h&gt;</span><br><span class="line">#include &quot;Vtop.h&quot;</span><br><span class="line">static TOP_NAME dut;</span><br><span class="line">void nvboard_bind_all_pins(Vtop* top);</span><br><span class="line">int main() &#123;</span><br><span class="line">	nvboard_bind_all_pins(&amp;dut);</span><br><span class="line">	nvboard_init();</span><br><span class="line">	while(1) &#123;</span><br><span class="line">		dut.eval();</span><br><span class="line">		nvboard_update();</span><br><span class="line">	&#125;</span><br><span class="line">	nvboard_quit();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	TOP_NAME 实例化一个top模块dut，<code>nvboard_bind_all_pins(Vtop* top);</code>将模块上的引脚按照<code>constr/top.nxdc</code>中描述的方式连接。<code>nvboard_init();</code>初始化nvboard，通过<code>while(1)</code>循环等待鼠标事件发生。<code>dut.eval() nvboard_update();</code>用于更新模块和nvboard。<code>nvboard_quit();</code>退出nvboard。</p>
<p>​	NVBoard的引脚名字在<code>nvboard/board/N4</code>中。top.nxdc文件中给出连接方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">top=top</span><br><span class="line"></span><br><span class="line">a SW0</span><br><span class="line">b SW1</span><br><span class="line">f LD0</span><br></pre></td></tr></table></figure>

<p>​	top &#x3D; top_modulename, 顶层模块名，<code>a SW0</code>表示a 连接到SW0上。makefile文件仿照nvboard示例即可。 效果如下：</p>
<p><img src="/../images/%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/%E6%88%AA%E5%B1%8F2023-08-21%2016.47.47-2607672.png" alt="截屏2023-08-21 16.47.47"></p>
<h2 id="示例：流水灯"><a href="#示例：流水灯" class="headerlink" title="示例：流水灯"></a>示例：流水灯</h2><h2 id="任务：将流水灯接入NVBoard"><a href="#任务：将流水灯接入NVBoard" class="headerlink" title="任务：将流水灯接入NVBoard"></a>任务：将流水灯接入NVBoard</h2><blockquote>
<p>编写流水灯模块, 然后接入NVBoard并分配引脚. 如果你的实现正确, 你将看到灯从右端往左端依次亮起并熄灭.</p>
</blockquote>
<p>​	理解了如何接入NVBoard后，这个任务非常的简单。Makefile保持不变，要注意的地方就是C++文件和nxdc文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;nvboard.h&gt;</span><br><span class="line">#include &quot;Vtop.h&quot;</span><br><span class="line"></span><br><span class="line">static TOP_NAME dut;</span><br><span class="line"></span><br><span class="line">void nvboard_bind_all_pins(Vtop* top);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void single_cycle() &#123;</span><br><span class="line">	dut.clk = 0; dut.eval();</span><br><span class="line">	dut.clk = 1; dut.eval();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void reset(int n) &#123;</span><br><span class="line">	dut.rst = 1;</span><br><span class="line">	while(n-- &gt; 0) single_cycle();</span><br><span class="line">	dut.rst = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	nvboard_bind_all_pins(&amp;dut);</span><br><span class="line">	nvboard_init();</span><br><span class="line">	reset(10);</span><br><span class="line"></span><br><span class="line">	while(1) &#123;</span><br><span class="line">		nvboard_update();</span><br><span class="line">		single_cycle();</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">top=top</span><br><span class="line"></span><br><span class="line">led (LD15, LD14, LD13, LD12, LD11, LD10, LD9, LD8, LD7, LD6, LD5, LD4, LD3, LD2, LD1, LD0)</span><br><span class="line"></span><br><span class="line">clk PS2_CLK</span><br><span class="line">rst BTNC </span><br></pre></td></tr></table></figure>

<p>​	效果如下，等会一个一个的点亮，但是在连接reset的时候没有找到RST，改到PB_C成功实现reset功能。<img src="/../images/%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/%E6%88%AA%E5%B1%8F2023-08-21%2016.37.47-2607075.png" alt="截屏2023-08-21 16.37.47"></p>
<h2 id="任务：理解RTL仿真的行为-2"><a href="#任务：理解RTL仿真的行为-2" class="headerlink" title="任务：理解RTL仿真的行为(2)"></a>任务：理解RTL仿真的行为(2)</h2><blockquote>
<p>阅读verilator编译出的C++代码, 然后结合verilog代码, 尝试理解仿真器是如何对时序逻辑电路进行仿真的.</p>
</blockquote>
<p>​	对时序逻辑电路的仿真主要是要维护一个时钟，在时钟上沿改变电路的状态。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>​	搭建verilator仿真环境这一章耗费了笔者大约一周的时间，掌握一个新的工具困难在于对未知的恐惧，特别是在学习verilator和nvboard的过程中，由于网络上只有很少的中文博客，导致STFW无法很好的解决问题，只能通过RTFM和RTFSC来学习verilator如何使用。幸运的是几乎所有的README都写的详细并且附带示例，读者只需要在阅读完之后加以模仿，就可以完成讲义里的任务，RTFM的好处在于可以更全面的了解整个程序是如何工作的，一定要动手写代码并运行，观察报错信息并改正它。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/17/Itsembedded/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不舍昼夜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="master haodong">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/17/Itsembedded/" class="post-title-link" itemprop="url">Itsembedded</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-17 13:25:10" itemprop="dateCreated datePublished" datetime="2023-08-17T13:25:10+08:00">2023-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-18 10:16:08" itemprop="dateModified" datetime="2023-08-18T10:16:08+08:00">2023-08-18</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Verilator教程"><a href="#Verilator教程" class="headerlink" title="Verilator教程"></a>Verilator教程</h1><p>详情见<a target="_blank" rel="noopener" href="https://itsembedded.com/dhd/verilator_1/">itsembedded.com</a></p>
<h2 id="Verilator-Pt-1"><a href="#Verilator-Pt-1" class="headerlink" title="Verilator Pt.1"></a>Verilator Pt.1</h2><p>在开始Pt.1之前，请先自学数字电路并且具备一些c&#x2F;c++基础</p>
<ol>
<li><p>在GitHub上下载源码，切换到分支pt1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/n-kremeris/verilator_basics</span><br><span class="line">git checkout verilator_pt1</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了检测verilator是如何工作的，我们需要一种 DUT (device under test)，观察目录下的alu.sv文件。</p>
<ol>
<li>开始定义了一个枚举类声明operation_t，包含add, sub, nop操作。</li>
<li>定义alu模块，包含6个输入和2个输出。</li>
<li>在always语法块中，左边的变量需要用logic或者register</li>
<li>当 clk，rst中任意一个发生改变时，对输入进行更改。</li>
<li>计算结果，用case判读需要进行的操作</li>
<li>输出结果。</li>
</ol>
</li>
<li><p>Verilator 通过c++进行测试，但是无法将SystemVerilog ALU文件加载到C++，testbench中，因此我们要先通过verilator把systemVerilgo ALU 转换为C++文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verilator --cc alu.sv</span><br></pre></td></tr></table></figure>

<p><code>--cc</code>告诉verilator转换为c++，<code>--sc</code>则转换为c。转换后的结果存放在<code>obj_dir</code>中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l obj_dir/</span><br><span class="line">Valu___024unit.cpp  Valu___024unit__Slow.cpp  Valu.cpp  Valu.mk</span><br><span class="line">Valu__Syms.cpp  Valu__ver.d Valu___024unit.h    Valu_classes.mk</span><br><span class="line">Valu.h    Valu__Slow.cpp  Valu__Syms.h    Valu__verFiles.dat</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>.mk</code>文件就被<code>Make</code>命令使用来构造一个模拟可执行文件 。<code>.h</code>和<code>.cpp</code>文件包含执行源码。</p>
<blockquote>
<p>The two files we’re most interested right now are <code>Valu.h</code> and <code>Valu___024unit.h</code>:</p>
<ul>
<li><code>Valu.h</code> - This is the primary design header which  contains the converted “ALU” class definition - this is what we will  “instantiate” in our C++ testbench as the DUT.</li>
<li><code>Valu___024unit.h</code> - This is an internal header for the “ALU” class, and it contains our <code>operation_t</code> type definition.</li>
</ul>
</blockquote>
</li>
<li><p>设计一个c++测试文件，下载的目录里面有一个叫<code>tb_alu.cpp</code>的文件，这就是我们的测试文件。打开并观察它。</p>
<ol>
<li><p>包含一些头文件，<code>&lt;verilated.h&gt;</code>和<code>&lt;verilated_vcd_c.h&gt;</code>有我们需要用到的verilator功能。<code>Valu.h</code>包含了ALU模组的类<code>Valu___024unit.h</code>包含了自定义的声明。</p>
</li>
<li><p><code>sim_time</code>表示模拟时间</p>
</li>
<li><p><code>Valu * dut = new Valu</code>声明了一个ALU模组实例。创建<code>m_trace</code>用于追踪<code>dut</code>,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char** argv, char** env) &#123;</span><br><span class="line">    Valu *dut = new Valu;</span><br><span class="line"></span><br><span class="line">    Verilated::traceEverOn(true);</span><br><span class="line">    VerilatedVcdC *m_trace = new VerilatedVcdC;</span><br><span class="line">    dut-&gt;trace(m_trace, 5);</span><br><span class="line">    m_trace-&gt;open(&quot;waveform.vcd&quot;);</span><br><span class="line"></span><br><span class="line">    /* &lt;...&gt; */</span><br><span class="line"></span><br><span class="line">    m_trace-&gt;close();</span><br><span class="line">    delete dut;</span><br><span class="line">    exit(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>这段代码用于更新模拟时间，<code>dut-&gt;eval();</code>评估所有信号，<code>m_trace-&gt;dump(sim_time);</code>将追踪的信号写入波形转储文件(waveform dump file)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while (sim_time &lt; MAX_SIM_TIME) &#123;</span><br><span class="line">    dut-&gt;clk ^= 1;</span><br><span class="line">    dut-&gt;eval();</span><br><span class="line">    m_trace-&gt;dump(sim_time);</span><br><span class="line">    sim_time++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>构建可执行模拟文件</p>
<ol>
<li><p>再次运行verilator产生包含c++测试文件的<code>.mk</code>文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verilator -Wall --trace -cc alu.sv --exe tb_alu.cpp</span><br></pre></td></tr></table></figure>

<ul>
<li><code>--trace</code> 打开波形追踪</li>
</ul>
</li>
<li><p>构建可执行文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -C obj_dir -f Valu.mk Valu</span><br></pre></td></tr></table></figure>

<p><code>-C obj_dir</code>告诉<code>make</code>在<code>obj_dir</code>目录下工作。<code>-f Valu.mk</code>是makfie文件，Valu可执行文件的名字。构造完成后在<code>obj_dir</code>中会找到<code>Valu</code>二进制可执行文件。</p>
</li>
<li><p>执行<code>./obj_dir/Valu</code>后会出现<code>waveform.vcd</code>，通过命令<code>gtkwave waveform.vcd</code>观察波形文件</p>
</li>
</ol>
</li>
</ol>
<h2 id="在开始Pt2前先学一点Makefile的知识"><a href="#在开始Pt2前先学一点Makefile的知识" class="headerlink" title="在开始Pt2前先学一点Makefile的知识"></a>在开始Pt2前先学一点Makefile的知识</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target_name : dependency_1 dependency_2 dependency_3</span><br><span class="line">    bash_command_that_generates_the_target &lt;parameters&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>make</code>    &lt;-build the first target that appears in the Makefile</li>
<li><code>make target_name</code>    &lt;- build the target with the name <code>target_name</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: waves</span><br><span class="line">waves : adder_tb_snapshot.wdb</span><br><span class="line">    @echo &quot;### OPENING WAVES ###&quot;</span><br><span class="line">    xsim --gui adder_tb_snapshot.wdb</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.PHONY: wave</code> marks the <code>waves</code> target as not generating any output files.</li>
<li>The part <code>: adder_tb_snapshot.wdb</code> tells waves that this file is a required dependency for this target.</li>
<li>“@” character before <code>echo</code> prevents printout of the actual <code>echo</code> command.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TB_TOP := tb</span><br><span class="line"></span><br><span class="line">.PHONY : waves</span><br><span class="line">waves : $(TB_TOP).wdb</span><br><span class="line">        @echo</span><br><span class="line">        @echo &quot;### OPENING WAVES ###&quot;</span><br><span class="line">        xsim --gui $(TB_TOP)_snapshot.wdb</span><br></pre></td></tr></table></figure>

<ul>
<li>store tb as a variable.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ifeq ($(SOURCES),)</span><br><span class="line">some_target :</span><br><span class="line">    @echo &quot;Print message saying that step was skipped&quot;</span><br><span class="line">else</span><br><span class="line">some_target : $(SOURCES)</span><br><span class="line">    run_build_command $(SOURCES)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<ul>
<li>to check if the corresponding source variable is set with <code>make</code>‘s <code>ifeq</code> command</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    rm -rf *.jou *.log *.pb *.wdb xsim.dir      # This deletes all files generated by Vivado</span><br><span class="line">    rm -rf .*.timestamp                         # This deletes all our timestamps</span><br></pre></td></tr></table></figure>

<ul>
<li>删除文件操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SUB ?= VHDL</span><br><span class="line">ifeq ($(SUB), VHDL)</span><br><span class="line">  $(info Building with VHDL subtractor)</span><br><span class="line">  DEFINES_SV := $(DEFINES_SV) -d SUBTRACTOR_VHDL</span><br><span class="line">else ifeq ($(SUB), SV)</span><br><span class="line">  $(info Building with SYSTEMVERILOG subtractor)</span><br><span class="line">  DEFINES_SV := $(DEFINES_SV) -d SUBTRACTOR_SV</span><br><span class="line">else</span><br><span class="line">  $(info )</span><br><span class="line">  $(info BAD SUBTRACTOR TYPE)</span><br><span class="line">  $(info Available options:)</span><br><span class="line">  $(info make SUB=VHDL &lt;target&gt;)</span><br><span class="line">  $(info make SUB=SV &lt;target&gt;)</span><br><span class="line">  $(error )</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<ul>
<li>第一行将SUB设置为变量，如果没有SUB默认为VHDL，<code>make SUB=SV</code>命令将SUB赋值为SV</li>
</ul>
<h2 id="Verilator-Pt-2"><a href="#Verilator-Pt-2" class="headerlink" title="Verilator Pt.2"></a>Verilator Pt.2</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/15/digital-design-and-computer-architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不舍昼夜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="master haodong">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/15/digital-design-and-computer-architecture/" class="post-title-link" itemprop="url">digital design and computer architecture</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-15 13:41:34" itemprop="dateCreated datePublished" datetime="2023-08-15T13:41:34+08:00">2023-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-22 15:20:12" itemprop="dateModified" datetime="2023-08-22T15:20:12+08:00">2023-08-22</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数字设计和计算机体系结构"><a href="#数字设计和计算机体系结构" class="headerlink" title="数字设计和计算机体系结构"></a>数字设计和计算机体系结构</h1><h2 id="第二章-组合逻辑设计"><a href="#第二章-组合逻辑设计" class="headerlink" title="第二章 组合逻辑设计"></a>第二章 组合逻辑设计</h2><ul>
<li><p>与或范式</p>
</li>
<li><p>或与范式</p>
</li>
<li><p>等式化简，展开一个蕴含式:</p>
<p><img src="/../images/digital-design-and-computer-architecture/%E6%88%AA%E5%B1%8F2023-08-15%2014.27.49-2080877-2089511.png" alt="截屏2023-08-15 14.27.49-2080877-2089511"></p>
</li>
<li><p>原理图</p>
<ul>
<li>两条线交叉地方有个点表示之间有连接</li>
<li>两条线交叉地方没有点表示没有连接</li>
</ul>
</li>
<li><p>用符号<code>X</code>表示不需要考虑的输入</p>
</li>
<li><p>推气泡</p>
<ol>
<li>从电路的输出端开始向输入方向推。</li>
<li>将气泡从最后的输出端向输入端推，可以读出输出<code>(Y)</code>的布尔表达式，而非输出的补<code>(^Y)</code>。</li>
<li>继续向后推，以消除每个门的气泡。如果当前的门有一个输入的气泡，则在前面门的输出加上气泡。如果当前的门不带输入气泡，前面的门也不带输出气泡。</li>
<li>气泡式串联删除的，可以忽略中间门的输出气泡和最右边门的输入气泡。</li>
</ol>
</li>
</ul>
<p><img src="/../images/digital-design-and-computer-architecture/%E6%88%AA%E5%B1%8F2023-08-15%2015.00.08-2082815-2089536-2688523.png" alt="截屏2023-08-15 15.00.08-2082815-2089536"></p>
<ul>
<li><code>X</code>和<code>Z</code>：布尔代数局限于0和1.然而，真实的电路中会出现非法值和浮空现象，分别用<code>X</code>和<code>Z</code>表示。<ul>
<li>一个典型的误解是将浮空或者未被驱动的节点和逻辑0等同。事实上浮空节点可能是0或1或之间的电压。</li>
</ul>
</li>
<li>三态缓冲器：<ul>
<li>三种可能输出：高电平<code>(1)</code>，低电平<code>(0)</code>，浮空<code>(Z)</code><ul>
<li>使能端<code>E</code>，高电平有效，作为一个简单的缓冲器，低电平无效，输出被置为高电阻<code>(Z)</code>。2-41反之。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/../images/digital-design-and-computer-architecture/%E6%88%AA%E5%B1%8F2023-08-15%2015.13.21-2083606-2089571-2688548.png" alt="截屏2023-08-15 15.13.21-2083606-2089571"></p>
<ul>
<li><p>卡诺图：一个图形化的化简布尔表达式方法</p>
<ol>
<li>用最少的圈来圈住全部所有的1；</li>
<li>圈中的所有方格必须都为1；</li>
<li>每个圈必须是矩形，其每边长必须是2的整数次幂（1，2，4）；</li>
<li>每个圈必须尽可能大；</li>
<li>圈可以环绕卡诺图的边界；</li>
<li>如果可以使用更少数量的圈，卡诺图中一个为1的方格可以被多次圈住；</li>
<li>如0果可以用较少和较大的圈覆盖1，这些无关项也可以被圈起来。<br><img src="/../images/digital-design-and-computer-architecture/%E6%88%AA%E5%B1%8F2023-08-15%2015.35.01-2084907-2089594-2688805.png" alt="截屏2023-08-15 15.35.01-2084907-2089594"></li>
</ol>
</li>
<li><p>多路选择器，可用于实现逻辑，真值表中的每一行和多路选择器的一个输入相对应。</p>
</li>
<li><p>时序</p>
<ul>
<li>传输延迟<code>(propagation delay)</code>和最小延迟<code>(contamination delay)</code></li>
<li>关键路径和最短路径</li>
<li>传输延迟是关键路径上每个元件的传输延迟之和</li>
<li>最小延迟是在最短路径上每个元件的最小延迟之和</li>
</ul>
</li>
<li><p>毛刺：<img src="/../images/digital-design-and-computer-architecture/%E6%88%AA%E5%B1%8F2023-08-15%2016.25.58.png" alt="截屏2023-08-15 16.25.58"></p>
<ul>
<li>只要读取输出之前的等待时间和传输延迟一样长，出现毛刺是不会有问题的，这是因为输出最终将稳定在正确的值。</li>
</ul>
</li>
</ul>
<h2 id="第三章-时序逻辑设计"><a href="#第三章-时序逻辑设计" class="headerlink" title="第三章 时序逻辑设计"></a>第三章 时序逻辑设计</h2><ul>
<li>锁存器和触发器<ul>
<li>SR锁存器</li>
<li>D锁存器，电平敏感的</li>
<li>D触发器，边沿触发的</li>
<li>寄存器</li>
<li>带使能端的触发器，<code>EN = 0</code> 时将忽略时钟，保持原来的状态不变。</li>
<li>带复位功能的触发器，<code>RESET = 1</code>，带复位功能的触发器忽略<code>D</code>并且将输出Q复位为0。同步复位的触发器仅仅在时钟上升沿时进行复位，异步复位只需要<code>RESET = 1</code>时就可以复位</li>
<li>同步时序电路<ul>
<li>每一个电路元件是寄存器或组合电路</li>
<li>至少有一个电路元件是寄存器</li>
<li>所有寄存器接收同一个时钟信号</li>
<li>每一个环路至少包含一个寄存器</li>
</ul>
</li>
<li>时序逻辑电路的时序</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/10/learnCTheHardWay/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不舍昼夜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="master haodong">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/10/learnCTheHardWay/" class="post-title-link" itemprop="url">learnCTheHardWay</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-10 16:02:51" itemprop="dateCreated datePublished" datetime="2023-08-10T16:02:51+08:00">2023-08-10</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/10/regularExpression/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不舍昼夜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="master haodong">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/10/regularExpression/" class="post-title-link" itemprop="url">regularExpression</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-10 13:54:58 / 修改时间：15:58:48" itemprop="dateCreated datePublished" datetime="2023-08-10T13:54:58+08:00">2023-08-10</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a><strong>正则表达式</strong></h1><h2 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h2><h2 id="课程-1：简介和字母-ABCs"><a href="#课程-1：简介和字母-ABCs" class="headerlink" title="课程 1：简介和字母 ABCs"></a>课程 1：简介和字母 ABCs</h2><p>​	abc就匹配abc</p>
<h2 id="课程-1½：数字-123s"><a href="#课程-1½：数字-123s" class="headerlink" title="课程 1½：数字 123s"></a>课程 1½：数字 123s</h2><p>​	123就匹配123</p>
<h2 id="课程-2：点-Dot"><a href="#课程-2：点-Dot" class="headerlink" title="课程 2：点 Dot"></a>课程 2：点 Dot</h2><p>​	<code>.</code>	匹配任意字符(包括字母，数字，空格等)</p>
<p>​	匹配点需要加转义字符<code>\</code> ，即<code>\.</code></p>
<h2 id="课程-3：匹配特定字符"><a href="#课程-3：匹配特定字符" class="headerlink" title="课程 3：匹配特定字符"></a>课程 3：匹配特定字符</h2><p>​	<code>[abc]</code>匹配字符串，a或b或c</p>
<h2 id="课程-4：排除特定字符"><a href="#课程-4：排除特定字符" class="headerlink" title="课程 4：排除特定字符"></a>课程 4：排除特定字符</h2><p>​	<code>[^abc]</code> 将匹配除<code>abc</code>外任意单个字符</p>
<h2 id="课程-5：字符范围"><a href="#课程-5：字符范围" class="headerlink" title="课程 5：字符范围"></a>课程 5：字符范围</h2><p>​	字母数字 (alphanumeric) 元字符<code>\w</code> 相当于字符范围 <code>[A-Za-z0-9_]</code></p>
<h2 id="课程-6：匹配重复字符-注意：有的正则表达式实现不支持下文重复语法的某些部分。"><a href="#课程-6：匹配重复字符-注意：有的正则表达式实现不支持下文重复语法的某些部分。" class="headerlink" title="课程 6：匹配重复字符(注意：有的正则表达式实现不支持下文重复语法的某些部分。)"></a>课程 6：匹配重复字符(<em>注意：有的正则表达式实现不支持下文重复语法的某些部分。</em>)</h2><ul>
<li><p>使用花括号表示法指定要匹配多少个字符，<code>a&#123;3&#125;</code>将匹配a字符正好三次，a{1,3}将匹配a字符至少1次，至多3次。</p>
</li>
<li><p>这个量词</u> (quantifier) 可以与任意字符或特殊的元字符一起使用，例如 <strong><code>w&#123;3&#125;</code></strong> (三个 w)、**<code>[wxy]&#123;5&#125;</code>** (五个字符，每个字符可以是 w、x 或 y) 和 <strong><code>.&#123;2,6&#125;</code></strong> (两到六个<strong>任意</strong>字符)。</p>
</li>
<li><p>花括号中的最大重复次数也可以省略：**<code>&#123;n,&#125;</code>** 表示重复至少 n 次，至多无限制。</p>
</li>
</ul>
<h2 id="课程-7：Kleene-操作符"><a href="#课程-7：Kleene-操作符" class="headerlink" title="课程 7：Kleene 操作符"></a>课程 7：Kleene 操作符</h2><ul>
<li><code>\d*</code>来匹配任意数量的数字</li>
<li><code>\d+</code>确保输入的字符串至少有一个数字</li>
<li>这些量词 (quantifiers) 可以与任意字符或特殊的元字符一起使用，例如 <strong><code>a+</code></strong> (一个或多个 a)、**<code>[abc]+</code><strong>(一个或多个字符 a、b 或 c) 和 <strong><code>.\*</code></strong> (零个或多个</strong>任意**字符)。</li>
</ul>
<h2 id="课程-8：可选字符"><a href="#课程-8：可选字符" class="headerlink" title="课程 8：可选字符"></a>课程 8：可选字符</h2><ul>
<li><strong><code>?</code></strong> (问号) 元字符表示<strong>可选性</strong>。这个元字符允许您匹配前面的零个或一个字符或组。</li>
<li>例如，模式 <strong><code>ab?c</code></strong> 将匹配字符串 “abc” 或 “ac”，因为 b 被认为是可选的。</li>
<li>问号是一个特殊字符，您必须使用斜杠 <strong><code>\?</code></strong> 匹配字符串中的普通问号字符。</li>
</ul>
<h2 id="课程-9：空白字符"><a href="#课程-9：空白字符" class="headerlink" title="课程 9：空白字符"></a>课程 9：空白字符</h2><ul>
<li><strong><code>\s</code></strong> 能够匹配上面的<strong>任意</strong>空白符，包括<strong>空格 (␣)<strong>、</strong>制表符 (\t)<strong>、</strong>换行 (\n)</strong> 和<strong>回车 (\r)</strong></li>
</ul>
<h2 id="课程-10：开始与结束"><a href="#课程-10：开始与结束" class="headerlink" title="课程 10：开始与结束"></a>课程 10：开始与结束</h2><ul>
<li><strong><code>^</code> (hat)</strong> 和 <strong><code>$</code> (美元符号)</strong> 来描述一行的开始和结束。</li>
<li>模式 <strong><code>^success</code></strong> 来<strong>只</strong>匹配以单词 “success” 开头的行，而不匹配 “Error: unsuccessful operation”。如果我们把 <code>^</code> 和 <code>$</code> 结合起来，就能实现一个匹配从开头到结尾一整行的模式。</li>
<li>请注意，**<code>^</code>** 和方括号 <strong><code>[^...]</code></strong> 中用于排除字符的 hat 不同，这在读取正则表达式时容易混淆。</li>
</ul>
<h2 id="课程-11：捕获组"><a href="#课程-11：捕获组" class="headerlink" title="课程 11：捕获组"></a>课程 11：捕获组</h2><ul>
<li>正则表达式不仅允许我们匹配文本，还允许我们提取信息以便进一步处理。这是通过定义<strong>字符组 (groups of characters)</strong> 并使用特殊的圆括号 <strong>(</strong> 和 <strong>)</strong> 元字符捕获它们来实现的。一对括号内的任何子模式 (subpattern) 都将被<strong>捕获</strong> (capture) 为一个组 (group)。<img src="/../images/regularExpression/%E6%88%AA%E5%B1%8F2023-08-10%2015.38.16.png" alt="截屏2023-08-10 15.38.16"></li>
</ul>
<h2 id="课程-12：嵌套组"><a href="#课程-12：嵌套组" class="headerlink" title="课程 12：嵌套组"></a>课程 12：嵌套组</h2><ul>
<li>如果每个图像文件的文件名中都有一个连续的图片编号，我们可以通过编写 <strong><code>^(IMG(\d+))\.png$</code></strong> 之类的表达式 (使用嵌套的括号来捕获数字)，使用同一个模式同时提取文件名和图片编号。</li>
<li>在模式中，嵌套组按照从左到右的<em>左括号</em>出现的顺序定义，第一个捕获组是第一个括号里的内容，以此类推。捕获的结果也按照这个顺序排列。</li>
</ul>
<h2 id="课程-13：关于分组的更多内容"><a href="#课程-13：关于分组的更多内容" class="headerlink" title="课程 13：关于分组的更多内容"></a>课程 13：关于分组的更多内容</h2><ul>
<li>所有的量词 (quantifiers) ——包括星号 **<code>\*</code>**、加号 **<code>+</code>**、重复 <strong><code>&#123;m，n&#125;</code></strong> 和问号 <strong><code>?</code></strong> ——都可以在捕获组模式中使用。</li>
<li>例如，如果我们知道一个电话号码可能包含区号，也可能不包含区号，那么正确的模式是测试整个数字组是否存在 **<code>(\d&#123;3&#125;)?</code>**，而不是测试单个字符本身 (这是错误的)。</li>
</ul>
<h2 id="课程-14：条件"><a href="#课程-14：条件" class="headerlink" title="课程 14：条件"></a>课程 14：条件</h2><ul>
<li>使用 <strong><code>|</code> (逻辑或 locigal OR，也就是管道 pipe)</strong> 来表示<strong>可能的不同的字符集</strong>，尤其是在使用组的时候。</li>
</ul>
<h2 id="课程-15：其他元字符"><a href="#课程-15：其他元字符" class="headerlink" title="课程 15：其他元字符"></a>课程 15：其他元字符</h2><ul>
<li>元字符 **<code>\b</code>**，它匹配单词和非单词字符之间的边界。它在捕获整个单词时最有用，例如模式 **<code>\w+\b</code>**。</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/23/missing-semester/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不舍昼夜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="master haodong">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/23/missing-semester/" class="post-title-link" itemprop="url">missing semester 1.the Shell</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-23 14:40:42" itemprop="dateCreated datePublished" datetime="2023-07-23T14:40:42+08:00">2023-07-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-17 17:01:35" itemprop="dateModified" datetime="2023-08-17T17:01:35+08:00">2023-08-17</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="主题-1-The-shell"><a href="#主题-1-The-shell" class="headerlink" title="主题 1: The shell"></a>主题 1: The shell</h1><ol>
<li><code>ls -l</code> 输出第一列字符表示文件类型，其余9个字符表示文件或目录的访问权限，分别对应三个字符一组的<code>rwx</code>，第一个三个字符表示所有者权限，中间三个字符表示所属组权限，后三个表示其他用户权限。<ul>
<li><code>r</code> 读权限</li>
<li><code>w</code> 写权限</li>
<li><code>x</code> 执行权限</li>
<li><code>-</code> 没有权限</li>
</ul>
</li>
<li><code>chmod </code>用来设置用户权限，<code>ugoa</code>，分别表示用户，组，其他，全部，用法为<code>chmod ugoa+rwx file</code>要改谁就写谁。</li>
<li><code>curl</code> is a tool for transferring data from or to a server.</li>
<li><code>grep name file</code>  从文件中匹配名字并返回这一行</li>
</ol>
<h1 id="主题-2-Shell-脚本-bash"><a href="#主题-2-Shell-脚本-bash" class="headerlink" title="主题 2: Shell 脚本(bash)"></a>主题 2: Shell 脚本(bash)</h1><h2 id="第一个shell脚本"><a href="#第一个shell脚本" class="headerlink" title="第一个shell脚本"></a>第一个shell脚本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;Hello World !&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>#!是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行。</li>
<li>echo 命令用于向窗口输出文本</li>
</ul>
<h2 id="Shell变量"><a href="#Shell变量" class="headerlink" title="Shell变量"></a>Shell变量</h2><ul>
<li><p>定义变量：<code>your_name=&quot;runoob.com&quot;</code>(变量名和等号之间不能有空格)</p>
</li>
<li><p>使用变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">your_name=&quot;qinjx&quot;</span><br><span class="line">echo $your_name</span><br><span class="line">echo $&#123;your_name&#125;</span><br></pre></td></tr></table></figure>

<p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界。推荐给所有变量加上花括号，这是个好的编程习惯。</p>
</li>
<li><p>只读变量：使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。<code>readonly variable_name</code></p>
</li>
<li><p>删除变量：<code>unset variable_name</code></p>
</li>
</ul>
<h2 id="Shell字符串"><a href="#Shell字符串" class="headerlink" title="Shell字符串"></a>Shell字符串</h2><ul>
<li><p>单引号：<code>str=&#39;this is a string&#39;</code></p>
</li>
<li><p>双引号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">your_name=&quot;runoob&quot;</span><br><span class="line">str=&quot;Hello, I know you are \&quot;$your_name\&quot;! \n&quot;</span><br><span class="line">echo -e $str</span><br><span class="line">输出：</span><br><span class="line">Hello, I know you are &quot;runoob&quot;! </span><br></pre></td></tr></table></figure>

<p>引号的优点：</p>
<ul>
<li>双引号里可以有变量</li>
<li>双引号里可以出现转义字符</li>
</ul>
</li>
<li><p>获取字符串长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;abcd&quot;</span><br><span class="line">echo $&#123;#string&#125;   # 输出 4</span><br><span class="line"># 变量为字符串时$&#123;#string&#125; 等价于 $&#123;#string[0]&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提取字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;runoob is a great site&quot;</span><br><span class="line">echo $&#123;string:1:4&#125; # 输出 unoo</span><br></pre></td></tr></table></figure>
</li>
<li><p>Shell数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_name=(value0 value1 value2 value3)</span><br></pre></td></tr></table></figure>

<p>读取数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valuen=$&#123;array_name[n]&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <strong>@</strong> 符号可以获取数组中的所有元素，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;array_name[@]&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Shell传递参数"><a href="#Shell传递参数" class="headerlink" title="Shell传递参数"></a>Shell传递参数</h2><ul>
<li><p>脚本内获取参数的格式为：<code>$n</code>，n代表一个数字，1为第一个参数，以此类推</p>
</li>
<li><table>
<thead>
<tr>
<th>参数处理</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$#</td>
<td>传递到脚本的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td>以一个单字符串显示所有向脚本传递的参数。如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。</td>
</tr>
<tr>
<td>$$</td>
<td>脚本运行的当前进程ID号</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td>$@</td>
<td>与$*相同，但是使用时加引号，并在引号中返回每个参数。<br/>如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。</td>
</tr>
<tr>
<td>$-</td>
<td>显示Shell使用的当前选项，与<a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-set.html">set命令</a>功能相同。</td>
</tr>
<tr>
<td>$?</td>
<td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody></table>
<p><code>$*</code> 和 <code>$@</code>区别：</p>
<ul>
<li>相同点：都是引用所有参数。</li>
<li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</li>
</ul>
</li>
</ul>
<h2 id="Shell数组"><a href="#Shell数组" class="headerlink" title="Shell数组"></a>Shell数组</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/10/Lab-system-calls/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不舍昼夜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="master haodong">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/10/Lab-system-calls/" class="post-title-link" itemprop="url">Lab: system calls</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-10 20:42:34" itemprop="dateCreated datePublished" datetime="2023-07-10T20:42:34+08:00">2023-07-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-20 17:08:19" itemprop="dateModified" datetime="2023-07-20T17:08:19+08:00">2023-07-20</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-using-gdb"><a href="#1-using-gdb" class="headerlink" title="1. using gdb"></a>1. using gdb</h1><p>​		1. layout命令展示gdb目前位于代码的什么位置，该命令会将窗口分割</p>
<p>​		2. backtrace 命令简介：  </p>
<p>​		backtrace命令用于打印当前调试环境中所有栈帧信息：<br>​       <code>backtrace [-full] [n]</code>. </p>
<p>​		· n：一个整数值，当为正整数时，表示打印最里层的 n 个栈帧的信息；n 为负整数时，那么表示打印最外层 n 个栈帧的信息；</p>
<p>​		· -full：打印栈帧信息的同时，打印出局部变量的值。  </p>
<h2 id="·-Question-1"><a href="#·-Question-1" class="headerlink" title="· Question 1"></a>· Question 1</h2><pre><code> `Looking at the backtrace output, which function called syscall`  
</code></pre>
<p><img src="/../images/Lab-system-calls/backtrace.png" alt="backtrace"></p>
<pre><code>from the output, we find the trace frame usertrap() at kernel/trap.c :67. Now, follow the trace we open file kernel/trap.c. 
![trap](../images/Lab-system-calls/trap.png)
</code></pre>
<p>At this time we find out that the syscall() is called in funtion usertrap() and this is the answer for the first question.</p>
<h2 id="·-Question-2"><a href="#·-Question-2" class="headerlink" title="· Question 2"></a>· Question 2</h2><pre><code> `What is the value of `p-&gt;trapframe-&gt;a7` and what does that value represent? (Hint: look `user/initcode.S`, the first user program xv6 starts.)`
</code></pre>
<p>​	首先解释gdb命令 p：  </p>
<p>​		命令p是print的缩写，允许自定义输出格式，下表列出具体格式  </p>
<p>​		<img src="/../images/Lab-system-calls/fmt-9052134.png" alt="fmt">  </p>
<p>​       打印 p &#x2F;x *p 后显示 </p>
<p><img src="/../images/Lab-system-calls/p%20:x%20*p-9053504-9053542.png" alt="p :x *p"></p>
<p>​	通过检查pro.h 中 struct proc 结构</p>
<pre><code>struct proc &#123;

  struct spinlock lock;

  // p-&gt;lock must be held when using these:

  enum procstate state;        // Process state

  void *chan;                  // If non-zero, sleeping on chan

  int killed;                  // If non-zero, have been killed

  int xstate;                  // Exit status to be returned to parent&#39;s wait

  int pid;                     // Process ID

  // wait_lock must be held when using this:

  struct proc *parent;         // Parent process

  // these are private to the process, so p-&gt;lock need not be held.

  uint64 kstack;               // Virtual address of kernel stack

  uint64 sz;                   // Size of process memory (bytes)

  pagetable_t pagetable;       // User page table

  struct trapframe *trapframe; // data page for trampoline.S

  struct context context;      // swtch() here to run process

  struct file *ofile[NOFILE];  // Open files

  struct inode *cwd;           // Current directory

  char name[16];               // Process name (debugging)

&#125;;
</code></pre>
<p>​	观察到 trapframe 的地址为0x87f74000 且可以知道我们要找的值 <code>*p-&gt;trapframe-&gt;a7</code> 是在 trapframe中，尝试输入 <code>p /x *p-&gt;trapframe</code> 得到输出.  </p>
<p><img src="/../images/Lab-system-calls/p-%3Etrapframe-9054502-9054503-9054504.png" alt="p-&gt;trapframe"></p>
<p>​	如图所示，<code>*p-&gt;trapframe-&gt;a7 = 0x7</code> 那么这个数字7代表的是什么意思呢？通过对 <code>struct trapframe</code> 的解释，我们大概(<strong>可能有错</strong>)了解到该结构的作用是在user process 将user mode 中的寄存器存储的地方，方便之后重新载入时将存储的值重新加载到寄存器中。接着，跟随文档中的提示，我们打开<code>initcode.S</code>文件：  </p>
<p><img src="/../images/Lab-system-calls/initcodes-9056225-9056228.png" alt="initcodes"></p>
<p>​	既然<code>a7</code>是一个寄存器，代码中将<code>SYS_exec</code> 加载到 <code>a7</code>中去，查阅文档，其中有一句提到：</p>
<blockquote>
<p>​	The kernel uses the number in register a7 in syscall (kernel&#x2F;syscall.c:133) to call the desired system call. The system call table (kernel&#x2F;syscall.c:108) maps SYS_EXEC to sys_exec, which the kernel invokes. As we saw in Chapter 1, exec replaces the memory and registers of the current process with a new program (in this case, &#x2F;init).&#96; </p>
</blockquote>
<p>​	至此，我们知道了<code>a7</code> 中存储的是当前进程想要使用的系统调用(<code>system call</code>) ，继续翻阅代码<code>kernel/syscall.c :108</code></p>
<p><img src="/../images/Lab-system-calls/sycscall-9056869.png" alt="sycscall"></p>
<p>7 表示SYS_exec 系统调用，至此我们终于得到答案，a7中存储的值表示进程想唤醒的系统调用<code>SYS_exec</code>。</p>
<h2 id="·-Question-3"><a href="#·-Question-3" class="headerlink" title="· Question 3"></a>· Question 3</h2><p>​	<code>What was the previous mode that the CPU was in?</code></p>
<p>​	<code>(gdb)p /x $sstatus</code> 得到：</p>
<p>​	<img src="/../images/Lab-system-calls/p%20:x%20$sstatus-9057564.png" alt="p :x $sstatus"></p>
<p>​	阅读文档<code>riscv-privileged-20211203</code>，我们知道 <code>sstatus register keeps track of theprocessor&#39;s current operating state</code> </p>
<p>​	每位表示的信息如下图所示:</p>
<p><img src="/../images/Lab-system-calls/sstatus64-9058263.png" alt="sstatus64"></p>
<p>​	<code>0x200000022</code> 换成二进制表示为<code>0010 0000 0000 0000 0000 0000 0000 0010 0010</code></p>
<p>​	文档指出:</p>
<blockquote>
<p>The SPP bit indicates the privilege level at which a hart was executing before entering supervisor mode.</p>
</blockquote>
<p>​	因此我们知道当前SSP位为 0, <code>SSP is set to 0 if the trap originated from user mode</code></p>
<p>​	至此，我们可以回答<code>Question 3</code>, <code>the previous mode that the CPU was in user mode</code></p>
<h2 id="·-Question-4"><a href="#·-Question-4" class="headerlink" title="· Question 4"></a>· Question 4</h2><p>​	<code>Write down the assembly instruction the kernel is panicing at. Which register corresponds to the varialable </code>num<code>?</code></p>
<p>​	在这个lab中我们需要更改源码，要记住修改的地方 ，</p>
<p>​	在<code>kernel/syscall.c:137</code> 中修改如下:</p>
<p>​	<code>replace the statement </code>num &#x3D; p-&gt;trapframe-&gt;a7;<code>with</code>num &#x3D; * (int *) 0;<code> </code></p>
<p>​	<code>make qemu</code> 后输出如下</p>
<p>​	<img src="/../images/Lab-system-calls/num=0-9059807.png" alt="num=0"></p>
<p>​	查阅文档<code>riscv-privileged-20211203</code> 可知 <code>sepc</code> 是 <code>Supervisor Exception Program Counter</code> 的缩写。</p>
<blockquote>
<p>​	<code>sepc</code> is a WARL register that must be able to hold all valid virtual addresses.</p>
</blockquote>
<p>​	这句话比较重要：</p>
<blockquote>
<p>​	When a trap is taken into S-mode, sepc is written with the virtual address of the instruction that was interrupted or that encountered the exception. Otherwise, sepc is never written by the implementation, though it may be explicitly written by software.</p>
</blockquote>
<p>​	大意是当在<code>supervisor mode</code>中如果有一个<code>trap</code>, <code>sepc</code> 只会写入被中断或遇到异常指令的虚拟地址。上图<code>sepc=0x0000000080001ff8</code> 反映了内核在虚拟地址为<code>0x0000000080001ff8</code>的地方发生了<code>panic</code>。</p>
<p>​	知道了虚拟地址后，我们寻找汇编码。</p>
<blockquote>
<p>​	To track down the source of a kernel page-fault panic, search for the <code>sepc</code> value printed for the panic you just saw in the file <code>kernel/kernel.asm</code>, which contains the assembly for the compiled kernel.</p>
</blockquote>
<p>​	跟随文档提示，我们打开<code>kernel/kernel.asm</code>，查找<code>80001ff8</code></p>
<p>​	<img src="/../images/Lab-system-calls/80001ff8-9061766.png" alt="80001ff8"></p>
<p>​	图中给出了发生<code>panic</code>的位置,</p>
<p>​	<code>the assembly instruction the kernel is pannicing at</code> :  <code>lw a3, 0(zero)</code></p>
<p>​	该 <code>assembly code</code> 向 <code>register a3</code> 中载入 <code>0</code>，<code>so the register corresponds to the variable is a3</code>.</p>
<p>​	以上是我们人工的推测，现在尝试通过<code>gdb</code>验证我们的推测是否正确。</p>
<blockquote>
<p>​	To inspect the state of the processor and the kernel at the faulting instruction, fire up gdb, and set a breakpoint at the faulting <code>epc</code></p>
</blockquote>
<p>​	<img src="/../images/Lab-system-calls/80001ff8%E9%AA%8C%E8%AF%81-9064072.png" alt="80001ff8验证"></p>
<p>​	事实证明我们的推测是正确的，因为在达到断点处继续输入n之后，gdb无法继续运行下去，并且程序窗口(而不是gdb窗口)，输出：</p>
<p>​	<img src="/../images/Lab-system-calls/gdb-80001ff8.png" alt="gdb-80001ff8"></p>
<h2 id="·-Question-5"><a href="#·-Question-5" class="headerlink" title="· Question 5"></a>· Question 5</h2><p>​	 <code>Why does the kernel crash? Hint: look at figure 3-3 in the text; is address 0 mapped in the kernel address space? Is that confirmed by the value in </code>scause<code>above? (See description of</code>scause<code> in [RISC-V privileged instructions]: https://pdos.csail.mit.edu/6.828/2022/labs/n//github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf)</code></p>
<p>​	刚看到这个问题我没有什么头绪，试试在文档中查找<code>scause</code>:</p>
<h4 id="Supervisor-Cause-Register"><a href="#Supervisor-Cause-Register" class="headerlink" title="Supervisor Cause Register :"></a><code>Supervisor Cause Register</code> :</h4><blockquote>
<p>​	The scause register is an SXLEN-bit read-write register formatted as shown in Figure 4.11. When a trap is taken into S-mode, scause is written with a code indicating the event that caused the trap. Otherwise, scause is never written by the implementation, though it may be explicitly written by software.</p>
<p>​	The Interrupt bit in the scause register is set if the trap was caused by an interrupt. The Exception Code field contains a code identifying the last exception or interrupt. Table 4.2 lists the possible exception codes for the current supervisor ISAs. The Exception Code is a WLRL field. It is required to hold the values 0–31 (i.e., bits 4–0 must be implemented), but otherwise it is only guaranteed to hold supported exception codes.</p>
</blockquote>
<p>​	<img src="/../images/Lab-system-calls/scause-9066981-9066982.png" alt="scause"></p>
<p>​		<code>interrupt</code>位为<code>1</code>时，表示当前<code>trap</code>是由<code>interrupt</code>引起的，<code>Exception Code</code>用于定位最后一个<code>exception</code> 或<code>interrupt</code>，<code>table 4.2</code> 列出了可能的<code>exception code</code>。</p>
<p>​		<img src="/../images/Lab-system-calls/table%204.2-9068017.png" alt="table 4.2"></p>
<p>​	现在我们知道，<code>scause</code>是用于定位中断和异常的，回顾<code>make qemu failed</code> in Question 4, 我们发现终端窗口中输出的<code>scause = 0x000000000000000d</code> ，查表可知，当前错误是由于 <code>LOAD page fault</code> 产生的。</p>
<p>​				<strong><u>但没有弄清楚后两问的答案，搜索互联网后也没有得到比较好的答案。</u></strong></p>
<blockquote>
<p>​	当地址为0的时候 ，并没有映射到任何地址上，我们在程序中使用的地址均为虚拟地址，所以自然无法获取他的值。</p>
</blockquote>
<h2 id="·-Question-6"><a href="#·-Question-6" class="headerlink" title="· Question 6"></a>· Question 6</h2><p>​	<code>What is the name of the binary that was running when the kernel paniced? What is its process id (</code>pid<code>)?</code></p>
<blockquote>
<p>​	Note that <code>scause</code> was printed by the kernel panic above, but often you need to look at additional info to track down the problem that caused the panic. For example, to find out which user process was running when the kernel paniced, you can print out the process’s name:	</p>
</blockquote>
<p>​	教程告诉我们，仅仅通过<code>scause</code>所能知道的信息是有限的，我们需要知道更多的信息去追踪是什么导致程序终端。例如，通过打印进程名字，<code>p p-&gt;name</code>。</p>
<p>​	<img src="/../images/Lab-system-calls/QQ20230712-202342.png" alt="QQ20230712-202342"></p>
<p>​	我们现在知道程序在运行 initcode函数的二进制文件时导致了内存崩溃。打印<code>p p-&gt;pid</code> 知道程序的pid是1。</p>
<h1 id="2-System-call-tracing"><a href="#2-System-call-tracing" class="headerlink" title="2. System call tracing"></a>2. System call tracing</h1><blockquote>
<p>​	In this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new <code>trace</code> system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls <code>trace(1 &lt;&lt; SYS_fork)</code>, where <code>SYS_fork</code> is a syscall number from <code>kernel/syscall.h</code>. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The <code>trace</code> system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</p>
</blockquote>
<p>​	这个实验要实现一个<code>trace</code>系统调用。该系统调用传入一个int 类型的参数,我们称该参数为mask, 该参数的二进制形式用来确定<code>trace</code>追踪哪个系统调用。确定的方法是对1做左移位运算，例如 <code>SYS_read = 5</code>，追踪 SYS_read 的命令为<code>trace 32</code>，这是因为32的二进制表示为<code>100000</code>，同时 32 &#x3D; 1 &lt;&lt; 5。</p>
<p>​	那就先跟着hints一步一步走。首先看一看一开始提到的<code>user/user.S</code>和<code>user/usys.pl</code>。<code>.S</code>文件是汇编代码文件，<code>.pl</code>文件是一种脚本文件。在这个项目中，<code>user.S</code>文件是在<code>make</code>时通过<code>usys.pl</code>产生的。在阅读<code>usys.pl</code> 文档时我们顺带学习一些perl语法。</p>
<ul>
<li>sub <function_name>&#96; 用于定义函数。</li>
<li><code>my $name</code>用于定义局部变量标准关键字，标准关键字以<code>$</code>开头。</li>
<li><code>shift ARRAY</code>:  这个函数把数组的第一个值移出并且返回它，然后把数组长度减一并且把所有的东西都顺移。如果在数组中不再存在元素，它返回 undef。如果省略了 ARRAY，那么该函数在子过程和格式的词法范围里移动 @_；它在文件范围（通常是主程序）里移动 @ARGV。</li>
<li>向子程序传递参数时，子程序参数使用特殊数组<code>@_</code>标明，因此子程序第一个参数为 <code>$_[0]</code>, 第二个参数为 <code>$_[1]</code>, 以此类推。</li>
</ul>
<p>​	现在我们通过对比 <code>usys.S</code> 和 <code>usys,pl</code>发现，<code>usys.S</code>正好是通过该脚本语言产生的。把系统调用路由到内核的用户空间“存根”位于<code>user/usys.S</code>中。将系统调用路由到实现它的内核函数的内核空间代码位于<code>kernel/syscall.c</code>和<code>kernel/syscall.h</code>中。进程相关的代码在<code>kernel/pro.h</code> 和 <code>kernel/proc.c</code>中。</p>
<p>​	现在可以开始尝试更改代码。</p>
<ul>
<li><blockquote>
<p>​	Add <code>$U/_trace</code> to UPROGS in Makefile.</p>
</blockquote>
<p><img src="/../images/Lab-system-calls/56d4a1105995fee1df5c7c74cbbbc0d4-9260851-9260853.png" alt="56d4a1105995fee1df5c7c74cbbbc0d4"></p>
</li>
<li><blockquote>
<p>Run make qemu and you will see that the compiler cannot compile <code>user/trace.c</code>, because the user-space stubs for the system call don’t exist yet: add a prototype for the system call to <code>user/user.h</code>, a stub to <code>user/usys.pl</code>, and a syscall number to <code>kernel/syscall.h</code>. The Makefile invokes the perl script <code>user/usys.pl</code>, which produces <code>user/usys.S</code>, the actual system call stubs, which use the RISC-V <code>ecall</code> instruction to transition to the kernel. Once you fix the compilation issues, run trace 32 grep hello README; it will fail because you haven’t implemented the system call in the kernel yet.</p>
</blockquote>
</li>
</ul>
<p>​	In<code> user.h</code>,</p>
<p><img src="/../images/Lab-system-calls/int%20trace-9240023.png" alt="int trace"></p>
<p>​		这里要说明一下传参的问题，使用int类型是因为上文提到<code>trace(1 &lt;&lt; SYS_fork)</code>，这说明trace函数的参数是一个int类型，第二个地方能证明传入是int类型位于<code>user.c/trace.c</code>, <code>atoi()</code>函数将字符转换为<code>int</code>，也证明了参数类型为int。</p>
<p><img src="/../images/Lab-system-calls/7819266e33873c6ad8a1865dd10afa30-9247771.png" alt="7819266e33873c6ad8a1865dd10afa30"></p>
<p>​	In <code>usys.pl</code>,</p>
<p><img src="/../images/Lab-system-calls/entry_trace.png" alt="entry_trace"></p>
<p>​	In <code>syscall.h</code>, add a syscall number,</p>
<p><img src="/../images/Lab-system-calls/SYS_trace.png" alt="SYS_trace"></p>
<ul>
<li><blockquote>
<p>Add a <code>sys_trace()</code> function in <code>kernel/sysproc.c</code> that implements the new system call by remembering its argument in a new variable in the <code>proc</code> structure (see <code>kernel/proc.h</code>). The functions to retrieve system call arguments from user space are in <code>kernel/syscall.c</code>, and you can see examples of their use in <code>kernel/sysproc.c</code>.</p>
</blockquote>
</li>
</ul>
<p>​	In <code>kernel/sysproc.c</code>, add a <code>sys_trace()</code>, </p>
<p><img src="/../images/Lab-system-calls/856d5a80fff400209485597fb245a98f-9247005.png" alt="856d5a80fff400209485597fb245a98f"></p>
<p>​	这里能看出来在代码<code>syscall.c</code>中是实现系统调用的地方，此时我们在这个新加的函数中尝试打印一些信息来证明我们的猜想。下图证明猜想正确。</p>
<p><img src="/../images/Lab-system-calls/54da95c980228341e338d4d5a666ba61.png" alt="54da95c980228341e338d4d5a666ba61"></p>
<p>​	根据提示 by remembreing its argument in a new variable in the <code>proc</code> structure. 这里让我们在 <code>pro </code>struct 里面添加一个变量用来存储<code>mask</code>值。</p>
<p>​	In <code>kernel/pro.h</code>,</p>
<p><img src="/../images/Lab-system-calls/%E6%88%AA%E5%B1%8F2023-07-13%2021.15.28-9254153-9254155.png" alt="截屏2023-07-13 21.15.28"></p>
<p>​	增加进程结构变量后，我们需要在初始进程的时候给定变量一个初始值，查看<code>allocproc(void)</code>函数后我们知道，该函数通过调用<code>freeproc()</code>清空已经存在的进程内容，我们在<code>freeproc()</code>函数中要将增加的变量赋值为0，即<code>p-&gt;trace_mask = 0</code>。</p>
<p>​	In <code>proc.c</code>,</p>
<p><img src="/../images/Lab-system-calls/%E6%88%AA%E5%B1%8F2023-07-13%2022.18.00.png" alt="截屏2023-07-13 22.18.00"></p>
<p>​	</p>
<p>​	在<code>sys_trace</code>函数中，我们首先需要将终端输入的<code>mask</code>值读取并存储到，看一看别的系统调用是怎么做的：</p>
<p><img src="/../images/Lab-system-calls/%E6%88%AA%E5%B1%8F2023-07-13%2021.27.50-9254881-9254955.png" alt="截屏2023-07-13 21.27.50"></p>
<p>​	我们发现在<code>sys_sleep</code>函数中使用<code>argint(0, &amp;n)</code>将参数读入n中。<code>mypro()</code>函数 返回当前的进程结构。依葫芦画瓢，修改<code>sys_trace()</code>函数。</p>
<p><img src="/../images/Lab-system-calls/%E6%88%AA%E5%B1%8F2023-07-13%2021.39.50-9255595-9255597.png" alt="截屏2023-07-13 21.39.50"></p>
<p>​	现在我们应该思考的问题是在哪里打印输出内容，既然是追踪系统调用，那我们在调用的时候打印信息是最好的，程序在什么地方实现的系统调用呢？那当然是在<code>kernel/syscall.c</code>中。</p>
<blockquote>
<p>​	The functions to retrieve system call arguments from user space are in <code>kernel/syscall.c</code>, </p>
</blockquote>
<p>​	修改<code>syscall(void)</code>函数：</p>
<p><img src="/../images/Lab-system-calls/043d4c827b9d9ab26bc1527d0164ccb1.png" alt="043d4c827b9d9ab26bc1527d0164ccb1"></p>
<p>​	首先声明数存储系统调用函数的名称，接着用位运算<code>(p-&gt;trace_mask &gt;&gt; num) &amp; 1</code> 当掩码位和当前系统调用的为相与不为0时，输出进程序号<code>p-&gt;pid</code>，系统调用名称<code>syscall_names[nums-1]</code>，返回值<code>p-&gt;trapframe-&gt;a0</code>。</p>
<ul>
<li><blockquote>
<p>Modify <code>fork()</code> (see <code>kernel/proc.c</code>) to copy the trace mask from the parent to the child process.</p>
</blockquote>
</li>
</ul>
<p>​	最后，为了将掩码mask传递给子进程，要修改<code>fork()</code>。观察<code>fork()</code>函数可知，该函数将进程p的内容全部复制给进程np，最后返回进程np的pid，由此我们可以知道np就是子进程。</p>
<p><img src="/../images/Lab-system-calls/%E6%88%AA%E5%B1%8F2023-07-13%2022.30.49.png" alt="截屏2023-07-13 22.30.49"></p>
<p>​	现在测试是否正确。</p>
<p><img src="/../images/Lab-system-calls/%E6%88%AA%E5%B1%8F2023-07-13%2022.54.14-9260059.png" alt="截屏2023-07-13 22.54.14"></p>
<p>​	恭喜，我们终于完成了这项实验！！！</p>
<h1 id="3-Sysinfo"><a href="#3-Sysinfo" class="headerlink" title="3. Sysinfo"></a>3. Sysinfo</h1><blockquote>
<p>​	In this assignment you will add a system call, <code>sysinfo</code>, that collects information about the running system. The system call takes one argument: a pointer to a <code>struct sysinfo</code> (see <code>kernel/sysinfo.h</code>). The kernel should fill out the fields of this struct: the <code>freemem</code> field should be set to the number of bytes of free memory, and the <code>nproc</code>field should be set to the number of processes whose <code>state</code> is not <code>UNUSED</code>. We provide a test program <code>sysinfotest</code>; you pass this assignment if it prints “sysinfotest: OK”.</p>
</blockquote>
<p>​	Sysinfo 收集正在运行的系统的信息。该函数有一个参数 ，这个参数是一个指向<code>struct sysinfo</code> 的指针。内核应填写这个结构的字段。freemem字段应该设置为可用内存的字节数，nproc字段应该设为状态不是UNUSED的进程数。</p>
<ul>
<li><blockquote>
<p>Add <code>$U/_sysinfotest</code> to UPROGS in Makefile</p>
</blockquote>
</li>
</ul>
<p><img src="/../images/Lab-system-calls/%E6%88%AA%E5%B1%8F2023-07-14%2015.20.11-9319216.png" alt="截屏2023-07-14 15.20.11"></p>
<ul>
<li><blockquote>
<p>Run make qemu; <code>user/sysinfotest.c</code> will fail to compile. Add the system call sysinfo, following the same steps as in the previous assignment. To declare the prototype for sysinfo() <code>in user/user.h</code> you need predeclare the existence of <code>struct sysinfo</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct sysinfo;</span><br><span class="line">int sysinfo(struct sysinfo *);</span><br></pre></td></tr></table></figure>
<p>Once you fix the compilation issues, run sysinfotest; it will fail because you haven’t implemented the system call in the kernel yet.</p>
</blockquote>
</li>
</ul>
<p>​	与2.system call tracing 中添加系统调用步骤相同。</p>
<ul>
<li><blockquote>
<p>sysinfo needs to copy a <code>struct sysinfo</code> back to user space; see <code>sys_fstat()</code> (<code>kernel/sysfile.c</code>) and <code>filestat()</code>(<code>kernel/file.c</code>) for examples of how to do that using <code>copyout()</code>.</p>
</blockquote>
</li>
<li><p>​	浏览<code>kernel/sysfile.c</code> 和 <code>kernel/file.c</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uint64 sys_fstat(void) &#123;</span><br><span class="line">	struct file *f;</span><br><span class="line">	uint64 st; // user pointer to struct stat</span><br><span class="line">	argaddr(1, &amp;st);</span><br><span class="line">	if(argfd(0, 0, &amp;f) &lt; 0)</span><br><span class="line">	  	return -1;</span><br><span class="line">	return filestat(f, st);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>先看函数<code>argaddr(int n, uint64 *i)</code></p>
<p>检索作为指针的参数。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Retrieve an argument as a pointer.</span><br><span class="line">// Doesn&#x27;t check for legality, since</span><br><span class="line">// copyin/copyout will do that.</span><br><span class="line">void</span><br><span class="line">argaddr(int n, uint64 *ip)</span><br><span class="line">&#123;</span><br><span class="line">  *ip = argraw(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>再看函数<code>argraw(n)</code></p>
<p>了解到该函数的目的是从进程的data page中返回指定的寄存器的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static uint64</span><br><span class="line">argraw(int n)</span><br><span class="line">&#123;</span><br><span class="line">  struct proc *p = myproc();</span><br><span class="line">  switch (n) &#123;</span><br><span class="line">  case 0:</span><br><span class="line">    return p-&gt;trapframe-&gt;a0;</span><br><span class="line">  case 1:</span><br><span class="line">    return p-&gt;trapframe-&gt;a1;</span><br><span class="line">  case 2:</span><br><span class="line">    return p-&gt;trapframe-&gt;a2;</span><br><span class="line">  case 3:</span><br><span class="line">    return p-&gt;trapframe-&gt;a3;</span><br><span class="line">  case 4:</span><br><span class="line">    return p-&gt;trapframe-&gt;a4;</span><br><span class="line">  case 5:</span><br><span class="line">    return p-&gt;trapframe-&gt;a5;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(&quot;argraw&quot;);</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>现在我们知道 <code>st</code> 存储的是<code>trapframe</code>中第二个寄存器<code>a1</code>的值。</p>
</li>
<li><p>紧接着看函数<code>argfd(0, 0, &amp;f)</code>， 该函数获取第n个字大小的系统调用参数作为文件描述符并返回描述符<code>pfd</code>和相应的结构文件<code>pf</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Fetch the nth word-sized system call argument as a file descriptor</span><br><span class="line">// and return both the descriptor and the corresponding struct file.</span><br><span class="line">static int</span><br><span class="line">argfd(int n, int *pfd, struct file **pf)</span><br><span class="line">&#123;</span><br><span class="line">  int fd;</span><br><span class="line">  struct file *f;</span><br><span class="line"></span><br><span class="line">  argint(n, &amp;fd);</span><br><span class="line">  if(fd &lt; 0 || fd &gt;= NOFILE || (f=myproc()-&gt;ofile[fd]) == 0)</span><br><span class="line">    return -1;</span><br><span class="line">  if(pfd)</span><br><span class="line">    *pfd = fd;</span><br><span class="line">  if(pf)</span><br><span class="line">    *pf = f;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数<code>argint(int n, int *p)</code>的作用是获取第n个32位的系统调用并存储在地址<code>ip</code>中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Fetch the nth 32-bit system call argument.</span><br><span class="line">void</span><br><span class="line">argint(int n, int *ip)</span><br><span class="line">&#123;</span><br><span class="line">  *ip = argraw(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数<code>filestat(f, st)</code>获取文件<code>f</code>的数据，<code>addr</code>是用户虚拟地址，指向状态结构体</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Get metadata about file f.</span><br><span class="line">// addr is a user virtual address, pointing to a struct stat.</span><br><span class="line">int</span><br><span class="line">filestat(struct file *f, uint64 addr)</span><br><span class="line">&#123;</span><br><span class="line">  struct proc *p = myproc();</span><br><span class="line">  struct stat st;</span><br><span class="line">  </span><br><span class="line">  if(f-&gt;type == FD_INODE || f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    stati(f-&gt;ip, &amp;st);</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">    if(copyout(p-&gt;pagetable, addr, (char *)&amp;st, sizeof(st)) &lt; 0)</span><br><span class="line">      return -1;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>观察<code>copyout</code>函数: </p>
<p>该函数从内核向用户拷贝信息，从参数<code>src</code>指向的地址开始，将<code>len</code>个字节复制到指定页表<code>pagetable</code>中的虚拟地址<code>dstva</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// Copy from kernel to user.</span><br><span class="line">// Copy len bytes from src to virtual address dstva in a given page table.</span><br><span class="line">// Return 0 on success, -1 on error.</span><br><span class="line">int</span><br><span class="line">copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)</span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  while(len &gt; 0)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    if(pa0 == 0)</span><br><span class="line">      return -1;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    if(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((void *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><blockquote>
<p>To collect the amount of free memory, add a function to <code>kernel/kalloc.c</code></p>
</blockquote>
<p>提示让我们在<code>kernel/kalloc.c</code>中添加收集空闲内存的函数，<code>struct sysinfo</code>中有一个成员<code>uint64 freemem</code>,所以我们要添加一个<code>unint64 freemem(void)</code>的函数，统计并返回空闲内存。观察<code>kalloc.c</code>中的函数，在分配和回收内存空间的时候需要请求锁。</p>
</li>
</ul>
<p>​	</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/09/my-new-post/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不舍昼夜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="master haodong">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/09/my-new-post/" class="post-title-link" itemprop="url">How to run GDB on Athena</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-09 21:29:03" itemprop="dateCreated datePublished" datetime="2023-07-09T21:29:03+08:00">2023-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-10 20:32:20" itemprop="dateModified" datetime="2023-07-10T20:32:20+08:00">2023-07-10</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>622</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="用于记录MIT6-S081-lab-2-syscall步骤"><a href="#用于记录MIT6-S081-lab-2-syscall步骤" class="headerlink" title="用于记录MIT6.S081 lab 2 syscall步骤"></a>用于记录MIT6.S081 lab 2 syscall步骤</h1><h2 id="第一个终端窗口"><a href="#第一个终端窗口" class="headerlink" title="第一个终端窗口"></a>第一个终端窗口</h2><ol>
<li>cd xv6-labs-2022</li>
<li>make qemu-gdb</li>
<li>注意输出的最后一行出现一个tcp::&lt;PORT NUMBER HERE&gt;</li>
</ol>
<h2 id="第二个终端窗口"><a href="#第二个终端窗口" class="headerlink" title="第二个终端窗口"></a>第二个终端窗口</h2><ol>
<li>cd xv6-labs-2022</li>
<li>riscv64-unknown-elf-gdb<br>这个时候gdb已经打开了  </li>
<li>在gdb窗口中需要输入 target remote localhost:&lt;PORT NUMBER FROM POINT 3 ABOVE&gt;  (这个步骤用于告诉gdb该程序的是从哪里开始，如果跳过该步骤，终端会输出 GDB dont know how to run).<br>现在你需要每一次调用 kernel&#x2F;syscall.c 中 syscall 时中断，即设置断点。  </li>
<li>在gdb窗口中输入: file kernel&#x2F;kernel(这是内核代码的二进制可执行文件)<br> gdb file 命令用于加载程序。  </li>
<li>b syscall (在syscall函数中设置断点)</li>
<li>持续输入 c 用于查看内核什么时候达到 syscall function</li>
</ol>
<h2 id="附加如何使用-hexo-上传博客"><a href="#附加如何使用-hexo-上传博客" class="headerlink" title="附加如何使用 hexo 上传博客"></a>附加如何使用 hexo 上传博客</h2><ol>
<li>首先在本地hexo根目录下打开终端输入 hexo new “post name”</li>
<li>然后输入 hexo clean</li>
<li>generate static file： hexo generate</li>
<li>部署到远程网站上：hexo deploy</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/09/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="theLonging">
      <meta itemprop="description" content="不舍昼夜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="master haodong">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/09/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-09 20:27:54" itemprop="dateCreated datePublished" datetime="2023-07-09T20:27:54+08:00">2023-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-10 17:10:59" itemprop="dateModified" datetime="2023-07-10T17:10:59+08:00">2023-07-10</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>431</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="theLonging"
      src="/images/touxiang.JPG">
  <p class="site-author-name" itemprop="name">theLonging</p>
  <div class="site-description" itemprop="description">不舍昼夜</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/chantchanH7" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chantchanH7" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/562879980@qq.com" title="E-Mail → 562879980@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-07 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">theLonging</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">37k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">34 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
